/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.THREE = global.THREE || {})));
}(this, (function (exports) { 'use strict';

  // Polyfills

  if ( Number.EPSILON === undefined ) {

    Number.EPSILON = Math.pow( 2, - 52 );

  }

  if ( Number.isInteger === undefined ) {

    // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

    Number.isInteger = function ( value ) {

      return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

    };

  }

  //

  if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function ( x ) {

      return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    };

  }

  if ( Function.prototype.name === undefined ) {

    // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

      get: function () {

        return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

      }

    } );

  }

  if ( Object.assign === undefined ) {

    // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    ( function () {

      Object.assign = function ( target ) {

        'use strict';

        if ( target === undefined || target === null ) {

          throw new TypeError( 'Cannot convert undefined or null to object' );

        }

        var output = Object( target );

        for ( var index = 1; index < arguments.length; index ++ ) {

          var source = arguments[ index ];

          if ( source !== undefined && source !== null ) {

            for ( var nextKey in source ) {

              if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

                output[ nextKey ] = source[ nextKey ];

              }

            }

          }

        }

        return output;

      };

    } )();

  }

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  function EventDispatcher() {}

  Object.assign( EventDispatcher.prototype, {

    addEventListener: function ( type, listener ) {

      if ( this._listeners === undefined ) this._listeners = {};

      var listeners = this._listeners;

      if ( listeners[ type ] === undefined ) {

        listeners[ type ] = [];

      }

      if ( listeners[ type ].indexOf( listener ) === - 1 ) {

        listeners[ type ].push( listener );

      }

    },

    hasEventListener: function ( type, listener ) {

      if ( this._listeners === undefined ) return false;

      var listeners = this._listeners;

      return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

    },

    removeEventListener: function ( type, listener ) {

      if ( this._listeners === undefined ) return;

      var listeners = this._listeners;
      var listenerArray = listeners[ type ];

      if ( listenerArray !== undefined ) {

        var index = listenerArray.indexOf( listener );

        if ( index !== - 1 ) {

          listenerArray.splice( index, 1 );

        }

      }

    },

    dispatchEvent: function ( event ) {

      if ( this._listeners === undefined ) return;

      var listeners = this._listeners;
      var listenerArray = listeners[ event.type ];

      if ( listenerArray !== undefined ) {

        event.target = this;

        var array = listenerArray.slice( 0 );

        for ( var i = 0, l = array.length; i < l; i ++ ) {

          array[ i ].call( this, event );

        }

      }

    }

  } );

  var REVISION = '88dev';
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var CullFaceFrontBack = 3;
  var FrontFaceDirectionCW = 0;
  var FrontFaceDirectionCCW = 1;
  var BasicShadowMap = 0;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var SmoothShading = 2;
  var NoColors = 0;
  var FaceColors = 1;
  var VertexColors = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var Uncharted2ToneMapping = 3;
  var CineonToneMapping = 4;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var SphericalReflectionMapping = 305;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1000;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipMapNearestFilter = 1004;
  var NearestMipMapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipMapNearestFilter = 1007;
  var LinearMipMapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var RGBEFormat = RGBAFormat;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RGB_S3TC_DXT1_Format = 2001;
  var RGBA_S3TC_DXT1_Format = 2002;
  var RGBA_S3TC_DXT3_Format = 2003;
  var RGBA_S3TC_DXT5_Format = 2004;
  var RGB_PVRTC_4BPPV1_Format = 2100;
  var RGB_PVRTC_2BPPV1_Format = 2101;
  var RGBA_PVRTC_4BPPV1_Format = 2102;
  var RGBA_PVRTC_2BPPV1_Format = 2103;
  var RGB_ETC1_Format = 2151;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3000;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  var _Math = {

    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,

    generateUUID: function () {

      // http://www.broofa.com/Tools/Math.uuid.htm

      var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
      var uuid = new Array( 36 );
      var rnd = 0, r;

      return function generateUUID() {

        for ( var i = 0; i < 36; i ++ ) {

          if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

            uuid[ i ] = '-';

          } else if ( i === 14 ) {

            uuid[ i ] = '4';

          } else {

            if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
            r = rnd & 0xf;
            rnd = rnd >> 4;
            uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

          }

        }

        return uuid.join( '' );

      };

    }(),

    clamp: function ( value, min, max ) {

      return Math.max( min, Math.min( max, value ) );

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function ( n, m ) {

      return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function ( x, a1, a2, b1, b2 ) {

      return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // https://en.wikipedia.org/wiki/Linear_interpolation

    lerp: function ( x, y, t ) {

      return ( 1 - t ) * x + t * y;

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function ( x, min, max ) {

      if ( x <= min ) return 0;
      if ( x >= max ) return 1;

      x = ( x - min ) / ( max - min );

      return x * x * ( 3 - 2 * x );

    },

    smootherstep: function ( x, min, max ) {

      if ( x <= min ) return 0;
      if ( x >= max ) return 1;

      x = ( x - min ) / ( max - min );

      return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random integer from <low, high> interval

    randInt: function ( low, high ) {

      return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function ( low, high ) {

      return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function ( range ) {

      return range * ( 0.5 - Math.random() );

    },

    degToRad: function ( degrees ) {

      return degrees * _Math.DEG2RAD;

    },

    radToDeg: function ( radians ) {

      return radians * _Math.RAD2DEG;

    },

    isPowerOfTwo: function ( value ) {

      return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    ceilPowerOfTwo: function ( value ) {

      return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

    },

    floorPowerOfTwo: function ( value ) {

      return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

    }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  function Vector2( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

  }

  Object.defineProperties( Vector2.prototype, {

    "width": {

      get: function () {

        return this.x;

      },

      set: function ( value ) {

        this.x = value;

      }

    },

    "height": {

      get: function () {

        return this.y;

      },

      set: function ( value ) {

        this.y = value;

      }

    }

  } );

  Object.assign( Vector2.prototype, {

    isVector2: true,

    set: function ( x, y ) {

      this.x = x;
      this.y = y;

      return this;

    },

    setScalar: function ( scalar ) {

      this.x = scalar;
      this.y = scalar;

      return this;

    },

    setX: function ( x ) {

      this.x = x;

      return this;

    },

    setY: function ( y ) {

      this.y = y;

      return this;

    },

    setComponent: function ( index, value ) {

      switch ( index ) {

        case 0: this.x = value; break;
        case 1: this.y = value; break;
        default: throw new Error( 'index is out of range: ' + index );

      }

      return this;

    },

    getComponent: function ( index ) {

      switch ( index ) {

        case 0: return this.x;
        case 1: return this.y;
        default: throw new Error( 'index is out of range: ' + index );

      }

    },

    clone: function () {

      return new this.constructor( this.x, this.y );

    },

    copy: function ( v ) {

      this.x = v.x;
      this.y = v.y;

      return this;

    },

    add: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
        return this.addVectors( v, w );

      }

      this.x += v.x;
      this.y += v.y;

      return this;

    },

    addScalar: function ( s ) {

      this.x += s;
      this.y += s;

      return this;

    },

    addVectors: function ( a, b ) {

      this.x = a.x + b.x;
      this.y = a.y + b.y;

      return this;

    },

    addScaledVector: function ( v, s ) {

      this.x += v.x * s;
      this.y += v.y * s;

      return this;

    },

    sub: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
        return this.subVectors( v, w );

      }

      this.x -= v.x;
      this.y -= v.y;

      return this;

    },

    subScalar: function ( s ) {

      this.x -= s;
      this.y -= s;

      return this;

    },

    subVectors: function ( a, b ) {

      this.x = a.x - b.x;
      this.y = a.y - b.y;

      return this;

    },

    multiply: function ( v ) {

      this.x *= v.x;
      this.y *= v.y;

      return this;

    },

    multiplyScalar: function ( scalar ) {

      this.x *= scalar;
      this.y *= scalar;

      return this;

    },

    divide: function ( v ) {

      this.x /= v.x;
      this.y /= v.y;

      return this;

    },

    divideScalar: function ( scalar ) {

      return this.multiplyScalar( 1 / scalar );

    },

    applyMatrix3: function ( m ) {

      var x = this.x, y = this.y;
      var e = m.elements;

      this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
      this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

      return this;

    },

    min: function ( v ) {

      this.x = Math.min( this.x, v.x );
      this.y = Math.min( this.y, v.y );

      return this;

    },

    max: function ( v ) {

      this.x = Math.max( this.x, v.x );
      this.y = Math.max( this.y, v.y );

      return this;

    },

    clamp: function ( min, max ) {

      // assumes min < max, componentwise

      this.x = Math.max( min.x, Math.min( max.x, this.x ) );
      this.y = Math.max( min.y, Math.min( max.y, this.y ) );

      return this;

    },

    clampScalar: function () {

      var min = new Vector2();
      var max = new Vector2();

      return function clampScalar( minVal, maxVal ) {

        min.set( minVal, minVal );
        max.set( maxVal, maxVal );

        return this.clamp( min, max );

      };

    }(),

    clampLength: function ( min, max ) {

      var length = this.length();

      return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    },

    floor: function () {

      this.x = Math.floor( this.x );
      this.y = Math.floor( this.y );

      return this;

    },

    ceil: function () {

      this.x = Math.ceil( this.x );
      this.y = Math.ceil( this.y );

      return this;

    },

    round: function () {

      this.x = Math.round( this.x );
      this.y = Math.round( this.y );

      return this;

    },

    roundToZero: function () {

      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

      return this;

    },

    negate: function () {

      this.x = - this.x;
      this.y = - this.y;

      return this;

    },

    dot: function ( v ) {

      return this.x * v.x + this.y * v.y;

    },

    lengthSq: function () {

      return this.x * this.x + this.y * this.y;

    },

    length: function () {

      return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function () {

      return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function () {

      return this.divideScalar( this.length() || 1 );

    },

    angle: function () {

      // computes the angle in radians with respect to the positive x-axis

      var angle = Math.atan2( this.y, this.x );

      if ( angle < 0 ) angle += 2 * Math.PI;

      return angle;

    },

    distanceTo: function ( v ) {

      return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

      var dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;

    },

    distanceToManhattan: function ( v ) {

      return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    },

    setLength: function ( length ) {

      return this.normalize().multiplyScalar( length );

    },

    lerp: function ( v, alpha ) {

      this.x += ( v.x - this.x ) * alpha;
      this.y += ( v.y - this.y ) * alpha;

      return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    },

    equals: function ( v ) {

      return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      this.x = array[ offset ];
      this.y = array[ offset + 1 ];

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this.x;
      array[ offset + 1 ] = this.y;

      return array;

    },

    fromBufferAttribute: function ( attribute, index, offset ) {

      if ( offset !== undefined ) {

        console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

      }

      this.x = attribute.getX( index );
      this.y = attribute.getY( index );

      return this;

    },

    rotateAround: function ( center, angle ) {

      var c = Math.cos( angle ), s = Math.sin( angle );

      var x = this.x - center.x;
      var y = this.y - center.y;

      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Matrix4() {

    this.elements = [

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    ];

    if ( arguments.length > 0 ) {

      console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

  }

  Object.assign( Matrix4.prototype, {

    isMatrix4: true,

    set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

      var te = this.elements;

      te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
      te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
      te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
      te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

      return this;

    },

    identity: function () {

      this.set(

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

      );

      return this;

    },

    clone: function () {

      return new Matrix4().fromArray( this.elements );

    },

    copy: function ( m ) {

      var te = this.elements;
      var me = m.elements;

      te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
      te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
      te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
      te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

      return this;

    },

    copyPosition: function ( m ) {

      var te = this.elements, me = m.elements;

      te[ 12 ] = me[ 12 ];
      te[ 13 ] = me[ 13 ];
      te[ 14 ] = me[ 14 ];

      return this;

    },

    extractBasis: function ( xAxis, yAxis, zAxis ) {

      xAxis.setFromMatrixColumn( this, 0 );
      yAxis.setFromMatrixColumn( this, 1 );
      zAxis.setFromMatrixColumn( this, 2 );

      return this;

    },

    makeBasis: function ( xAxis, yAxis, zAxis ) {

      this.set(
        xAxis.x, yAxis.x, zAxis.x, 0,
        xAxis.y, yAxis.y, zAxis.y, 0,
        xAxis.z, yAxis.z, zAxis.z, 0,
        0, 0, 0, 1
      );

      return this;

    },

    extractRotation: function () {

      var v1 = new Vector3();

      return function extractRotation( m ) {

        var te = this.elements;
        var me = m.elements;

        var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
        var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
        var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

        te[ 0 ] = me[ 0 ] * scaleX;
        te[ 1 ] = me[ 1 ] * scaleX;
        te[ 2 ] = me[ 2 ] * scaleX;

        te[ 4 ] = me[ 4 ] * scaleY;
        te[ 5 ] = me[ 5 ] * scaleY;
        te[ 6 ] = me[ 6 ] * scaleY;

        te[ 8 ] = me[ 8 ] * scaleZ;
        te[ 9 ] = me[ 9 ] * scaleZ;
        te[ 10 ] = me[ 10 ] * scaleZ;

        return this;

      };

    }(),

    makeRotationFromEuler: function ( euler ) {

      if ( ! ( euler && euler.isEuler ) ) {

        console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      var te = this.elements;

      var x = euler.x, y = euler.y, z = euler.z;
      var a = Math.cos( x ), b = Math.sin( x );
      var c = Math.cos( y ), d = Math.sin( y );
      var e = Math.cos( z ), f = Math.sin( z );

      if ( euler.order === 'XYZ' ) {

        var ae = a * e, af = a * f, be = b * e, bf = b * f;

        te[ 0 ] = c * e;
        te[ 4 ] = - c * f;
        te[ 8 ] = d;

        te[ 1 ] = af + be * d;
        te[ 5 ] = ae - bf * d;
        te[ 9 ] = - b * c;

        te[ 2 ] = bf - ae * d;
        te[ 6 ] = be + af * d;
        te[ 10 ] = a * c;

      } else if ( euler.order === 'YXZ' ) {

        var ce = c * e, cf = c * f, de = d * e, df = d * f;

        te[ 0 ] = ce + df * b;
        te[ 4 ] = de * b - cf;
        te[ 8 ] = a * d;

        te[ 1 ] = a * f;
        te[ 5 ] = a * e;
        te[ 9 ] = - b;

        te[ 2 ] = cf * b - de;
        te[ 6 ] = df + ce * b;
        te[ 10 ] = a * c;

      } else if ( euler.order === 'ZXY' ) {

        var ce = c * e, cf = c * f, de = d * e, df = d * f;

        te[ 0 ] = ce - df * b;
        te[ 4 ] = - a * f;
        te[ 8 ] = de + cf * b;

        te[ 1 ] = cf + de * b;
        te[ 5 ] = a * e;
        te[ 9 ] = df - ce * b;

        te[ 2 ] = - a * d;
        te[ 6 ] = b;
        te[ 10 ] = a * c;

      } else if ( euler.order === 'ZYX' ) {

        var ae = a * e, af = a * f, be = b * e, bf = b * f;

        te[ 0 ] = c * e;
        te[ 4 ] = be * d - af;
        te[ 8 ] = ae * d + bf;

        te[ 1 ] = c * f;
        te[ 5 ] = bf * d + ae;
        te[ 9 ] = af * d - be;

        te[ 2 ] = - d;
        te[ 6 ] = b * c;
        te[ 10 ] = a * c;

      } else if ( euler.order === 'YZX' ) {

        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

        te[ 0 ] = c * e;
        te[ 4 ] = bd - ac * f;
        te[ 8 ] = bc * f + ad;

        te[ 1 ] = f;
        te[ 5 ] = a * e;
        te[ 9 ] = - b * e;

        te[ 2 ] = - d * e;
        te[ 6 ] = ad * f + bc;
        te[ 10 ] = ac - bd * f;

      } else if ( euler.order === 'XZY' ) {

        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

        te[ 0 ] = c * e;
        te[ 4 ] = - f;
        te[ 8 ] = d * e;

        te[ 1 ] = ac * f + bd;
        te[ 5 ] = a * e;
        te[ 9 ] = ad * f - bc;

        te[ 2 ] = bc * f - ad;
        te[ 6 ] = b * e;
        te[ 10 ] = bd * f + ac;

      }

      // last column
      te[ 3 ] = 0;
      te[ 7 ] = 0;
      te[ 11 ] = 0;

      // bottom row
      te[ 12 ] = 0;
      te[ 13 ] = 0;
      te[ 14 ] = 0;
      te[ 15 ] = 1;

      return this;

    },

    makeRotationFromQuaternion: function ( q ) {

      var te = this.elements;

      var x = q._x, y = q._y, z = q._z, w = q._w;
      var x2 = x + x, y2 = y + y, z2 = z + z;
      var xx = x * x2, xy = x * y2, xz = x * z2;
      var yy = y * y2, yz = y * z2, zz = z * z2;
      var wx = w * x2, wy = w * y2, wz = w * z2;

      te[ 0 ] = 1 - ( yy + zz );
      te[ 4 ] = xy - wz;
      te[ 8 ] = xz + wy;

      te[ 1 ] = xy + wz;
      te[ 5 ] = 1 - ( xx + zz );
      te[ 9 ] = yz - wx;

      te[ 2 ] = xz - wy;
      te[ 6 ] = yz + wx;
      te[ 10 ] = 1 - ( xx + yy );

      // last column
      te[ 3 ] = 0;
      te[ 7 ] = 0;
      te[ 11 ] = 0;

      // bottom row
      te[ 12 ] = 0;
      te[ 13 ] = 0;
      te[ 14 ] = 0;
      te[ 15 ] = 1;

      return this;

    },

    lookAt: function () {

      var x = new Vector3();
      var y = new Vector3();
      var z = new Vector3();

      return function lookAt( eye, target, up ) {

        var te = this.elements;

        z.subVectors( eye, target );

        if ( z.lengthSq() === 0 ) {

          // eye and target are in the same position

          z.z = 1;

        }

        z.normalize();
        x.crossVectors( up, z );

        if ( x.lengthSq() === 0 ) {

          // up and z are parallel

          if ( Math.abs( up.z ) === 1 ) {

            z.x += 0.0001;

          } else {

            z.z += 0.0001;

          }

          z.normalize();
          x.crossVectors( up, z );

        }

        x.normalize();
        y.crossVectors( z, x );

        te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
        te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
        te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

        return this;

      };

    }(),

    multiply: function ( m, n ) {

      if ( n !== undefined ) {

        console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
        return this.multiplyMatrices( m, n );

      }

      return this.multiplyMatrices( this, m );

    },

    premultiply: function ( m ) {

      return this.multiplyMatrices( m, this );

    },

    multiplyMatrices: function ( a, b ) {

      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;

      var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
      var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
      var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
      var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

      var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
      var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
      var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
      var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

      te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

      te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

      te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

      te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

      return this;

    },

    multiplyScalar: function ( s ) {

      var te = this.elements;

      te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
      te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
      te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
      te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

      return this;

    },

    applyToBufferAttribute: function () {

      var v1 = new Vector3();

      return function applyToBufferAttribute( attribute ) {

        for ( var i = 0, l = attribute.count; i < l; i ++ ) {

          v1.x = attribute.getX( i );
          v1.y = attribute.getY( i );
          v1.z = attribute.getZ( i );

          v1.applyMatrix4( this );

          attribute.setXYZ( i, v1.x, v1.y, v1.z );

        }

        return attribute;

      };

    }(),

    determinant: function () {

      var te = this.elements;

      var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
      var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
      var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
      var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

      //TODO: make this more efficient
      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

      return (
        n41 * (
          + n14 * n23 * n32
           - n13 * n24 * n32
           - n14 * n22 * n33
           + n12 * n24 * n33
           + n13 * n22 * n34
           - n12 * n23 * n34
        ) +
        n42 * (
          + n11 * n23 * n34
           - n11 * n24 * n33
           + n14 * n21 * n33
           - n13 * n21 * n34
           + n13 * n24 * n31
           - n14 * n23 * n31
        ) +
        n43 * (
          + n11 * n24 * n32
           - n11 * n22 * n34
           - n14 * n21 * n32
           + n12 * n21 * n34
           + n14 * n22 * n31
           - n12 * n24 * n31
        ) +
        n44 * (
          - n13 * n22 * n31
           - n11 * n23 * n32
           + n11 * n22 * n33
           + n13 * n21 * n32
           - n12 * n21 * n33
           + n12 * n23 * n31
        )

      );

    },

    transpose: function () {

      var te = this.elements;
      var tmp;

      tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
      tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
      tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

      tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
      tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
      tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

      return this;

    },

    setPosition: function ( v ) {

      var te = this.elements;

      te[ 12 ] = v.x;
      te[ 13 ] = v.y;
      te[ 14 ] = v.z;

      return this;

    },

    getInverse: function ( m, throwOnDegenerate ) {

      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
      var te = this.elements,
        me = m.elements,

        n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
        n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
        n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
        n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

      if ( det === 0 ) {

        var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

        if ( throwOnDegenerate === true ) {

          throw new Error( msg );

        } else {

          console.warn( msg );

        }

        return this.identity();

      }

      var detInv = 1 / det;

      te[ 0 ] = t11 * detInv;
      te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
      te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
      te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

      te[ 4 ] = t12 * detInv;
      te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
      te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
      te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

      te[ 8 ] = t13 * detInv;
      te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
      te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
      te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

      te[ 12 ] = t14 * detInv;
      te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
      te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
      te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

      return this;

    },

    scale: function ( v ) {

      var te = this.elements;
      var x = v.x, y = v.y, z = v.z;

      te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
      te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
      te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
      te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

      return this;

    },

    getMaxScaleOnAxis: function () {

      var te = this.elements;

      var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
      var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
      var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

      return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    },

    makeTranslation: function ( x, y, z ) {

      this.set(

        1, 0, 0, x,
        0, 1, 0, y,
        0, 0, 1, z,
        0, 0, 0, 1

      );

      return this;

    },

    makeRotationX: function ( theta ) {

      var c = Math.cos( theta ), s = Math.sin( theta );

      this.set(

        1, 0, 0, 0,
        0, c, - s, 0,
        0, s, c, 0,
        0, 0, 0, 1

      );

      return this;

    },

    makeRotationY: function ( theta ) {

      var c = Math.cos( theta ), s = Math.sin( theta );

      this.set(

         c, 0, s, 0,
         0, 1, 0, 0,
        - s, 0, c, 0,
         0, 0, 0, 1

      );

      return this;

    },

    makeRotationZ: function ( theta ) {

      var c = Math.cos( theta ), s = Math.sin( theta );

      this.set(

        c, - s, 0, 0,
        s, c, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

      );

      return this;

    },

    makeRotationAxis: function ( axis, angle ) {

      // Based on http://www.gamedev.net/reference/articles/article1199.asp

      var c = Math.cos( angle );
      var s = Math.sin( angle );
      var t = 1 - c;
      var x = axis.x, y = axis.y, z = axis.z;
      var tx = t * x, ty = t * y;

      this.set(

        tx * x + c, tx * y - s * z, tx * z + s * y, 0,
        tx * y + s * z, ty * y + c, ty * z - s * x, 0,
        tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
        0, 0, 0, 1

      );

       return this;

    },

    makeScale: function ( x, y, z ) {

      this.set(

        x, 0, 0, 0,
        0, y, 0, 0,
        0, 0, z, 0,
        0, 0, 0, 1

      );

      return this;

    },

    makeShear: function ( x, y, z ) {

      this.set(

        1, y, z, 0,
        x, 1, z, 0,
        x, y, 1, 0,
        0, 0, 0, 1

      );

      return this;

    },

    compose: function ( position, quaternion, scale ) {

      this.makeRotationFromQuaternion( quaternion );
      this.scale( scale );
      this.setPosition( position );

      return this;

    },

    decompose: function () {

      var vector = new Vector3();
      var matrix = new Matrix4();

      return function decompose( position, quaternion, scale ) {

        var te = this.elements;

        var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
        var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
        var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if ( det < 0 ) sx = - sx;

        position.x = te[ 12 ];
        position.y = te[ 13 ];
        position.z = te[ 14 ];

        // scale the rotation part
        matrix.copy( this );

        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;

        matrix.elements[ 0 ] *= invSX;
        matrix.elements[ 1 ] *= invSX;
        matrix.elements[ 2 ] *= invSX;

        matrix.elements[ 4 ] *= invSY;
        matrix.elements[ 5 ] *= invSY;
        matrix.elements[ 6 ] *= invSY;

        matrix.elements[ 8 ] *= invSZ;
        matrix.elements[ 9 ] *= invSZ;
        matrix.elements[ 10 ] *= invSZ;

        quaternion.setFromRotationMatrix( matrix );

        scale.x = sx;
        scale.y = sy;
        scale.z = sz;

        return this;

      };

    }(),

    makePerspective: function ( left, right, top, bottom, near, far ) {

      if ( far === undefined ) {

        console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

      }

      var te = this.elements;
      var x = 2 * near / ( right - left );
      var y = 2 * near / ( top - bottom );

      var a = ( right + left ) / ( right - left );
      var b = ( top + bottom ) / ( top - bottom );
      var c = - ( far + near ) / ( far - near );
      var d = - 2 * far * near / ( far - near );

      te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
      te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
      te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
      te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

      return this;

    },

    makeOrthographic: function ( left, right, top, bottom, near, far ) {

      var te = this.elements;
      var w = 1.0 / ( right - left );
      var h = 1.0 / ( top - bottom );
      var p = 1.0 / ( far - near );

      var x = ( right + left ) * w;
      var y = ( top + bottom ) * h;
      var z = ( far + near ) * p;

      te[ 0 ] = 2 * w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
      te[ 1 ] = 0;  te[ 5 ] = 2 * h;  te[ 9 ] = 0;  te[ 13 ] = - y;
      te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 * p; te[ 14 ] = - z;
      te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

      return this;

    },

    equals: function ( matrix ) {

      var te = this.elements;
      var me = matrix.elements;

      for ( var i = 0; i < 16; i ++ ) {

        if ( te[ i ] !== me[ i ] ) return false;

      }

      return true;

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      for ( var i = 0; i < 16; i ++ ) {

        this.elements[ i ] = array[ i + offset ];

      }

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      var te = this.elements;

      array[ offset ] = te[ 0 ];
      array[ offset + 1 ] = te[ 1 ];
      array[ offset + 2 ] = te[ 2 ];
      array[ offset + 3 ] = te[ 3 ];

      array[ offset + 4 ] = te[ 4 ];
      array[ offset + 5 ] = te[ 5 ];
      array[ offset + 6 ] = te[ 6 ];
      array[ offset + 7 ] = te[ 7 ];

      array[ offset + 8 ] = te[ 8 ];
      array[ offset + 9 ] = te[ 9 ];
      array[ offset + 10 ] = te[ 10 ];
      array[ offset + 11 ] = te[ 11 ];

      array[ offset + 12 ] = te[ 12 ];
      array[ offset + 13 ] = te[ 13 ];
      array[ offset + 14 ] = te[ 14 ];
      array[ offset + 15 ] = te[ 15 ];

      return array;

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Quaternion( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Quaternion, {

    slerp: function ( qa, qb, qm, t ) {

      return qm.copy( qa ).slerp( qb, t );

    },

    slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

      // fuzz-free, array-based Quaternion SLERP operation

      var x0 = src0[ srcOffset0 + 0 ],
        y0 = src0[ srcOffset0 + 1 ],
        z0 = src0[ srcOffset0 + 2 ],
        w0 = src0[ srcOffset0 + 3 ],

        x1 = src1[ srcOffset1 + 0 ],
        y1 = src1[ srcOffset1 + 1 ],
        z1 = src1[ srcOffset1 + 2 ],
        w1 = src1[ srcOffset1 + 3 ];

      if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

        var s = 1 - t,

          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

          dir = ( cos >= 0 ? 1 : - 1 ),
          sqrSin = 1 - cos * cos;

        // Skip the Slerp for tiny steps to avoid numeric problems:
        if ( sqrSin > Number.EPSILON ) {

          var sin = Math.sqrt( sqrSin ),
            len = Math.atan2( sin, cos * dir );

          s = Math.sin( s * len ) / sin;
          t = Math.sin( t * len ) / sin;

        }

        var tDir = t * dir;

        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;

        // Normalize in case we just did a lerp:
        if ( s === 1 - t ) {

          var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;

        }

      }

      dst[ dstOffset ] = x0;
      dst[ dstOffset + 1 ] = y0;
      dst[ dstOffset + 2 ] = z0;
      dst[ dstOffset + 3 ] = w0;

    }

  } );

  Object.defineProperties( Quaternion.prototype, {

    x: {

      get: function () {

        return this._x;

      },

      set: function ( value ) {

        this._x = value;
        this.onChangeCallback();

      }

    },

    y: {

      get: function () {

        return this._y;

      },

      set: function ( value ) {

        this._y = value;
        this.onChangeCallback();

      }

    },

    z: {

      get: function () {

        return this._z;

      },

      set: function ( value ) {

        this._z = value;
        this.onChangeCallback();

      }

    },

    w: {

      get: function () {

        return this._w;

      },

      set: function ( value ) {

        this._w = value;
        this.onChangeCallback();

      }

    }

  } );

  Object.assign( Quaternion.prototype, {

    set: function ( x, y, z, w ) {

      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;

      this.onChangeCallback();

      return this;

    },

    clone: function () {

      return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function ( quaternion ) {

      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;

      this.onChangeCallback();

      return this;

    },

    setFromEuler: function ( euler, update ) {

      if ( ! ( euler && euler.isEuler ) ) {

        throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

      }

      var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

      // http://www.mathworks.com/matlabcentral/fileexchange/
      //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
      //  content/SpinCalc.m

      var cos = Math.cos;
      var sin = Math.sin;

      var c1 = cos( x / 2 );
      var c2 = cos( y / 2 );
      var c3 = cos( z / 2 );

      var s1 = sin( x / 2 );
      var s2 = sin( y / 2 );
      var s3 = sin( z / 2 );

      if ( order === 'XYZ' ) {

        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;

      } else if ( order === 'YXZ' ) {

        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;

      } else if ( order === 'ZXY' ) {

        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;

      } else if ( order === 'ZYX' ) {

        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;

      } else if ( order === 'YZX' ) {

        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;

      } else if ( order === 'XZY' ) {

        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;

      }

      if ( update !== false ) this.onChangeCallback();

      return this;

    },

    setFromAxisAngle: function ( axis, angle ) {

      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

      // assumes axis is normalized

      var halfAngle = angle / 2, s = Math.sin( halfAngle );

      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos( halfAngle );

      this.onChangeCallback();

      return this;

    },

    setFromRotationMatrix: function ( m ) {

      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements,

        m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
        m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
        m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

        trace = m11 + m22 + m33,
        s;

      if ( trace > 0 ) {

        s = 0.5 / Math.sqrt( trace + 1.0 );

        this._w = 0.25 / s;
        this._x = ( m32 - m23 ) * s;
        this._y = ( m13 - m31 ) * s;
        this._z = ( m21 - m12 ) * s;

      } else if ( m11 > m22 && m11 > m33 ) {

        s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

        this._w = ( m32 - m23 ) / s;
        this._x = 0.25 * s;
        this._y = ( m12 + m21 ) / s;
        this._z = ( m13 + m31 ) / s;

      } else if ( m22 > m33 ) {

        s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

        this._w = ( m13 - m31 ) / s;
        this._x = ( m12 + m21 ) / s;
        this._y = 0.25 * s;
        this._z = ( m23 + m32 ) / s;

      } else {

        s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

        this._w = ( m21 - m12 ) / s;
        this._x = ( m13 + m31 ) / s;
        this._y = ( m23 + m32 ) / s;
        this._z = 0.25 * s;

      }

      this.onChangeCallback();

      return this;

    },

    setFromUnitVectors: function () {

      // assumes direction vectors vFrom and vTo are normalized

      var v1 = new Vector3();
      var r;

      var EPS = 0.000001;

      return function setFromUnitVectors( vFrom, vTo ) {

        if ( v1 === undefined ) v1 = new Vector3();

        r = vFrom.dot( vTo ) + 1;

        if ( r < EPS ) {

          r = 0;

          if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

            v1.set( - vFrom.y, vFrom.x, 0 );

          } else {

            v1.set( 0, - vFrom.z, vFrom.y );

          }

        } else {

          v1.crossVectors( vFrom, vTo );

        }

        this._x = v1.x;
        this._y = v1.y;
        this._z = v1.z;
        this._w = r;

        return this.normalize();

      };

    }(),

    inverse: function () {

      return this.conjugate().normalize();

    },

    conjugate: function () {

      this._x *= - 1;
      this._y *= - 1;
      this._z *= - 1;

      this.onChangeCallback();

      return this;

    },

    dot: function ( v ) {

      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function () {

      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function () {

      return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function () {

      var l = this.length();

      if ( l === 0 ) {

        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;

      } else {

        l = 1 / l;

        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;

      }

      this.onChangeCallback();

      return this;

    },

    multiply: function ( q, p ) {

      if ( p !== undefined ) {

        console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
        return this.multiplyQuaternions( q, p );

      }

      return this.multiplyQuaternions( this, q );

    },

    premultiply: function ( q ) {

      return this.multiplyQuaternions( q, this );

    },

    multiplyQuaternions: function ( a, b ) {

      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

      var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

      this.onChangeCallback();

      return this;

    },

    slerp: function ( qb, t ) {

      if ( t === 0 ) return this;
      if ( t === 1 ) return this.copy( qb );

      var x = this._x, y = this._y, z = this._z, w = this._w;

      // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

      if ( cosHalfTheta < 0 ) {

        this._w = - qb._w;
        this._x = - qb._x;
        this._y = - qb._y;
        this._z = - qb._z;

        cosHalfTheta = - cosHalfTheta;

      } else {

        this.copy( qb );

      }

      if ( cosHalfTheta >= 1.0 ) {

        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;

        return this;

      }

      var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

      if ( Math.abs( sinHalfTheta ) < 0.001 ) {

        this._w = 0.5 * ( w + this._w );
        this._x = 0.5 * ( x + this._x );
        this._y = 0.5 * ( y + this._y );
        this._z = 0.5 * ( z + this._z );

        return this;

      }

      var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
      var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
        ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

      this._w = ( w * ratioA + this._w * ratioB );
      this._x = ( x * ratioA + this._x * ratioB );
      this._y = ( y * ratioA + this._y * ratioB );
      this._z = ( z * ratioA + this._z * ratioB );

      this.onChangeCallback();

      return this;

    },

    equals: function ( quaternion ) {

      return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      this._x = array[ offset ];
      this._y = array[ offset + 1 ];
      this._z = array[ offset + 2 ];
      this._w = array[ offset + 3 ];

      this.onChangeCallback();

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this._x;
      array[ offset + 1 ] = this._y;
      array[ offset + 2 ] = this._z;
      array[ offset + 3 ] = this._w;

      return array;

    },

    onChange: function ( callback ) {

      this.onChangeCallback = callback;

      return this;

    },

    onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector3( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

  }

  Object.assign( Vector3.prototype, {

    isVector3: true,

    set: function ( x, y, z ) {

      this.x = x;
      this.y = y;
      this.z = z;

      return this;

    },

    setScalar: function ( scalar ) {

      this.x = scalar;
      this.y = scalar;
      this.z = scalar;

      return this;

    },

    setX: function ( x ) {

      this.x = x;

      return this;

    },

    setY: function ( y ) {

      this.y = y;

      return this;

    },

    setZ: function ( z ) {

      this.z = z;

      return this;

    },

    setComponent: function ( index, value ) {

      switch ( index ) {

        case 0: this.x = value; break;
        case 1: this.y = value; break;
        case 2: this.z = value; break;
        default: throw new Error( 'index is out of range: ' + index );

      }

      return this;

    },

    getComponent: function ( index ) {

      switch ( index ) {

        case 0: return this.x;
        case 1: return this.y;
        case 2: return this.z;
        default: throw new Error( 'index is out of range: ' + index );

      }

    },

    clone: function () {

      return new this.constructor( this.x, this.y, this.z );

    },

    copy: function ( v ) {

      this.x = v.x;
      this.y = v.y;
      this.z = v.z;

      return this;

    },

    add: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
        return this.addVectors( v, w );

      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;

      return this;

    },

    addScalar: function ( s ) {

      this.x += s;
      this.y += s;
      this.z += s;

      return this;

    },

    addVectors: function ( a, b ) {

      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;

      return this;

    },

    addScaledVector: function ( v, s ) {

      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;

      return this;

    },

    sub: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
        return this.subVectors( v, w );

      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;

      return this;

    },

    subScalar: function ( s ) {

      this.x -= s;
      this.y -= s;
      this.z -= s;

      return this;

    },

    subVectors: function ( a, b ) {

      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;

      return this;

    },

    multiply: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
        return this.multiplyVectors( v, w );

      }

      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;

      return this;

    },

    multiplyScalar: function ( scalar ) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;

      return this;

    },

    multiplyVectors: function ( a, b ) {

      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;

      return this;

    },

    applyEuler: function () {

      var quaternion = new Quaternion();

      return function applyEuler( euler ) {

        if ( ! ( euler && euler.isEuler ) ) {

          console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

        }

        return this.applyQuaternion( quaternion.setFromEuler( euler ) );

      };

    }(),

    applyAxisAngle: function () {

      var quaternion = new Quaternion();

      return function applyAxisAngle( axis, angle ) {

        return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      };

    }(),

    applyMatrix3: function ( m ) {

      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;

      this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
      this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
      this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

      return this;

    },

    applyMatrix4: function ( m ) {

      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;

      var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

      this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
      this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
      this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

      return this;

    },

    applyQuaternion: function ( q ) {

      var x = this.x, y = this.y, z = this.z;
      var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

      // calculate quat * vector

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = - qx * x - qy * y - qz * z;

      // calculate result * inverse quat

      this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
      this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
      this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

      return this;

    },

    project: function () {

      var matrix = new Matrix4();

      return function project( camera ) {

        matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
        return this.applyMatrix4( matrix );

      };

    }(),

    unproject: function () {

      var matrix = new Matrix4();

      return function unproject( camera ) {

        matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
        return this.applyMatrix4( matrix );

      };

    }(),

    transformDirection: function ( m ) {

      // input: THREE.Matrix4 affine matrix
      // vector interpreted as a direction

      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;

      this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
      this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
      this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

      return this.normalize();

    },

    divide: function ( v ) {

      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;

      return this;

    },

    divideScalar: function ( scalar ) {

      return this.multiplyScalar( 1 / scalar );

    },

    min: function ( v ) {

      this.x = Math.min( this.x, v.x );
      this.y = Math.min( this.y, v.y );
      this.z = Math.min( this.z, v.z );

      return this;

    },

    max: function ( v ) {

      this.x = Math.max( this.x, v.x );
      this.y = Math.max( this.y, v.y );
      this.z = Math.max( this.z, v.z );

      return this;

    },

    clamp: function ( min, max ) {

      // assumes min < max, componentwise

      this.x = Math.max( min.x, Math.min( max.x, this.x ) );
      this.y = Math.max( min.y, Math.min( max.y, this.y ) );
      this.z = Math.max( min.z, Math.min( max.z, this.z ) );

      return this;

    },

    clampScalar: function () {

      var min = new Vector3();
      var max = new Vector3();

      return function clampScalar( minVal, maxVal ) {

        min.set( minVal, minVal, minVal );
        max.set( maxVal, maxVal, maxVal );

        return this.clamp( min, max );

      };

    }(),

    clampLength: function ( min, max ) {

      var length = this.length();

      return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    },

    floor: function () {

      this.x = Math.floor( this.x );
      this.y = Math.floor( this.y );
      this.z = Math.floor( this.z );

      return this;

    },

    ceil: function () {

      this.x = Math.ceil( this.x );
      this.y = Math.ceil( this.y );
      this.z = Math.ceil( this.z );

      return this;

    },

    round: function () {

      this.x = Math.round( this.x );
      this.y = Math.round( this.y );
      this.z = Math.round( this.z );

      return this;

    },

    roundToZero: function () {

      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
      this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

      return this;

    },

    negate: function () {

      this.x = - this.x;
      this.y = - this.y;
      this.z = - this.z;

      return this;

    },

    dot: function ( v ) {

      return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    // TODO lengthSquared?

    lengthSq: function () {

      return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function () {

      return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function () {

      return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function () {

      return this.divideScalar( this.length() || 1 );

    },

    setLength: function ( length ) {

      return this.normalize().multiplyScalar( length );

    },

    lerp: function ( v, alpha ) {

      this.x += ( v.x - this.x ) * alpha;
      this.y += ( v.y - this.y ) * alpha;
      this.z += ( v.z - this.z ) * alpha;

      return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    },

    cross: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
        return this.crossVectors( v, w );

      }

      var x = this.x, y = this.y, z = this.z;

      this.x = y * v.z - z * v.y;
      this.y = z * v.x - x * v.z;
      this.z = x * v.y - y * v.x;

      return this;

    },

    crossVectors: function ( a, b ) {

      var ax = a.x, ay = a.y, az = a.z;
      var bx = b.x, by = b.y, bz = b.z;

      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;

      return this;

    },

    projectOnVector: function ( vector ) {

      var scalar = vector.dot( this ) / vector.lengthSq();

      return this.copy( vector ).multiplyScalar( scalar );

    },

    projectOnPlane: function () {

      var v1 = new Vector3();

      return function projectOnPlane( planeNormal ) {

        v1.copy( this ).projectOnVector( planeNormal );

        return this.sub( v1 );

      };

    }(),

    reflect: function () {

      // reflect incident vector off plane orthogonal to normal
      // normal is assumed to have unit length

      var v1 = new Vector3();

      return function reflect( normal ) {

        return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

      };

    }(),

    angleTo: function ( v ) {

      var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

      // clamp, to handle numerical problems

      return Math.acos( _Math.clamp( theta, - 1, 1 ) );

    },

    distanceTo: function ( v ) {

      return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

      var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

      return dx * dx + dy * dy + dz * dz;

    },

    distanceToManhattan: function ( v ) {

      return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    },

    setFromSpherical: function ( s ) {

      var sinPhiRadius = Math.sin( s.phi ) * s.radius;

      this.x = sinPhiRadius * Math.sin( s.theta );
      this.y = Math.cos( s.phi ) * s.radius;
      this.z = sinPhiRadius * Math.cos( s.theta );

      return this;

    },

    setFromCylindrical: function ( c ) {

      this.x = c.radius * Math.sin( c.theta );
      this.y = c.y;
      this.z = c.radius * Math.cos( c.theta );

      return this;

    },

    setFromMatrixPosition: function ( m ) {

      var e = m.elements;

      this.x = e[ 12 ];
      this.y = e[ 13 ];
      this.z = e[ 14 ];

      return this;

    },

    setFromMatrixScale: function ( m ) {

      var sx = this.setFromMatrixColumn( m, 0 ).length();
      var sy = this.setFromMatrixColumn( m, 1 ).length();
      var sz = this.setFromMatrixColumn( m, 2 ).length();

      this.x = sx;
      this.y = sy;
      this.z = sz;

      return this;

    },

    setFromMatrixColumn: function ( m, index ) {

      return this.fromArray( m.elements, index * 4 );

    },

    equals: function ( v ) {

      return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      this.x = array[ offset ];
      this.y = array[ offset + 1 ];
      this.z = array[ offset + 2 ];

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this.x;
      array[ offset + 1 ] = this.y;
      array[ offset + 2 ] = this.z;

      return array;

    },

    fromBufferAttribute: function ( attribute, index, offset ) {

      if ( offset !== undefined ) {

        console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

      }

      this.x = attribute.getX( index );
      this.y = attribute.getY( index );
      this.z = attribute.getZ( index );

      return this;

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */

  function Matrix3() {

    this.elements = [

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    ];

    if ( arguments.length > 0 ) {

      console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

  }

  Object.assign( Matrix3.prototype, {

    isMatrix3: true,

    set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

      var te = this.elements;

      te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
      te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
      te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

      return this;

    },

    identity: function () {

      this.set(

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

      );

      return this;

    },

    clone: function () {

      return new this.constructor().fromArray( this.elements );

    },

    copy: function ( m ) {

      var te = this.elements;
      var me = m.elements;

      te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
      te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
      te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

      return this;

    },

    setFromMatrix4: function ( m ) {

      var me = m.elements;

      this.set(

        me[ 0 ], me[ 4 ], me[ 8 ],
        me[ 1 ], me[ 5 ], me[ 9 ],
        me[ 2 ], me[ 6 ], me[ 10 ]

      );

      return this;

    },

    applyToBufferAttribute: function () {

      var v1 = new Vector3();

      return function applyToBufferAttribute( attribute ) {

        for ( var i = 0, l = attribute.count; i < l; i ++ ) {

          v1.x = attribute.getX( i );
          v1.y = attribute.getY( i );
          v1.z = attribute.getZ( i );

          v1.applyMatrix3( this );

          attribute.setXYZ( i, v1.x, v1.y, v1.z );

        }

        return attribute;

      };

    }(),

    multiply: function ( m ) {

      return this.multiplyMatrices( this, m );

    },

    premultiply: function ( m ) {

      return this.multiplyMatrices( m, this );

    },

    multiplyMatrices: function ( a, b ) {

      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;

      var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
      var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
      var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

      var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
      var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
      var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

      te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
      te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
      te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

      te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
      te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
      te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

      te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
      te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
      te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

      return this;

    },

    multiplyScalar: function ( s ) {

      var te = this.elements;

      te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
      te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
      te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

      return this;

    },

    determinant: function () {

      var te = this.elements;

      var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
        d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
        g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function ( matrix, throwOnDegenerate ) {

      if ( matrix && matrix.isMatrix4 ) {

        console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

      }

      var me = matrix.elements,
        te = this.elements,

        n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
        n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
        n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,

        det = n11 * t11 + n21 * t12 + n31 * t13;

      if ( det === 0 ) {

        var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

        if ( throwOnDegenerate === true ) {

          throw new Error( msg );

        } else {

          console.warn( msg );

        }

        return this.identity();

      }

      var detInv = 1 / det;

      te[ 0 ] = t11 * detInv;
      te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
      te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

      te[ 3 ] = t12 * detInv;
      te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
      te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

      te[ 6 ] = t13 * detInv;
      te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
      te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

      return this;

    },

    transpose: function () {

      var tmp, m = this.elements;

      tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
      tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
      tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

      return this;

    },

    getNormalMatrix: function ( matrix4 ) {

      return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

    },

    transposeIntoArray: function ( r ) {

      var m = this.elements;

      r[ 0 ] = m[ 0 ];
      r[ 1 ] = m[ 3 ];
      r[ 2 ] = m[ 6 ];
      r[ 3 ] = m[ 1 ];
      r[ 4 ] = m[ 4 ];
      r[ 5 ] = m[ 7 ];
      r[ 6 ] = m[ 2 ];
      r[ 7 ] = m[ 5 ];
      r[ 8 ] = m[ 8 ];

      return this;

    },

    setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

      var c = Math.cos( rotation );
      var s = Math.sin( rotation );

      this.set(
        sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
        - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
        0, 0, 1
      );

    },

    scale: function ( sx, sy ) {

      var te = this.elements;

      te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
      te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

      return this;

    },

    rotate: function ( theta ) {

      var c = Math.cos( theta );
      var s = Math.sin( theta );

      var te = this.elements;

      var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
      var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

      te[ 0 ] = c * a11 + s * a21;
      te[ 3 ] = c * a12 + s * a22;
      te[ 6 ] = c * a13 + s * a23;

      te[ 1 ] = - s * a11 + c * a21;
      te[ 4 ] = - s * a12 + c * a22;
      te[ 7 ] = - s * a13 + c * a23;

      return this;

    },

    translate: function ( tx, ty ) {

      var te = this.elements;

      te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
      te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

      return this;

    },

    equals: function ( matrix ) {

      var te = this.elements;
      var me = matrix.elements;

      for ( var i = 0; i < 9; i ++ ) {

        if ( te[ i ] !== me[ i ] ) return false;

      }

      return true;

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      for ( var i = 0; i < 9; i ++ ) {

        this.elements[ i ] = array[ i + offset ];

      }

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      var te = this.elements;

      array[ offset ] = te[ 0 ];
      array[ offset + 1 ] = te[ 1 ];
      array[ offset + 2 ] = te[ 2 ];

      array[ offset + 3 ] = te[ 3 ];
      array[ offset + 4 ] = te[ 4 ];
      array[ offset + 5 ] = te[ 5 ];

      array[ offset + 6 ] = te[ 6 ];
      array[ offset + 7 ] = te[ 7 ];
      array[ offset + 8 ] = te[ 8 ];

      return array;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  var textureId = 0;

  function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    Object.defineProperty( this, 'id', { value: textureId ++ } );

    this.uuid = _Math.generateUUID();

    this.name = '';

    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : RGBAFormat;
    this.type = type !== undefined ? type : UnsignedByteType;

    this.offset = new Vector2( 0, 0 );
    this.repeat = new Vector2( 1, 1 );
    this.center = new Vector2( 0, 0 );
    this.rotation = 0;

    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;

    this.version = 0;
    this.onUpdate = null;

  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;

  Object.defineProperty( Texture.prototype, "needsUpdate", {

    set: function ( value ) {

      if ( value === true ) this.version ++;

    }

  } );

  Object.assign( Texture.prototype, EventDispatcher.prototype, {

    constructor: Texture,

    isTexture: true,

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( source ) {

      this.name = source.name;

      this.image = source.image;
      this.mipmaps = source.mipmaps.slice( 0 );

      this.mapping = source.mapping;

      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;

      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;

      this.anisotropy = source.anisotropy;

      this.format = source.format;
      this.type = source.type;

      this.offset.copy( source.offset );
      this.repeat.copy( source.repeat );
      this.center.copy( source.center );
      this.rotation = source.rotation;

      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy( source.matrix );

      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;

      return this;

    },

    toJSON: function ( meta ) {

      var isRootObject = ( meta === undefined || typeof meta === 'string' );

      if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

        return meta.textures[ this.uuid ];

      }

      function getDataURL( image ) {

        var canvas;

        if ( image instanceof HTMLCanvasElement ) {

          canvas = image;

        } else {

          canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
          canvas.width = image.width;
          canvas.height = image.height;

          var context = canvas.getContext( '2d' );

          if ( image instanceof ImageData ) {

            context.putImageData( image, 0, 0 );

          } else {

            context.drawImage( image, 0, 0, image.width, image.height );

          }

        }

        if ( canvas.width > 2048 || canvas.height > 2048 ) {

          return canvas.toDataURL( 'image/jpeg', 0.6 );

        } else {

          return canvas.toDataURL( 'image/png' );

        }

      }

      var output = {
        metadata: {
          version: 4.5,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },

        uuid: this.uuid,
        name: this.name,

        mapping: this.mapping,

        repeat: [ this.repeat.x, this.repeat.y ],
        offset: [ this.offset.x, this.offset.y ],
        center: [ this.center.x, this.center.y ],
        rotation: this.rotation,

        wrap: [ this.wrapS, this.wrapT ],

        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,

        flipY: this.flipY
      };

      if ( this.image !== undefined ) {

        // TODO: Move to THREE.Image

        var image = this.image;

        if ( image.uuid === undefined ) {

          image.uuid = _Math.generateUUID(); // UGH

        }

        if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

          meta.images[ image.uuid ] = {
            uuid: image.uuid,
            url: getDataURL( image )
          };

        }

        output.image = image.uuid;

      }

      if ( ! isRootObject ) {

        meta.textures[ this.uuid ] = output;

      }

      return output;

    },

    dispose: function () {

      this.dispatchEvent( { type: 'dispose' } );

    },

    transformUv: function ( uv ) {

      if ( this.mapping !== UVMapping ) return;

      uv.applyMatrix3( this.matrix );

      if ( uv.x < 0 || uv.x > 1 ) {

        switch ( this.wrapS ) {

          case RepeatWrapping:

            uv.x = uv.x - Math.floor( uv.x );
            break;

          case ClampToEdgeWrapping:

            uv.x = uv.x < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:

            if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

              uv.x = Math.ceil( uv.x ) - uv.x;

            } else {

              uv.x = uv.x - Math.floor( uv.x );

            }
            break;

        }

      }

      if ( uv.y < 0 || uv.y > 1 ) {

        switch ( this.wrapT ) {

          case RepeatWrapping:

            uv.y = uv.y - Math.floor( uv.y );
            break;

          case ClampToEdgeWrapping:

            uv.y = uv.y < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:

            if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

              uv.y = Math.ceil( uv.y ) - uv.y;

            } else {

              uv.y = uv.y - Math.floor( uv.y );

            }
            break;

        }

      }

      if ( this.flipY ) {

        uv.y = 1 - uv.y;

      }

    }

  } );

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector4( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Vector4.prototype, {

    isVector4: true,

    set: function ( x, y, z, w ) {

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;

      return this;

    },

    setScalar: function ( scalar ) {

      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;

      return this;

    },

    setX: function ( x ) {

      this.x = x;

      return this;

    },

    setY: function ( y ) {

      this.y = y;

      return this;

    },

    setZ: function ( z ) {

      this.z = z;

      return this;

    },

    setW: function ( w ) {

      this.w = w;

      return this;

    },

    setComponent: function ( index, value ) {

      switch ( index ) {

        case 0: this.x = value; break;
        case 1: this.y = value; break;
        case 2: this.z = value; break;
        case 3: this.w = value; break;
        default: throw new Error( 'index is out of range: ' + index );

      }

      return this;

    },

    getComponent: function ( index ) {

      switch ( index ) {

        case 0: return this.x;
        case 1: return this.y;
        case 2: return this.z;
        case 3: return this.w;
        default: throw new Error( 'index is out of range: ' + index );

      }

    },

    clone: function () {

      return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function ( v ) {

      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = ( v.w !== undefined ) ? v.w : 1;

      return this;

    },

    add: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
        return this.addVectors( v, w );

      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;

      return this;

    },

    addScalar: function ( s ) {

      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;

      return this;

    },

    addVectors: function ( a, b ) {

      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;

      return this;

    },

    addScaledVector: function ( v, s ) {

      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;

      return this;

    },

    sub: function ( v, w ) {

      if ( w !== undefined ) {

        console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
        return this.subVectors( v, w );

      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;

      return this;

    },

    subScalar: function ( s ) {

      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;

      return this;

    },

    subVectors: function ( a, b ) {

      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;

      return this;

    },

    multiplyScalar: function ( scalar ) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;

      return this;

    },

    applyMatrix4: function ( m ) {

      var x = this.x, y = this.y, z = this.z, w = this.w;
      var e = m.elements;

      this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
      this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
      this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
      this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

      return this;

    },

    divideScalar: function ( scalar ) {

      return this.multiplyScalar( 1 / scalar );

    },

    setAxisAngleFromQuaternion: function ( q ) {

      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

      // q is assumed to be normalized

      this.w = 2 * Math.acos( q.w );

      var s = Math.sqrt( 1 - q.w * q.w );

      if ( s < 0.0001 ) {

        this.x = 1;
        this.y = 0;
        this.z = 0;

      } else {

        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;

      }

      return this;

    },

    setAxisAngleFromRotationMatrix: function ( m ) {

      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var angle, x, y, z,   // variables for result
        epsilon = 0.01,   // margin to allow for rounding errors
        epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

        te = m.elements,

        m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
        m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
        m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

      if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
           ( Math.abs( m13 - m31 ) < epsilon ) &&
           ( Math.abs( m23 - m32 ) < epsilon ) ) {

        // singularity found
        // first check for identity matrix which must have +1 for all terms
        // in leading diagonal and zero in other terms

        if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
             ( Math.abs( m13 + m31 ) < epsilon2 ) &&
             ( Math.abs( m23 + m32 ) < epsilon2 ) &&
             ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

          // this singularity is identity matrix so angle = 0

          this.set( 1, 0, 0, 0 );

          return this; // zero angle, arbitrary axis

        }

        // otherwise this singularity is angle = 180

        angle = Math.PI;

        var xx = ( m11 + 1 ) / 2;
        var yy = ( m22 + 1 ) / 2;
        var zz = ( m33 + 1 ) / 2;
        var xy = ( m12 + m21 ) / 4;
        var xz = ( m13 + m31 ) / 4;
        var yz = ( m23 + m32 ) / 4;

        if ( ( xx > yy ) && ( xx > zz ) ) {

          // m11 is the largest diagonal term

          if ( xx < epsilon ) {

            x = 0;
            y = 0.707106781;
            z = 0.707106781;

          } else {

            x = Math.sqrt( xx );
            y = xy / x;
            z = xz / x;

          }

        } else if ( yy > zz ) {

          // m22 is the largest diagonal term

          if ( yy < epsilon ) {

            x = 0.707106781;
            y = 0;
            z = 0.707106781;

          } else {

            y = Math.sqrt( yy );
            x = xy / y;
            z = yz / y;

          }

        } else {

          // m33 is the largest diagonal term so base result on this

          if ( zz < epsilon ) {

            x = 0.707106781;
            y = 0.707106781;
            z = 0;

          } else {

            z = Math.sqrt( zz );
            x = xz / z;
            y = yz / z;

          }

        }

        this.set( x, y, z, angle );

        return this; // return 180 deg rotation

      }

      // as we have reached here there are no singularities so we can handle normally

      var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
                         ( m13 - m31 ) * ( m13 - m31 ) +
                         ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

      if ( Math.abs( s ) < 0.001 ) s = 1;

      // prevent divide by zero, should not happen if matrix is orthogonal and should be
      // caught by singularity test above, but I've left it in just in case

      this.x = ( m32 - m23 ) / s;
      this.y = ( m13 - m31 ) / s;
      this.z = ( m21 - m12 ) / s;
      this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

      return this;

    },

    min: function ( v ) {

      this.x = Math.min( this.x, v.x );
      this.y = Math.min( this.y, v.y );
      this.z = Math.min( this.z, v.z );
      this.w = Math.min( this.w, v.w );

      return this;

    },

    max: function ( v ) {

      this.x = Math.max( this.x, v.x );
      this.y = Math.max( this.y, v.y );
      this.z = Math.max( this.z, v.z );
      this.w = Math.max( this.w, v.w );

      return this;

    },

    clamp: function ( min, max ) {

      // assumes min < max, componentwise

      this.x = Math.max( min.x, Math.min( max.x, this.x ) );
      this.y = Math.max( min.y, Math.min( max.y, this.y ) );
      this.z = Math.max( min.z, Math.min( max.z, this.z ) );
      this.w = Math.max( min.w, Math.min( max.w, this.w ) );

      return this;

    },

    clampScalar: function () {

      var min, max;

      return function clampScalar( minVal, maxVal ) {

        if ( min === undefined ) {

          min = new Vector4();
          max = new Vector4();

        }

        min.set( minVal, minVal, minVal, minVal );
        max.set( maxVal, maxVal, maxVal, maxVal );

        return this.clamp( min, max );

      };

    }(),

    clampLength: function ( min, max ) {

      var length = this.length();

      return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    },

    floor: function () {

      this.x = Math.floor( this.x );
      this.y = Math.floor( this.y );
      this.z = Math.floor( this.z );
      this.w = Math.floor( this.w );

      return this;

    },

    ceil: function () {

      this.x = Math.ceil( this.x );
      this.y = Math.ceil( this.y );
      this.z = Math.ceil( this.z );
      this.w = Math.ceil( this.w );

      return this;

    },

    round: function () {

      this.x = Math.round( this.x );
      this.y = Math.round( this.y );
      this.z = Math.round( this.z );
      this.w = Math.round( this.w );

      return this;

    },

    roundToZero: function () {

      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
      this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
      this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

      return this;

    },

    negate: function () {

      this.x = - this.x;
      this.y = - this.y;
      this.z = - this.z;
      this.w = - this.w;

      return this;

    },

    dot: function ( v ) {

      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function () {

      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function () {

      return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function () {

      return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function () {

      return this.divideScalar( this.length() || 1 );

    },

    setLength: function ( length ) {

      return this.normalize().multiplyScalar( length );

    },

    lerp: function ( v, alpha ) {

      this.x += ( v.x - this.x ) * alpha;
      this.y += ( v.y - this.y ) * alpha;
      this.z += ( v.z - this.z ) * alpha;
      this.w += ( v.w - this.w ) * alpha;

      return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    },

    equals: function ( v ) {

      return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      this.x = array[ offset ];
      this.y = array[ offset + 1 ];
      this.z = array[ offset + 2 ];
      this.w = array[ offset + 3 ];

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this.x;
      array[ offset + 1 ] = this.y;
      array[ offset + 2 ] = this.z;
      array[ offset + 3 ] = this.w;

      return array;

    },

    fromBufferAttribute: function ( attribute, index, offset ) {

      if ( offset !== undefined ) {

        console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

      }

      this.x = attribute.getX( index );
      this.y = attribute.getY( index );
      this.z = attribute.getZ( index );
      this.w = attribute.getW( index );

      return this;

    }

  } );

  /**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  function WebGLRenderTarget( width, height, options ) {

    this.uuid = _Math.generateUUID();

    this.width = width;
    this.height = height;

    this.scissor = new Vector4( 0, 0, width, height );
    this.scissorTest = false;

    this.viewport = new Vector4( 0, 0, width, height );

    options = options || {};

    if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

    this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

    isWebGLRenderTarget: true,

    setSize: function ( width, height ) {

      if ( this.width !== width || this.height !== height ) {

        this.width = width;
        this.height = height;

        this.dispose();

      }

      this.viewport.set( 0, 0, width, height );
      this.scissor.set( 0, 0, width, height );

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( source ) {

      this.width = source.width;
      this.height = source.height;

      this.viewport.copy( source.viewport );

      this.texture = source.texture.clone();

      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;

      return this;

    },

    dispose: function () {

      this.dispatchEvent( { type: 'dispose' } );

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com
   */

  function WebGLRenderTargetCube( width, height, options ) {

    WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    this.activeMipMapLevel = 0;

  }

  WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
  WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

  WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    this.image = { data: data, width: width, height: height };

    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;

  }

  DataTexture.prototype = Object.create( Texture.prototype );
  DataTexture.prototype.constructor = DataTexture;

  DataTexture.prototype.isDataTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    this.flipY = false;

  }

  CubeTexture.prototype = Object.create( Texture.prototype );
  CubeTexture.prototype.constructor = CubeTexture;

  CubeTexture.prototype.isCubeTexture = true;

  Object.defineProperty( CubeTexture.prototype, 'images', {

    get: function () {

      return this.image;

    },

    set: function ( value ) {

      this.image = value;

    }

  } );

  /**
   * @author tschw
   *
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [renderer] )
   *
   *    uploads a uniform value(s)
   *    the 'renderer' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (renderer factorizations):
   *
   * .upload( gl, seq, values, renderer )
   *
   *    sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   *    filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (renderer factorizations):
   *
   * .setValue( gl, name, value )
   *
   *    sets uniform with  name 'name' to 'value'
   *
   * .set( gl, obj, prop )
   *
   *    sets uniform from object and property with same name than uniform
   *
   * .setOptional( gl, obj, prop )
   *
   *    like .set for an optional property of the object
   *
   */

  var emptyTexture = new Texture();
  var emptyCubeTexture = new CubeTexture();

  // --- Base for inner nodes (including the root) ---

  function UniformContainer() {

    this.seq = [];
    this.map = {};

  }

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  var arrayCacheF32 = [];
  var arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  var mat4array = new Float32Array( 16 );
  var mat3array = new Float32Array( 9 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

    var firstElem = array[ 0 ];

    if ( firstElem <= 0 || firstElem > 0 ) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983

    var n = nBlocks * blockSize,
      r = arrayCacheF32[ n ];

    if ( r === undefined ) {

      r = new Float32Array( n );
      arrayCacheF32[ n ] = r;

    }

    if ( nBlocks !== 0 ) {

      firstElem.toArray( r, 0 );

      for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

        offset += blockSize;
        array[ i ].toArray( r, offset );

      }

    }

    return r;

  }

  // Texture unit allocation

  function allocTexUnits( renderer, n ) {

    var r = arrayCacheI32[ n ];

    if ( r === undefined ) {

      r = new Int32Array( n );
      arrayCacheI32[ n ] = r;

    }

    for ( var i = 0; i !== n; ++ i )
      r[ i ] = renderer.allocTextureUnit();

    return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValue1f( gl, v ) {

    gl.uniform1f( this.addr, v );

  }

  function setValue1i( gl, v ) {

    gl.uniform1i( this.addr, v );

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValue2fv( gl, v ) {

    if ( v.x === undefined ) {

      gl.uniform2fv( this.addr, v );

    } else {

      gl.uniform2f( this.addr, v.x, v.y );

    }

  }

  function setValue3fv( gl, v ) {

    if ( v.x !== undefined ) {

      gl.uniform3f( this.addr, v.x, v.y, v.z );

    } else if ( v.r !== undefined ) {

      gl.uniform3f( this.addr, v.r, v.g, v.b );

    } else {

      gl.uniform3fv( this.addr, v );

    }

  }

  function setValue4fv( gl, v ) {

    if ( v.x === undefined ) {

      gl.uniform4fv( this.addr, v );

    } else {

       gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    }

  }

  // Single matrix (from flat array or MatrixN)

  function setValue2fm( gl, v ) {

    gl.uniformMatrix2fv( this.addr, false, v.elements || v );

  }

  function setValue3fm( gl, v ) {

    if ( v.elements === undefined ) {

      gl.uniformMatrix3fv( this.addr, false, v );

    } else {

      mat3array.set( v.elements );
      gl.uniformMatrix3fv( this.addr, false, mat3array );

    }

  }

  function setValue4fm( gl, v ) {

    if ( v.elements === undefined ) {

      gl.uniformMatrix4fv( this.addr, false, v );

    } else {

      mat4array.set( v.elements );
      gl.uniformMatrix4fv( this.addr, false, mat4array );

    }

  }

  // Single texture (2D / Cube)

  function setValueT1( gl, v, renderer ) {

    var unit = renderer.allocTextureUnit();
    gl.uniform1i( this.addr, unit );
    renderer.setTexture2D( v || emptyTexture, unit );

  }

  function setValueT6( gl, v, renderer ) {

    var unit = renderer.allocTextureUnit();
    gl.uniform1i( this.addr, unit );
    renderer.setTextureCube( v || emptyCubeTexture, unit );

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)

  function setValue2iv( gl, v ) {

    gl.uniform2iv( this.addr, v );

  }

  function setValue3iv( gl, v ) {

    gl.uniform3iv( this.addr, v );

  }

  function setValue4iv( gl, v ) {

    gl.uniform4iv( this.addr, v );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

    switch ( type ) {

      case 0x1406: return setValue1f; // FLOAT
      case 0x8b50: return setValue2fv; // _VEC2
      case 0x8b51: return setValue3fv; // _VEC3
      case 0x8b52: return setValue4fv; // _VEC4

      case 0x8b5a: return setValue2fm; // _MAT2
      case 0x8b5b: return setValue3fm; // _MAT3
      case 0x8b5c: return setValue4fm; // _MAT4

      case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
      case 0x8b60: return setValueT6; // SAMPLER_CUBE

      case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
      case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
      case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
      case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    }

  }

  // Array of scalars

  function setValue1fv( gl, v ) {

    gl.uniform1fv( this.addr, v );

  }
  function setValue1iv( gl, v ) {

    gl.uniform1iv( this.addr, v );

  }

  // Array of vectors (flat or from THREE classes)

  function setValueV2a( gl, v ) {

    gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

  }

  function setValueV3a( gl, v ) {

    gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

  }

  function setValueV4a( gl, v ) {

    gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

  }

  // Array of matrices (flat or from THREE clases)

  function setValueM2a( gl, v ) {

    gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

  }

  function setValueM3a( gl, v ) {

    gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

  }

  function setValueM4a( gl, v ) {

    gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

  }

  // Array of textures (2D / Cube)

  function setValueT1a( gl, v, renderer ) {

    var n = v.length,
      units = allocTexUnits( renderer, n );

    gl.uniform1iv( this.addr, units );

    for ( var i = 0; i !== n; ++ i ) {

      renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    }

  }

  function setValueT6a( gl, v, renderer ) {

    var n = v.length,
      units = allocTexUnits( renderer, n );

    gl.uniform1iv( this.addr, units );

    for ( var i = 0; i !== n; ++ i ) {

      renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    }

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

    switch ( type ) {

      case 0x1406: return setValue1fv; // FLOAT
      case 0x8b50: return setValueV2a; // _VEC2
      case 0x8b51: return setValueV3a; // _VEC3
      case 0x8b52: return setValueV4a; // _VEC4

      case 0x8b5a: return setValueM2a; // _MAT2
      case 0x8b5b: return setValueM3a; // _MAT3
      case 0x8b5c: return setValueM4a; // _MAT4

      case 0x8b5e: return setValueT1a; // SAMPLER_2D
      case 0x8b60: return setValueT6a; // SAMPLER_CUBE

      case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
      case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
      case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
      case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    }

  }

  // --- Uniform Classes ---

  function SingleUniform( id, activeInfo, addr ) {

    this.id = id;
    this.addr = addr;
    this.setValue = getSingularSetter( activeInfo.type );

    // this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform( id, activeInfo, addr ) {

    this.id = id;
    this.addr = addr;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter( activeInfo.type );

    // this.path = activeInfo.name; // DEBUG

  }

  function StructuredUniform( id ) {

    this.id = id;

    UniformContainer.call( this ); // mix-in

  }

  StructuredUniform.prototype.setValue = function ( gl, value ) {

    // Note: Don't need an extra 'renderer' parameter, since samplers
    // are not allowed in structured uniforms.

    var seq = this.seq;

    for ( var i = 0, n = seq.length; i !== n; ++ i ) {

      var u = seq[ i ];
      u.setValue( gl, value[ u.id ] );

    }

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  // extracts
  //  - the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

    container.seq.push( uniformObject );
    container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

    var path = activeInfo.name,
      pathLength = path.length;

    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;

    for ( ; ; ) {

      var match = RePathPart.exec( path ),
        matchEnd = RePathPart.lastIndex,

        id = match[ 1 ],
        idIsIndex = match[ 2 ] === ']',
        subscript = match[ 3 ];

      if ( idIsIndex ) id = id | 0; // convert to integer

      if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

        // bare name or "pure" bottom-level array "[0]" suffix

        addUniform( container, subscript === undefined ?
          new SingleUniform( id, activeInfo, addr ) :
          new PureArrayUniform( id, activeInfo, addr ) );

        break;

      } else {

        // step into inner node / create it in case it doesn't exist

        var map = container.map, next = map[ id ];

        if ( next === undefined ) {

          next = new StructuredUniform( id );
          addUniform( container, next );

        }

        container = next;

      }

    }

  }

  // Root Container

  function WebGLUniforms( gl, program, renderer ) {

    UniformContainer.call( this );

    this.renderer = renderer;

    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    for ( var i = 0; i < n; ++ i ) {

      var info = gl.getActiveUniform( program, i ),
        path = info.name,
        addr = gl.getUniformLocation( program, path );

      parseUniform( info, addr, this );

    }

  }

  WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

    var u = this.map[ name ];

    if ( u !== undefined ) u.setValue( gl, value, this.renderer );

  };

  WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

    var v = object[ name ];

    if ( v !== undefined ) this.setValue( gl, name, v );

  };


  // Static interface

  WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

    for ( var i = 0, n = seq.length; i !== n; ++ i ) {

      var u = seq[ i ],
        v = values[ u.id ];

      if ( v.needsUpdate !== false ) {

        // note: always updating when .needsUpdate is undefined
        u.setValue( gl, v.value, renderer );

      }

    }

  };

  WebGLUniforms.seqWithValue = function ( seq, values ) {

    var r = [];

    for ( var i = 0, n = seq.length; i !== n; ++ i ) {

      var u = seq[ i ];
      if ( u.id in values ) r.push( u );

    }

    return r;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  function Color( r, g, b ) {

    if ( g === undefined && b === undefined ) {

      // r is THREE.Color, hex or string
      return this.set( r );

    }

    return this.setRGB( r, g, b );

  }

  Object.assign( Color.prototype, {

    isColor: true,

    r: 1, g: 1, b: 1,

    set: function ( value ) {

      if ( value && value.isColor ) {

        this.copy( value );

      } else if ( typeof value === 'number' ) {

        this.setHex( value );

      } else if ( typeof value === 'string' ) {

        this.setStyle( value );

      }

      return this;

    },

    setScalar: function ( scalar ) {

      this.r = scalar;
      this.g = scalar;
      this.b = scalar;

      return this;

    },

    setHex: function ( hex ) {

      hex = Math.floor( hex );

      this.r = ( hex >> 16 & 255 ) / 255;
      this.g = ( hex >> 8 & 255 ) / 255;
      this.b = ( hex & 255 ) / 255;

      return this;

    },

    setRGB: function ( r, g, b ) {

      this.r = r;
      this.g = g;
      this.b = b;

      return this;

    },

    setHSL: function () {

      function hue2rgb( p, q, t ) {

        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;

      }

      return function setHSL( h, s, l ) {

        // h,s,l ranges are in 0.0 - 1.0
        h = _Math.euclideanModulo( h, 1 );
        s = _Math.clamp( s, 0, 1 );
        l = _Math.clamp( l, 0, 1 );

        if ( s === 0 ) {

          this.r = this.g = this.b = l;

        } else {

          var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
          var q = ( 2 * l ) - p;

          this.r = hue2rgb( q, p, h + 1 / 3 );
          this.g = hue2rgb( q, p, h );
          this.b = hue2rgb( q, p, h - 1 / 3 );

        }

        return this;

      };

    }(),

    setStyle: function ( style ) {

      function handleAlpha( string ) {

        if ( string === undefined ) return;

        if ( parseFloat( string ) < 1 ) {

          console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

        }

      }


      var m;

      if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

        // rgb / hsl

        var color;
        var name = m[ 1 ];
        var components = m[ 2 ];

        switch ( name ) {

          case 'rgb':
          case 'rgba':

            if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

              // rgb(255,0,0) rgba(255,0,0,0.5)
              this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
              this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
              this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

              handleAlpha( color[ 5 ] );

              return this;

            }

            if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
              this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
              this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
              this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

              handleAlpha( color[ 5 ] );

              return this;

            }

            break;

          case 'hsl':
          case 'hsla':

            if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
              var h = parseFloat( color[ 1 ] ) / 360;
              var s = parseInt( color[ 2 ], 10 ) / 100;
              var l = parseInt( color[ 3 ], 10 ) / 100;

              handleAlpha( color[ 5 ] );

              return this.setHSL( h, s, l );

            }

            break;

        }

      } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

        // hex color

        var hex = m[ 1 ];
        var size = hex.length;

        if ( size === 3 ) {

          // #ff0
          this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
          this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
          this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

          return this;

        } else if ( size === 6 ) {

          // #ff0000
          this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
          this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
          this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

          return this;

        }

      }

      if ( style && style.length > 0 ) {

        // color keywords
        var hex = ColorKeywords[ style ];

        if ( hex !== undefined ) {

          // red
          this.setHex( hex );

        } else {

          // unknown color
          console.warn( 'THREE.Color: Unknown color ' + style );

        }

      }

      return this;

    },

    clone: function () {

      return new this.constructor( this.r, this.g, this.b );

    },

    copy: function ( color ) {

      this.r = color.r;
      this.g = color.g;
      this.b = color.b;

      return this;

    },

    copyGammaToLinear: function ( color, gammaFactor ) {

      if ( gammaFactor === undefined ) gammaFactor = 2.0;

      this.r = Math.pow( color.r, gammaFactor );
      this.g = Math.pow( color.g, gammaFactor );
      this.b = Math.pow( color.b, gammaFactor );

      return this;

    },

    copyLinearToGamma: function ( color, gammaFactor ) {

      if ( gammaFactor === undefined ) gammaFactor = 2.0;

      var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

      this.r = Math.pow( color.r, safeInverse );
      this.g = Math.pow( color.g, safeInverse );
      this.b = Math.pow( color.b, safeInverse );

      return this;

    },

    convertGammaToLinear: function () {

      var r = this.r, g = this.g, b = this.b;

      this.r = r * r;
      this.g = g * g;
      this.b = b * b;

      return this;

    },

    convertLinearToGamma: function () {

      this.r = Math.sqrt( this.r );
      this.g = Math.sqrt( this.g );
      this.b = Math.sqrt( this.b );

      return this;

    },

    getHex: function () {

      return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function () {

      return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    },

    getHSL: function ( optionalTarget ) {

      // h,s,l ranges are in 0.0 - 1.0

      var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

      var r = this.r, g = this.g, b = this.b;

      var max = Math.max( r, g, b );
      var min = Math.min( r, g, b );

      var hue, saturation;
      var lightness = ( min + max ) / 2.0;

      if ( min === max ) {

        hue = 0;
        saturation = 0;

      } else {

        var delta = max - min;

        saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

        switch ( max ) {

          case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
          case g: hue = ( b - r ) / delta + 2; break;
          case b: hue = ( r - g ) / delta + 4; break;

        }

        hue /= 6;

      }

      hsl.h = hue;
      hsl.s = saturation;
      hsl.l = lightness;

      return hsl;

    },

    getStyle: function () {

      return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function ( h, s, l ) {

      var hsl = this.getHSL();

      hsl.h += h; hsl.s += s; hsl.l += l;

      this.setHSL( hsl.h, hsl.s, hsl.l );

      return this;

    },

    add: function ( color ) {

      this.r += color.r;
      this.g += color.g;
      this.b += color.b;

      return this;

    },

    addColors: function ( color1, color2 ) {

      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;

      return this;

    },

    addScalar: function ( s ) {

      this.r += s;
      this.g += s;
      this.b += s;

      return this;

    },

    sub: function ( color ) {

      this.r = Math.max( 0, this.r - color.r );
      this.g = Math.max( 0, this.g - color.g );
      this.b = Math.max( 0, this.b - color.b );

      return this;

    },

    multiply: function ( color ) {

      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;

      return this;

    },

    multiplyScalar: function ( s ) {

      this.r *= s;
      this.g *= s;
      this.b *= s;

      return this;

    },

    lerp: function ( color, alpha ) {

      this.r += ( color.r - this.r ) * alpha;
      this.g += ( color.g - this.g ) * alpha;
      this.b += ( color.b - this.b ) * alpha;

      return this;

    },

    equals: function ( c ) {

      return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function ( array, offset ) {

      if ( offset === undefined ) offset = 0;

      this.r = array[ offset ];
      this.g = array[ offset + 1 ];
      this.b = array[ offset + 2 ];

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this.r;
      array[ offset + 1 ] = this.g;
      array[ offset + 2 ] = this.b;

      return array;

    },

    toJSON: function () {

      return this.getHex();

    }

  } );

  /**
   * Uniforms library for shared webgl shaders
   */

  var UniformsLib = {

    common: {

      diffuse: { value: new Color( 0xeeeeee ) },
      opacity: { value: 1.0 },

      map: { value: null },
      uvTransform: { value: new Matrix3() },

      alphaMap: { value: null },

    },

    specularmap: {

      specularMap: { value: null },

    },

    envmap: {

      envMap: { value: null },
      flipEnvMap: { value: - 1 },
      reflectivity: { value: 1.0 },
      refractionRatio: { value: 0.98 }

    },

    aomap: {

      aoMap: { value: null },
      aoMapIntensity: { value: 1 }

    },

    lightmap: {

      lightMap: { value: null },
      lightMapIntensity: { value: 1 }

    },

    emissivemap: {

      emissiveMap: { value: null }

    },

    bumpmap: {

      bumpMap: { value: null },
      bumpScale: { value: 1 }

    },

    normalmap: {

      normalMap: { value: null },
      normalScale: { value: new Vector2( 1, 1 ) }

    },

    displacementmap: {

      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }

    },

    roughnessmap: {

      roughnessMap: { value: null }

    },

    metalnessmap: {

      metalnessMap: { value: null }

    },

    gradientmap: {

      gradientMap: { value: null }

    },

    fog: {

      fogDensity: { value: 0.00025 },
      fogNear: { value: 1 },
      fogFar: { value: 2000 },
      fogColor: { value: new Color( 0xffffff ) }

    },

    lights: {

      ambientLightColor: { value: [] },

      directionalLights: { value: [], properties: {
        direction: {},
        color: {},

        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },

      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },

      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},

        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },

      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },

      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},

        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },

      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },

      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },

      // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } }

    },

    points: {

      diffuse: { value: new Color( 0xeeeeee ) },
      opacity: { value: 1.0 },
      size: { value: 1.0 },
      scale: { value: 1.0 },
      map: { value: null },
      uvTransform: { value: new Matrix3() }

    }

  };

  /**
   * Uniform Utilities
   */

  var UniformsUtils = {

    merge: function ( uniforms ) {

      var merged = {};

      for ( var u = 0; u < uniforms.length; u ++ ) {

        var tmp = this.clone( uniforms[ u ] );

        for ( var p in tmp ) {

          merged[ p ] = tmp[ p ];

        }

      }

      return merged;

    },

    clone: function ( uniforms_src ) {

      var uniforms_dst = {};

      for ( var u in uniforms_src ) {

        uniforms_dst[ u ] = {};

        for ( var p in uniforms_src[ u ] ) {

          var parameter_src = uniforms_src[ u ][ p ];

          if ( parameter_src && ( parameter_src.isColor ||
            parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
            parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
            parameter_src.isTexture ) ) {

            uniforms_dst[ u ][ p ] = parameter_src.clone();

          } else if ( Array.isArray( parameter_src ) ) {

            uniforms_dst[ u ][ p ] = parameter_src.slice();

          } else {

            uniforms_dst[ u ][ p ] = parameter_src;

          }

        }

      }

      return uniforms_dst;

    }

  };

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

  var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var begin_vertex = "\nvec3 transformed = vec3( position );\n";

  var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

  var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

  var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

  var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

  var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

  var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

  var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

  var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

  var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

  var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

  var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

  var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

  var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

  var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

  var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

  var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

  var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

  var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

  var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

  var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

  var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

  var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

  var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

  var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

  var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

  var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars: lights_pars,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_template: lights_template,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment: normal_fragment,
    normalmap_pars_fragment: normalmap_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,

    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   */

  var ShaderLib = {

    basic: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ] ),

      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag

    },

    lambert: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color( 0x000000 ) }
        }
      ] ),

      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag

    },

    phong: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color( 0x000000 ) },
          specular: { value: new Color( 0x111111 ) },
          shininess: { value: 30 }
        }
      ] ),

      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag

    },

    standard: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color( 0x000000 ) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 } // temporary
        }
      ] ),

      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag

    },

    points: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.points,
        UniformsLib.fog
      ] ),

      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag

    },

    dashed: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ] ),

      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag

    },

    depth: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.displacementmap
      ] ),

      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag

    },

    normal: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1.0 }
        }
      ] ),

      vertexShader: ShaderChunk.normal_vert,
      fragmentShader: ShaderChunk.normal_frag

    },

    /* -------------------------------------------------------------------------
    //  Cube map shader
     ------------------------------------------------------------------------- */

    cube: {

      uniforms: {
        tCube: { value: null },
        tFlip: { value: - 1 },
        opacity: { value: 1.0 }
      },

      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag

    },

    equirect: {

      uniforms: {
        tEquirect: { value: null },
      },

      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag

    },

    distanceRGBA: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1000 }
        }
      ] ),

      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag

    },

    shadow: {

      uniforms: UniformsUtils.merge( [
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color( 0x00000 ) },
          opacity: { value: 1.0 }
        },
      ] ),

      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag

    }

  };

  ShaderLib.physical = {

    uniforms: UniformsUtils.merge( [
      ShaderLib.standard.uniforms,
      {
        clearCoat: { value: 0 },
        clearCoatRoughness: { value: 0 }
      }
    ] ),

    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag

  };

  /**
   * @author bhouston / http://clara.io
   */

  function Box2( min, max ) {

    this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
    this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

  }

  Object.assign( Box2.prototype, {

    set: function ( min, max ) {

      this.min.copy( min );
      this.max.copy( max );

      return this;

    },

    setFromPoints: function ( points ) {

      this.makeEmpty();

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        this.expandByPoint( points[ i ] );

      }

      return this;

    },

    setFromCenterAndSize: function () {

      var v1 = new Vector2();

      return function setFromCenterAndSize( center, size ) {

        var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );

        return this;

      };

    }(),

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( box ) {

      this.min.copy( box.min );
      this.max.copy( box.max );

      return this;

    },

    makeEmpty: function () {

      this.min.x = this.min.y = + Infinity;
      this.max.x = this.max.y = - Infinity;

      return this;

    },

    isEmpty: function () {

      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    getCenter: function ( optionalTarget ) {

      var result = optionalTarget || new Vector2();
      return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    getSize: function ( optionalTarget ) {

      var result = optionalTarget || new Vector2();
      return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

      this.min.min( point );
      this.max.max( point );

      return this;

    },

    expandByVector: function ( vector ) {

      this.min.sub( vector );
      this.max.add( vector );

      return this;

    },

    expandByScalar: function ( scalar ) {

      this.min.addScalar( - scalar );
      this.max.addScalar( scalar );

      return this;

    },

    containsPoint: function ( point ) {

      return point.x < this.min.x || point.x > this.max.x ||
        point.y < this.min.y || point.y > this.max.y ? false : true;

    },

    containsBox: function ( box ) {

      return this.min.x <= box.min.x && box.max.x <= this.max.x &&
        this.min.y <= box.min.y && box.max.y <= this.max.y;

    },

    getParameter: function ( point, optionalTarget ) {

      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      var result = optionalTarget || new Vector2();

      return result.set(
        ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
        ( point.y - this.min.y ) / ( this.max.y - this.min.y )
      );

    },

    intersectsBox: function ( box ) {

      // using 4 splitting planes to rule out intersections

      return box.max.x < this.min.x || box.min.x > this.max.x ||
        box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

    },

    clampPoint: function ( point, optionalTarget ) {

      var result = optionalTarget || new Vector2();
      return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

      var v1 = new Vector2();

      return function distanceToPoint( point ) {

        var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
        return clampedPoint.sub( point ).length();

      };

    }(),

    intersect: function ( box ) {

      this.min.max( box.min );
      this.max.min( box.max );

      return this;

    },

    union: function ( box ) {

      this.min.min( box.min );
      this.max.max( box.max );

      return this;

    },

    translate: function ( offset ) {

      this.min.add( offset );
      this.max.add( offset );

      return this;

    },

    equals: function ( box ) {

      return box.min.equals( this.min ) && box.max.equals( this.max );

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {

    var vertexBuffer, elementBuffer;
    var shader, program, attributes, uniforms;

    var tempTexture, occlusionTexture;

    function init() {

      var vertices = new Float32Array( [
        - 1, - 1, 0, 0,
          1, - 1, 1, 0,
          1, 1, 1, 1,
        - 1, 1, 0, 1
      ] );

      var faces = new Uint16Array( [
        0, 1, 2,
        0, 2, 3
      ] );

      // buffers

      vertexBuffer = gl.createBuffer();
      elementBuffer = gl.createBuffer();

      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

      // textures

      tempTexture = gl.createTexture();
      occlusionTexture = gl.createTexture();

      state.bindTexture( gl.TEXTURE_2D, tempTexture );
      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

      state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

      shader = {

        vertexShader: [

          'uniform lowp int renderType;',

          'uniform vec3 screenPosition;',
          'uniform vec2 scale;',
          'uniform float rotation;',

          'uniform sampler2D occlusionMap;',

          'attribute vec2 position;',
          'attribute vec2 uv;',

          'varying vec2 vUV;',
          'varying float vVisibility;',

          'void main() {',

          ' vUV = uv;',

          ' vec2 pos = position;',

          ' if ( renderType == 2 ) {',

          '   vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
          '   visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',

          '   vVisibility =        visibility.r / 9.0;',
          '   vVisibility *= 1.0 - visibility.g / 9.0;',
          '   vVisibility *=       visibility.b / 9.0;',
          '   vVisibility *= 1.0 - visibility.a / 9.0;',

          '   pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
          '   pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',

          ' }',

          ' gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',

          '}'

        ].join( '\n' ),

        fragmentShader: [

          'uniform lowp int renderType;',

          'uniform sampler2D map;',
          'uniform float opacity;',
          'uniform vec3 color;',

          'varying vec2 vUV;',
          'varying float vVisibility;',

          'void main() {',

          // pink square

          ' if ( renderType == 0 ) {',

          '   gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',

          // restore

          ' } else if ( renderType == 1 ) {',

          '   gl_FragColor = texture2D( map, vUV );',

          // flare

          ' } else {',

          '   vec4 texture = texture2D( map, vUV );',
          '   texture.a *= opacity * vVisibility;',
          '   gl_FragColor = texture;',
          '   gl_FragColor.rgb *= color;',

          ' }',

          '}'

        ].join( '\n' )

      };

      program = createProgram( shader );

      attributes = {
        vertex: gl.getAttribLocation( program, 'position' ),
        uv: gl.getAttribLocation( program, 'uv' )
      };

      uniforms = {
        renderType: gl.getUniformLocation( program, 'renderType' ),
        map: gl.getUniformLocation( program, 'map' ),
        occlusionMap: gl.getUniformLocation( program, 'occlusionMap' ),
        opacity: gl.getUniformLocation( program, 'opacity' ),
        color: gl.getUniformLocation( program, 'color' ),
        scale: gl.getUniformLocation( program, 'scale' ),
        rotation: gl.getUniformLocation( program, 'rotation' ),
        screenPosition: gl.getUniformLocation( program, 'screenPosition' )
      };

    }

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function ( flares, scene, camera, viewport ) {

      if ( flares.length === 0 ) return;

      var tempPosition = new Vector3();

      var invAspect = viewport.w / viewport.z,
        halfViewportWidth = viewport.z * 0.5,
        halfViewportHeight = viewport.w * 0.5;

      var size = 16 / viewport.w,
        scale = new Vector2( size * invAspect, size );

      var screenPosition = new Vector3( 1, 1, 0 ),
        screenPositionPixels = new Vector2( 1, 1 );

      var validArea = new Box2();

      validArea.min.set( viewport.x, viewport.y );
      validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

      if ( program === undefined ) {

        init();

      }

      state.useProgram( program );

      state.initAttributes();
      state.enableAttribute( attributes.vertex );
      state.enableAttribute( attributes.uv );
      state.disableUnusedAttributes();

      // loop through all lens flares to update their occlusion and positions
      // setup gl and common used attribs/uniforms

      gl.uniform1i( uniforms.occlusionMap, 0 );
      gl.uniform1i( uniforms.map, 1 );

      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
      gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
      gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

      state.disable( gl.CULL_FACE );
      state.buffers.depth.setMask( false );

      for ( var i = 0, l = flares.length; i < l; i ++ ) {

        size = 16 / viewport.w;
        scale.set( size * invAspect, size );

        // calc object screen position

        var flare = flares[ i ];

        tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

        tempPosition.applyMatrix4( camera.matrixWorldInverse );
        tempPosition.applyMatrix4( camera.projectionMatrix );

        // setup arrays for gl programs

        screenPosition.copy( tempPosition );

        // horizontal and vertical coordinate of the lower left corner of the pixels to copy

        screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
        screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

        // screen cull

        if ( validArea.containsPoint( screenPositionPixels ) === true ) {

          // save current RGB to temp texture

          state.activeTexture( gl.TEXTURE0 );
          state.bindTexture( gl.TEXTURE_2D, null );
          state.activeTexture( gl.TEXTURE1 );
          state.bindTexture( gl.TEXTURE_2D, tempTexture );
          gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


          // render pink quad

          gl.uniform1i( uniforms.renderType, 0 );
          gl.uniform2f( uniforms.scale, scale.x, scale.y );
          gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

          state.disable( gl.BLEND );
          state.enable( gl.DEPTH_TEST );

          gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


          // copy result to occlusionMap

          state.activeTexture( gl.TEXTURE0 );
          state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
          gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


          // restore graphics

          gl.uniform1i( uniforms.renderType, 1 );
          state.disable( gl.DEPTH_TEST );

          state.activeTexture( gl.TEXTURE1 );
          state.bindTexture( gl.TEXTURE_2D, tempTexture );
          gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


          // update object positions

          flare.positionScreen.copy( screenPosition );

          if ( flare.customUpdateCallback ) {

            flare.customUpdateCallback( flare );

          } else {

            flare.updateLensFlares();

          }

          // render flares

          gl.uniform1i( uniforms.renderType, 2 );
          state.enable( gl.BLEND );

          for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

            var sprite = flare.lensFlares[ j ];

            if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

              screenPosition.x = sprite.x;
              screenPosition.y = sprite.y;
              screenPosition.z = sprite.z;

              size = sprite.size * sprite.scale / viewport.w;

              scale.x = size * invAspect;
              scale.y = size;

              gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
              gl.uniform2f( uniforms.scale, scale.x, scale.y );
              gl.uniform1f( uniforms.rotation, sprite.rotation );

              gl.uniform1f( uniforms.opacity, sprite.opacity );
              gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

              state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );

              textures.setTexture2D( sprite.texture, 1 );

              gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

            }

          }

        }

      }

      // restore gl

      state.enable( gl.CULL_FACE );
      state.enable( gl.DEPTH_TEST );
      state.buffers.depth.setMask( true );

      state.reset();

    };

    function createProgram( shader ) {

      var program = gl.createProgram();

      var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
      var vertexShader = gl.createShader( gl.VERTEX_SHADER );

      var prefix = 'precision ' + capabilities.precision + ' float;\n';

      gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
      gl.shaderSource( vertexShader, prefix + shader.vertexShader );

      gl.compileShader( fragmentShader );
      gl.compileShader( vertexShader );

      gl.attachShader( program, fragmentShader );
      gl.attachShader( program, vertexShader );

      gl.linkProgram( program );

      return program;

    }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

  }

  CanvasTexture.prototype = Object.create( Texture.prototype );
  CanvasTexture.prototype.constructor = CanvasTexture;

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new Vector3();
    var spriteRotation = new Quaternion();
    var spriteScale = new Vector3();

    function init() {

      var vertices = new Float32Array( [
        - 0.5, - 0.5, 0, 0,
          0.5, - 0.5, 1, 0,
          0.5, 0.5, 1, 1,
        - 0.5, 0.5, 0, 1
      ] );

      var faces = new Uint16Array( [
        0, 1, 2,
        0, 2, 3
      ] );

      vertexBuffer = gl.createBuffer();
      elementBuffer = gl.createBuffer();

      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

      program = createProgram();

      attributes = {
        position: gl.getAttribLocation( program, 'position' ),
        uv: gl.getAttribLocation( program, 'uv' )
      };

      uniforms = {
        uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
        uvScale: gl.getUniformLocation( program, 'uvScale' ),

        rotation: gl.getUniformLocation( program, 'rotation' ),
        scale: gl.getUniformLocation( program, 'scale' ),

        color: gl.getUniformLocation( program, 'color' ),
        map: gl.getUniformLocation( program, 'map' ),
        opacity: gl.getUniformLocation( program, 'opacity' ),

        modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
        projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

        fogType: gl.getUniformLocation( program, 'fogType' ),
        fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
        fogNear: gl.getUniformLocation( program, 'fogNear' ),
        fogFar: gl.getUniformLocation( program, 'fogFar' ),
        fogColor: gl.getUniformLocation( program, 'fogColor' ),
        fogDepth: gl.getUniformLocation( program, 'fogDepth' ),

        alphaTest: gl.getUniformLocation( program, 'alphaTest' )
      };

      var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
      canvas.width = 8;
      canvas.height = 8;

      var context = canvas.getContext( '2d' );
      context.fillStyle = 'white';
      context.fillRect( 0, 0, 8, 8 );

      texture = new CanvasTexture( canvas );

    }

    this.render = function ( sprites, scene, camera ) {

      if ( sprites.length === 0 ) return;

      // setup gl

      if ( program === undefined ) {

        init();

      }

      state.useProgram( program );

      state.initAttributes();
      state.enableAttribute( attributes.position );
      state.enableAttribute( attributes.uv );
      state.disableUnusedAttributes();

      state.disable( gl.CULL_FACE );
      state.enable( gl.BLEND );

      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
      gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
      gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

      gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      state.activeTexture( gl.TEXTURE0 );
      gl.uniform1i( uniforms.map, 0 );

      var oldFogType = 0;
      var sceneFogType = 0;
      var fog = scene.fog;

      if ( fog ) {

        gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

        if ( fog.isFog ) {

          gl.uniform1f( uniforms.fogNear, fog.near );
          gl.uniform1f( uniforms.fogFar, fog.far );

          gl.uniform1i( uniforms.fogType, 1 );
          oldFogType = 1;
          sceneFogType = 1;

        } else if ( fog.isFogExp2 ) {

          gl.uniform1f( uniforms.fogDensity, fog.density );

          gl.uniform1i( uniforms.fogType, 2 );
          oldFogType = 2;
          sceneFogType = 2;

        }

      } else {

        gl.uniform1i( uniforms.fogType, 0 );
        oldFogType = 0;
        sceneFogType = 0;

      }


      // update positions and sort

      for ( var i = 0, l = sprites.length; i < l; i ++ ) {

        var sprite = sprites[ i ];

        sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
        sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

      }

      sprites.sort( painterSortStable );

      // render all sprites

      var scale = [];

      for ( var i = 0, l = sprites.length; i < l; i ++ ) {

        var sprite = sprites[ i ];
        var material = sprite.material;

        if ( material.visible === false ) continue;

        sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

        gl.uniform1f( uniforms.alphaTest, material.alphaTest );
        gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

        sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

        scale[ 0 ] = spriteScale.x;
        scale[ 1 ] = spriteScale.y;

        var fogType = 0;

        if ( scene.fog && material.fog ) {

          fogType = sceneFogType;

        }

        if ( oldFogType !== fogType ) {

          gl.uniform1i( uniforms.fogType, fogType );
          oldFogType = fogType;

        }

        if ( material.map !== null ) {

          gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
          gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

        } else {

          gl.uniform2f( uniforms.uvOffset, 0, 0 );
          gl.uniform2f( uniforms.uvScale, 1, 1 );

        }

        gl.uniform1f( uniforms.opacity, material.opacity );
        gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

        gl.uniform1f( uniforms.rotation, material.rotation );
        gl.uniform2fv( uniforms.scale, scale );

        state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
        state.buffers.depth.setTest( material.depthTest );
        state.buffers.depth.setMask( material.depthWrite );
        state.buffers.color.setMask( material.colorWrite );

        textures.setTexture2D( material.map || texture, 0 );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

      }

      // restore gl

      state.enable( gl.CULL_FACE );

      state.reset();

    };

    function createProgram() {

      var program = gl.createProgram();

      var vertexShader = gl.createShader( gl.VERTEX_SHADER );
      var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

      gl.shaderSource( vertexShader, [

        'precision ' + capabilities.precision + ' float;',

        '#define SHADER_NAME ' + 'SpriteMaterial',

        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform float rotation;',
        'uniform vec2 scale;',
        'uniform vec2 uvOffset;',
        'uniform vec2 uvScale;',

        'attribute vec2 position;',
        'attribute vec2 uv;',

        'varying vec2 vUV;',
        'varying float fogDepth;',

        'void main() {',

        ' vUV = uvOffset + uv * uvScale;',

        ' vec2 alignedPosition = position * scale;',

        ' vec2 rotatedPosition;',
        ' rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        ' rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        ' vec4 mvPosition;',

        ' mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        ' mvPosition.xy += rotatedPosition;',

        ' gl_Position = projectionMatrix * mvPosition;',

        ' fogDepth = - mvPosition.z;',

        '}'

      ].join( '\n' ) );

      gl.shaderSource( fragmentShader, [

        'precision ' + capabilities.precision + ' float;',

        '#define SHADER_NAME ' + 'SpriteMaterial',

        'uniform vec3 color;',
        'uniform sampler2D map;',
        'uniform float opacity;',

        'uniform int fogType;',
        'uniform vec3 fogColor;',
        'uniform float fogDensity;',
        'uniform float fogNear;',
        'uniform float fogFar;',
        'uniform float alphaTest;',

        'varying vec2 vUV;',
        'varying float fogDepth;',

        'void main() {',

        ' vec4 texture = texture2D( map, vUV );',

        ' gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        ' if ( gl_FragColor.a < alphaTest ) discard;',

        ' if ( fogType > 0 ) {',

        '   float fogFactor = 0.0;',

        '   if ( fogType == 1 ) {',

        '     fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

        '   } else {',

        '     const float LOG2 = 1.442695;',
        '     fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
        '     fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

        '   }',

        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

        ' }',

        '}'

      ].join( '\n' ) );

      gl.compileShader( vertexShader );
      gl.compileShader( fragmentShader );

      gl.attachShader( program, vertexShader );
      gl.attachShader( program, fragmentShader );

      gl.linkProgram( program );

      return program;

    }

    function painterSortStable( a, b ) {

      if ( a.renderOrder !== b.renderOrder ) {

        return a.renderOrder - b.renderOrder;

      } else if ( a.z !== b.z ) {

        return b.z - a.z;

      } else {

        return b.id - a.id;

      }

    }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  var materialId = 0;

  function Material() {

    Object.defineProperty( this, 'id', { value: materialId ++ } );

    this.uuid = _Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.fog = true;
    this.lights = true;

    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

    this.opacity = 1;
    this.transparent = false;

    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.dithering = false;

    this.alphaTest = 0;
    this.premultipliedAlpha = false;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this.userData = {};

    this.needsUpdate = true;

  }

  Object.assign( Material.prototype, EventDispatcher.prototype, {

    isMaterial: true,

    onBeforeCompile: function () {},

    setValues: function ( values ) {

      if ( values === undefined ) return;

      for ( var key in values ) {

        var newValue = values[ key ];

        if ( newValue === undefined ) {

          console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
          continue;

        }

        // for backward compatability if shading is set in the constructor
        if ( key === 'shading' ) {

          console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
          this.flatShading = ( newValue === FlatShading ) ? true : false;
          continue;

        }

        var currentValue = this[ key ];

        if ( currentValue === undefined ) {

          console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
          continue;

        }

        if ( currentValue && currentValue.isColor ) {

          currentValue.set( newValue );

        } else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

          currentValue.copy( newValue );

        } else if ( key === 'overdraw' ) {

          // ensure overdraw is backwards-compatible with legacy boolean type
          this[ key ] = Number( newValue );

        } else {

          this[ key ] = newValue;

        }

      }

    },

    toJSON: function ( meta ) {

      var isRoot = ( meta === undefined || typeof meta === 'string' );

      if ( isRoot ) {

        meta = {
          textures: {},
          images: {}
        };

      }

      var data = {
        metadata: {
          version: 4.5,
          type: 'Material',
          generator: 'Material.toJSON'
        }
      };

      // standard Material serialization
      data.uuid = this.uuid;
      data.type = this.type;

      if ( this.name !== '' ) data.name = this.name;

      if ( this.color && this.color.isColor ) data.color = this.color.getHex();

      if ( this.roughness !== undefined ) data.roughness = this.roughness;
      if ( this.metalness !== undefined ) data.metalness = this.metalness;

      if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
      if ( this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;

      if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
      if ( this.shininess !== undefined ) data.shininess = this.shininess;
      if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
      if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

      if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
      if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
      if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
      if ( this.bumpMap && this.bumpMap.isTexture ) {

        data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
        data.bumpScale = this.bumpScale;

      }
      if ( this.normalMap && this.normalMap.isTexture ) {

        data.normalMap = this.normalMap.toJSON( meta ).uuid;
        data.normalScale = this.normalScale.toArray();

      }
      if ( this.displacementMap && this.displacementMap.isTexture ) {

        data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;

      }
      if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
      if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

      if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
      if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

      if ( this.envMap && this.envMap.isTexture ) {

        data.envMap = this.envMap.toJSON( meta ).uuid;
        data.reflectivity = this.reflectivity; // Scale behind envMap

      }

      if ( this.gradientMap && this.gradientMap.isTexture ) {

        data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

      }

      if ( this.size !== undefined ) data.size = this.size;
      if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

      if ( this.blending !== NormalBlending ) data.blending = this.blending;
      if ( this.flatShading === true ) data.flatShading = this.flatShading;
      if ( this.side !== FrontSide ) data.side = this.side;
      if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

      if ( this.opacity < 1 ) data.opacity = this.opacity;
      if ( this.transparent === true ) data.transparent = this.transparent;

      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;

      // rotation (SpriteMaterial)
      if ( this.rotation !== 0 ) data.rotation = this.rotation;

      if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
      if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
      if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
      if ( this.scale !== undefined ) data.scale = this.scale;

      if ( this.dithering === true ) data.dithering = true;

      if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
      if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

      if ( this.wireframe === true ) data.wireframe = this.wireframe;
      if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
      if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
      if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

      if ( this.morphTargets === true ) data.morphTargets = true;
      if ( this.skinning === true ) data.skinning = true;

      if ( this.visible === false ) data.visible = false;
      if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

      // TODO: Copied from Object3D.toJSON

      function extractFromCache( cache ) {

        var values = [];

        for ( var key in cache ) {

          var data = cache[ key ];
          delete data.metadata;
          values.push( data );

        }

        return values;

      }

      if ( isRoot ) {

        var textures = extractFromCache( meta.textures );
        var images = extractFromCache( meta.images );

        if ( textures.length > 0 ) data.textures = textures;
        if ( images.length > 0 ) data.images = images;

      }

      return data;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( source ) {

      this.name = source.name;

      this.fog = source.fog;
      this.lights = source.lights;

      this.blending = source.blending;
      this.side = source.side;
      this.flatShading = source.flatShading;
      this.vertexColors = source.vertexColors;

      this.opacity = source.opacity;
      this.transparent = source.transparent;

      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;

      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;

      this.colorWrite = source.colorWrite;

      this.precision = source.precision;

      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;

      this.dithering = source.dithering;

      this.alphaTest = source.alphaTest;
      this.premultipliedAlpha = source.premultipliedAlpha;

      this.overdraw = source.overdraw;

      this.visible = source.visible;
      this.userData = JSON.parse( JSON.stringify( source.userData ) );

      this.clipShadows = source.clipShadows;
      this.clipIntersection = source.clipIntersection;

      var srcPlanes = source.clippingPlanes,
        dstPlanes = null;

      if ( srcPlanes !== null ) {

        var n = srcPlanes.length;
        dstPlanes = new Array( n );

        for ( var i = 0; i !== n; ++ i )
          dstPlanes[ i ] = srcPlanes[ i ].clone();

      }

      this.clippingPlanes = dstPlanes;

      return this;

    },

    dispose: function () {

      this.dispatchEvent( { type: 'dispose' } );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  function MeshDepthMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.depthPacking = BasicDepthPacking;

    this.skinning = false;
    this.morphTargets = false;

    this.map = null;

    this.alphaMap = null;

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false;
    this.lights = false;

    this.setValues( parameters );

  }

  MeshDepthMaterial.prototype = Object.create( Material.prototype );
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.depthPacking = source.depthPacking;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    this.map = source.map;

    this.alphaMap = source.alphaMap;

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */

  function MeshDistanceMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshDistanceMaterial';

    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;

    this.skinning = false;
    this.morphTargets = false;

    this.map = null;

    this.alphaMap = null;

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.fog = false;
    this.lights = false;

    this.setValues( parameters );

  }

  MeshDistanceMaterial.prototype = Object.create( Material.prototype );
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.referencePosition.copy( source.referencePosition );
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    this.map = source.map;

    this.alphaMap = source.alphaMap;

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    return this;

  };

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3( min, max ) {

    this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
    this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

  }

  Object.assign( Box3.prototype, {

    isBox3: true,

    set: function ( min, max ) {

      this.min.copy( min );
      this.max.copy( max );

      return this;

    },

    setFromArray: function ( array ) {

      var minX = + Infinity;
      var minY = + Infinity;
      var minZ = + Infinity;

      var maxX = - Infinity;
      var maxY = - Infinity;
      var maxZ = - Infinity;

      for ( var i = 0, l = array.length; i < l; i += 3 ) {

        var x = array[ i ];
        var y = array[ i + 1 ];
        var z = array[ i + 2 ];

        if ( x < minX ) minX = x;
        if ( y < minY ) minY = y;
        if ( z < minZ ) minZ = z;

        if ( x > maxX ) maxX = x;
        if ( y > maxY ) maxY = y;
        if ( z > maxZ ) maxZ = z;

      }

      this.min.set( minX, minY, minZ );
      this.max.set( maxX, maxY, maxZ );

      return this;

    },

    setFromBufferAttribute: function ( attribute ) {

      var minX = + Infinity;
      var minY = + Infinity;
      var minZ = + Infinity;

      var maxX = - Infinity;
      var maxY = - Infinity;
      var maxZ = - Infinity;

      for ( var i = 0, l = attribute.count; i < l; i ++ ) {

        var x = attribute.getX( i );
        var y = attribute.getY( i );
        var z = attribute.getZ( i );

        if ( x < minX ) minX = x;
        if ( y < minY ) minY = y;
        if ( z < minZ ) minZ = z;

        if ( x > maxX ) maxX = x;
        if ( y > maxY ) maxY = y;
        if ( z > maxZ ) maxZ = z;

      }

      this.min.set( minX, minY, minZ );
      this.max.set( maxX, maxY, maxZ );

      return this;

    },

    setFromPoints: function ( points ) {

      this.makeEmpty();

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        this.expandByPoint( points[ i ] );

      }

      return this;

    },

    setFromCenterAndSize: function () {

      var v1 = new Vector3();

      return function setFromCenterAndSize( center, size ) {

        var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );

        return this;

      };

    }(),

    setFromObject: function ( object ) {

      this.makeEmpty();

      return this.expandByObject( object );

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( box ) {

      this.min.copy( box.min );
      this.max.copy( box.max );

      return this;

    },

    makeEmpty: function () {

      this.min.x = this.min.y = this.min.z = + Infinity;
      this.max.x = this.max.y = this.max.z = - Infinity;

      return this;

    },

    isEmpty: function () {

      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    getCenter: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    getSize: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

      this.min.min( point );
      this.max.max( point );

      return this;

    },

    expandByVector: function ( vector ) {

      this.min.sub( vector );
      this.max.add( vector );

      return this;

    },

    expandByScalar: function ( scalar ) {

      this.min.addScalar( - scalar );
      this.max.addScalar( scalar );

      return this;

    },

    expandByObject: function () {

      // Computes the world-axis-aligned bounding box of an object (including its children),
      // accounting for both the object's, and children's, world transforms

      var v1 = new Vector3();

      return function expandByObject( object ) {

        var scope = this;

        object.updateMatrixWorld( true );

        object.traverse( function ( node ) {

          var i, l;

          var geometry = node.geometry;

          if ( geometry !== undefined ) {

            if ( geometry.isGeometry ) {

              var vertices = geometry.vertices;

              for ( i = 0, l = vertices.length; i < l; i ++ ) {

                v1.copy( vertices[ i ] );
                v1.applyMatrix4( node.matrixWorld );

                scope.expandByPoint( v1 );

              }

            } else if ( geometry.isBufferGeometry ) {

              var attribute = geometry.attributes.position;

              if ( attribute !== undefined ) {

                for ( i = 0, l = attribute.count; i < l; i ++ ) {

                  v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

                  scope.expandByPoint( v1 );

                }

              }

            }

          }

        } );

        return this;

      };

    }(),

    containsPoint: function ( point ) {

      return point.x < this.min.x || point.x > this.max.x ||
        point.y < this.min.y || point.y > this.max.y ||
        point.z < this.min.z || point.z > this.max.z ? false : true;

    },

    containsBox: function ( box ) {

      return this.min.x <= box.min.x && box.max.x <= this.max.x &&
        this.min.y <= box.min.y && box.max.y <= this.max.y &&
        this.min.z <= box.min.z && box.max.z <= this.max.z;

    },

    getParameter: function ( point, optionalTarget ) {

      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      var result = optionalTarget || new Vector3();

      return result.set(
        ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
        ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
        ( point.z - this.min.z ) / ( this.max.z - this.min.z )
      );

    },

    intersectsBox: function ( box ) {

      // using 6 splitting planes to rule out intersections.
      return box.max.x < this.min.x || box.min.x > this.max.x ||
        box.max.y < this.min.y || box.min.y > this.max.y ||
        box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

    },

    intersectsSphere: ( function () {

      var closestPoint = new Vector3();

      return function intersectsSphere( sphere ) {

        // Find the point on the AABB closest to the sphere center.
        this.clampPoint( sphere.center, closestPoint );

        // If that point is inside the sphere, the AABB and sphere intersect.
        return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

      };

    } )(),

    intersectsPlane: function ( plane ) {

      // We compute the minimum and maximum dot product values. If those values
      // are on the same side (back or front) of the plane, then there is no intersection.

      var min, max;

      if ( plane.normal.x > 0 ) {

        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;

      } else {

        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;

      }

      if ( plane.normal.y > 0 ) {

        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;

      } else {

        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;

      }

      if ( plane.normal.z > 0 ) {

        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;

      } else {

        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;

      }

      return ( min <= plane.constant && max >= plane.constant );

    },

    clampPoint: function ( point, optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

      var v1 = new Vector3();

      return function distanceToPoint( point ) {

        var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
        return clampedPoint.sub( point ).length();

      };

    }(),

    getBoundingSphere: function () {

      var v1 = new Vector3();

      return function getBoundingSphere( optionalTarget ) {

        var result = optionalTarget || new Sphere();

        this.getCenter( result.center );

        result.radius = this.getSize( v1 ).length() * 0.5;

        return result;

      };

    }(),

    intersect: function ( box ) {

      this.min.max( box.min );
      this.max.min( box.max );

      // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
      if ( this.isEmpty() ) this.makeEmpty();

      return this;

    },

    union: function ( box ) {

      this.min.min( box.min );
      this.max.max( box.max );

      return this;

    },

    applyMatrix4: function () {

      var points = [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ];

      return function applyMatrix4( matrix ) {

        // transform of empty box is an empty box.
        if ( this.isEmpty() ) return this;

        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
        points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
        points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
        points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
        points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
        points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
        points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
        points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

        this.setFromPoints( points );

        return this;

      };

    }(),

    translate: function ( offset ) {

      this.min.add( offset );
      this.max.add( offset );

      return this;

    },

    equals: function ( box ) {

      return box.min.equals( this.min ) && box.max.equals( this.max );

    }

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Sphere( center, radius ) {

    this.center = ( center !== undefined ) ? center : new Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

  }

  Object.assign( Sphere.prototype, {

    set: function ( center, radius ) {

      this.center.copy( center );
      this.radius = radius;

      return this;

    },

    setFromPoints: function () {

      var box = new Box3();

      return function setFromPoints( points, optionalCenter ) {

        var center = this.center;

        if ( optionalCenter !== undefined ) {

          center.copy( optionalCenter );

        } else {

          box.setFromPoints( points ).getCenter( center );

        }

        var maxRadiusSq = 0;

        for ( var i = 0, il = points.length; i < il; i ++ ) {

          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

        }

        this.radius = Math.sqrt( maxRadiusSq );

        return this;

      };

    }(),

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( sphere ) {

      this.center.copy( sphere.center );
      this.radius = sphere.radius;

      return this;

    },

    empty: function () {

      return ( this.radius <= 0 );

    },

    containsPoint: function ( point ) {

      return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function ( point ) {

      return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function ( sphere ) {

      var radiusSum = this.radius + sphere.radius;

      return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    intersectsBox: function ( box ) {

      return box.intersectsSphere( this );

    },

    intersectsPlane: function ( plane ) {

      return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

    },

    clampPoint: function ( point, optionalTarget ) {

      var deltaLengthSq = this.center.distanceToSquared( point );

      var result = optionalTarget || new Vector3();

      result.copy( point );

      if ( deltaLengthSq > ( this.radius * this.radius ) ) {

        result.sub( this.center ).normalize();
        result.multiplyScalar( this.radius ).add( this.center );

      }

      return result;

    },

    getBoundingBox: function ( optionalTarget ) {

      var box = optionalTarget || new Box3();

      box.set( this.center, this.center );
      box.expandByScalar( this.radius );

      return box;

    },

    applyMatrix4: function ( matrix ) {

      this.center.applyMatrix4( matrix );
      this.radius = this.radius * matrix.getMaxScaleOnAxis();

      return this;

    },

    translate: function ( offset ) {

      this.center.add( offset );

      return this;

    },

    equals: function ( sphere ) {

      return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Plane( normal, constant ) {

    // normal is assumed to be normalized

    this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

  }

  Object.assign( Plane.prototype, {

    set: function ( normal, constant ) {

      this.normal.copy( normal );
      this.constant = constant;

      return this;

    },

    setComponents: function ( x, y, z, w ) {

      this.normal.set( x, y, z );
      this.constant = w;

      return this;

    },

    setFromNormalAndCoplanarPoint: function ( normal, point ) {

      this.normal.copy( normal );
      this.constant = - point.dot( this.normal );

      return this;

    },

    setFromCoplanarPoints: function () {

      var v1 = new Vector3();
      var v2 = new Vector3();

      return function setFromCoplanarPoints( a, b, c ) {

        var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

        this.setFromNormalAndCoplanarPoint( normal, a );

        return this;

      };

    }(),

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( plane ) {

      this.normal.copy( plane.normal );
      this.constant = plane.constant;

      return this;

    },

    normalize: function () {

      // Note: will lead to a divide by zero if the plane is invalid.

      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar( inverseNormalLength );
      this.constant *= inverseNormalLength;

      return this;

    },

    negate: function () {

      this.constant *= - 1;
      this.normal.negate();

      return this;

    },

    distanceToPoint: function ( point ) {

      return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function ( sphere ) {

      return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function ( point, optionalTarget ) {

      var result = optionalTarget || new Vector3();

      return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

    },

    intersectLine: function () {

      var v1 = new Vector3();

      return function intersectLine( line, optionalTarget ) {

        var result = optionalTarget || new Vector3();

        var direction = line.delta( v1 );

        var denominator = this.normal.dot( direction );

        if ( denominator === 0 ) {

          // line is coplanar, return origin
          if ( this.distanceToPoint( line.start ) === 0 ) {

            return result.copy( line.start );

          }

          // Unsure if this is the correct method to handle this case.
          return undefined;

        }

        var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

        if ( t < 0 || t > 1 ) {

          return undefined;

        }

        return result.copy( direction ).multiplyScalar( t ).add( line.start );

      };

    }(),

    intersectsLine: function ( line ) {

      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

      var startSign = this.distanceToPoint( line.start );
      var endSign = this.distanceToPoint( line.end );

      return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectsBox: function ( box ) {

      return box.intersectsPlane( this );

    },

    intersectsSphere: function ( sphere ) {

      return sphere.intersectsPlane( this );

    },

    coplanarPoint: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();

      return result.copy( this.normal ).multiplyScalar( - this.constant );

    },

    applyMatrix4: function () {

      var v1 = new Vector3();
      var m1 = new Matrix3();

      return function applyMatrix4( matrix, optionalNormalMatrix ) {

        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

        var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

        var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

        this.constant = - referencePoint.dot( normal );

        return this;

      };

    }(),

    translate: function ( offset ) {

      this.constant -= offset.dot( this.normal );

      return this;

    },

    equals: function ( plane ) {

      return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */

  function Frustum( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

      ( p0 !== undefined ) ? p0 : new Plane(),
      ( p1 !== undefined ) ? p1 : new Plane(),
      ( p2 !== undefined ) ? p2 : new Plane(),
      ( p3 !== undefined ) ? p3 : new Plane(),
      ( p4 !== undefined ) ? p4 : new Plane(),
      ( p5 !== undefined ) ? p5 : new Plane()

    ];

  }

  Object.assign( Frustum.prototype, {

    set: function ( p0, p1, p2, p3, p4, p5 ) {

      var planes = this.planes;

      planes[ 0 ].copy( p0 );
      planes[ 1 ].copy( p1 );
      planes[ 2 ].copy( p2 );
      planes[ 3 ].copy( p3 );
      planes[ 4 ].copy( p4 );
      planes[ 5 ].copy( p5 );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( frustum ) {

      var planes = this.planes;

      for ( var i = 0; i < 6; i ++ ) {

        planes[ i ].copy( frustum.planes[ i ] );

      }

      return this;

    },

    setFromMatrix: function ( m ) {

      var planes = this.planes;
      var me = m.elements;
      var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
      var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
      var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
      var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

      planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
      planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
      planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
      planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
      planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
      planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

      return this;

    },

    intersectsObject: function () {

      var sphere = new Sphere();

      return function intersectsObject( object ) {

        var geometry = object.geometry;

        if ( geometry.boundingSphere === null )
          geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere )
          .applyMatrix4( object.matrixWorld );

        return this.intersectsSphere( sphere );

      };

    }(),

    intersectsSprite: function () {

      var sphere = new Sphere();

      return function intersectsSprite( sprite ) {

        sphere.center.set( 0, 0, 0 );
        sphere.radius = 0.7071067811865476;
        sphere.applyMatrix4( sprite.matrixWorld );

        return this.intersectsSphere( sphere );

      };

    }(),

    intersectsSphere: function ( sphere ) {

      var planes = this.planes;
      var center = sphere.center;
      var negRadius = - sphere.radius;

      for ( var i = 0; i < 6; i ++ ) {

        var distance = planes[ i ].distanceToPoint( center );

        if ( distance < negRadius ) {

          return false;

        }

      }

      return true;

    },

    intersectsBox: function () {

      var p1 = new Vector3(),
        p2 = new Vector3();

      return function intersectsBox( box ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i ++ ) {

          var plane = planes[ i ];

          p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
          p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
          p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
          p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

          var d1 = plane.distanceToPoint( p1 );
          var d2 = plane.distanceToPoint( p2 );

          // if both outside plane, no intersection

          if ( d1 < 0 && d2 < 0 ) {

            return false;

          }

        }

        return true;

      };

    }(),

    containsPoint: function ( point ) {

      var planes = this.planes;

      for ( var i = 0; i < 6; i ++ ) {

        if ( planes[ i ].distanceToPoint( point ) < 0 ) {

          return false;

        }

      }

      return true;

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

    var _frustum = new Frustum(),
      _projScreenMatrix = new Matrix4(),

      _shadowMapSize = new Vector2(),
      _maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

      _lookTarget = new Vector3(),
      _lightPositionWorld = new Vector3(),

      _MorphingFlag = 1,
      _SkinningFlag = 2,

      _NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

      _depthMaterials = new Array( _NumberOfMaterialVariants ),
      _distanceMaterials = new Array( _NumberOfMaterialVariants ),

      _materialCache = {};

    var cubeDirections = [
      new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
      new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
    ];

    var cubeUps = [
      new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
      new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, - 1 )
    ];

    var cube2DViewPorts = [
      new Vector4(), new Vector4(), new Vector4(),
      new Vector4(), new Vector4(), new Vector4()
    ];

    // init

    for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

      var useMorphing = ( i & _MorphingFlag ) !== 0;
      var useSkinning = ( i & _SkinningFlag ) !== 0;

      var depthMaterial = new MeshDepthMaterial( {

        depthPacking: RGBADepthPacking,

        morphTargets: useMorphing,
        skinning: useSkinning

      } );

      _depthMaterials[ i ] = depthMaterial;

      //

      var distanceMaterial = new MeshDistanceMaterial( {

        morphTargets: useMorphing,
        skinning: useSkinning

      } );

      _distanceMaterials[ i ] = distanceMaterial;

    }

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = PCFShadowMap;

    this.renderReverseSided = true;
    this.renderSingleSided = true;

    this.render = function ( lights, scene, camera ) {

      if ( scope.enabled === false ) return;
      if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

      if ( lights.length === 0 ) return;

      // TODO Clean up (needed in case of contextlost)
      var _gl = _renderer.context;
      var _state = _renderer.state;

      // Set GL state for depth map.
      _state.disable( _gl.BLEND );
      _state.buffers.color.setClear( 1, 1, 1, 1 );
      _state.buffers.depth.setTest( true );
      _state.setScissorTest( false );

      // render depth map

      var faceCount;

      for ( var i = 0, il = lights.length; i < il; i ++ ) {

        var light = lights[ i ];
        var shadow = light.shadow;
        var isPointLight = light && light.isPointLight;

        if ( shadow === undefined ) {

          console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
          continue;

        }

        var shadowCamera = shadow.camera;

        _shadowMapSize.copy( shadow.mapSize );
        _shadowMapSize.min( _maxShadowMapSize );

        if ( isPointLight ) {

          var vpWidth = _shadowMapSize.x;
          var vpHeight = _shadowMapSize.y;

          // These viewports map a cube-map onto a 2D texture with the
          // following orientation:
          //
          //  xzXZ
          //   y Y
          //
          // X - Positive x direction
          // x - Negative x direction
          // Y - Positive y direction
          // y - Negative y direction
          // Z - Positive z direction
          // z - Negative z direction

          // positive X
          cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
          // negative X
          cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
          // positive Z
          cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
          // negative Z
          cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
          // positive Y
          cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
          // negative Y
          cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

          _shadowMapSize.x *= 4.0;
          _shadowMapSize.y *= 2.0;

        }

        if ( shadow.map === null ) {

          var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

          shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
          shadow.map.texture.name = light.name + ".shadowMap";

          shadowCamera.updateProjectionMatrix();

        }

        if ( shadow.isSpotLightShadow ) {

          shadow.update( light );

        }

        var shadowMap = shadow.map;
        var shadowMatrix = shadow.matrix;

        _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
        shadowCamera.position.copy( _lightPositionWorld );

        if ( isPointLight ) {

          faceCount = 6;

          // for point lights we set the shadow matrix to be a translation-only matrix
          // equal to inverse of the light's position

          shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

        } else {

          faceCount = 1;

          _lookTarget.setFromMatrixPosition( light.target.matrixWorld );
          shadowCamera.lookAt( _lookTarget );
          shadowCamera.updateMatrixWorld();

          // compute shadow matrix

          shadowMatrix.set(
            0.5, 0.0, 0.0, 0.5,
            0.0, 0.5, 0.0, 0.5,
            0.0, 0.0, 0.5, 0.5,
            0.0, 0.0, 0.0, 1.0
          );

          shadowMatrix.multiply( shadowCamera.projectionMatrix );
          shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

        }

        _renderer.setRenderTarget( shadowMap );
        _renderer.clear();

        // render shadow map for each cube face (if omni-directional) or
        // run a single pass if not

        for ( var face = 0; face < faceCount; face ++ ) {

          if ( isPointLight ) {

            _lookTarget.copy( shadowCamera.position );
            _lookTarget.add( cubeDirections[ face ] );
            shadowCamera.up.copy( cubeUps[ face ] );
            shadowCamera.lookAt( _lookTarget );
            shadowCamera.updateMatrixWorld();

            var vpDimensions = cube2DViewPorts[ face ];
            _state.viewport( vpDimensions );

          }

          // update camera matrices and frustum

          _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
          _frustum.setFromMatrix( _projScreenMatrix );

          // set object matrices & frustum culling

          renderObject( scene, camera, shadowCamera, isPointLight );

        }

      }

      scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

      var geometry = object.geometry;

      var result = null;

      var materialVariants = _depthMaterials;
      var customMaterial = object.customDepthMaterial;

      if ( isPointLight ) {

        materialVariants = _distanceMaterials;
        customMaterial = object.customDistanceMaterial;

      }

      if ( ! customMaterial ) {

        var useMorphing = false;

        if ( material.morphTargets ) {

          if ( geometry && geometry.isBufferGeometry ) {

            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

          } else if ( geometry && geometry.isGeometry ) {

            useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

          }

        }

        if ( object.isSkinnedMesh && material.skinning === false ) {

          console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

        }

        var useSkinning = object.isSkinnedMesh && material.skinning;

        var variantIndex = 0;

        if ( useMorphing ) variantIndex |= _MorphingFlag;
        if ( useSkinning ) variantIndex |= _SkinningFlag;

        result = materialVariants[ variantIndex ];

      } else {

        result = customMaterial;

      }

      if ( _renderer.localClippingEnabled &&
          material.clipShadows === true &&
          material.clippingPlanes.length !== 0 ) {

        // in this case we need a unique material instance reflecting the
        // appropriate state

        var keyA = result.uuid, keyB = material.uuid;

        var materialsForVariant = _materialCache[ keyA ];

        if ( materialsForVariant === undefined ) {

          materialsForVariant = {};
          _materialCache[ keyA ] = materialsForVariant;

        }

        var cachedMaterial = materialsForVariant[ keyB ];

        if ( cachedMaterial === undefined ) {

          cachedMaterial = result.clone();
          materialsForVariant[ keyB ] = cachedMaterial;

        }

        result = cachedMaterial;

      }

      result.visible = material.visible;
      result.wireframe = material.wireframe;

      var side = material.side;

      if ( scope.renderSingleSided && side == DoubleSide ) {

        side = FrontSide;

      }

      if ( scope.renderReverseSided ) {

        if ( side === FrontSide ) side = BackSide;
        else if ( side === BackSide ) side = FrontSide;

      }

      result.side = side;

      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;

      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;

      if ( isPointLight && result.isMeshDistanceMaterial ) {

        result.referencePosition.copy( lightPositionWorld );
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;

      }

      return result;

    }

    function renderObject( object, camera, shadowCamera, isPointLight ) {

      if ( object.visible === false ) return;

      var visible = object.layers.test( camera.layers );

      if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

        if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

          object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

          var geometry = _objects.update( object );
          var material = object.material;

          if ( Array.isArray( material ) ) {

            var groups = geometry.groups;

            for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

              var group = groups[ k ];
              var groupMaterial = material[ group.materialIndex ];

              if ( groupMaterial && groupMaterial.visible ) {

                var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
                _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

              }

            }

          } else if ( material.visible ) {

            var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
            _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

          }

        }

      }

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        renderObject( children[ i ], camera, shadowCamera, isPointLight );

      }

    }

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLAttributes( gl ) {

    var buffers = {};

    function createBuffer( attribute, bufferType ) {

      var array = attribute.array;
      var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

      var buffer = gl.createBuffer();

      gl.bindBuffer( bufferType, buffer );
      gl.bufferData( bufferType, array, usage );

      attribute.onUploadCallback();

      var type = gl.FLOAT;

      if ( array instanceof Float32Array ) {

        type = gl.FLOAT;

      } else if ( array instanceof Float64Array ) {

        console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

      } else if ( array instanceof Uint16Array ) {

        type = gl.UNSIGNED_SHORT;

      } else if ( array instanceof Int16Array ) {

        type = gl.SHORT;

      } else if ( array instanceof Uint32Array ) {

        type = gl.UNSIGNED_INT;

      } else if ( array instanceof Int32Array ) {

        type = gl.INT;

      } else if ( array instanceof Int8Array ) {

        type = gl.BYTE;

      } else if ( array instanceof Uint8Array ) {

        type = gl.UNSIGNED_BYTE;

      }

      return {
        buffer: buffer,
        type: type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };

    }

    function updateBuffer( buffer, attribute, bufferType ) {

      var array = attribute.array;
      var updateRange = attribute.updateRange;

      gl.bindBuffer( bufferType, buffer );

      if ( attribute.dynamic === false ) {

        gl.bufferData( bufferType, array, gl.STATIC_DRAW );

      } else if ( updateRange.count === - 1 ) {

        // Not using update ranges

        gl.bufferSubData( bufferType, 0, array );

      } else if ( updateRange.count === 0 ) {

        console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

      } else {

        gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

        updateRange.count = - 1; // reset range

      }

    }

    //

    function get( attribute ) {

      if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

      return buffers[ attribute.uuid ];

    }

    function remove( attribute ) {

      if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

      var data = buffers[ attribute.uuid ];

      if ( data ) {

        gl.deleteBuffer( data.buffer );

        delete buffers[ attribute.uuid ];

      }

    }

    function update( attribute, bufferType ) {

      if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

      var data = buffers[ attribute.uuid ];

      if ( data === undefined ) {

        buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

      } else if ( data.version < attribute.version ) {

        updateBuffer( data.buffer, attribute, bufferType );

        data.version = attribute.version;

      }

    }

    return {

      get: get,
      remove: remove,
      update: update

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Euler( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || Euler.DefaultOrder;

  }

  Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  Euler.DefaultOrder = 'XYZ';

  Object.defineProperties( Euler.prototype, {

    x: {

      get: function () {

        return this._x;

      },

      set: function ( value ) {

        this._x = value;
        this.onChangeCallback();

      }

    },

    y: {

      get: function () {

        return this._y;

      },

      set: function ( value ) {

        this._y = value;
        this.onChangeCallback();

      }

    },

    z: {

      get: function () {

        return this._z;

      },

      set: function ( value ) {

        this._z = value;
        this.onChangeCallback();

      }

    },

    order: {

      get: function () {

        return this._order;

      },

      set: function ( value ) {

        this._order = value;
        this.onChangeCallback();

      }

    }

  } );

  Object.assign( Euler.prototype, {

    isEuler: true,

    set: function ( x, y, z, order ) {

      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;

      this.onChangeCallback();

      return this;

    },

    clone: function () {

      return new this.constructor( this._x, this._y, this._z, this._order );

    },

    copy: function ( euler ) {

      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;

      this.onChangeCallback();

      return this;

    },

    setFromRotationMatrix: function ( m, order, update ) {

      var clamp = _Math.clamp;

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements;
      var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
      var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
      var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

      order = order || this._order;

      if ( order === 'XYZ' ) {

        this._y = Math.asin( clamp( m13, - 1, 1 ) );

        if ( Math.abs( m13 ) < 0.99999 ) {

          this._x = Math.atan2( - m23, m33 );
          this._z = Math.atan2( - m12, m11 );

        } else {

          this._x = Math.atan2( m32, m22 );
          this._z = 0;

        }

      } else if ( order === 'YXZ' ) {

        this._x = Math.asin( - clamp( m23, - 1, 1 ) );

        if ( Math.abs( m23 ) < 0.99999 ) {

          this._y = Math.atan2( m13, m33 );
          this._z = Math.atan2( m21, m22 );

        } else {

          this._y = Math.atan2( - m31, m11 );
          this._z = 0;

        }

      } else if ( order === 'ZXY' ) {

        this._x = Math.asin( clamp( m32, - 1, 1 ) );

        if ( Math.abs( m32 ) < 0.99999 ) {

          this._y = Math.atan2( - m31, m33 );
          this._z = Math.atan2( - m12, m22 );

        } else {

          this._y = 0;
          this._z = Math.atan2( m21, m11 );

        }

      } else if ( order === 'ZYX' ) {

        this._y = Math.asin( - clamp( m31, - 1, 1 ) );

        if ( Math.abs( m31 ) < 0.99999 ) {

          this._x = Math.atan2( m32, m33 );
          this._z = Math.atan2( m21, m11 );

        } else {

          this._x = 0;
          this._z = Math.atan2( - m12, m22 );

        }

      } else if ( order === 'YZX' ) {

        this._z = Math.asin( clamp( m21, - 1, 1 ) );

        if ( Math.abs( m21 ) < 0.99999 ) {

          this._x = Math.atan2( - m23, m22 );
          this._y = Math.atan2( - m31, m11 );

        } else {

          this._x = 0;
          this._y = Math.atan2( m13, m33 );

        }

      } else if ( order === 'XZY' ) {

        this._z = Math.asin( - clamp( m12, - 1, 1 ) );

        if ( Math.abs( m12 ) < 0.99999 ) {

          this._x = Math.atan2( m32, m22 );
          this._y = Math.atan2( m13, m11 );

        } else {

          this._x = Math.atan2( - m23, m33 );
          this._y = 0;

        }

      } else {

        console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

      }

      this._order = order;

      if ( update !== false ) this.onChangeCallback();

      return this;

    },

    setFromQuaternion: function () {

      var matrix = new Matrix4();

      return function setFromQuaternion( q, order, update ) {

        matrix.makeRotationFromQuaternion( q );

        return this.setFromRotationMatrix( matrix, order, update );

      };

    }(),

    setFromVector3: function ( v, order ) {

      return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function () {

      // WARNING: this discards revolution information -bhouston

      var q = new Quaternion();

      return function reorder( newOrder ) {

        q.setFromEuler( this );

        return this.setFromQuaternion( q, newOrder );

      };

    }(),

    equals: function ( euler ) {

      return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function ( array ) {

      this._x = array[ 0 ];
      this._y = array[ 1 ];
      this._z = array[ 2 ];
      if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

      this.onChangeCallback();

      return this;

    },

    toArray: function ( array, offset ) {

      if ( array === undefined ) array = [];
      if ( offset === undefined ) offset = 0;

      array[ offset ] = this._x;
      array[ offset + 1 ] = this._y;
      array[ offset + 2 ] = this._z;
      array[ offset + 3 ] = this._order;

      return array;

    },

    toVector3: function ( optionalResult ) {

      if ( optionalResult ) {

        return optionalResult.set( this._x, this._y, this._z );

      } else {

        return new Vector3( this._x, this._y, this._z );

      }

    },

    onChange: function ( callback ) {

      this.onChangeCallback = callback;

      return this;

    },

    onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Layers() {

    this.mask = 1 | 0;

  }

  Object.assign( Layers.prototype, {

    set: function ( channel ) {

      this.mask = 1 << channel | 0;

    },

    enable: function ( channel ) {

      this.mask |= 1 << channel | 0;

    },

    toggle: function ( channel ) {

      this.mask ^= 1 << channel | 0;

    },

    disable: function ( channel ) {

      this.mask &= ~ ( 1 << channel | 0 );

    },

    test: function ( layers ) {

      return ( this.mask & layers.mask ) !== 0;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */

  var object3DId = 0;

  function Object3D() {

    Object.defineProperty( this, 'id', { value: object3DId ++ } );

    this.uuid = _Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.children = [];

    this.up = Object3D.DefaultUp.clone();

    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3( 1, 1, 1 );

    function onRotationChange() {

      quaternion.setFromEuler( rotation, false );

    }

    function onQuaternionChange() {

      rotation.setFromQuaternion( quaternion, undefined, false );

    }

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
      position: {
        enumerable: true,
        value: position
      },
      rotation: {
        enumerable: true,
        value: rotation
      },
      quaternion: {
        enumerable: true,
        value: quaternion
      },
      scale: {
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    } );

    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();

    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.layers = new Layers();
    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

  }

  Object3D.DefaultUp = new Vector3( 0, 1, 0 );
  Object3D.DefaultMatrixAutoUpdate = true;

  Object.assign( Object3D.prototype, EventDispatcher.prototype, {

    isObject3D: true,

    onBeforeRender: function () {},
    onAfterRender: function () {},

    applyMatrix: function ( matrix ) {

      this.matrix.multiplyMatrices( matrix, this.matrix );

      this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    applyQuaternion: function ( q ) {

      this.quaternion.premultiply( q );

      return this;

    },

    setRotationFromAxisAngle: function ( axis, angle ) {

      // assumes axis is normalized

      this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function ( euler ) {

      this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function ( m ) {

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function ( q ) {

      // assumes q is normalized

      this.quaternion.copy( q );

    },

    rotateOnAxis: function () {

      // rotate object on axis in object space
      // axis is assumed to be normalized

      var q1 = new Quaternion();

      return function rotateOnAxis( axis, angle ) {

        q1.setFromAxisAngle( axis, angle );

        this.quaternion.multiply( q1 );

        return this;

      };

    }(),

    rotateX: function () {

      var v1 = new Vector3( 1, 0, 0 );

      return function rotateX( angle ) {

        return this.rotateOnAxis( v1, angle );

      };

    }(),

    rotateY: function () {

      var v1 = new Vector3( 0, 1, 0 );

      return function rotateY( angle ) {

        return this.rotateOnAxis( v1, angle );

      };

    }(),

    rotateZ: function () {

      var v1 = new Vector3( 0, 0, 1 );

      return function rotateZ( angle ) {

        return this.rotateOnAxis( v1, angle );

      };

    }(),

    translateOnAxis: function () {

      // translate object by distance along axis in object space
      // axis is assumed to be normalized

      var v1 = new Vector3();

      return function translateOnAxis( axis, distance ) {

        v1.copy( axis ).applyQuaternion( this.quaternion );

        this.position.add( v1.multiplyScalar( distance ) );

        return this;

      };

    }(),

    translateX: function () {

      var v1 = new Vector3( 1, 0, 0 );

      return function translateX( distance ) {

        return this.translateOnAxis( v1, distance );

      };

    }(),

    translateY: function () {

      var v1 = new Vector3( 0, 1, 0 );

      return function translateY( distance ) {

        return this.translateOnAxis( v1, distance );

      };

    }(),

    translateZ: function () {

      var v1 = new Vector3( 0, 0, 1 );

      return function translateZ( distance ) {

        return this.translateOnAxis( v1, distance );

      };

    }(),

    localToWorld: function ( vector ) {

      return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function () {

      var m1 = new Matrix4();

      return function worldToLocal( vector ) {

        return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

      };

    }(),

    lookAt: function () {

      // This method does not support objects with rotated and/or translated parent(s)

      var m1 = new Matrix4();
      var vector = new Vector3();

      return function lookAt( x, y, z ) {

        if ( x.isVector3 ) {

          vector.copy( x );

        } else {

          vector.set( x, y, z );

        }

        if ( this.isCamera ) {

          m1.lookAt( this.position, vector, this.up );

        } else {

          m1.lookAt( vector, this.position, this.up );

        }

        this.quaternion.setFromRotationMatrix( m1 );

      };

    }(),

    add: function ( object ) {

      if ( arguments.length > 1 ) {

        for ( var i = 0; i < arguments.length; i ++ ) {

          this.add( arguments[ i ] );

        }

        return this;

      }

      if ( object === this ) {

        console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
        return this;

      }

      if ( ( object && object.isObject3D ) ) {

        if ( object.parent !== null ) {

          object.parent.remove( object );

        }

        object.parent = this;
        object.dispatchEvent( { type: 'added' } );

        this.children.push( object );

      } else {

        console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

      }

      return this;

    },

    remove: function ( object ) {

      if ( arguments.length > 1 ) {

        for ( var i = 0; i < arguments.length; i ++ ) {

          this.remove( arguments[ i ] );

        }

        return this;

      }

      var index = this.children.indexOf( object );

      if ( index !== - 1 ) {

        object.parent = null;

        object.dispatchEvent( { type: 'removed' } );

        this.children.splice( index, 1 );

      }

      return this;

    },

    getObjectById: function ( id ) {

      return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function ( name ) {

      return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function ( name, value ) {

      if ( this[ name ] === value ) return this;

      for ( var i = 0, l = this.children.length; i < l; i ++ ) {

        var child = this.children[ i ];
        var object = child.getObjectByProperty( name, value );

        if ( object !== undefined ) {

          return object;

        }

      }

      return undefined;

    },

    getWorldPosition: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();

      this.updateMatrixWorld( true );

      return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function () {

      var position = new Vector3();
      var scale = new Vector3();

      return function getWorldQuaternion( optionalTarget ) {

        var result = optionalTarget || new Quaternion();

        this.updateMatrixWorld( true );

        this.matrixWorld.decompose( position, result, scale );

        return result;

      };

    }(),

    getWorldRotation: function () {

      var quaternion = new Quaternion();

      return function getWorldRotation( optionalTarget ) {

        var result = optionalTarget || new Euler();

        this.getWorldQuaternion( quaternion );

        return result.setFromQuaternion( quaternion, this.rotation.order, false );

      };

    }(),

    getWorldScale: function () {

      var position = new Vector3();
      var quaternion = new Quaternion();

      return function getWorldScale( optionalTarget ) {

        var result = optionalTarget || new Vector3();

        this.updateMatrixWorld( true );

        this.matrixWorld.decompose( position, quaternion, result );

        return result;

      };

    }(),

    getWorldDirection: function () {

      var quaternion = new Quaternion();

      return function getWorldDirection( optionalTarget ) {

        var result = optionalTarget || new Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

      };

    }(),

    raycast: function () {},

    traverse: function ( callback ) {

      callback( this );

      var children = this.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        children[ i ].traverse( callback );

      }

    },

    traverseVisible: function ( callback ) {

      if ( this.visible === false ) return;

      callback( this );

      var children = this.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        children[ i ].traverseVisible( callback );

      }

    },

    traverseAncestors: function ( callback ) {

      var parent = this.parent;

      if ( parent !== null ) {

        callback( parent );

        parent.traverseAncestors( callback );

      }

    },

    updateMatrix: function () {

      this.matrix.compose( this.position, this.quaternion, this.scale );

      this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function ( force ) {

      if ( this.matrixAutoUpdate ) this.updateMatrix();

      if ( this.matrixWorldNeedsUpdate || force ) {

        if ( this.parent === null ) {

          this.matrixWorld.copy( this.matrix );

        } else {

          this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

        }

        this.matrixWorldNeedsUpdate = false;

        force = true;

      }

      // update children

      var children = this.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        children[ i ].updateMatrixWorld( force );

      }

    },

    toJSON: function ( meta ) {

      // meta is a string when called from JSON.stringify
      var isRootObject = ( meta === undefined || typeof meta === 'string' );

      var output = {};

      // meta is a hash used to collect geometries, materials.
      // not providing it implies that this is the root object
      // being serialized.
      if ( isRootObject ) {

        // initialize meta obj
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {}
        };

        output.metadata = {
          version: 4.5,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };

      }

      // standard Object3D serialization

      var object = {};

      object.uuid = this.uuid;
      object.type = this.type;

      if ( this.name !== '' ) object.name = this.name;
      if ( this.castShadow === true ) object.castShadow = true;
      if ( this.receiveShadow === true ) object.receiveShadow = true;
      if ( this.visible === false ) object.visible = false;
      if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

      object.matrix = this.matrix.toArray();

      //

      function serialize( library, element ) {

        if ( library[ element.uuid ] === undefined ) {

          library[ element.uuid ] = element.toJSON( meta );

        }

        return element.uuid;

      }

      if ( this.geometry !== undefined ) {

        object.geometry = serialize( meta.geometries, this.geometry );

      }

      if ( this.material !== undefined ) {

        if ( Array.isArray( this.material ) ) {

          var uuids = [];

          for ( var i = 0, l = this.material.length; i < l; i ++ ) {

            uuids.push( serialize( meta.materials, this.material[ i ] ) );

          }

          object.material = uuids;

        } else {

          object.material = serialize( meta.materials, this.material );

        }

      }

      //

      if ( this.children.length > 0 ) {

        object.children = [];

        for ( var i = 0; i < this.children.length; i ++ ) {

          object.children.push( this.children[ i ].toJSON( meta ).object );

        }

      }

      if ( isRootObject ) {

        var geometries = extractFromCache( meta.geometries );
        var materials = extractFromCache( meta.materials );
        var textures = extractFromCache( meta.textures );
        var images = extractFromCache( meta.images );

        if ( geometries.length > 0 ) output.geometries = geometries;
        if ( materials.length > 0 ) output.materials = materials;
        if ( textures.length > 0 ) output.textures = textures;
        if ( images.length > 0 ) output.images = images;

      }

      output.object = object;

      return output;

      // extract data from the cache hash
      // remove metadata on each item
      // and return as array
      function extractFromCache( cache ) {

        var values = [];
        for ( var key in cache ) {

          var data = cache[ key ];
          delete data.metadata;
          values.push( data );

        }
        return values;

      }

    },

    clone: function ( recursive ) {

      return new this.constructor().copy( this, recursive );

    },

    copy: function ( source, recursive ) {

      if ( recursive === undefined ) recursive = true;

      this.name = source.name;

      this.up.copy( source.up );

      this.position.copy( source.position );
      this.quaternion.copy( source.quaternion );
      this.scale.copy( source.scale );

      this.matrix.copy( source.matrix );
      this.matrixWorld.copy( source.matrixWorld );

      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

      this.layers.mask = source.layers.mask;
      this.visible = source.visible;

      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;

      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;

      this.userData = JSON.parse( JSON.stringify( source.userData ) );

      if ( recursive === true ) {

        for ( var i = 0; i < source.children.length; i ++ ) {

          var child = source.children[ i ];
          this.add( child.clone() );

        }

      }

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
  */

  function Camera() {

    Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();

  }

  Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Camera,

    isCamera: true,

    copy: function ( source, recursive ) {

      Object3D.prototype.copy.call( this, source, recursive );

      this.matrixWorldInverse.copy( source.matrixWorldInverse );
      this.projectionMatrix.copy( source.projectionMatrix );

      return this;

    },

    getWorldDirection: function () {

      var quaternion = new Quaternion();

      return function getWorldDirection( optionalTarget ) {

        var result = optionalTarget || new Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

      };

    }(),

    updateMatrixWorld: function ( force ) {

      Object3D.prototype.updateMatrixWorld.call( this, force );

      this.matrixWorldInverse.getInverse( this.matrixWorld );

    },

    clone: function () {

      return new this.constructor().copy( this );

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */

  function OrthographicCamera( left, right, top, bottom, near, far ) {

    Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;
    this.view = null;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

  }

  OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    constructor: OrthographicCamera,

    isOrthographicCamera: true,

    copy: function ( source, recursive ) {

      Camera.prototype.copy.call( this, source, recursive );

      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;

      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign( {}, source.view );

      return this;

    },

    setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

      if ( this.view === null ) {

        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };

      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;

      this.updateProjectionMatrix();

    },

    clearViewOffset: function () {

      if ( this.view !== null ) {

        this.view.enabled = false;

      }

      this.updateProjectionMatrix();

    },

    updateProjectionMatrix: function () {

      var dx = ( this.right - this.left ) / ( 2 * this.zoom );
      var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
      var cx = ( this.right + this.left ) / 2;
      var cy = ( this.top + this.bottom ) / 2;

      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;

      if ( this.view !== null && this.view.enabled ) {

        var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
        var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
        var scaleW = ( this.right - this.left ) / this.view.width;
        var scaleH = ( this.top - this.bottom ) / this.view.height;

        left += scaleW * ( this.view.offsetX / zoomW );
        right = left + scaleW * ( this.view.width / zoomW );
        top -= scaleH * ( this.view.offsetY / zoomH );
        bottom = top - scaleH * ( this.view.height / zoomH );

      }

      this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    },

    toJSON: function ( meta ) {

      var data = Object3D.prototype.toJSON.call( this, meta );

      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;

      if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

      return data;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Face3( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = ( color && color.isColor ) ? color : new Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign( Face3.prototype, {

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( source ) {

      this.a = source.a;
      this.b = source.b;
      this.c = source.c;

      this.normal.copy( source.normal );
      this.color.copy( source.color );

      this.materialIndex = source.materialIndex;

      for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

        this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

      }

      for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

        this.vertexColors[ i ] = source.vertexColors[ i ].clone();

      }

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */

  var geometryId = 0; // Geometry uses even numbers as Id

  function Geometry() {

    Object.defineProperty( this, 'id', { value: geometryId += 2 } );

    this.uuid = _Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];

    this.morphTargets = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

  }

  Object.assign( Geometry.prototype, EventDispatcher.prototype, {

    isGeometry: true,

    applyMatrix: function ( matrix ) {

      var normalMatrix = new Matrix3().getNormalMatrix( matrix );

      for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

        var vertex = this.vertices[ i ];
        vertex.applyMatrix4( matrix );

      }

      for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

        var face = this.faces[ i ];
        face.normal.applyMatrix3( normalMatrix ).normalize();

        for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

          face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

        }

      }

      if ( this.boundingBox !== null ) {

        this.computeBoundingBox();

      }

      if ( this.boundingSphere !== null ) {

        this.computeBoundingSphere();

      }

      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;

      return this;

    },

    rotateX: function () {

      // rotate geometry around world x-axis

      var m1 = new Matrix4();

      return function rotateX( angle ) {

        m1.makeRotationX( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    rotateY: function () {

      // rotate geometry around world y-axis

      var m1 = new Matrix4();

      return function rotateY( angle ) {

        m1.makeRotationY( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    rotateZ: function () {

      // rotate geometry around world z-axis

      var m1 = new Matrix4();

      return function rotateZ( angle ) {

        m1.makeRotationZ( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    translate: function () {

      // translate geometry

      var m1 = new Matrix4();

      return function translate( x, y, z ) {

        m1.makeTranslation( x, y, z );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    scale: function () {

      // scale geometry

      var m1 = new Matrix4();

      return function scale( x, y, z ) {

        m1.makeScale( x, y, z );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    lookAt: function () {

      var obj = new Object3D();

      return function lookAt( vector ) {

        obj.lookAt( vector );

        obj.updateMatrix();

        this.applyMatrix( obj.matrix );

      };

    }(),

    fromBufferGeometry: function ( geometry ) {

      var scope = this;

      var indices = geometry.index !== null ? geometry.index.array : undefined;
      var attributes = geometry.attributes;

      var positions = attributes.position.array;
      var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
      var colors = attributes.color !== undefined ? attributes.color.array : undefined;
      var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
      var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

      if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

      var tempNormals = [];
      var tempUVs = [];
      var tempUVs2 = [];

      for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

        scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

        if ( normals !== undefined ) {

          tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

        }

        if ( colors !== undefined ) {

          scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

        }

        if ( uvs !== undefined ) {

          tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

        }

        if ( uvs2 !== undefined ) {

          tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

        }

      }

      function addFace( a, b, c, materialIndex ) {

        var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
        var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

        var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

        scope.faces.push( face );

        if ( uvs !== undefined ) {

          scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

        }

        if ( uvs2 !== undefined ) {

          scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

        }

      }

      var groups = geometry.groups;

      if ( groups.length > 0 ) {

        for ( var i = 0; i < groups.length; i ++ ) {

          var group = groups[ i ];

          var start = group.start;
          var count = group.count;

          for ( var j = start, jl = start + count; j < jl; j += 3 ) {

            if ( indices !== undefined ) {

              addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

            } else {

              addFace( j, j + 1, j + 2, group.materialIndex );

            }

          }

        }

      } else {

        if ( indices !== undefined ) {

          for ( var i = 0; i < indices.length; i += 3 ) {

            addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

          }

        } else {

          for ( var i = 0; i < positions.length / 3; i += 3 ) {

            addFace( i, i + 1, i + 2 );

          }

        }

      }

      this.computeFaceNormals();

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      return this;

    },

    center: function () {

      this.computeBoundingBox();

      var offset = this.boundingBox.getCenter().negate();

      this.translate( offset.x, offset.y, offset.z );

      return offset;

    },

    normalize: function () {

      this.computeBoundingSphere();

      var center = this.boundingSphere.center;
      var radius = this.boundingSphere.radius;

      var s = radius === 0 ? 1 : 1.0 / radius;

      var matrix = new Matrix4();
      matrix.set(
        s, 0, 0, - s * center.x,
        0, s, 0, - s * center.y,
        0, 0, s, - s * center.z,
        0, 0, 0, 1
      );

      this.applyMatrix( matrix );

      return this;

    },

    computeFaceNormals: function () {

      var cb = new Vector3(), ab = new Vector3();

      for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

        var face = this.faces[ f ];

        var vA = this.vertices[ face.a ];
        var vB = this.vertices[ face.b ];
        var vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        cb.normalize();

        face.normal.copy( cb );

      }

    },

    computeVertexNormals: function ( areaWeighted ) {

      if ( areaWeighted === undefined ) areaWeighted = true;

      var v, vl, f, fl, face, vertices;

      vertices = new Array( this.vertices.length );

      for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

        vertices[ v ] = new Vector3();

      }

      if ( areaWeighted ) {

        // vertex normals weighted by triangle areas
        // http://www.iquilezles.org/www/articles/normals/normals.htm

        var vA, vB, vC;
        var cb = new Vector3(), ab = new Vector3();

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          face = this.faces[ f ];

          vA = this.vertices[ face.a ];
          vB = this.vertices[ face.b ];
          vC = this.vertices[ face.c ];

          cb.subVectors( vC, vB );
          ab.subVectors( vA, vB );
          cb.cross( ab );

          vertices[ face.a ].add( cb );
          vertices[ face.b ].add( cb );
          vertices[ face.c ].add( cb );

        }

      } else {

        this.computeFaceNormals();

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          face = this.faces[ f ];

          vertices[ face.a ].add( face.normal );
          vertices[ face.b ].add( face.normal );
          vertices[ face.c ].add( face.normal );

        }

      }

      for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

        vertices[ v ].normalize();

      }

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        var vertexNormals = face.vertexNormals;

        if ( vertexNormals.length === 3 ) {

          vertexNormals[ 0 ].copy( vertices[ face.a ] );
          vertexNormals[ 1 ].copy( vertices[ face.b ] );
          vertexNormals[ 2 ].copy( vertices[ face.c ] );

        } else {

          vertexNormals[ 0 ] = vertices[ face.a ].clone();
          vertexNormals[ 1 ] = vertices[ face.b ].clone();
          vertexNormals[ 2 ] = vertices[ face.c ].clone();

        }

      }

      if ( this.faces.length > 0 ) {

        this.normalsNeedUpdate = true;

      }

    },

    computeFlatVertexNormals: function () {

      var f, fl, face;

      this.computeFaceNormals();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        var vertexNormals = face.vertexNormals;

        if ( vertexNormals.length === 3 ) {

          vertexNormals[ 0 ].copy( face.normal );
          vertexNormals[ 1 ].copy( face.normal );
          vertexNormals[ 2 ].copy( face.normal );

        } else {

          vertexNormals[ 0 ] = face.normal.clone();
          vertexNormals[ 1 ] = face.normal.clone();
          vertexNormals[ 2 ] = face.normal.clone();

        }

      }

      if ( this.faces.length > 0 ) {

        this.normalsNeedUpdate = true;

      }

    },

    computeMorphNormals: function () {

      var i, il, f, fl, face;

      // save original normals
      // - create temp variables on first access
      //   otherwise just copy (for faster repeated calls)

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        if ( ! face.__originalFaceNormal ) {

          face.__originalFaceNormal = face.normal.clone();

        } else {

          face.__originalFaceNormal.copy( face.normal );

        }

        if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

        for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

          if ( ! face.__originalVertexNormals[ i ] ) {

            face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

          } else {

            face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

          }

        }

      }

      // use temp geometry to compute face and vertex normals for each morph

      var tmpGeo = new Geometry();
      tmpGeo.faces = this.faces;

      for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

        // create on first access

        if ( ! this.morphNormals[ i ] ) {

          this.morphNormals[ i ] = {};
          this.morphNormals[ i ].faceNormals = [];
          this.morphNormals[ i ].vertexNormals = [];

          var dstNormalsFace = this.morphNormals[ i ].faceNormals;
          var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

          var faceNormal, vertexNormals;

          for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            faceNormal = new Vector3();
            vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

            dstNormalsFace.push( faceNormal );
            dstNormalsVertex.push( vertexNormals );

          }

        }

        var morphNormals = this.morphNormals[ i ];

        // set vertices to morph target

        tmpGeo.vertices = this.morphTargets[ i ].vertices;

        // compute morph normals

        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();

        // store morph normals

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          face = this.faces[ f ];

          faceNormal = morphNormals.faceNormals[ f ];
          vertexNormals = morphNormals.vertexNormals[ f ];

          faceNormal.copy( face.normal );

          vertexNormals.a.copy( face.vertexNormals[ 0 ] );
          vertexNormals.b.copy( face.vertexNormals[ 1 ] );
          vertexNormals.c.copy( face.vertexNormals[ 2 ] );

        }

      }

      // restore original normals

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;

      }

    },

    computeLineDistances: function () {

      var d = 0;
      var vertices = this.vertices;

      for ( var i = 0, il = vertices.length; i < il; i ++ ) {

        if ( i > 0 ) {

          d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

        }

        this.lineDistances[ i ] = d;

      }

    },

    computeBoundingBox: function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new Box3();

      }

      this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new Sphere();

      }

      this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function ( geometry, matrix, materialIndexOffset ) {

      if ( ! ( geometry && geometry.isGeometry ) ) {

        console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
        return;

      }

      var normalMatrix,
        vertexOffset = this.vertices.length,
        vertices1 = this.vertices,
        vertices2 = geometry.vertices,
        faces1 = this.faces,
        faces2 = geometry.faces,
        uvs1 = this.faceVertexUvs[ 0 ],
        uvs2 = geometry.faceVertexUvs[ 0 ],
        colors1 = this.colors,
        colors2 = geometry.colors;

      if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

      if ( matrix !== undefined ) {

        normalMatrix = new Matrix3().getNormalMatrix( matrix );

      }

      // vertices

      for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

        var vertex = vertices2[ i ];

        var vertexCopy = vertex.clone();

        if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

        vertices1.push( vertexCopy );

      }

      // colors

      for ( var i = 0, il = colors2.length; i < il; i ++ ) {

        colors1.push( colors2[ i ].clone() );

      }

      // faces

      for ( i = 0, il = faces2.length; i < il; i ++ ) {

        var face = faces2[ i ], faceCopy, normal, color,
          faceVertexNormals = face.vertexNormals,
          faceVertexColors = face.vertexColors;

        faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
        faceCopy.normal.copy( face.normal );

        if ( normalMatrix !== undefined ) {

          faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

        }

        for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

          normal = faceVertexNormals[ j ].clone();

          if ( normalMatrix !== undefined ) {

            normal.applyMatrix3( normalMatrix ).normalize();

          }

          faceCopy.vertexNormals.push( normal );

        }

        faceCopy.color.copy( face.color );

        for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

          color = faceVertexColors[ j ];
          faceCopy.vertexColors.push( color.clone() );

        }

        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

        faces1.push( faceCopy );

      }

      // uvs

      for ( i = 0, il = uvs2.length; i < il; i ++ ) {

        var uv = uvs2[ i ], uvCopy = [];

        if ( uv === undefined ) {

          continue;

        }

        for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

          uvCopy.push( uv[ j ].clone() );

        }

        uvs1.push( uvCopy );

      }

    },

    mergeMesh: function ( mesh ) {

      if ( ! ( mesh && mesh.isMesh ) ) {

        console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
        return;

      }

      mesh.matrixAutoUpdate && mesh.updateMatrix();

      this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function () {

      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
      var unique = [], changes = [];

      var v, key;
      var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
      var precision = Math.pow( 10, precisionPoints );
      var i, il, face;
      var indices, j, jl;

      for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

        v = this.vertices[ i ];
        key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

        if ( verticesMap[ key ] === undefined ) {

          verticesMap[ key ] = i;
          unique.push( this.vertices[ i ] );
          changes[ i ] = unique.length - 1;

        } else {

          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
          changes[ i ] = changes[ verticesMap[ key ] ];

        }

      }


      // if faces are completely degenerate after merging vertices, we
      // have to remove them from the geometry.
      var faceIndicesToRemove = [];

      for ( i = 0, il = this.faces.length; i < il; i ++ ) {

        face = this.faces[ i ];

        face.a = changes[ face.a ];
        face.b = changes[ face.b ];
        face.c = changes[ face.c ];

        indices = [ face.a, face.b, face.c ];

        // if any duplicate vertices are found in a Face3
        // we have to remove the face as nothing can be saved
        for ( var n = 0; n < 3; n ++ ) {

          if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

            faceIndicesToRemove.push( i );
            break;

          }

        }

      }

      for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

        var idx = faceIndicesToRemove[ i ];

        this.faces.splice( idx, 1 );

        for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

          this.faceVertexUvs[ j ].splice( idx, 1 );

        }

      }

      // Use unique set of vertices

      var diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;

    },

    sortFacesByMaterialIndex: function () {

      var faces = this.faces;
      var length = faces.length;

      // tag faces

      for ( var i = 0; i < length; i ++ ) {

        faces[ i ]._id = i;

      }

      // sort faces

      function materialIndexSort( a, b ) {

        return a.materialIndex - b.materialIndex;

      }

      faces.sort( materialIndexSort );

      // sort uvs

      var uvs1 = this.faceVertexUvs[ 0 ];
      var uvs2 = this.faceVertexUvs[ 1 ];

      var newUvs1, newUvs2;

      if ( uvs1 && uvs1.length === length ) newUvs1 = [];
      if ( uvs2 && uvs2.length === length ) newUvs2 = [];

      for ( var i = 0; i < length; i ++ ) {

        var id = faces[ i ]._id;

        if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
        if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

      }

      if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
      if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    },

    toJSON: function () {

      var data = {
        metadata: {
          version: 4.5,
          type: 'Geometry',
          generator: 'Geometry.toJSON'
        }
      };

      // standard Geometry serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if ( this.name !== '' ) data.name = this.name;

      if ( this.parameters !== undefined ) {

        var parameters = this.parameters;

        for ( var key in parameters ) {

          if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

        }

        return data;

      }

      var vertices = [];

      for ( var i = 0; i < this.vertices.length; i ++ ) {

        var vertex = this.vertices[ i ];
        vertices.push( vertex.x, vertex.y, vertex.z );

      }

      var faces = [];
      var normals = [];
      var normalsHash = {};
      var colors = [];
      var colorsHash = {};
      var uvs = [];
      var uvsHash = {};

      for ( var i = 0; i < this.faces.length; i ++ ) {

        var face = this.faces[ i ];

        var hasMaterial = true;
        var hasFaceUv = false; // deprecated
        var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
        var hasFaceNormal = face.normal.length() > 0;
        var hasFaceVertexNormal = face.vertexNormals.length > 0;
        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        var hasFaceVertexColor = face.vertexColors.length > 0;

        var faceType = 0;

        faceType = setBit( faceType, 0, 0 ); // isQuad
        faceType = setBit( faceType, 1, hasMaterial );
        faceType = setBit( faceType, 2, hasFaceUv );
        faceType = setBit( faceType, 3, hasFaceVertexUv );
        faceType = setBit( faceType, 4, hasFaceNormal );
        faceType = setBit( faceType, 5, hasFaceVertexNormal );
        faceType = setBit( faceType, 6, hasFaceColor );
        faceType = setBit( faceType, 7, hasFaceVertexColor );

        faces.push( faceType );
        faces.push( face.a, face.b, face.c );
        faces.push( face.materialIndex );

        if ( hasFaceVertexUv ) {

          var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

          faces.push(
            getUvIndex( faceVertexUvs[ 0 ] ),
            getUvIndex( faceVertexUvs[ 1 ] ),
            getUvIndex( faceVertexUvs[ 2 ] )
          );

        }

        if ( hasFaceNormal ) {

          faces.push( getNormalIndex( face.normal ) );

        }

        if ( hasFaceVertexNormal ) {

          var vertexNormals = face.vertexNormals;

          faces.push(
            getNormalIndex( vertexNormals[ 0 ] ),
            getNormalIndex( vertexNormals[ 1 ] ),
            getNormalIndex( vertexNormals[ 2 ] )
          );

        }

        if ( hasFaceColor ) {

          faces.push( getColorIndex( face.color ) );

        }

        if ( hasFaceVertexColor ) {

          var vertexColors = face.vertexColors;

          faces.push(
            getColorIndex( vertexColors[ 0 ] ),
            getColorIndex( vertexColors[ 1 ] ),
            getColorIndex( vertexColors[ 2 ] )
          );

        }

      }

      function setBit( value, position, enabled ) {

        return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

      }

      function getNormalIndex( normal ) {

        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

        if ( normalsHash[ hash ] !== undefined ) {

          return normalsHash[ hash ];

        }

        normalsHash[ hash ] = normals.length / 3;
        normals.push( normal.x, normal.y, normal.z );

        return normalsHash[ hash ];

      }

      function getColorIndex( color ) {

        var hash = color.r.toString() + color.g.toString() + color.b.toString();

        if ( colorsHash[ hash ] !== undefined ) {

          return colorsHash[ hash ];

        }

        colorsHash[ hash ] = colors.length;
        colors.push( color.getHex() );

        return colorsHash[ hash ];

      }

      function getUvIndex( uv ) {

        var hash = uv.x.toString() + uv.y.toString();

        if ( uvsHash[ hash ] !== undefined ) {

          return uvsHash[ hash ];

        }

        uvsHash[ hash ] = uvs.length / 2;
        uvs.push( uv.x, uv.y );

        return uvsHash[ hash ];

      }

      data.data = {};

      data.data.vertices = vertices;
      data.data.normals = normals;
      if ( colors.length > 0 ) data.data.colors = colors;
      if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
      data.data.faces = faces;

      return data;

    },

    clone: function () {

      /*
       // Handle primitives

       var parameters = this.parameters;

       if ( parameters !== undefined ) {

       var values = [];

       for ( var key in parameters ) {

       values.push( parameters[ key ] );

       }

       var geometry = Object.create( this.constructor.prototype );
       this.constructor.apply( geometry, values );
       return geometry;

       }

       return new this.constructor().copy( this );
       */

      return new Geometry().copy( this );

    },

    copy: function ( source ) {

      var i, il, j, jl, k, kl;

      // reset

      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;

      // name

      this.name = source.name;

      // vertices

      var vertices = source.vertices;

      for ( i = 0, il = vertices.length; i < il; i ++ ) {

        this.vertices.push( vertices[ i ].clone() );

      }

      // colors

      var colors = source.colors;

      for ( i = 0, il = colors.length; i < il; i ++ ) {

        this.colors.push( colors[ i ].clone() );

      }

      // faces

      var faces = source.faces;

      for ( i = 0, il = faces.length; i < il; i ++ ) {

        this.faces.push( faces[ i ].clone() );

      }

      // face vertex uvs

      for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

        var faceVertexUvs = source.faceVertexUvs[ i ];

        if ( this.faceVertexUvs[ i ] === undefined ) {

          this.faceVertexUvs[ i ] = [];

        }

        for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

          var uvs = faceVertexUvs[ j ], uvsCopy = [];

          for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

            var uv = uvs[ k ];

            uvsCopy.push( uv.clone() );

          }

          this.faceVertexUvs[ i ].push( uvsCopy );

        }

      }

      // morph targets

      var morphTargets = source.morphTargets;

      for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

        var morphTarget = {};
        morphTarget.name = morphTargets[ i ].name;

        // vertices

        if ( morphTargets[ i ].vertices !== undefined ) {

          morphTarget.vertices = [];

          for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

            morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

          }

        }

        // normals

        if ( morphTargets[ i ].normals !== undefined ) {

          morphTarget.normals = [];

          for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

            morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

          }

        }

        this.morphTargets.push( morphTarget );

      }

      // morph normals

      var morphNormals = source.morphNormals;

      for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

        var morphNormal = {};

        // vertex normals

        if ( morphNormals[ i ].vertexNormals !== undefined ) {

          morphNormal.vertexNormals = [];

          for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

            var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
            var destVertexNormal = {};

            destVertexNormal.a = srcVertexNormal.a.clone();
            destVertexNormal.b = srcVertexNormal.b.clone();
            destVertexNormal.c = srcVertexNormal.c.clone();

            morphNormal.vertexNormals.push( destVertexNormal );

          }

        }

        // face normals

        if ( morphNormals[ i ].faceNormals !== undefined ) {

          morphNormal.faceNormals = [];

          for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

            morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

          }

        }

        this.morphNormals.push( morphNormal );

      }

      // skin weights

      var skinWeights = source.skinWeights;

      for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

        this.skinWeights.push( skinWeights[ i ].clone() );

      }

      // skin indices

      var skinIndices = source.skinIndices;

      for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

        this.skinIndices.push( skinIndices[ i ].clone() );

      }

      // line distances

      var lineDistances = source.lineDistances;

      for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

        this.lineDistances.push( lineDistances[ i ] );

      }

      // bounding box

      var boundingBox = source.boundingBox;

      if ( boundingBox !== null ) {

        this.boundingBox = boundingBox.clone();

      }

      // bounding sphere

      var boundingSphere = source.boundingSphere;

      if ( boundingSphere !== null ) {

        this.boundingSphere = boundingSphere.clone();

      }

      // update flags

      this.elementsNeedUpdate = source.elementsNeedUpdate;
      this.verticesNeedUpdate = source.verticesNeedUpdate;
      this.uvsNeedUpdate = source.uvsNeedUpdate;
      this.normalsNeedUpdate = source.normalsNeedUpdate;
      this.colorsNeedUpdate = source.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = source.groupsNeedUpdate;

      return this;

    },

    dispose: function () {

      this.dispatchEvent( { type: 'dispose' } );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferAttribute( array, itemSize, normalized ) {

    if ( Array.isArray( array ) ) {

      throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    }

    this.uuid = _Math.generateUUID();
    this.name = '';

    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.onUploadCallback = function () {};

    this.version = 0;

  }

  Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

    set: function ( value ) {

      if ( value === true ) this.version ++;

    }

  } );

  Object.assign( BufferAttribute.prototype, {

    isBufferAttribute: true,

    setArray: function ( array ) {

      if ( Array.isArray( array ) ) {

        throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

      }

      this.count = array !== undefined ? array.length / this.itemSize : 0;
      this.array = array;

    },

    setDynamic: function ( value ) {

      this.dynamic = value;

      return this;

    },

    copy: function ( source ) {

      this.array = new source.array.constructor( source.array );
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;

      this.dynamic = source.dynamic;

      return this;

    },

    copyAt: function ( index1, attribute, index2 ) {

      index1 *= this.itemSize;
      index2 *= attribute.itemSize;

      for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

        this.array[ index1 + i ] = attribute.array[ index2 + i ];

      }

      return this;

    },

    copyArray: function ( array ) {

      this.array.set( array );

      return this;

    },

    copyColorsArray: function ( colors ) {

      var array = this.array, offset = 0;

      for ( var i = 0, l = colors.length; i < l; i ++ ) {

        var color = colors[ i ];

        if ( color === undefined ) {

          console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
          color = new Color();

        }

        array[ offset ++ ] = color.r;
        array[ offset ++ ] = color.g;
        array[ offset ++ ] = color.b;

      }

      return this;

    },

    copyIndicesArray: function ( indices ) {

      var array = this.array, offset = 0;

      for ( var i = 0, l = indices.length; i < l; i ++ ) {

        var index = indices[ i ];

        array[ offset ++ ] = index.a;
        array[ offset ++ ] = index.b;
        array[ offset ++ ] = index.c;

      }

      return this;

    },

    copyVector2sArray: function ( vectors ) {

      var array = this.array, offset = 0;

      for ( var i = 0, l = vectors.length; i < l; i ++ ) {

        var vector = vectors[ i ];

        if ( vector === undefined ) {

          console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
          vector = new Vector2();

        }

        array[ offset ++ ] = vector.x;
        array[ offset ++ ] = vector.y;

      }

      return this;

    },

    copyVector3sArray: function ( vectors ) {

      var array = this.array, offset = 0;

      for ( var i = 0, l = vectors.length; i < l; i ++ ) {

        var vector = vectors[ i ];

        if ( vector === undefined ) {

          console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
          vector = new Vector3();

        }

        array[ offset ++ ] = vector.x;
        array[ offset ++ ] = vector.y;
        array[ offset ++ ] = vector.z;

      }

      return this;

    },

    copyVector4sArray: function ( vectors ) {

      var array = this.array, offset = 0;

      for ( var i = 0, l = vectors.length; i < l; i ++ ) {

        var vector = vectors[ i ];

        if ( vector === undefined ) {

          console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
          vector = new Vector4();

        }

        array[ offset ++ ] = vector.x;
        array[ offset ++ ] = vector.y;
        array[ offset ++ ] = vector.z;
        array[ offset ++ ] = vector.w;

      }

      return this;

    },

    set: function ( value, offset ) {

      if ( offset === undefined ) offset = 0;

      this.array.set( value, offset );

      return this;

    },

    getX: function ( index ) {

      return this.array[ index * this.itemSize ];

    },

    setX: function ( index, x ) {

      this.array[ index * this.itemSize ] = x;

      return this;

    },

    getY: function ( index ) {

      return this.array[ index * this.itemSize + 1 ];

    },

    setY: function ( index, y ) {

      this.array[ index * this.itemSize + 1 ] = y;

      return this;

    },

    getZ: function ( index ) {

      return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function ( index, z ) {

      this.array[ index * this.itemSize + 2 ] = z;

      return this;

    },

    getW: function ( index ) {

      return this.array[ index * this.itemSize + 3 ];

    },

    setW: function ( index, w ) {

      this.array[ index * this.itemSize + 3 ] = w;

      return this;

    },

    setXY: function ( index, x, y ) {

      index *= this.itemSize;

      this.array[ index + 0 ] = x;
      this.array[ index + 1 ] = y;

      return this;

    },

    setXYZ: function ( index, x, y, z ) {

      index *= this.itemSize;

      this.array[ index + 0 ] = x;
      this.array[ index + 1 ] = y;
      this.array[ index + 2 ] = z;

      return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

      index *= this.itemSize;

      this.array[ index + 0 ] = x;
      this.array[ index + 1 ] = y;
      this.array[ index + 2 ] = z;
      this.array[ index + 3 ] = w;

      return this;

    },

    onUpload: function ( callback ) {

      this.onUploadCallback = callback;

      return this;

    },

    clone: function () {

      return new this.constructor( this.array, this.itemSize ).copy( this );

    }

  } );

  //

  function Int8BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

  }

  Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


  function Uint8BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

  }

  Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


  function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

  }

  Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


  function Int16BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

  }

  Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


  function Uint16BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

  }

  Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


  function Int32BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

  }

  Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


  function Uint32BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

  }

  Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


  function Float32BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

  }

  Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


  function Float64BufferAttribute( array, itemSize, normalized ) {

    BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

  }

  Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectGeometry() {

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

  }

  Object.assign( DirectGeometry.prototype, {

    computeGroups: function ( geometry ) {

      var group;
      var groups = [];
      var materialIndex = undefined;

      var faces = geometry.faces;

      for ( var i = 0; i < faces.length; i ++ ) {

        var face = faces[ i ];

        // materials

        if ( face.materialIndex !== materialIndex ) {

          materialIndex = face.materialIndex;

          if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

          }

          group = {
            start: i * 3,
            materialIndex: materialIndex
          };

        }

      }

      if ( group !== undefined ) {

        group.count = ( i * 3 ) - group.start;
        groups.push( group );

      }

      this.groups = groups;

    },

    fromGeometry: function ( geometry ) {

      var faces = geometry.faces;
      var vertices = geometry.vertices;
      var faceVertexUvs = geometry.faceVertexUvs;

      var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
      var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

      // morphs

      var morphTargets = geometry.morphTargets;
      var morphTargetsLength = morphTargets.length;

      var morphTargetsPosition;

      if ( morphTargetsLength > 0 ) {

        morphTargetsPosition = [];

        for ( var i = 0; i < morphTargetsLength; i ++ ) {

          morphTargetsPosition[ i ] = [];

        }

        this.morphTargets.position = morphTargetsPosition;

      }

      var morphNormals = geometry.morphNormals;
      var morphNormalsLength = morphNormals.length;

      var morphTargetsNormal;

      if ( morphNormalsLength > 0 ) {

        morphTargetsNormal = [];

        for ( var i = 0; i < morphNormalsLength; i ++ ) {

          morphTargetsNormal[ i ] = [];

        }

        this.morphTargets.normal = morphTargetsNormal;

      }

      // skins

      var skinIndices = geometry.skinIndices;
      var skinWeights = geometry.skinWeights;

      var hasSkinIndices = skinIndices.length === vertices.length;
      var hasSkinWeights = skinWeights.length === vertices.length;

      //

      for ( var i = 0; i < faces.length; i ++ ) {

        var face = faces[ i ];

        this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

        var vertexNormals = face.vertexNormals;

        if ( vertexNormals.length === 3 ) {

          this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

        } else {

          var normal = face.normal;

          this.normals.push( normal, normal, normal );

        }

        var vertexColors = face.vertexColors;

        if ( vertexColors.length === 3 ) {

          this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

        } else {

          var color = face.color;

          this.colors.push( color, color, color );

        }

        if ( hasFaceVertexUv === true ) {

          var vertexUvs = faceVertexUvs[ 0 ][ i ];

          if ( vertexUvs !== undefined ) {

            this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

          } else {

            console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

            this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

          }

        }

        if ( hasFaceVertexUv2 === true ) {

          var vertexUvs = faceVertexUvs[ 1 ][ i ];

          if ( vertexUvs !== undefined ) {

            this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

          } else {

            console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

            this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

          }

        }

        // morphs

        for ( var j = 0; j < morphTargetsLength; j ++ ) {

          var morphTarget = morphTargets[ j ].vertices;

          morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

        }

        for ( var j = 0; j < morphNormalsLength; j ++ ) {

          var morphNormal = morphNormals[ j ].vertexNormals[ i ];

          morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

        }

        // skins

        if ( hasSkinIndices ) {

          this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

        }

        if ( hasSkinWeights ) {

          this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

        }

      }

      this.computeGroups( geometry );

      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function arrayMax( array ) {

    if ( array.length === 0 ) return - Infinity;

    var max = array[ 0 ];

    for ( var i = 1, l = array.length; i < l; ++ i ) {

      if ( array[ i ] > max ) max = array[ i ];

    }

    return max;

  }

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

  function BufferGeometry() {

    Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

    this.uuid = _Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = { start: 0, count: Infinity };

  }

  Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

    isBufferGeometry: true,

    getIndex: function () {

      return this.index;

    },

    setIndex: function ( index ) {

      if ( Array.isArray( index ) ) {

        this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

      } else {

        this.index = index;

      }

    },

    addAttribute: function ( name, attribute ) {

      if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

        console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

        this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

        return;

      }

      if ( name === 'index' ) {

        console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
        this.setIndex( attribute );

        return;

      }

      this.attributes[ name ] = attribute;

      return this;

    },

    getAttribute: function ( name ) {

      return this.attributes[ name ];

    },

    removeAttribute: function ( name ) {

      delete this.attributes[ name ];

      return this;

    },

    addGroup: function ( start, count, materialIndex ) {

      this.groups.push( {

        start: start,
        count: count,
        materialIndex: materialIndex !== undefined ? materialIndex : 0

      } );

    },

    clearGroups: function () {

      this.groups = [];

    },

    setDrawRange: function ( start, count ) {

      this.drawRange.start = start;
      this.drawRange.count = count;

    },

    applyMatrix: function ( matrix ) {

      var position = this.attributes.position;

      if ( position !== undefined ) {

        matrix.applyToBufferAttribute( position );
        position.needsUpdate = true;

      }

      var normal = this.attributes.normal;

      if ( normal !== undefined ) {

        var normalMatrix = new Matrix3().getNormalMatrix( matrix );

        normalMatrix.applyToBufferAttribute( normal );
        normal.needsUpdate = true;

      }

      if ( this.boundingBox !== null ) {

        this.computeBoundingBox();

      }

      if ( this.boundingSphere !== null ) {

        this.computeBoundingSphere();

      }

      return this;

    },

    rotateX: function () {

      // rotate geometry around world x-axis

      var m1 = new Matrix4();

      return function rotateX( angle ) {

        m1.makeRotationX( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    rotateY: function () {

      // rotate geometry around world y-axis

      var m1 = new Matrix4();

      return function rotateY( angle ) {

        m1.makeRotationY( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    rotateZ: function () {

      // rotate geometry around world z-axis

      var m1 = new Matrix4();

      return function rotateZ( angle ) {

        m1.makeRotationZ( angle );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    translate: function () {

      // translate geometry

      var m1 = new Matrix4();

      return function translate( x, y, z ) {

        m1.makeTranslation( x, y, z );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    scale: function () {

      // scale geometry

      var m1 = new Matrix4();

      return function scale( x, y, z ) {

        m1.makeScale( x, y, z );

        this.applyMatrix( m1 );

        return this;

      };

    }(),

    lookAt: function () {

      var obj = new Object3D();

      return function lookAt( vector ) {

        obj.lookAt( vector );

        obj.updateMatrix();

        this.applyMatrix( obj.matrix );

      };

    }(),

    center: function () {

      this.computeBoundingBox();

      var offset = this.boundingBox.getCenter().negate();

      this.translate( offset.x, offset.y, offset.z );

      return offset;

    },

    setFromObject: function ( object ) {

      // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

      var geometry = object.geometry;

      if ( object.isPoints || object.isLine ) {

        var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
        var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

        this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
        this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

        if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

          var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

          this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

        }

        if ( geometry.boundingSphere !== null ) {

          this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

          this.boundingBox = geometry.boundingBox.clone();

        }

      } else if ( object.isMesh ) {

        if ( geometry && geometry.isGeometry ) {

          this.fromGeometry( geometry );

        }

      }

      return this;

    },

    updateFromObject: function ( object ) {

      var geometry = object.geometry;

      if ( object.isMesh ) {

        var direct = geometry.__directGeometry;

        if ( geometry.elementsNeedUpdate === true ) {

          direct = undefined;
          geometry.elementsNeedUpdate = false;

        }

        if ( direct === undefined ) {

          return this.fromGeometry( geometry );

        }

        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

        geometry.verticesNeedUpdate = false;
        geometry.normalsNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.uvsNeedUpdate = false;
        geometry.groupsNeedUpdate = false;

        geometry = direct;

      }

      var attribute;

      if ( geometry.verticesNeedUpdate === true ) {

        attribute = this.attributes.position;

        if ( attribute !== undefined ) {

          attribute.copyVector3sArray( geometry.vertices );
          attribute.needsUpdate = true;

        }

        geometry.verticesNeedUpdate = false;

      }

      if ( geometry.normalsNeedUpdate === true ) {

        attribute = this.attributes.normal;

        if ( attribute !== undefined ) {

          attribute.copyVector3sArray( geometry.normals );
          attribute.needsUpdate = true;

        }

        geometry.normalsNeedUpdate = false;

      }

      if ( geometry.colorsNeedUpdate === true ) {

        attribute = this.attributes.color;

        if ( attribute !== undefined ) {

          attribute.copyColorsArray( geometry.colors );
          attribute.needsUpdate = true;

        }

        geometry.colorsNeedUpdate = false;

      }

      if ( geometry.uvsNeedUpdate ) {

        attribute = this.attributes.uv;

        if ( attribute !== undefined ) {

          attribute.copyVector2sArray( geometry.uvs );
          attribute.needsUpdate = true;

        }

        geometry.uvsNeedUpdate = false;

      }

      if ( geometry.lineDistancesNeedUpdate ) {

        attribute = this.attributes.lineDistance;

        if ( attribute !== undefined ) {

          attribute.copyArray( geometry.lineDistances );
          attribute.needsUpdate = true;

        }

        geometry.lineDistancesNeedUpdate = false;

      }

      if ( geometry.groupsNeedUpdate ) {

        geometry.computeGroups( object.geometry );
        this.groups = geometry.groups;

        geometry.groupsNeedUpdate = false;

      }

      return this;

    },

    fromGeometry: function ( geometry ) {

      geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

      return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function ( geometry ) {

      var positions = new Float32Array( geometry.vertices.length * 3 );
      this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

      if ( geometry.normals.length > 0 ) {

        var normals = new Float32Array( geometry.normals.length * 3 );
        this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

      }

      if ( geometry.colors.length > 0 ) {

        var colors = new Float32Array( geometry.colors.length * 3 );
        this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

      }

      if ( geometry.uvs.length > 0 ) {

        var uvs = new Float32Array( geometry.uvs.length * 2 );
        this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

      }

      if ( geometry.uvs2.length > 0 ) {

        var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
        this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

      }

      if ( geometry.indices.length > 0 ) {

        var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
        var indices = new TypeArray( geometry.indices.length * 3 );
        this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

      }

      // groups

      this.groups = geometry.groups;

      // morphs

      for ( var name in geometry.morphTargets ) {

        var array = [];
        var morphTargets = geometry.morphTargets[ name ];

        for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

          var morphTarget = morphTargets[ i ];

          var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

          array.push( attribute.copyVector3sArray( morphTarget ) );

        }

        this.morphAttributes[ name ] = array;

      }

      // skinning

      if ( geometry.skinIndices.length > 0 ) {

        var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
        this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

      }

      if ( geometry.skinWeights.length > 0 ) {

        var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
        this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

      }

      //

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

      return this;

    },

    computeBoundingBox: function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new Box3();

      }

      var position = this.attributes.position;

      if ( position !== undefined ) {

        this.boundingBox.setFromBufferAttribute( position );

      } else {

        this.boundingBox.makeEmpty();

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

      }

    },

    computeBoundingSphere: function () {

      var box = new Box3();
      var vector = new Vector3();

      return function computeBoundingSphere() {

        if ( this.boundingSphere === null ) {

          this.boundingSphere = new Sphere();

        }

        var position = this.attributes.position;

        if ( position ) {

          var center = this.boundingSphere.center;

          box.setFromBufferAttribute( position );
          box.getCenter( center );

          // hoping to find a boundingSphere with a radius smaller than the
          // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

          var maxRadiusSq = 0;

          for ( var i = 0, il = position.count; i < il; i ++ ) {

            vector.x = position.getX( i );
            vector.y = position.getY( i );
            vector.z = position.getZ( i );
            maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

          }

          this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

          if ( isNaN( this.boundingSphere.radius ) ) {

            console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

          }

        }

      };

    }(),

    computeFaceNormals: function () {

      // backwards compatibility

    },

    computeVertexNormals: function () {

      var index = this.index;
      var attributes = this.attributes;
      var groups = this.groups;

      if ( attributes.position ) {

        var positions = attributes.position.array;

        if ( attributes.normal === undefined ) {

          this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

        } else {

          // reset existing normals to zero

          var array = attributes.normal.array;

          for ( var i = 0, il = array.length; i < il; i ++ ) {

            array[ i ] = 0;

          }

        }

        var normals = attributes.normal.array;

        var vA, vB, vC;
        var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        var cb = new Vector3(), ab = new Vector3();

        // indexed elements

        if ( index ) {

          var indices = index.array;

          if ( groups.length === 0 ) {

            this.addGroup( 0, indices.length );

          }

          for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

            var group = groups[ j ];

            var start = group.start;
            var count = group.count;

            for ( var i = start, il = start + count; i < il; i += 3 ) {

              vA = indices[ i + 0 ] * 3;
              vB = indices[ i + 1 ] * 3;
              vC = indices[ i + 2 ] * 3;

              pA.fromArray( positions, vA );
              pB.fromArray( positions, vB );
              pC.fromArray( positions, vC );

              cb.subVectors( pC, pB );
              ab.subVectors( pA, pB );
              cb.cross( ab );

              normals[ vA ] += cb.x;
              normals[ vA + 1 ] += cb.y;
              normals[ vA + 2 ] += cb.z;

              normals[ vB ] += cb.x;
              normals[ vB + 1 ] += cb.y;
              normals[ vB + 2 ] += cb.z;

              normals[ vC ] += cb.x;
              normals[ vC + 1 ] += cb.y;
              normals[ vC + 2 ] += cb.z;

            }

          }

        } else {

          // non-indexed elements (unconnected triangle soup)

          for ( var i = 0, il = positions.length; i < il; i += 9 ) {

            pA.fromArray( positions, i );
            pB.fromArray( positions, i + 3 );
            pC.fromArray( positions, i + 6 );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ i ] = cb.x;
            normals[ i + 1 ] = cb.y;
            normals[ i + 2 ] = cb.z;

            normals[ i + 3 ] = cb.x;
            normals[ i + 4 ] = cb.y;
            normals[ i + 5 ] = cb.z;

            normals[ i + 6 ] = cb.x;
            normals[ i + 7 ] = cb.y;
            normals[ i + 8 ] = cb.z;

          }

        }

        this.normalizeNormals();

        attributes.normal.needsUpdate = true;

      }

    },

    merge: function ( geometry, offset ) {

      if ( ! ( geometry && geometry.isBufferGeometry ) ) {

        console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
        return;

      }

      if ( offset === undefined ) offset = 0;

      var attributes = this.attributes;

      for ( var key in attributes ) {

        if ( geometry.attributes[ key ] === undefined ) continue;

        var attribute1 = attributes[ key ];
        var attributeArray1 = attribute1.array;

        var attribute2 = geometry.attributes[ key ];
        var attributeArray2 = attribute2.array;

        var attributeSize = attribute2.itemSize;

        for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

          attributeArray1[ j ] = attributeArray2[ i ];

        }

      }

      return this;

    },

    normalizeNormals: function () {

      var vector = new Vector3();

      return function normalizeNormals() {

        var normals = this.attributes.normal;

        for ( var i = 0, il = normals.count; i < il; i ++ ) {

          vector.x = normals.getX( i );
          vector.y = normals.getY( i );
          vector.z = normals.getZ( i );

          vector.normalize();

          normals.setXYZ( i, vector.x, vector.y, vector.z );

        }

      };

    }(),

    toNonIndexed: function () {

      if ( this.index === null ) {

        console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
        return this;

      }

      var geometry2 = new BufferGeometry();

      var indices = this.index.array;
      var attributes = this.attributes;

      for ( var name in attributes ) {

        var attribute = attributes[ name ];

        var array = attribute.array;
        var itemSize = attribute.itemSize;

        var array2 = new array.constructor( indices.length * itemSize );

        var index = 0, index2 = 0;

        for ( var i = 0, l = indices.length; i < l; i ++ ) {

          index = indices[ i ] * itemSize;

          for ( var j = 0; j < itemSize; j ++ ) {

            array2[ index2 ++ ] = array[ index ++ ];

          }

        }

        geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

      }

      return geometry2;

    },

    toJSON: function () {

      var data = {
        metadata: {
          version: 4.5,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      };

      // standard BufferGeometry serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if ( this.name !== '' ) data.name = this.name;

      if ( this.parameters !== undefined ) {

        var parameters = this.parameters;

        for ( var key in parameters ) {

          if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

        }

        return data;

      }

      data.data = { attributes: {} };

      var index = this.index;

      if ( index !== null ) {

        var array = Array.prototype.slice.call( index.array );

        data.data.index = {
          type: index.array.constructor.name,
          array: array
        };

      }

      var attributes = this.attributes;

      for ( var key in attributes ) {

        var attribute = attributes[ key ];

        var array = Array.prototype.slice.call( attribute.array );

        data.data.attributes[ key ] = {
          itemSize: attribute.itemSize,
          type: attribute.array.constructor.name,
          array: array,
          normalized: attribute.normalized
        };

      }

      var groups = this.groups;

      if ( groups.length > 0 ) {

        data.data.groups = JSON.parse( JSON.stringify( groups ) );

      }

      var boundingSphere = this.boundingSphere;

      if ( boundingSphere !== null ) {

        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };

      }

      return data;

    },

    clone: function () {

      /*
       // Handle primitives

       var parameters = this.parameters;

       if ( parameters !== undefined ) {

       var values = [];

       for ( var key in parameters ) {

       values.push( parameters[ key ] );

       }

       var geometry = Object.create( this.constructor.prototype );
       this.constructor.apply( geometry, values );
       return geometry;

       }

       return new this.constructor().copy( this );
       */

      return new BufferGeometry().copy( this );

    },

    copy: function ( source ) {

      var name, i, l;

      // reset

      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;

      // name

      this.name = source.name;

      // index

      var index = source.index;

      if ( index !== null ) {

        this.setIndex( index.clone() );

      }

      // attributes

      var attributes = source.attributes;

      for ( name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

      }

      // morph attributes

      var morphAttributes = source.morphAttributes;

      for ( name in morphAttributes ) {

        var array = [];
        var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

        for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

          array.push( morphAttribute[ i ].clone() );

        }

        this.morphAttributes[ name ] = array;

      }

      // groups

      var groups = source.groups;

      for ( i = 0, l = groups.length; i < l; i ++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.materialIndex );

      }

      // bounding box

      var boundingBox = source.boundingBox;

      if ( boundingBox !== null ) {

        this.boundingBox = boundingBox.clone();

      }

      // bounding sphere

      var boundingSphere = source.boundingSphere;

      if ( boundingSphere !== null ) {

        this.boundingSphere = boundingSphere.clone();

      }

      // draw range

      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;

      return this;

    },

    dispose: function () {

      this.dispatchEvent( { type: 'dispose' } );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // BoxGeometry

  function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };

    this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
    this.mergeVertices();

  }

  BoxGeometry.prototype = Object.create( Geometry.prototype );
  BoxGeometry.prototype.constructor = BoxGeometry;

  // BoxBufferGeometry

  function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    BufferGeometry.call( this );

    this.type = 'BoxBufferGeometry';

    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };

    var scope = this;

    // segments

    widthSegments = Math.floor( widthSegments ) || 1;
    heightSegments = Math.floor( heightSegments ) || 1;
    depthSegments = Math.floor( depthSegments ) || 1;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var numberOfVertices = 0;
    var groupStart = 0;

    // build each side of the box geometry

    buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
    buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
    buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
    buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
    buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
    buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

      var segmentWidth = width / gridX;
      var segmentHeight = height / gridY;

      var widthHalf = width / 2;
      var heightHalf = height / 2;
      var depthHalf = depth / 2;

      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;

      var vertexCounter = 0;
      var groupCount = 0;

      var ix, iy;

      var vector = new Vector3();

      // generate vertices, normals and uvs

      for ( iy = 0; iy < gridY1; iy ++ ) {

        var y = iy * segmentHeight - heightHalf;

        for ( ix = 0; ix < gridX1; ix ++ ) {

          var x = ix * segmentWidth - widthHalf;

          // set values to correct vector component

          vector[ u ] = x * udir;
          vector[ v ] = y * vdir;
          vector[ w ] = depthHalf;

          // now apply vector to vertex buffer

          vertices.push( vector.x, vector.y, vector.z );

          // set values to correct vector component

          vector[ u ] = 0;
          vector[ v ] = 0;
          vector[ w ] = depth > 0 ? 1 : - 1;

          // now apply vector to normal buffer

          normals.push( vector.x, vector.y, vector.z );

          // uvs

          uvs.push( ix / gridX );
          uvs.push( 1 - ( iy / gridY ) );

          // counters

          vertexCounter += 1;

        }

      }

      // indices

      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment

      for ( iy = 0; iy < gridY; iy ++ ) {

        for ( ix = 0; ix < gridX; ix ++ ) {

          var a = numberOfVertices + ix + gridX1 * iy;
          var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
          var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
          var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

          // faces

          indices.push( a, b, d );
          indices.push( b, c, d );

          // increase counter

          groupCount += 6;

        }

      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup( groupStart, groupCount, materialIndex );

      // calculate new start value for groups

      groupStart += groupCount;

      // update total number of vertices

      numberOfVertices += vertexCounter;

    }

  }

  BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PlaneGeometry

  function PlaneGeometry( width, height, widthSegments, heightSegments ) {

    Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };

    this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
    this.mergeVertices();

  }

  PlaneGeometry.prototype = Object.create( Geometry.prototype );
  PlaneGeometry.prototype.constructor = PlaneGeometry;

  // PlaneBufferGeometry

  function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

    BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var ix, iy;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // generate vertices, normals and uvs

    for ( iy = 0; iy < gridY1; iy ++ ) {

      var y = iy * segment_height - height_half;

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var x = ix * segment_width - width_half;

        vertices.push( x, - y, 0 );

        normals.push( 0, 0, 1 );

        uvs.push( ix / gridX );
        uvs.push( 1 - ( iy / gridY ) );

      }

    }

    // indices

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        // faces

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */

  function MeshBasicMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new Color( 0xffffff ); // emissive

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.skinning = false;
    this.morphTargets = false;

    this.lights = false;

    this.setValues( parameters );

  }

  MeshBasicMaterial.prototype = Object.create( Material.prototype );
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function ShaderMaterial( parameters ) {

    Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog
    this.lights = false; // set to use scene lights
    this.clipping = false; // set to use user-defined clipping planes

    this.skinning = false; // set to use skinning attribute streams
    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.extensions = {
      derivatives: false, // set to use derivatives
      fragDepth: false, // set to use fragment depth values
      drawBuffers: false, // set to use draw buffers
      shaderTextureLOD: false // set to use shader texture LOD
    };

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
      'color': [ 1, 1, 1 ],
      'uv': [ 0, 0 ],
      'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

      if ( parameters.attributes !== undefined ) {

        console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

      }

      this.setValues( parameters );

    }

  }

  ShaderMaterial.prototype = Object.create( Material.prototype );
  ShaderMaterial.prototype.constructor = ShaderMaterial;

  ShaderMaterial.prototype.isShaderMaterial = true;

  ShaderMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = UniformsUtils.clone( source.uniforms );

    this.defines = source.defines;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.lights = source.lights;
    this.clipping = source.clipping;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.extensions = source.extensions;

    return this;

  };

  ShaderMaterial.prototype.toJSON = function ( meta ) {

    var data = Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

  };

  /**
   * @author bhouston / http://clara.io
   */

  function Ray( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new Vector3();
    this.direction = ( direction !== undefined ) ? direction : new Vector3();

  }

  Object.assign( Ray.prototype, {

    set: function ( origin, direction ) {

      this.origin.copy( origin );
      this.direction.copy( direction );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( ray ) {

      this.origin.copy( ray.origin );
      this.direction.copy( ray.direction );

      return this;

    },

    at: function ( t, optionalTarget ) {

      var result = optionalTarget || new Vector3();

      return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    lookAt: function ( v ) {

      this.direction.copy( v ).sub( this.origin ).normalize();

      return this;

    },

    recast: function () {

      var v1 = new Vector3();

      return function recast( t ) {

        this.origin.copy( this.at( t, v1 ) );

        return this;

      };

    }(),

    closestPointToPoint: function ( point, optionalTarget ) {

      var result = optionalTarget || new Vector3();
      result.subVectors( point, this.origin );
      var directionDistance = result.dot( this.direction );

      if ( directionDistance < 0 ) {

        return result.copy( this.origin );

      }

      return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function ( point ) {

      return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function () {

      var v1 = new Vector3();

      return function distanceSqToPoint( point ) {

        var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

        // point behind the ray

        if ( directionDistance < 0 ) {

          return this.origin.distanceToSquared( point );

        }

        v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

        return v1.distanceToSquared( point );

      };

    }(),

    distanceSqToSegment: function () {

      var segCenter = new Vector3();
      var segDir = new Vector3();
      var diff = new Vector3();

      return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment

        segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
        segDir.copy( v1 ).sub( v0 ).normalize();
        diff.copy( this.origin ).sub( segCenter );

        var segExtent = v0.distanceTo( v1 ) * 0.5;
        var a01 = - this.direction.dot( segDir );
        var b0 = diff.dot( this.direction );
        var b1 = - diff.dot( segDir );
        var c = diff.lengthSq();
        var det = Math.abs( 1 - a01 * a01 );
        var s0, s1, sqrDist, extDet;

        if ( det > 0 ) {

          // The ray and segment are not parallel.

          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;

          if ( s0 >= 0 ) {

            if ( s1 >= - extDet ) {

              if ( s1 <= extDet ) {

                // region 0
                // Minimum at interior points of ray and segment.

                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

              } else {

                // region 1

                s1 = segExtent;
                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

              }

            } else {

              // region 5

              s1 = - segExtent;
              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          } else {

            if ( s1 <= - extDet ) {

              // region 4

              s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
              s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            } else if ( s1 <= extDet ) {

              // region 3

              s0 = 0;
              s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
              sqrDist = s1 * ( s1 + 2 * b1 ) + c;

            } else {

              // region 2

              s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
              s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          }

        } else {

          // Ray and segment are parallel.

          s1 = ( a01 > 0 ) ? - segExtent : segExtent;
          s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
          sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

        }

        if ( optionalPointOnRay ) {

          optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

        }

        if ( optionalPointOnSegment ) {

          optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

        }

        return sqrDist;

      };

    }(),

    intersectSphere: function () {

      var v1 = new Vector3();

      return function intersectSphere( sphere, optionalTarget ) {

        v1.subVectors( sphere.center, this.origin );
        var tca = v1.dot( this.direction );
        var d2 = v1.dot( v1 ) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;

        if ( d2 > radius2 ) return null;

        var thc = Math.sqrt( radius2 - d2 );

        // t0 = first intersect point - entrance on front of sphere
        var t0 = tca - thc;

        // t1 = second intersect point - exit point on back of sphere
        var t1 = tca + thc;

        // test to see if both t0 and t1 are behind the ray - if so, return null
        if ( t0 < 0 && t1 < 0 ) return null;

        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if ( t0 < 0 ) return this.at( t1, optionalTarget );

        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at( t0, optionalTarget );

      };

    }(),

    intersectsSphere: function ( sphere ) {

      return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    distanceToPlane: function ( plane ) {

      var denominator = plane.normal.dot( this.direction );

      if ( denominator === 0 ) {

        // line is coplanar, return origin
        if ( plane.distanceToPoint( this.origin ) === 0 ) {

          return 0;

        }

        // Null is preferable to undefined since undefined means.... it is undefined

        return null;

      }

      var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

      // Return if the ray never intersects the plane

      return t >= 0 ? t : null;

    },

    intersectPlane: function ( plane, optionalTarget ) {

      var t = this.distanceToPlane( plane );

      if ( t === null ) {

        return null;

      }

      return this.at( t, optionalTarget );

    },

    intersectsPlane: function ( plane ) {

      // check if the ray lies on the plane first

      var distToPoint = plane.distanceToPoint( this.origin );

      if ( distToPoint === 0 ) {

        return true;

      }

      var denominator = plane.normal.dot( this.direction );

      if ( denominator * distToPoint < 0 ) {

        return true;

      }

      // ray origin is behind the plane (and is pointing behind it)

      return false;

    },

    intersectBox: function ( box, optionalTarget ) {

      var tmin, tmax, tymin, tymax, tzmin, tzmax;

      var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;

      var origin = this.origin;

      if ( invdirx >= 0 ) {

        tmin = ( box.min.x - origin.x ) * invdirx;
        tmax = ( box.max.x - origin.x ) * invdirx;

      } else {

        tmin = ( box.max.x - origin.x ) * invdirx;
        tmax = ( box.min.x - origin.x ) * invdirx;

      }

      if ( invdiry >= 0 ) {

        tymin = ( box.min.y - origin.y ) * invdiry;
        tymax = ( box.max.y - origin.y ) * invdiry;

      } else {

        tymin = ( box.max.y - origin.y ) * invdiry;
        tymax = ( box.min.y - origin.y ) * invdiry;

      }

      if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

      // These lines also handle the case where tmin or tmax is NaN
      // (result of 0 * Infinity). x !== x returns true if x is NaN

      if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

      if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

      if ( invdirz >= 0 ) {

        tzmin = ( box.min.z - origin.z ) * invdirz;
        tzmax = ( box.max.z - origin.z ) * invdirz;

      } else {

        tzmin = ( box.max.z - origin.z ) * invdirz;
        tzmax = ( box.min.z - origin.z ) * invdirz;

      }

      if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

      if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

      if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

      //return point closest to the ray (positive side)

      if ( tmax < 0 ) return null;

      return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectsBox: ( function () {

      var v = new Vector3();

      return function intersectsBox( box ) {

        return this.intersectBox( box, v ) !== null;

      };

    } )(),

    intersectTriangle: function () {

      // Compute the offset origin, edges, and normal.
      var diff = new Vector3();
      var edge1 = new Vector3();
      var edge2 = new Vector3();
      var normal = new Vector3();

      return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

        edge1.subVectors( b, a );
        edge2.subVectors( c, a );
        normal.crossVectors( edge1, edge2 );

        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        var DdN = this.direction.dot( normal );
        var sign;

        if ( DdN > 0 ) {

          if ( backfaceCulling ) return null;
          sign = 1;

        } else if ( DdN < 0 ) {

          sign = - 1;
          DdN = - DdN;

        } else {

          return null;

        }

        diff.subVectors( this.origin, a );
        var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

        // b1 < 0, no intersection
        if ( DdQxE2 < 0 ) {

          return null;

        }

        var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

        // b2 < 0, no intersection
        if ( DdE1xQ < 0 ) {

          return null;

        }

        // b1+b2 > 1, no intersection
        if ( DdQxE2 + DdE1xQ > DdN ) {

          return null;

        }

        // Line intersects triangle, check if ray does.
        var QdN = - sign * diff.dot( normal );

        // t < 0, no intersection
        if ( QdN < 0 ) {

          return null;

        }

        // Ray intersects triangle.
        return this.at( QdN / DdN, optionalTarget );

      };

    }(),

    applyMatrix4: function ( matrix4 ) {

      this.origin.applyMatrix4( matrix4 );
      this.direction.transformDirection( matrix4 );

      return this;

    },

    equals: function ( ray ) {

      return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Line3( start, end ) {

    this.start = ( start !== undefined ) ? start : new Vector3();
    this.end = ( end !== undefined ) ? end : new Vector3();

  }

  Object.assign( Line3.prototype, {

    set: function ( start, end ) {

      this.start.copy( start );
      this.end.copy( end );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( line ) {

      this.start.copy( line.start );
      this.end.copy( line.end );

      return this;

    },

    getCenter: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return result.subVectors( this.end, this.start );

    },

    distanceSq: function () {

      return this.start.distanceToSquared( this.end );

    },

    distance: function () {

      return this.start.distanceTo( this.end );

    },

    at: function ( t, optionalTarget ) {

      var result = optionalTarget || new Vector3();

      return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function () {

      var startP = new Vector3();
      var startEnd = new Vector3();

      return function closestPointToPointParameter( point, clampToLine ) {

        startP.subVectors( point, this.start );
        startEnd.subVectors( this.end, this.start );

        var startEnd2 = startEnd.dot( startEnd );
        var startEnd_startP = startEnd.dot( startP );

        var t = startEnd_startP / startEnd2;

        if ( clampToLine ) {

          t = _Math.clamp( t, 0, 1 );

        }

        return t;

      };

    }(),

    closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

      var t = this.closestPointToPointParameter( point, clampToLine );

      var result = optionalTarget || new Vector3();

      return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function ( matrix ) {

      this.start.applyMatrix4( matrix );
      this.end.applyMatrix4( matrix );

      return this;

    },

    equals: function ( line ) {

      return line.start.equals( this.start ) && line.end.equals( this.end );

    }

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Triangle( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new Vector3();
    this.b = ( b !== undefined ) ? b : new Vector3();
    this.c = ( c !== undefined ) ? c : new Vector3();

  }

  Object.assign( Triangle, {

    normal: function () {

      var v0 = new Vector3();

      return function normal( a, b, c, optionalTarget ) {

        var result = optionalTarget || new Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

          return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

      };

    }(),

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    barycoordFromPoint: function () {

      var v0 = new Vector3();
      var v1 = new Vector3();
      var v2 = new Vector3();

      return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

          // arbitrary location outside of triangle?
          // not sure if this is the best idea, maybe should be returning undefined
          return result.set( - 2, - 1, - 1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

      };

    }(),

    containsPoint: function () {

      var v1 = new Vector3();

      return function containsPoint( point, a, b, c ) {

        var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

      };

    }()

  } );

  Object.assign( Triangle.prototype, {

    set: function ( a, b, c ) {

      this.a.copy( a );
      this.b.copy( b );
      this.c.copy( c );

      return this;

    },

    setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

      this.a.copy( points[ i0 ] );
      this.b.copy( points[ i1 ] );
      this.c.copy( points[ i2 ] );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( triangle ) {

      this.a.copy( triangle.a );
      this.b.copy( triangle.b );
      this.c.copy( triangle.c );

      return this;

    },

    area: function () {

      var v0 = new Vector3();
      var v1 = new Vector3();

      return function area() {

        v0.subVectors( this.c, this.b );
        v1.subVectors( this.a, this.b );

        return v0.cross( v1 ).length() * 0.5;

      };

    }(),

    midpoint: function ( optionalTarget ) {

      var result = optionalTarget || new Vector3();
      return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function ( optionalTarget ) {

      return Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function ( optionalTarget ) {

      var result = optionalTarget || new Plane();

      return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function ( point, optionalTarget ) {

      return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function ( point ) {

      return Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    closestPointToPoint: function () {

      var plane = new Plane();
      var edgeList = [ new Line3(), new Line3(), new Line3() ];
      var projectedPoint = new Vector3();
      var closestPoint = new Vector3();

      return function closestPointToPoint( point, optionalTarget ) {

        var result = optionalTarget || new Vector3();
        var minDistance = Infinity;

        // project the point onto the plane of the triangle

        plane.setFromCoplanarPoints( this.a, this.b, this.c );
        plane.projectPoint( point, projectedPoint );

        // check if the projection lies within the triangle

        if ( this.containsPoint( projectedPoint ) === true ) {

          // if so, this is the closest point

          result.copy( projectedPoint );

        } else {

          // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

          edgeList[ 0 ].set( this.a, this.b );
          edgeList[ 1 ].set( this.b, this.c );
          edgeList[ 2 ].set( this.c, this.a );

          for ( var i = 0; i < edgeList.length; i ++ ) {

            edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

            var distance = projectedPoint.distanceToSquared( closestPoint );

            if ( distance < minDistance ) {

              minDistance = distance;

              result.copy( closestPoint );

            }

          }

        }

        return result;

      };

    }(),

    equals: function ( triangle ) {

      return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */

  function Mesh( geometry, material ) {

    Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    this.drawMode = TrianglesDrawMode;

    this.updateMorphTargets();

  }

  Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Mesh,

    isMesh: true,

    setDrawMode: function ( value ) {

      this.drawMode = value;

    },

    copy: function ( source ) {

      Object3D.prototype.copy.call( this, source );

      this.drawMode = source.drawMode;

      if ( source.morphTargetInfluences !== undefined ) {

        this.morphTargetInfluences = source.morphTargetInfluences.slice();

      }

      if ( source.morphTargetDictionary !== undefined ) {

        this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

      }

      return this;

    },

    updateMorphTargets: function () {

      var geometry = this.geometry;
      var m, ml, name;

      if ( geometry.isBufferGeometry ) {

        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys( morphAttributes );

        if ( keys.length > 0 ) {

          var morphAttribute = morphAttributes[ keys[ 0 ] ];

          if ( morphAttribute !== undefined ) {

            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

              name = morphAttribute[ m ].name || String( m );

              this.morphTargetInfluences.push( 0 );
              this.morphTargetDictionary[ name ] = m;

            }

          }

        }

      } else {

        var morphTargets = geometry.morphTargets;

        if ( morphTargets !== undefined && morphTargets.length > 0 ) {

          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

            name = morphTargets[ m ].name || String( m );

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ name ] = m;

          }

        }

      }

    },

    raycast: ( function () {

      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();

      var vA = new Vector3();
      var vB = new Vector3();
      var vC = new Vector3();

      var tempA = new Vector3();
      var tempB = new Vector3();
      var tempC = new Vector3();

      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();

      var barycoord = new Vector3();

      var intersectionPoint = new Vector3();
      var intersectionPointWorld = new Vector3();

      function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

      }

      function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

        var intersect;

        if ( material.side === BackSide ) {

          intersect = ray.intersectTriangle( pC, pB, pA, true, point );

        } else {

          intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

        }

        if ( intersect === null ) return null;

        intersectionPointWorld.copy( point );
        intersectionPointWorld.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

        if ( distance < raycaster.near || distance > raycaster.far ) return null;

        return {
          distance: distance,
          point: intersectionPointWorld.clone(),
          object: object
        };

      }

      function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

        vA.fromBufferAttribute( position, a );
        vB.fromBufferAttribute( position, b );
        vC.fromBufferAttribute( position, c );

        var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );

        if ( intersection ) {

          if ( uv ) {

            uvA.fromBufferAttribute( uv, a );
            uvB.fromBufferAttribute( uv, b );
            uvC.fromBufferAttribute( uv, c );

            intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

          }

          intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
          intersection.faceIndex = a;

        }

        return intersection;

      }

      return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( matrixWorld );

        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

        //

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        // Check boundingBox before continuing

        if ( geometry.boundingBox !== null ) {

          if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

        }

        var intersection;

        if ( geometry.isBufferGeometry ) {

          var a, b, c;
          var index = geometry.index;
          var position = geometry.attributes.position;
          var uv = geometry.attributes.uv;
          var i, l;

          if ( index !== null ) {

            // indexed buffer geometry

            for ( i = 0, l = index.count; i < l; i += 3 ) {

              a = index.getX( i );
              b = index.getX( i + 1 );
              c = index.getX( i + 2 );

              intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

              if ( intersection ) {

                intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
                intersects.push( intersection );

              }

            }

          } else if ( position !== undefined ) {

            // non-indexed buffer geometry

            for ( i = 0, l = position.count; i < l; i += 3 ) {

              a = i;
              b = i + 1;
              c = i + 2;

              intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

              if ( intersection ) {

                intersection.index = a; // triangle number in positions buffer semantics
                intersects.push( intersection );

              }

            }

          }

        } else if ( geometry.isGeometry ) {

          var fvA, fvB, fvC;
          var isMultiMaterial = Array.isArray( material );

          var vertices = geometry.vertices;
          var faces = geometry.faces;
          var uvs;

          var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
          if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

          for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

            var face = faces[ f ];
            var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

            if ( faceMaterial === undefined ) continue;

            fvA = vertices[ face.a ];
            fvB = vertices[ face.b ];
            fvC = vertices[ face.c ];

            if ( faceMaterial.morphTargets === true ) {

              var morphTargets = geometry.morphTargets;
              var morphInfluences = this.morphTargetInfluences;

              vA.set( 0, 0, 0 );
              vB.set( 0, 0, 0 );
              vC.set( 0, 0, 0 );

              for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                var influence = morphInfluences[ t ];

                if ( influence === 0 ) continue;

                var targets = morphTargets[ t ].vertices;

                vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
                vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
                vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

              }

              vA.add( fvA );
              vB.add( fvB );
              vC.add( fvC );

              fvA = vA;
              fvB = vB;
              fvC = vC;

            }

            intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

            if ( intersection ) {

              if ( uvs && uvs[ f ] ) {

                var uvs_f = uvs[ f ];
                uvA.copy( uvs_f[ 0 ] );
                uvB.copy( uvs_f[ 1 ] );
                uvC.copy( uvs_f[ 2 ] );

                intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

              }

              intersection.face = face;
              intersection.faceIndex = f;
              intersects.push( intersection );

            }

          }

        }

      };

    }() ),

    clone: function () {

      return new this.constructor( this.geometry, this.material ).copy( this );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {

    var clearColor = new Color( 0x000000 );
    var clearAlpha = 0;

    var planeCamera, planeMesh;
    var boxMesh;

    function render( renderList, scene, camera, forceClear ) {

      var background = scene.background;

      if ( background === null ) {

        setClear( clearColor, clearAlpha );

      } else if ( background && background.isColor ) {

        setClear( background, 1 );
        forceClear = true;

      }

      if ( renderer.autoClear || forceClear ) {

        renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

      }

      if ( background && background.isCubeTexture ) {

        if ( boxMesh === undefined ) {

          boxMesh = new Mesh(
            new BoxBufferGeometry( 1, 1, 1 ),
            new ShaderMaterial( {
              uniforms: ShaderLib.cube.uniforms,
              vertexShader: ShaderLib.cube.vertexShader,
              fragmentShader: ShaderLib.cube.fragmentShader,
              side: BackSide,
              depthTest: true,
              depthWrite: false,
              polygonOffset: true,
              fog: false
            } )
          );

          boxMesh.geometry.removeAttribute( 'normal' );
          boxMesh.geometry.removeAttribute( 'uv' );

          boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

            var scale = camera.far;

            this.matrixWorld.makeScale( scale, scale, scale );
            this.matrixWorld.copyPosition( camera.matrixWorld );

            this.material.polygonOffsetUnits = scale * 10;

          };

          geometries.update( boxMesh.geometry );

        }

        boxMesh.material.uniforms.tCube.value = background;

        renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

      } else if ( background && background.isTexture ) {

        if ( planeCamera === undefined ) {

          planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

          planeMesh = new Mesh(
            new PlaneBufferGeometry( 2, 2 ),
            new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
          );

          geometries.update( planeMesh.geometry );

        }

        planeMesh.material.map = background;

        // TODO Push this to renderList

        renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

      }

    }

    function setClear( color, alpha ) {

      state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

    }

    return {

      getClearColor: function () {

        return clearColor;

      },
      setClearColor: function ( color, alpha ) {

        clearColor.set( color );
        clearAlpha = alpha !== undefined ? alpha : 1;
        setClear( clearColor, clearAlpha );

      },
      getClearAlpha: function () {

        return clearAlpha;

      },
      setClearAlpha: function ( alpha ) {

        clearAlpha = alpha;
        setClear( clearColor, clearAlpha );

      },
      render: render

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function painterSortStable( a, b ) {

    if ( a.renderOrder !== b.renderOrder ) {

      return a.renderOrder - b.renderOrder;

    } else if ( a.program && b.program && a.program !== b.program ) {

      return a.program.id - b.program.id;

    } else if ( a.material.id !== b.material.id ) {

      return a.material.id - b.material.id;

    } else if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable( a, b ) {

    if ( a.renderOrder !== b.renderOrder ) {

      return a.renderOrder - b.renderOrder;

    } if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  function WebGLRenderList() {

    var renderItems = [];
    var renderItemsIndex = 0;

    var opaque = [];
    var transparent = [];

    function init() {

      renderItemsIndex = 0;

      opaque.length = 0;
      transparent.length = 0;

    }

    function push( object, geometry, material, z, group ) {

      var renderItem = renderItems[ renderItemsIndex ];

      if ( renderItem === undefined ) {

        renderItem = {
          id: object.id,
          object: object,
          geometry: geometry,
          material: material,
          program: material.program,
          renderOrder: object.renderOrder,
          z: z,
          group: group
        };

        renderItems[ renderItemsIndex ] = renderItem;

      } else {

        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.program = material.program;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;

      }

      ( material.transparent === true ? transparent : opaque ).push( renderItem );

      renderItemsIndex ++;

    }

    function sort() {

      if ( opaque.length > 1 ) opaque.sort( painterSortStable );
      if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

    }

    return {
      opaque: opaque,
      transparent: transparent,

      init: init,
      push: push,

      sort: sort
    };

  }

  function WebGLRenderLists() {

    var lists = {};

    function get( scene, camera ) {

      var hash = scene.id + ',' + camera.id;
      var list = lists[ hash ];

      if ( list === undefined ) {

        // console.log( 'THREE.WebGLRenderLists:', hash );

        list = new WebGLRenderList();
        lists[ hash ] = list;

      }

      return list;

    }

    function dispose() {

      lists = {};

    }

    return {
      get: get,
      dispose: dispose
    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function absNumericalSort( a, b ) {

    return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

  }

  function WebGLMorphtargets( gl ) {

    var influencesList = {};
    var morphInfluences = new Float32Array( 8 );

    function update( object, geometry, material, program ) {

      var objectInfluences = object.morphTargetInfluences;

      var length = objectInfluences.length;

      var influences = influencesList[ geometry.id ];

      if ( influences === undefined ) {

        // initialise list

        influences = [];

        for ( var i = 0; i < length; i ++ ) {

          influences[ i ] = [ i, 0 ];

        }

        influencesList[ geometry.id ] = influences;

      }

      var morphTargets = material.morphTargets && geometry.morphAttributes.position;
      var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

      // Remove current morphAttributes

      for ( var i = 0; i < length; i ++ ) {

        var influence = influences[ i ];

        if ( influence[ 1 ] !== 0 ) {

          if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
          if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

        }

      }

      // Collect influences

      for ( var i = 0; i < length; i ++ ) {

        var influence = influences[ i ];

        influence[ 0 ] = i;
        influence[ 1 ] = objectInfluences[ i ];

      }

      influences.sort( absNumericalSort );

      // Add morphAttributes

      for ( var i = 0; i < 8; i ++ ) {

        var influence = influences[ i ];

        if ( influence ) {

          var index = influence[ 0 ];
          var value = influence[ 1 ];

          if ( value ) {

            if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
            if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

            morphInfluences[ i ] = value;
            continue;

          }

        }

        morphInfluences[ i ] = 0;

      }

      program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

    }

    return {

      update: update

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

    var mode;

    function setMode( value ) {

      mode = value;

    }

    var type, bytesPerElement;

    function setIndex( value ) {

      type = value.type;
      bytesPerElement = value.bytesPerElement;

    }

    function render( start, count ) {

      gl.drawElements( mode, count, type, start * bytesPerElement );

      infoRender.calls ++;
      infoRender.vertices += count;

      if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
      else if ( mode === gl.POINTS ) infoRender.points += count;

    }

    function renderInstances( geometry, start, count ) {

      var extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

      extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

      infoRender.calls ++;
      infoRender.vertices += count * geometry.maxInstancedCount;

      if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
      else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

    }

    //

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBufferRenderer( gl, extensions, infoRender ) {

    var mode;

    function setMode( value ) {

      mode = value;

    }

    function render( start, count ) {

      gl.drawArrays( mode, start, count );

      infoRender.calls ++;
      infoRender.vertices += count;

      if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
      else if ( mode === gl.POINTS ) infoRender.points += count;

    }

    function renderInstances( geometry, start, count ) {

      var extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

      var position = geometry.attributes.position;

      if ( position.isInterleavedBufferAttribute ) {

        count = position.data.count;

        extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

      } else {

        extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

      }

      infoRender.calls ++;
      infoRender.vertices += count * geometry.maxInstancedCount;

      if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
      else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

    }

    //

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLGeometries( gl, attributes, infoMemory ) {

    var geometries = {};
    var wireframeAttributes = {};

    function onGeometryDispose( event ) {

      var geometry = event.target;
      var buffergeometry = geometries[ geometry.id ];

      if ( buffergeometry.index !== null ) {

        attributes.remove( buffergeometry.index );

      }

      for ( var name in buffergeometry.attributes ) {

        attributes.remove( buffergeometry.attributes[ name ] );

      }

      geometry.removeEventListener( 'dispose', onGeometryDispose );

      delete geometries[ geometry.id ];

      // TODO Remove duplicate code

      var attribute = wireframeAttributes[ geometry.id ];

      if ( attribute ) {

        attributes.remove( attribute );
        delete wireframeAttributes[ geometry.id ];

      }

      attribute = wireframeAttributes[ buffergeometry.id ];

      if ( attribute ) {

        attributes.remove( attribute );
        delete wireframeAttributes[ buffergeometry.id ];

      }

      //

      infoMemory.geometries --;

    }

    function get( object, geometry ) {

      var buffergeometry = geometries[ geometry.id ];

      if ( buffergeometry ) return buffergeometry;

      geometry.addEventListener( 'dispose', onGeometryDispose );

      if ( geometry.isBufferGeometry ) {

        buffergeometry = geometry;

      } else if ( geometry.isGeometry ) {

        if ( geometry._bufferGeometry === undefined ) {

          geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

        }

        buffergeometry = geometry._bufferGeometry;

      }

      geometries[ geometry.id ] = buffergeometry;

      infoMemory.geometries ++;

      return buffergeometry;

    }

    function update( geometry ) {

      var index = geometry.index;
      var geometryAttributes = geometry.attributes;

      if ( index !== null ) {

        attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

      }

      for ( var name in geometryAttributes ) {

        attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

      }

      // morph targets

      var morphAttributes = geometry.morphAttributes;

      for ( var name in morphAttributes ) {

        var array = morphAttributes[ name ];

        for ( var i = 0, l = array.length; i < l; i ++ ) {

          attributes.update( array[ i ], gl.ARRAY_BUFFER );

        }

      }

    }

    function getWireframeAttribute( geometry ) {

      var attribute = wireframeAttributes[ geometry.id ];

      if ( attribute ) return attribute;

      var indices = [];

      var geometryIndex = geometry.index;
      var geometryAttributes = geometry.attributes;

      // console.time( 'wireframe' );

      if ( geometryIndex !== null ) {

        var array = geometryIndex.array;

        for ( var i = 0, l = array.length; i < l; i += 3 ) {

          var a = array[ i + 0 ];
          var b = array[ i + 1 ];
          var c = array[ i + 2 ];

          indices.push( a, b, b, c, c, a );

        }

      } else {

        var array = geometryAttributes.position.array;

        for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

          var a = i + 0;
          var b = i + 1;
          var c = i + 2;

          indices.push( a, b, b, c, c, a );

        }

      }

      // console.timeEnd( 'wireframe' );

      attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

      attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

      wireframeAttributes[ geometry.id ] = attribute;

      return attribute;

    }

    return {

      get: get,
      update: update,

      getWireframeAttribute: getWireframeAttribute

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function UniformsCache() {

    var lights = {};

    return {

      get: function ( light ) {

        if ( lights[ light.id ] !== undefined ) {

          return lights[ light.id ];

        }

        var uniforms;

        switch ( light.type ) {

          case 'DirectionalLight':
            uniforms = {
              direction: new Vector3(),
              color: new Color(),

              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;

          case 'SpotLight':
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,

              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;

          case 'PointLight':
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0,

              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1000
            };
            break;

          case 'HemisphereLight':
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;

          case 'RectAreaLight':
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
              // TODO (abelnation): set RectAreaLight shadow uniforms
            };
            break;

        }

        lights[ light.id ] = uniforms;

        return uniforms;

      }

    };

  }

  function WebGLLights() {

    var cache = new UniformsCache();

    var state = {

      hash: '',

      ambient: [ 0, 0, 0 ],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []

    };

    var vector3 = new Vector3();
    var matrix4 = new Matrix4();
    var matrix42 = new Matrix4();

    function setup( lights, shadows, camera ) {

      var r = 0, g = 0, b = 0;

      var directionalLength = 0;
      var pointLength = 0;
      var spotLength = 0;
      var rectAreaLength = 0;
      var hemiLength = 0;

      var viewMatrix = camera.matrixWorldInverse;

      for ( var i = 0, l = lights.length; i < l; i ++ ) {

        var light = lights[ i ];

        var color = light.color;
        var intensity = light.intensity;
        var distance = light.distance;

        var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

        if ( light.isAmbientLight ) {

          r += color.r * intensity;
          g += color.g * intensity;
          b += color.b * intensity;

        } else if ( light.isDirectionalLight ) {

          var uniforms = cache.get( light );

          uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
          uniforms.direction.setFromMatrixPosition( light.matrixWorld );
          vector3.setFromMatrixPosition( light.target.matrixWorld );
          uniforms.direction.sub( vector3 );
          uniforms.direction.transformDirection( viewMatrix );

          uniforms.shadow = light.castShadow;

          if ( light.castShadow ) {

            var shadow = light.shadow;

            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;

          }

          state.directionalShadowMap[ directionalLength ] = shadowMap;
          state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
          state.directional[ directionalLength ] = uniforms;

          directionalLength ++;

        } else if ( light.isSpotLight ) {

          var uniforms = cache.get( light );

          uniforms.position.setFromMatrixPosition( light.matrixWorld );
          uniforms.position.applyMatrix4( viewMatrix );

          uniforms.color.copy( color ).multiplyScalar( intensity );
          uniforms.distance = distance;

          uniforms.direction.setFromMatrixPosition( light.matrixWorld );
          vector3.setFromMatrixPosition( light.target.matrixWorld );
          uniforms.direction.sub( vector3 );
          uniforms.direction.transformDirection( viewMatrix );

          uniforms.coneCos = Math.cos( light.angle );
          uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
          uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

          uniforms.shadow = light.castShadow;

          if ( light.castShadow ) {

            var shadow = light.shadow;

            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;

          }

          state.spotShadowMap[ spotLength ] = shadowMap;
          state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
          state.spot[ spotLength ] = uniforms;

          spotLength ++;

        } else if ( light.isRectAreaLight ) {

          var uniforms = cache.get( light );

          // (a) intensity controls irradiance of entire light
          uniforms.color
            .copy( color )
            .multiplyScalar( intensity / ( light.width * light.height ) );

          // (b) intensity controls the radiance per light area
          // uniforms.color.copy( color ).multiplyScalar( intensity );

          uniforms.position.setFromMatrixPosition( light.matrixWorld );
          uniforms.position.applyMatrix4( viewMatrix );

          // extract local rotation of light to derive width/height half vectors
          matrix42.identity();
          matrix4.copy( light.matrixWorld );
          matrix4.premultiply( viewMatrix );
          matrix42.extractRotation( matrix4 );

          uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
          uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

          uniforms.halfWidth.applyMatrix4( matrix42 );
          uniforms.halfHeight.applyMatrix4( matrix42 );

          // TODO (abelnation): RectAreaLight distance?
          // uniforms.distance = distance;

          state.rectArea[ rectAreaLength ] = uniforms;

          rectAreaLength ++;

        } else if ( light.isPointLight ) {

          var uniforms = cache.get( light );

          uniforms.position.setFromMatrixPosition( light.matrixWorld );
          uniforms.position.applyMatrix4( viewMatrix );

          uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
          uniforms.distance = light.distance;
          uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

          uniforms.shadow = light.castShadow;

          if ( light.castShadow ) {

            var shadow = light.shadow;

            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
            uniforms.shadowCameraNear = shadow.camera.near;
            uniforms.shadowCameraFar = shadow.camera.far;

          }

          state.pointShadowMap[ pointLength ] = shadowMap;
          state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
          state.point[ pointLength ] = uniforms;

          pointLength ++;

        } else if ( light.isHemisphereLight ) {

          var uniforms = cache.get( light );

          uniforms.direction.setFromMatrixPosition( light.matrixWorld );
          uniforms.direction.transformDirection( viewMatrix );
          uniforms.direction.normalize();

          uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
          uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

          state.hemi[ hemiLength ] = uniforms;

          hemiLength ++;

        }

      }

      state.ambient[ 0 ] = r;
      state.ambient[ 1 ] = g;
      state.ambient[ 2 ] = b;

      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;

      // TODO (sam-g-steel) why aren't we using join
      state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

    }

    return {
      setup: setup,
      state: state
    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLObjects( geometries, infoRender ) {

    var updateList = {};

    function update( object ) {

      var frame = infoRender.frame;

      var geometry = object.geometry;
      var buffergeometry = geometries.get( object, geometry );

      // Update once per frame

      if ( updateList[ buffergeometry.id ] !== frame ) {

        if ( geometry.isGeometry ) {

          buffergeometry.updateFromObject( object );

        }

        geometries.update( buffergeometry );

        updateList[ buffergeometry.id ] = frame;

      }

      return buffergeometry;

    }

    function clear() {

      updateList = {};

    }

    return {

      update: update,
      clear: clear

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function addLineNumbers( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  }

  function WebGLShader( gl, type, string ) {

    var shader = gl.createShader( type );

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var programIdCount = 0;

  function getEncodingComponents( encoding ) {

    switch ( encoding ) {

      case LinearEncoding:
        return [ 'Linear', '( value )' ];
      case sRGBEncoding:
        return [ 'sRGB', '( value )' ];
      case RGBEEncoding:
        return [ 'RGBE', '( value )' ];
      case RGBM7Encoding:
        return [ 'RGBM', '( value, 7.0 )' ];
      case RGBM16Encoding:
        return [ 'RGBM', '( value, 16.0 )' ];
      case RGBDEncoding:
        return [ 'RGBD', '( value, 256.0 )' ];
      case GammaEncoding:
        return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
      default:
        throw new Error( 'unsupported encoding: ' + encoding );

    }

  }

  function getTexelDecodingFunction( functionName, encoding ) {

    var components = getEncodingComponents( encoding );
    return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

  }

  function getTexelEncodingFunction( functionName, encoding ) {

    var components = getEncodingComponents( encoding );
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

  }

  function getToneMappingFunction( functionName, toneMapping ) {

    var toneMappingName;

    switch ( toneMapping ) {

      case LinearToneMapping:
        toneMappingName = "Linear";
        break;

      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;

      case Uncharted2ToneMapping:
        toneMappingName = "Uncharted2";
        break;

      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;

      default:
        throw new Error( 'unsupported toneMapping: ' + toneMapping );

    }

    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

  }

  function generateExtensions( extensions, parameters, rendererExtensions ) {

    extensions = extensions || {};

    var chunks = [
      ( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
      ( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
      ( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
      ( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];

    return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

    var chunks = [];

    for ( var name in defines ) {

      var value = defines[ name ];

      if ( value === false ) continue;

      chunks.push( '#define ' + name + ' ' + value );

    }

    return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

    var attributes = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveAttrib( program, i );
      var name = info.name;

      // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

      attributes[ name ] = gl.getAttribLocation( program, name );

    }

    return attributes;

  }

  function filterEmptyLine( string ) {

    return string !== '';

  }

  function replaceLightNums( string, parameters ) {

    return string
      .replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
      .replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
      .replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
      .replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
      .replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

  }

  function parseIncludes( string ) {

    var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

    function replace( match, include ) {

      var replace = ShaderChunk[ include ];

      if ( replace === undefined ) {

        throw new Error( 'Can not resolve #include <' + include + '>' );

      }

      return parseIncludes( replace );

    }

    return string.replace( pattern, replace );

  }

  function unrollLoops( string ) {

    var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    function replace( match, start, end, snippet ) {

      var unroll = '';

      for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

        unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

      }

      return unroll;

    }

    return string.replace( pattern, replace );

  }

  function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {

    var gl = renderer.context;

    var defines = material.defines;

    var vertexShader = shader.vertexShader;
    var fragmentShader = shader.fragmentShader;

    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if ( parameters.shadowMapType === PCFShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    } else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    }

    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    if ( parameters.envMap ) {

      switch ( material.envMap.mapping ) {

        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
          break;

        case EquirectangularReflectionMapping:
        case EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;

      }

      switch ( material.envMap.mapping ) {

        case CubeRefractionMapping:
        case EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;

      }

      switch ( material.combine ) {

        case MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;

      }

    }

    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    // console.log( 'building new program ' );

    //

    var customExtensions = generateExtensions( material.extensions, parameters, extensions );

    var customDefines = generateDefines( defines );

    //

    var program = gl.createProgram();

    var prefixVertex, prefixFragment;

    if ( material.isRawShaderMaterial ) {

      prefixVertex = [

        customDefines

      ].filter( filterEmptyLine ).join( '\n' );

      if ( prefixVertex.length > 0 ) {

        prefixVertex += '\n';

      }

      prefixFragment = [

        customExtensions,
        customDefines

      ].filter( filterEmptyLine ).join( '\n' );

      if ( prefixFragment.length > 0 ) {

        prefixFragment += '\n';

      }

    } else {

      prefixVertex = [

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + shader.name,

        customDefines,

        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        '#define MAX_BONES ' + parameters.maxBones,
        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',

        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        '#ifdef USE_COLOR',

        ' attribute vec3 color;',

        '#endif',

        '#ifdef USE_MORPHTARGETS',

        ' attribute vec3 morphTarget0;',
        ' attribute vec3 morphTarget1;',
        ' attribute vec3 morphTarget2;',
        ' attribute vec3 morphTarget3;',

        ' #ifdef USE_MORPHNORMALS',

        '   attribute vec3 morphNormal0;',
        '   attribute vec3 morphNormal1;',
        '   attribute vec3 morphNormal2;',
        '   attribute vec3 morphNormal3;',

        ' #else',

        '   attribute vec3 morphTarget4;',
        '   attribute vec3 morphTarget5;',
        '   attribute vec3 morphTarget6;',
        '   attribute vec3 morphTarget7;',

        ' #endif',

        '#endif',

        '#ifdef USE_SKINNING',

        ' attribute vec4 skinIndex;',
        ' attribute vec4 skinWeight;',

        '#endif',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

      prefixFragment = [

        customExtensions,

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + shader.name,

        customDefines,

        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
        '#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

        parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',

        ( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
        ( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
        ( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

        parameters.dithering ? '#define DITHERING' : '',

        ( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
        parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
        parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
        parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
        parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

        parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

    }

    vertexShader = parseIncludes( vertexShader );
    vertexShader = replaceLightNums( vertexShader, parameters );

    fragmentShader = parseIncludes( fragmentShader );
    fragmentShader = replaceLightNums( fragmentShader, parameters );

    if ( ! material.isShaderMaterial ) {

      vertexShader = unrollLoops( vertexShader );
      fragmentShader = unrollLoops( fragmentShader );

    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;

    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );

    var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    gl.attachShader( program, glVertexShader );
    gl.attachShader( program, glFragmentShader );

    // Force a particular attribute to index 0.

    if ( material.index0AttributeName !== undefined ) {

      gl.bindAttribLocation( program, 0, material.index0AttributeName );

    } else if ( parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0
      gl.bindAttribLocation( program, 0, 'position' );

    }

    gl.linkProgram( program );

    var programLog = gl.getProgramInfoLog( program );
    var vertexLog = gl.getShaderInfoLog( glVertexShader );
    var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    var runnable = true;
    var haveDiagnostics = true;

    // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

      runnable = false;

      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    } else if ( programLog !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    } else if ( vertexLog === '' || fragmentLog === '' ) {

      haveDiagnostics = false;

    }

    if ( haveDiagnostics ) {

      this.diagnostics = {

        runnable: runnable,
        material: material,

        programLog: programLog,

        vertexShader: {

          log: vertexLog,
          prefix: prefixVertex

        },

        fragmentShader: {

          log: fragmentLog,
          prefix: prefixFragment

        }

      };

    }

    // clean up

    gl.deleteShader( glVertexShader );
    gl.deleteShader( glFragmentShader );

    // set up caching for uniform locations

    var cachedUniforms;

    this.getUniforms = function () {

      if ( cachedUniforms === undefined ) {

        cachedUniforms = new WebGLUniforms( gl, program, renderer );

      }

      return cachedUniforms;

    };

    // set up caching for attribute locations

    var cachedAttributes;

    this.getAttributes = function () {

      if ( cachedAttributes === undefined ) {

        cachedAttributes = fetchAttributeLocations( gl, program );

      }

      return cachedAttributes;

    };

    // free resource

    this.destroy = function () {

      gl.deleteProgram( program );
      this.program = undefined;

    };

    // DEPRECATED

    Object.defineProperties( this, {

      uniforms: {
        get: function () {

          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
          return this.getUniforms();

        }
      },

      attributes: {
        get: function () {

          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
          return this.getAttributes();

        }
      }

    } );


    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLPrograms( renderer, extensions, capabilities ) {

    var programs = [];

    var shaderIDs = {
      MeshDepthMaterial: 'depth',
      MeshDistanceMaterial: 'distanceRGBA',
      MeshNormalMaterial: 'normal',
      MeshBasicMaterial: 'basic',
      MeshLambertMaterial: 'lambert',
      MeshPhongMaterial: 'phong',
      MeshToonMaterial: 'phong',
      MeshStandardMaterial: 'physical',
      MeshPhysicalMaterial: 'physical',
      LineBasicMaterial: 'basic',
      LineDashedMaterial: 'dashed',
      PointsMaterial: 'points',
      ShadowMaterial: 'shadow'
    };

    var parameterNames = [
      "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
      "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
      "roughnessMap", "metalnessMap", "gradientMap",
      "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
      "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
      "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
      "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
      "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
      "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
      "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
    ];


    function allocateBones( object ) {

      var skeleton = object.skeleton;
      var bones = skeleton.bones;

      if ( capabilities.floatVertexTextures ) {

        return 1024;

      } else {

        // default for when object is not specified
        // ( for example when prebuilding shader to be used with multiple objects )
        //
        //  - leave some extra space for other uniforms
        //  - limit here is ANGLE's 254 max uniform vectors
        //    (up to 54 should be safe)

        var nVertexUniforms = capabilities.maxVertexUniforms;
        var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

        var maxBones = Math.min( nVertexMatrices, bones.length );

        if ( maxBones < bones.length ) {

          console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
          return 0;

        }

        return maxBones;

      }

    }

    function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

      var encoding;

      if ( ! map ) {

        encoding = LinearEncoding;

      } else if ( map.isTexture ) {

        encoding = map.encoding;

      } else if ( map.isWebGLRenderTarget ) {

        console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
        encoding = map.texture.encoding;

      }

      // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
      if ( encoding === LinearEncoding && gammaOverrideLinear ) {

        encoding = GammaEncoding;

      }

      return encoding;

    }

    this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

      var shaderID = shaderIDs[ material.type ];

      // heuristics to create shader parameters according to lights in the scene
      // (not to blow over maxLights budget)

      var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
      var precision = capabilities.precision;

      if ( material.precision !== null ) {

        precision = capabilities.getMaxPrecision( material.precision );

        if ( precision !== material.precision ) {

          console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

        }

      }

      var currentRenderTarget = renderer.getRenderTarget();

      var parameters = {

        shaderID: shaderID,

        precision: precision,
        supportsVertexTextures: capabilities.vertexTextures,
        outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
        map: !! material.map,
        mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
        envMap: !! material.envMap,
        envMapMode: material.envMap && material.envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
        envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
        lightMap: !! material.lightMap,
        aoMap: !! material.aoMap,
        emissiveMap: !! material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
        bumpMap: !! material.bumpMap,
        normalMap: !! material.normalMap,
        displacementMap: !! material.displacementMap,
        roughnessMap: !! material.roughnessMap,
        metalnessMap: !! material.metalnessMap,
        specularMap: !! material.specularMap,
        alphaMap: !! material.alphaMap,

        gradientMap: !! material.gradientMap,

        combine: material.combine,

        vertexColors: material.vertexColors,

        fog: !! fog,
        useFog: material.fog,
        fogExp: ( fog && fog.isFogExp2 ),

        flatShading: material.flatShading,

        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

        skinning: material.skinning && maxBones > 0,
        maxBones: maxBones,
        useVertexTexture: capabilities.floatVertexTextures,

        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer.maxMorphTargets,
        maxMorphNormals: renderer.maxMorphNormals,

        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,

        numClippingPlanes: nClipPlanes,
        numClipIntersection: nClipIntersection,

        dithering: material.dithering,

        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,

        toneMapping: renderer.toneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,

        premultipliedAlpha: material.premultipliedAlpha,

        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,

        depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

      };

      return parameters;

    };

    this.getProgramCode = function ( material, parameters ) {

      var array = [];

      if ( parameters.shaderID ) {

        array.push( parameters.shaderID );

      } else {

        array.push( material.fragmentShader );
        array.push( material.vertexShader );

      }

      if ( material.defines !== undefined ) {

        for ( var name in material.defines ) {

          array.push( name );
          array.push( material.defines[ name ] );

        }

      }

      for ( var i = 0; i < parameterNames.length; i ++ ) {

        array.push( parameters[ parameterNames[ i ] ] );

      }

      array.push( material.onBeforeCompile.toString() );

      array.push( renderer.gammaOutput );

      return array.join();

    };

    this.acquireProgram = function ( material, shader, parameters, code ) {

      var program;

      // Check if code has been already compiled
      for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

        var programInfo = programs[ p ];

        if ( programInfo.code === code ) {

          program = programInfo;
          ++ program.usedTimes;

          break;

        }

      }

      if ( program === undefined ) {

        program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
        programs.push( program );

      }

      return program;

    };

    this.releaseProgram = function ( program ) {

      if ( -- program.usedTimes === 0 ) {

        // Remove from unordered set
        var i = programs.indexOf( program );
        programs[ i ] = programs[ programs.length - 1 ];
        programs.pop();

        // Free WebGL resources
        program.destroy();

      }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {

    var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );

    //

    function clampToMaxSize( image, maxSize ) {

      if ( image.width > maxSize || image.height > maxSize ) {

        // Warning: Scaling through the canvas will only work with images that use
        // premultiplied alpha.

        var scale = maxSize / Math.max( image.width, image.height );

        var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
        canvas.width = Math.floor( image.width * scale );
        canvas.height = Math.floor( image.height * scale );

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

        console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

        return canvas;

      }

      return image;

    }

    function isPowerOfTwo( image ) {

      return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

    }

    function makePowerOfTwo( image ) {

      if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

        var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
        canvas.width = _Math.floorPowerOfTwo( image.width );
        canvas.height = _Math.floorPowerOfTwo( image.height );

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0, canvas.width, canvas.height );

        console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

        return canvas;

      }

      return image;

    }

    function textureNeedsPowerOfTwo( texture ) {

      return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
        ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

    }

    function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

      return texture.generateMipmaps && isPowerOfTwo &&
        texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback( f ) {

      if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

        return _gl.NEAREST;

      }

      return _gl.LINEAR;

    }

    //

    function onTextureDispose( event ) {

      var texture = event.target;

      texture.removeEventListener( 'dispose', onTextureDispose );

      deallocateTexture( texture );

      infoMemory.textures --;


    }

    function onRenderTargetDispose( event ) {

      var renderTarget = event.target;

      renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

      deallocateRenderTarget( renderTarget );

      infoMemory.textures --;

    }

    //

    function deallocateTexture( texture ) {

      var textureProperties = properties.get( texture );

      if ( texture.image && textureProperties.__image__webglTextureCube ) {

        // cube texture

        _gl.deleteTexture( textureProperties.__image__webglTextureCube );

      } else {

        // 2D texture

        if ( textureProperties.__webglInit === undefined ) return;

        _gl.deleteTexture( textureProperties.__webglTexture );

      }

      // remove all webgl properties
      properties.remove( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

      var renderTargetProperties = properties.get( renderTarget );
      var textureProperties = properties.get( renderTarget.texture );

      if ( ! renderTarget ) return;

      if ( textureProperties.__webglTexture !== undefined ) {

        _gl.deleteTexture( textureProperties.__webglTexture );

      }

      if ( renderTarget.depthTexture ) {

        renderTarget.depthTexture.dispose();

      }

      if ( renderTarget.isWebGLRenderTargetCube ) {

        for ( var i = 0; i < 6; i ++ ) {

          _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
          if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

        }

      } else {

        _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
        if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

      }

      properties.remove( renderTarget.texture );
      properties.remove( renderTarget );

    }

    //



    function setTexture2D( texture, slot ) {

      var textureProperties = properties.get( texture );

      if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

        var image = texture.image;

        if ( image === undefined ) {

          console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

        } else if ( image.complete === false ) {

          console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

        } else {

          uploadTexture( textureProperties, texture, slot );
          return;

        }

      }

      state.activeTexture( _gl.TEXTURE0 + slot );
      state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    }

    function setTextureCube( texture, slot ) {

      var textureProperties = properties.get( texture );

      if ( texture.image.length === 6 ) {

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

          if ( ! textureProperties.__image__webglTextureCube ) {

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__image__webglTextureCube = _gl.createTexture();

            infoMemory.textures ++;

          }

          state.activeTexture( _gl.TEXTURE0 + slot );
          state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

          _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

          var isCompressed = ( texture && texture.isCompressedTexture );
          var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

          var cubeImage = [];

          for ( var i = 0; i < 6; i ++ ) {

            if ( ! isCompressed && ! isDataTexture ) {

              cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

            } else {

              cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

            }

          }

          var image = cubeImage[ 0 ],
            isPowerOfTwoImage = isPowerOfTwo( image ),
            glFormat = utils.convert( texture.format ),
            glType = utils.convert( texture.type );

          setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

          for ( var i = 0; i < 6; i ++ ) {

            if ( ! isCompressed ) {

              if ( isDataTexture ) {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

              } else {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

              }

            } else {

              var mipmap, mipmaps = cubeImage[ i ].mipmaps;

              for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

                mipmap = mipmaps[ j ];

                if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

                  if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                  } else {

                    console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

                  }

                } else {

                  state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

              }

            }

          }

          if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

            _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

          }

          textureProperties.__version = texture.version;

          if ( texture.onUpdate ) texture.onUpdate( texture );

        } else {

          state.activeTexture( _gl.TEXTURE0 + slot );
          state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

        }

      }

    }

    function setTextureCubeDynamic( texture, slot ) {

      state.activeTexture( _gl.TEXTURE0 + slot );
      state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

      var extension;

      if ( isPowerOfTwoImage ) {

        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

        _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
        _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

      } else {

        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

        if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

          console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

        }

        _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
        _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

        if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

          console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

        }

      }

      extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension ) {

        if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
        if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

        if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

          _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
          properties.get( texture ).__currentAnisotropy = texture.anisotropy;

        }

      }

    }

    function uploadTexture( textureProperties, texture, slot ) {

      if ( textureProperties.__webglInit === undefined ) {

        textureProperties.__webglInit = true;

        texture.addEventListener( 'dispose', onTextureDispose );

        textureProperties.__webglTexture = _gl.createTexture();

        infoMemory.textures ++;

      }

      state.activeTexture( _gl.TEXTURE0 + slot );
      state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

      _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
      _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
      _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

      var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

      if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

        image = makePowerOfTwo( image );

      }

      var isPowerOfTwoImage = isPowerOfTwo( image ),
        glFormat = utils.convert( texture.format ),
        glType = utils.convert( texture.type );

      setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

      var mipmap, mipmaps = texture.mipmaps;

      if ( texture.isDepthTexture ) {

        // populate depth texture with dummy data

        var internalFormat = _gl.DEPTH_COMPONENT;

        if ( texture.type === FloatType ) {

          if ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
          internalFormat = _gl.DEPTH_COMPONENT32F;

        } else if ( _isWebGL2 ) {

          // WebGL 2.0 requires signed internalformat for glTexImage2D
          internalFormat = _gl.DEPTH_COMPONENT16;

        }

        if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
          // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
          if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

            console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

            texture.type = UnsignedShortType;
            glType = utils.convert( texture.type );

          }

        }

        // Depth stencil textures need the DEPTH_STENCIL internal format
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if ( texture.format === DepthStencilFormat ) {

          internalFormat = _gl.DEPTH_STENCIL;

          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
          // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
          if ( texture.type !== UnsignedInt248Type ) {

            console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

            texture.type = UnsignedInt248Type;
            glType = utils.convert( texture.type );

          }

        }

        state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

      } else if ( texture.isDataTexture ) {

        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels

        if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

          for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

            mipmap = mipmaps[ i ];
            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

          }

          texture.generateMipmaps = false;

        } else {

          state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

        }

      } else if ( texture.isCompressedTexture ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];

          if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

            if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

              state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

            } else {

              console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

            }

          } else {

            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

          }

        }

      } else {

        // regular Texture (image, video, canvas)

        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels

        if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

          for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

            mipmap = mipmaps[ i ];
            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

          }

          texture.generateMipmaps = false;

        } else {

          state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

        }

      }

      if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );

      textureProperties.__version = texture.version;

      if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    // Render targets

    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

      var glFormat = utils.convert( renderTarget.texture.format );
      var glType = utils.convert( renderTarget.texture.type );
      state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
      _gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage( renderbuffer, renderTarget ) {

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

      if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

      } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

      } else {

        // FIXME: We don't support !depth !stencil
        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

      }

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

    }

    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture( framebuffer, renderTarget ) {

      var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
      if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

      if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

        throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

      }

      // upload an empty depth texture with framebuffer size
      if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
          renderTarget.depthTexture.image.width !== renderTarget.width ||
          renderTarget.depthTexture.image.height !== renderTarget.height ) {

        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;

      }

      setTexture2D( renderTarget.depthTexture, 0 );

      var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

      if ( renderTarget.depthTexture.format === DepthFormat ) {

        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

      } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

      } else {

        throw new Error( 'Unknown depthTexture format' );

      }

    }

    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer( renderTarget ) {

      var renderTargetProperties = properties.get( renderTarget );

      var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

      if ( renderTarget.depthTexture ) {

        if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

        setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

      } else {

        if ( isCube ) {

          renderTargetProperties.__webglDepthbuffer = [];

          for ( var i = 0; i < 6; i ++ ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
            renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
            setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

          }

        } else {

          _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

        }

      }

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    // Set up GL resources for the render target
    function setupRenderTarget( renderTarget ) {

      var renderTargetProperties = properties.get( renderTarget );
      var textureProperties = properties.get( renderTarget.texture );

      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

      textureProperties.__webglTexture = _gl.createTexture();

      infoMemory.textures ++;

      var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
      var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

      // Setup framebuffer

      if ( isCube ) {

        renderTargetProperties.__webglFramebuffer = [];

        for ( var i = 0; i < 6; i ++ ) {

          renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

        }

      } else {

        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      }

      // Setup color buffer

      if ( isCube ) {

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

        }

        if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

      } else {

        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
        setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
        setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

        if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
        state.bindTexture( _gl.TEXTURE_2D, null );

      }

      // Setup depth and stencil buffers

      if ( renderTarget.depthBuffer ) {

        setupDepthRenderbuffer( renderTarget );

      }

    }

    function updateRenderTargetMipmap( renderTarget ) {

      var texture = renderTarget.texture;
      var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

      if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

        var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var webglTexture = properties.get( texture ).__webglTexture;

        state.bindTexture( target, webglTexture );
        _gl.generateMipmap( target );
        state.bindTexture( target, null );

      }

    }

    this.setTexture2D = setTexture2D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;

  }

  /**
   * @author fordacious / fordacious.github.io
   */

  function WebGLProperties() {

    var properties = {};

    function get( object ) {

      var uuid = object.uuid;
      var map = properties[ uuid ];

      if ( map === undefined ) {

        map = {};
        properties[ uuid ] = map;

      }

      return map;

    }

    function remove( object ) {

      delete properties[ object.uuid ];

    }

    function clear() {

      properties = {};

    }

    return {
      get: get,
      remove: remove,
      clear: clear
    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLState( gl, extensions, utils ) {

    function ColorBuffer() {

      var locked = false;

      var color = new Vector4();
      var currentColorMask = null;
      var currentColorClear = new Vector4( 0, 0, 0, 0 );

      return {

        setMask: function ( colorMask ) {

          if ( currentColorMask !== colorMask && ! locked ) {

            gl.colorMask( colorMask, colorMask, colorMask, colorMask );
            currentColorMask = colorMask;

          }

        },

        setLocked: function ( lock ) {

          locked = lock;

        },

        setClear: function ( r, g, b, a, premultipliedAlpha ) {

          if ( premultipliedAlpha === true ) {

            r *= a; g *= a; b *= a;

          }

          color.set( r, g, b, a );

          if ( currentColorClear.equals( color ) === false ) {

            gl.clearColor( r, g, b, a );
            currentColorClear.copy( color );

          }

        },

        reset: function () {

          locked = false;

          currentColorMask = null;
          currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

        }

      };

    }

    function DepthBuffer() {

      var locked = false;

      var currentDepthMask = null;
      var currentDepthFunc = null;
      var currentDepthClear = null;

      return {

        setTest: function ( depthTest ) {

          if ( depthTest ) {

            enable( gl.DEPTH_TEST );

          } else {

            disable( gl.DEPTH_TEST );

          }

        },

        setMask: function ( depthMask ) {

          if ( currentDepthMask !== depthMask && ! locked ) {

            gl.depthMask( depthMask );
            currentDepthMask = depthMask;

          }

        },

        setFunc: function ( depthFunc ) {

          if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

              switch ( depthFunc ) {

                case NeverDepth:

                  gl.depthFunc( gl.NEVER );
                  break;

                case AlwaysDepth:

                  gl.depthFunc( gl.ALWAYS );
                  break;

                case LessDepth:

                  gl.depthFunc( gl.LESS );
                  break;

                case LessEqualDepth:

                  gl.depthFunc( gl.LEQUAL );
                  break;

                case EqualDepth:

                  gl.depthFunc( gl.EQUAL );
                  break;

                case GreaterEqualDepth:

                  gl.depthFunc( gl.GEQUAL );
                  break;

                case GreaterDepth:

                  gl.depthFunc( gl.GREATER );
                  break;

                case NotEqualDepth:

                  gl.depthFunc( gl.NOTEQUAL );
                  break;

                default:

                  gl.depthFunc( gl.LEQUAL );

              }

            } else {

              gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

          }

        },

        setLocked: function ( lock ) {

          locked = lock;

        },

        setClear: function ( depth ) {

          if ( currentDepthClear !== depth ) {

            gl.clearDepth( depth );
            currentDepthClear = depth;

          }

        },

        reset: function () {

          locked = false;

          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;

        }

      };

    }

    function StencilBuffer() {

      var locked = false;

      var currentStencilMask = null;
      var currentStencilFunc = null;
      var currentStencilRef = null;
      var currentStencilFuncMask = null;
      var currentStencilFail = null;
      var currentStencilZFail = null;
      var currentStencilZPass = null;
      var currentStencilClear = null;

      return {

        setTest: function ( stencilTest ) {

          if ( stencilTest ) {

            enable( gl.STENCIL_TEST );

          } else {

            disable( gl.STENCIL_TEST );

          }

        },

        setMask: function ( stencilMask ) {

          if ( currentStencilMask !== stencilMask && ! locked ) {

            gl.stencilMask( stencilMask );
            currentStencilMask = stencilMask;

          }

        },

        setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

          if ( currentStencilFunc !== stencilFunc ||
               currentStencilRef  !== stencilRef  ||
               currentStencilFuncMask !== stencilMask ) {

            gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;

          }

        },

        setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

          if ( currentStencilFail  !== stencilFail  ||
               currentStencilZFail !== stencilZFail ||
               currentStencilZPass !== stencilZPass ) {

            gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;

          }

        },

        setLocked: function ( lock ) {

          locked = lock;

        },

        setClear: function ( stencil ) {

          if ( currentStencilClear !== stencil ) {

            gl.clearStencil( stencil );
            currentStencilClear = stencil;

          }

        },

        reset: function () {

          locked = false;

          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;

        }

      };

    }

    //

    var colorBuffer = new ColorBuffer();
    var depthBuffer = new DepthBuffer();
    var stencilBuffer = new StencilBuffer();

    var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    var newAttributes = new Uint8Array( maxVertexAttributes );
    var enabledAttributes = new Uint8Array( maxVertexAttributes );
    var attributeDivisors = new Uint8Array( maxVertexAttributes );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentProgram = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentPremultipledAlpha = false;

    var currentFlipSided = null;
    var currentCullFace = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

    var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
    var lineWidthAvailable = parseFloat( version ) >= 1.0;

    var currentTextureSlot = null;
    var currentBoundTextures = {};

    var currentScissor = new Vector4();
    var currentViewport = new Vector4();

    function createTexture( type, target, count ) {

      var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
      var texture = gl.createTexture();

      gl.bindTexture( type, texture );
      gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
      gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

      for ( var i = 0; i < count; i ++ ) {

        gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

      }

      return texture;

    }

    var emptyTextures = {};
    emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
    emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

    // init

    colorBuffer.setClear( 0, 0, 0, 1 );
    depthBuffer.setClear( 1 );
    stencilBuffer.setClear( 0 );

    enable( gl.DEPTH_TEST );
    depthBuffer.setFunc( LessEqualDepth );

    setFlipSided( false );
    setCullFace( CullFaceBack );
    enable( gl.CULL_FACE );

    enable( gl.BLEND );
    setBlending( NormalBlending );

    //

    function initAttributes() {

      for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

        newAttributes[ i ] = 0;

      }

    }

    function enableAttribute( attribute ) {

      newAttributes[ attribute ] = 1;

      if ( enabledAttributes[ attribute ] === 0 ) {

        gl.enableVertexAttribArray( attribute );
        enabledAttributes[ attribute ] = 1;

      }

      if ( attributeDivisors[ attribute ] !== 0 ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        extension.vertexAttribDivisorANGLE( attribute, 0 );
        attributeDivisors[ attribute ] = 0;

      }

    }

    function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

      newAttributes[ attribute ] = 1;

      if ( enabledAttributes[ attribute ] === 0 ) {

        gl.enableVertexAttribArray( attribute );
        enabledAttributes[ attribute ] = 1;

      }

      if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
        attributeDivisors[ attribute ] = meshPerAttribute;

      }

    }

    function disableUnusedAttributes() {

      for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

        if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

          gl.disableVertexAttribArray( i );
          enabledAttributes[ i ] = 0;

        }

      }

    }

    function enable( id ) {

      if ( capabilities[ id ] !== true ) {

        gl.enable( id );
        capabilities[ id ] = true;

      }

    }

    function disable( id ) {

      if ( capabilities[ id ] !== false ) {

        gl.disable( id );
        capabilities[ id ] = false;

      }

    }

    function getCompressedTextureFormats() {

      if ( compressedTextureFormats === null ) {

        compressedTextureFormats = [];

        if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
             extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
             extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

          var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

          for ( var i = 0; i < formats.length; i ++ ) {

            compressedTextureFormats.push( formats[ i ] );

          }

        }

      }

      return compressedTextureFormats;

    }

    function useProgram( program ) {

      if ( currentProgram !== program ) {

        gl.useProgram( program );

        currentProgram = program;

        return true;

      }

      return false;

    }

    function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

      if ( blending !== NoBlending ) {

        enable( gl.BLEND );

      } else {

        disable( gl.BLEND );

      }

      if ( blending !== CustomBlending ) {

        if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

          switch ( blending ) {

            case AdditiveBlending:

              if ( premultipliedAlpha ) {

                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

              } else {

                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

              }
              break;

            case SubtractiveBlending:

              if ( premultipliedAlpha ) {

                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

              } else {

                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

              }
              break;

            case MultiplyBlending:

              if ( premultipliedAlpha ) {

                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

              } else {

                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

              }
              break;

            default:

              if ( premultipliedAlpha ) {

                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

              } else {

                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

              }

          }

        }

        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;

      } else {

        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;

        if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

          gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

          currentBlendEquation = blendEquation;
          currentBlendEquationAlpha = blendEquationAlpha;

        }

        if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

          gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

          currentBlendSrc = blendSrc;
          currentBlendDst = blendDst;
          currentBlendSrcAlpha = blendSrcAlpha;
          currentBlendDstAlpha = blendDstAlpha;

        }

      }

      currentBlending = blending;
      currentPremultipledAlpha = premultipliedAlpha;

    }

    function setMaterial( material ) {

      material.side === DoubleSide
        ? disable( gl.CULL_FACE )
        : enable( gl.CULL_FACE );

      setFlipSided( material.side === BackSide );

      material.transparent === true
        ? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
        : setBlending( NoBlending );

      depthBuffer.setFunc( material.depthFunc );
      depthBuffer.setTest( material.depthTest );
      depthBuffer.setMask( material.depthWrite );
      colorBuffer.setMask( material.colorWrite );

      setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    //

    function setFlipSided( flipSided ) {

      if ( currentFlipSided !== flipSided ) {

        if ( flipSided ) {

          gl.frontFace( gl.CW );

        } else {

          gl.frontFace( gl.CCW );

        }

        currentFlipSided = flipSided;

      }

    }

    function setCullFace( cullFace ) {

      if ( cullFace !== CullFaceNone ) {

        enable( gl.CULL_FACE );

        if ( cullFace !== currentCullFace ) {

          if ( cullFace === CullFaceBack ) {

            gl.cullFace( gl.BACK );

          } else if ( cullFace === CullFaceFront ) {

            gl.cullFace( gl.FRONT );

          } else {

            gl.cullFace( gl.FRONT_AND_BACK );

          }

        }

      } else {

        disable( gl.CULL_FACE );

      }

      currentCullFace = cullFace;

    }

    function setLineWidth( width ) {

      if ( width !== currentLineWidth ) {

        if ( lineWidthAvailable ) gl.lineWidth( width );

        currentLineWidth = width;

      }

    }

    function setPolygonOffset( polygonOffset, factor, units ) {

      if ( polygonOffset ) {

        enable( gl.POLYGON_OFFSET_FILL );

        if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

          gl.polygonOffset( factor, units );

          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;

        }

      } else {

        disable( gl.POLYGON_OFFSET_FILL );

      }

    }

    function setScissorTest( scissorTest ) {

      if ( scissorTest ) {

        enable( gl.SCISSOR_TEST );

      } else {

        disable( gl.SCISSOR_TEST );

      }

    }

    // texture

    function activeTexture( webglSlot ) {

      if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

      if ( currentTextureSlot !== webglSlot ) {

        gl.activeTexture( webglSlot );
        currentTextureSlot = webglSlot;

      }

    }

    function bindTexture( webglType, webglTexture ) {

      if ( currentTextureSlot === null ) {

        activeTexture();

      }

      var boundTexture = currentBoundTextures[ currentTextureSlot ];

      if ( boundTexture === undefined ) {

        boundTexture = { type: undefined, texture: undefined };
        currentBoundTextures[ currentTextureSlot ] = boundTexture;

      }

      if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

        gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;

      }

    }

    function compressedTexImage2D() {

      try {

        gl.compressedTexImage2D.apply( gl, arguments );

      } catch ( error ) {

        console.error( 'THREE.WebGLState:', error );

      }

    }

    function texImage2D() {

      try {

        gl.texImage2D.apply( gl, arguments );

      } catch ( error ) {

        console.error( 'THREE.WebGLState:', error );

      }

    }

    //

    function scissor( scissor ) {

      if ( currentScissor.equals( scissor ) === false ) {

        gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
        currentScissor.copy( scissor );

      }

    }

    function viewport( viewport ) {

      if ( currentViewport.equals( viewport ) === false ) {

        gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
        currentViewport.copy( viewport );

      }

    }

    //

    function reset() {

      for ( var i = 0; i < enabledAttributes.length; i ++ ) {

        if ( enabledAttributes[ i ] === 1 ) {

          gl.disableVertexAttribArray( i );
          enabledAttributes[ i ] = 0;

        }

      }

      capabilities = {};

      compressedTextureFormats = null;

      currentTextureSlot = null;
      currentBoundTextures = {};

      currentProgram = null;

      currentBlending = null;

      currentFlipSided = null;
      currentCullFace = null;

      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();

    }

    return {

      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },

      initAttributes: initAttributes,
      enableAttribute: enableAttribute,
      enableAttributeAndDivisor: enableAttributeAndDivisor,
      disableUnusedAttributes: disableUnusedAttributes,
      enable: enable,
      disable: disable,
      getCompressedTextureFormats: getCompressedTextureFormats,

      useProgram: useProgram,

      setBlending: setBlending,
      setMaterial: setMaterial,

      setFlipSided: setFlipSided,
      setCullFace: setCullFace,

      setLineWidth: setLineWidth,
      setPolygonOffset: setPolygonOffset,

      setScissorTest: setScissorTest,

      activeTexture: activeTexture,
      bindTexture: bindTexture,
      compressedTexImage2D: compressedTexImage2D,
      texImage2D: texImage2D,

      scissor: scissor,
      viewport: viewport,

      reset: reset

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLCapabilities( gl, extensions, parameters ) {

    var maxAnisotropy;

    function getMaxAnisotropy() {

      if ( maxAnisotropy !== undefined ) return maxAnisotropy;

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension !== null ) {

        maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

      } else {

        maxAnisotropy = 0;

      }

      return maxAnisotropy;

    }

    function getMaxPrecision( precision ) {

      if ( precision === 'highp' ) {

        if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
             gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

          return 'highp';

        }

        precision = 'mediump';

      }

      if ( precision === 'mediump' ) {

        if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
             gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

          return 'mediump';

        }

      }

      return 'lowp';

    }

    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    var maxPrecision = getMaxPrecision( precision );

    if ( maxPrecision !== precision ) {

      console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
      precision = maxPrecision;

    }

    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    var vertexTextures = maxVertexTextures > 0;
    var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    var floatVertexTextures = vertexTextures && floatFragmentTextures;

    return {

      getMaxAnisotropy: getMaxAnisotropy,
      getMaxPrecision: getMaxPrecision,

      precision: precision,
      logarithmicDepthBuffer: logarithmicDepthBuffer,

      maxTextures: maxTextures,
      maxVertexTextures: maxVertexTextures,
      maxTextureSize: maxTextureSize,
      maxCubemapSize: maxCubemapSize,

      maxAttributes: maxAttributes,
      maxVertexUniforms: maxVertexUniforms,
      maxVaryings: maxVaryings,
      maxFragmentUniforms: maxFragmentUniforms,

      vertexTextures: vertexTextures,
      floatFragmentTextures: floatFragmentTextures,
      floatVertexTextures: floatVertexTextures

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */

  function PerspectiveCamera( fov, aspect, near, far ) {

    Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;

    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;

    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;

    this.filmGauge = 35;  // width of the film (default in millimeters)
    this.filmOffset = 0;  // horizontal film offset (same unit as gauge)

    this.updateProjectionMatrix();

  }

  PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    constructor: PerspectiveCamera,

    isPerspectiveCamera: true,

    copy: function ( source, recursive ) {

      Camera.prototype.copy.call( this, source, recursive );

      this.fov = source.fov;
      this.zoom = source.zoom;

      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;

      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign( {}, source.view );

      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;

      return this;

    },

    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
    setFocalLength: function ( focalLength ) {

      // see http://www.bobatkins.com/photography/technical/field_of_view.html
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

      this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
      this.updateProjectionMatrix();

    },

    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
    getFocalLength: function () {

      var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

      return 0.5 * this.getFilmHeight() / vExtentSlope;

    },

    getEffectiveFOV: function () {

      return _Math.RAD2DEG * 2 * Math.atan(
        Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

    },

    getFilmWidth: function () {

      // film not completely covered in portrait format (aspect < 1)
      return this.filmGauge * Math.min( this.aspect, 1 );

    },

    getFilmHeight: function () {

      // film not completely covered in landscape format (aspect > 1)
      return this.filmGauge / Math.max( this.aspect, 1 );

    },

    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   var w = 1920;
     *   var h = 1080;
     *   var fullWidth = w * 3;
     *   var fullHeight = h * 2;
     *
     *   --A--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
    setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

      this.aspect = fullWidth / fullHeight;

      if ( this.view === null ) {

        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };

      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;

      this.updateProjectionMatrix();

    },

    clearViewOffset: function () {

      if ( this.view !== null ) {

        this.view.enabled = false;

      }

      this.updateProjectionMatrix();

    },

    updateProjectionMatrix: function () {

      var near = this.near,
        top = near * Math.tan(
          _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
        height = 2 * top,
        width = this.aspect * height,
        left = - 0.5 * width,
        view = this.view;

      if ( this.view !== null && this.view.enabled ) {

        var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;

        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;

      }

      var skew = this.filmOffset;
      if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

      this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

    },

    toJSON: function ( meta ) {

      var data = Object3D.prototype.toJSON.call( this, meta );

      data.object.fov = this.fov;
      data.object.zoom = this.zoom;

      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;

      data.object.aspect = this.aspect;

      if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;

      return data;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ArrayCamera( array ) {

    PerspectiveCamera.call( this );

    this.cameras = array || [];

  }

  ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

    constructor: ArrayCamera,

    isArrayCamera: true

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebVRManager( renderer ) {

    var scope = this;

    var device = null;
    var frameData = null;

    if ( 'VRFrameData' in window ) {

      frameData = new window.VRFrameData();

    }

    var matrixWorldInverse = new Matrix4();

    var standingMatrix = new Matrix4();
    var standingMatrixInverse = new Matrix4();

    var cameraL = new PerspectiveCamera();
    cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
    cameraL.layers.enable( 1 );

    var cameraR = new PerspectiveCamera();
    cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
    cameraR.layers.enable( 2 );

    var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
    cameraVR.layers.enable( 1 );
    cameraVR.layers.enable( 2 );

    //

    var currentSize, currentPixelRatio;

    function onVRDisplayPresentChange() {

      if ( device !== null && device.isPresenting ) {

        var eyeParameters = device.getEyeParameters( 'left' );
        var renderWidth = eyeParameters.renderWidth;
        var renderHeight = eyeParameters.renderHeight;

        currentPixelRatio = renderer.getPixelRatio();
        currentSize = renderer.getSize();

        renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

      } else if ( scope.enabled ) {

        renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

      }

    }

    window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

    //

    this.enabled = false;
    this.standing = false;

    this.getDevice = function () {

      return device;

    };

    this.setDevice = function ( value ) {

      if ( value !== undefined ) device = value;

    };

    this.getCamera = function ( camera ) {

      if ( device === null ) return camera;

      device.depthNear = camera.near;
      device.depthFar = camera.far;

      device.getFrameData( frameData );

      //

      var pose = frameData.pose;

      if ( pose.position !== null ) {

        camera.position.fromArray( pose.position );

      } else {

        camera.position.set( 0, 0, 0 );

      }

      if ( pose.orientation !== null ) {

        camera.quaternion.fromArray( pose.orientation );

      }

      camera.updateMatrixWorld();

      var stageParameters = device.stageParameters;

      if ( this.standing && stageParameters ) {

        standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
        standingMatrixInverse.getInverse( standingMatrix );

        camera.matrixWorld.multiply( standingMatrix );
        camera.matrixWorldInverse.multiply( standingMatrixInverse );

      }

      if ( device.isPresenting === false ) return camera;

      //

      cameraL.near = camera.near;
      cameraR.near = camera.near;

      cameraL.far = camera.far;
      cameraR.far = camera.far;

      cameraVR.matrixWorld.copy( camera.matrixWorld );
      cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

      cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
      cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

      if ( this.standing && stageParameters ) {

        cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
        cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

      }

      var parent = camera.parent;

      if ( parent !== null ) {

        matrixWorldInverse.getInverse( parent.matrixWorld );

        cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
        cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

      }

      // envMap and Mirror needs camera.matrixWorld

      cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
      cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

      cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
      cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

      // HACK @mrdoob
      // https://github.com/w3c/webvr/issues/203

      cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

      //

      var layers = device.getLayers();

      if ( layers.length ) {

        var layer = layers[ 0 ];

        if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

          cameraL.bounds.fromArray( layer.leftBounds );

        }

        if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

          cameraR.bounds.fromArray( layer.rightBounds );

        }

      }

      return cameraVR;

    };

    this.getStandingMatrix = function () {

      return standingMatrix;

    };

    this.submitFrame = function () {

      if ( device && device.isPresenting ) device.submitFrame();

    };

    this.dispose = function () {

      window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLExtensions( gl ) {

    var extensions = {};

    return {

      get: function ( name ) {

        if ( extensions[ name ] !== undefined ) {

          return extensions[ name ];

        }

        var extension;

        switch ( name ) {

          case 'WEBGL_depth_texture':
            extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
            break;

          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
            break;

          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
            break;

          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
            break;

          case 'WEBGL_compressed_texture_etc1':
            extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
            break;

          default:
            extension = gl.getExtension( name );

        }

        if ( extension === null ) {

          console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

      }

    };

  }

  /**
   * @author tschw
   */

  function WebGLClipping() {

    var scope = this,

      globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false,

      plane = new Plane(),
      viewNormalMatrix = new Matrix3(),

      uniform = { value: null, needsUpdate: false };

    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;

    this.init = function ( planes, enableLocalClipping, camera ) {

      var enabled =
        planes.length !== 0 ||
        enableLocalClipping ||
        // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 ||
        localClippingEnabled;

      localClippingEnabled = enableLocalClipping;

      globalState = projectPlanes( planes, camera, 0 );
      numGlobalPlanes = planes.length;

      return enabled;

    };

    this.beginShadows = function () {

      renderingShadows = true;
      projectPlanes( null );

    };

    this.endShadows = function () {

      renderingShadows = false;
      resetGlobalState();

    };

    this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

      if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

        // there's no local clipping

        if ( renderingShadows ) {

          // there's no global clipping

          projectPlanes( null );

        } else {

          resetGlobalState();

        }

      } else {

        var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4,

          dstArray = cache.clippingState || null;

        uniform.value = dstArray; // ensure unique state

        dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

        for ( var i = 0; i !== lGlobal; ++ i ) {

          dstArray[ i ] = globalState[ i ];

        }

        cache.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;

      }


    };

    function resetGlobalState() {

      if ( uniform.value !== globalState ) {

        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;

      }

      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;

    }

    function projectPlanes( planes, camera, dstOffset, skipTransform ) {

      var nPlanes = planes !== null ? planes.length : 0,
        dstArray = null;

      if ( nPlanes !== 0 ) {

        dstArray = uniform.value;

        if ( skipTransform !== true || dstArray === null ) {

          var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;

          viewNormalMatrix.getNormalMatrix( viewMatrix );

          if ( dstArray === null || dstArray.length < flatSize ) {

            dstArray = new Float32Array( flatSize );

          }

          for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

            plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

            plane.normal.toArray( dstArray, i4 );
            dstArray[ i4 + 3 ] = plane.constant;

          }

        }

        uniform.value = dstArray;
        uniform.needsUpdate = true;

      }

      scope.numPlanes = nPlanes;

      return dstArray;

    }

  }

  /**
   * @author thespite / http://www.twitter.com/thespite
   */

  function WebGLUtils( gl, extensions ) {

    function convert( p ) {

      var extension;

      if ( p === RepeatWrapping ) return gl.REPEAT;
      if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
      if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

      if ( p === NearestFilter ) return gl.NEAREST;
      if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
      if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

      if ( p === LinearFilter ) return gl.LINEAR;
      if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
      if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

      if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
      if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
      if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
      if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

      if ( p === ByteType ) return gl.BYTE;
      if ( p === ShortType ) return gl.SHORT;
      if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
      if ( p === IntType ) return gl.INT;
      if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
      if ( p === FloatType ) return gl.FLOAT;

      if ( p === HalfFloatType ) {

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) return extension.HALF_FLOAT_OES;

      }

      if ( p === AlphaFormat ) return gl.ALPHA;
      if ( p === RGBFormat ) return gl.RGB;
      if ( p === RGBAFormat ) return gl.RGBA;
      if ( p === LuminanceFormat ) return gl.LUMINANCE;
      if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
      if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
      if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

      if ( p === AddEquation ) return gl.FUNC_ADD;
      if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
      if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

      if ( p === ZeroFactor ) return gl.ZERO;
      if ( p === OneFactor ) return gl.ONE;
      if ( p === SrcColorFactor ) return gl.SRC_COLOR;
      if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
      if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
      if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
      if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
      if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

      if ( p === DstColorFactor ) return gl.DST_COLOR;
      if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
      if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

      if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
        p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

          if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

      }

      if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
        p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

          if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

      }

      if ( p === RGB_ETC1_Format ) {

        extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

        if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

      }

      if ( p === MinEquation || p === MaxEquation ) {

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

          if ( p === MinEquation ) return extension.MIN_EXT;
          if ( p === MaxEquation ) return extension.MAX_EXT;

        }

      }

      if ( p === UnsignedInt248Type ) {

        extension = extensions.get( 'WEBGL_depth_texture' );

        if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

      }

      return 0;

    }

    return { convert: convert };

  }

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   * @author tschw
   */

  function WebGLRenderer( parameters ) {

    console.log( 'THREE.WebGLRenderer', REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
      _context = parameters.context !== undefined ? parameters.context : null,

      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
      _depth = parameters.depth !== undefined ? parameters.depth : true,
      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    var lightsArray = [];
    var shadowsArray = [];

    var currentRenderList = null;

    var spritesArray = [];
    var flaresArray = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // user-defined clipping

    this.clippingPlanes = [];
    this.localClippingEnabled = false;

    // physically based shading

    this.gammaFactor = 2.0; // for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // physical lights

    this.physicallyCorrectLights = false;

    // tone mapping

    this.toneMapping = LinearToneMapping;
    this.toneMappingExposure = 1.0;
    this.toneMappingWhitePoint = 1.0;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // internal properties

    var _this = this,

      _isContextLost = false,

      // internal state cache

      _currentRenderTarget = null,
      _currentFramebuffer = null,
      _currentMaterialId = - 1,
      _currentGeometryProgram = '',

      _currentCamera = null,
      _currentArrayCamera = null,

      _currentViewport = new Vector4(),
      _currentScissor = new Vector4(),
      _currentScissorTest = null,

      //

      _usedTextureUnits = 0,

      //

      _width = _canvas.width,
      _height = _canvas.height,

      _pixelRatio = 1,

      _viewport = new Vector4( 0, 0, _width, _height ),
      _scissor = new Vector4( 0, 0, _width, _height ),
      _scissorTest = false,

      // frustum

      _frustum = new Frustum(),

      // clipping

      _clipping = new WebGLClipping(),
      _clippingEnabled = false,
      _localClippingEnabled = false,

      // camera matrices cache

      _projScreenMatrix = new Matrix4(),

      _vector3 = new Vector3(),

      // info

      _infoMemory = {
        geometries: 0,
        textures: 0
      },

      _infoRender = {

        frame: 0,
        calls: 0,
        vertices: 0,
        faces: 0,
        points: 0

      };

    this.info = {

      render: _infoRender,
      memory: _infoMemory,
      programs: null

    };

    function getTargetPixelRatio() {

      return _currentRenderTarget === null ? _pixelRatio : 1;

    }

    // initialize

    var _gl;

    try {

      var contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer
      };

      _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

      if ( _gl === null ) {

        if ( _canvas.getContext( 'webgl' ) !== null ) {

          throw 'Error creating WebGL context with your selected attributes.';

        } else {

          throw 'Error creating WebGL context.';

        }

      }

      // Some experimental-webgl implementations do not have getShaderPrecisionFormat

      if ( _gl.getShaderPrecisionFormat === undefined ) {

        _gl.getShaderPrecisionFormat = function () {

          return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

        };

      }

      _canvas.addEventListener( 'webglcontextlost', onContextLost, false );
      _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

    } catch ( error ) {

      console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions, capabilities, state;
    var properties, textures, attributes, geometries, objects, lights;
    var programCache, renderLists;

    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    var flareRenderer, spriteRenderer;

    var utils;

    function initGLContext() {

      extensions = new WebGLExtensions( _gl );
      extensions.get( 'WEBGL_depth_texture' );
      extensions.get( 'OES_texture_float' );
      extensions.get( 'OES_texture_float_linear' );
      extensions.get( 'OES_texture_half_float' );
      extensions.get( 'OES_texture_half_float_linear' );
      extensions.get( 'OES_standard_derivatives' );
      extensions.get( 'OES_element_index_uint' );
      extensions.get( 'ANGLE_instanced_arrays' );

      utils = new WebGLUtils( _gl, extensions );

      capabilities = new WebGLCapabilities( _gl, extensions, parameters );

      state = new WebGLState( _gl, extensions, utils );
      state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
      state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

      properties = new WebGLProperties();
      textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );
      attributes = new WebGLAttributes( _gl );
      geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
      objects = new WebGLObjects( geometries, _infoRender );
      morphtargets = new WebGLMorphtargets( _gl );
      programCache = new WebGLPrograms( _this, extensions, capabilities );
      lights = new WebGLLights();
      renderLists = new WebGLRenderLists();

      background = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );

      bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
      indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

      flareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );
      spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );

      _this.info.programs = programCache.programs;

      _this.context = _gl;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.state = state;

    }

    initGLContext();

    // vr

    var vr = new WebVRManager( _this );

    this.vr = vr;

    // shadow map

    var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

    this.shadowMap = shadowMap;

    // API

    this.getContext = function () {

      return _gl;

    };

    this.getContextAttributes = function () {

      return _gl.getContextAttributes();

    };

    this.forceContextLoss = function () {

      var extension = extensions.get( 'WEBGL_lose_context' );
      if ( extension ) extension.loseContext();

    };

    this.forceContextRestore = function () {

      var extension = extensions.get( 'WEBGL_lose_context' );
      if ( extension ) extension.restoreContext();

    };

    this.getPixelRatio = function () {

      return _pixelRatio;

    };

    this.setPixelRatio = function ( value ) {

      if ( value === undefined ) return;

      _pixelRatio = value;

      this.setSize( _width, _height, false );

    };

    this.getSize = function () {

      return {
        width: _width,
        height: _height
      };

    };

    this.setSize = function ( width, height, updateStyle ) {

      var device = vr.getDevice();

      if ( device && device.isPresenting ) {

        console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
        return;

      }

      _width = width;
      _height = height;

      _canvas.width = width * _pixelRatio;
      _canvas.height = height * _pixelRatio;

      if ( updateStyle !== false ) {

        _canvas.style.width = width + 'px';
        _canvas.style.height = height + 'px';

      }

      this.setViewport( 0, 0, width, height );

    };

    this.getDrawingBufferSize = function () {

      return {
        width: _width * _pixelRatio,
        height: _height * _pixelRatio
      };

    };

    this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

      _width = width;
      _height = height;

      _pixelRatio = pixelRatio;

      _canvas.width = width * pixelRatio;
      _canvas.height = height * pixelRatio;

      this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function ( x, y, width, height ) {

      _viewport.set( x, _height - y - height, width, height );
      state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

    };

    this.setScissor = function ( x, y, width, height ) {

      _scissor.set( x, _height - y - height, width, height );
      state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

    };

    this.setScissorTest = function ( boolean ) {

      state.setScissorTest( _scissorTest = boolean );

    };

    // Clearing

    this.getClearColor = background.getClearColor;
    this.setClearColor = background.setClearColor;
    this.getClearAlpha = background.getClearAlpha;
    this.setClearAlpha = background.setClearAlpha;

    this.clear = function ( color, depth, stencil ) {

      var bits = 0;

      if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
      if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
      if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

      _gl.clear( bits );

    };

    this.clearColor = function () {

      this.clear( true, false, false );

    };

    this.clearDepth = function () {

      this.clear( false, true, false );

    };

    this.clearStencil = function () {

      this.clear( false, false, true );

    };

    this.clearTarget = function ( renderTarget, color, depth, stencil ) {

      this.setRenderTarget( renderTarget );
      this.clear( color, depth, stencil );

    };

    //

    this.dispose = function () {

      _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
      _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

      renderLists.dispose();

      vr.dispose();

    };

    // Events

    function onContextLost( event ) {

      event.preventDefault();

      console.log( 'THREE.WebGLRenderer: Context Lost.' );

      _isContextLost = true;

    }

    function onContextRestore( /* event */ ) {

      console.log( 'THREE.WebGLRenderer: Context Restored.' );

      _isContextLost = false;

      initGLContext();

    }

    function onMaterialDispose( event ) {

      var material = event.target;

      material.removeEventListener( 'dispose', onMaterialDispose );

      deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateMaterial( material ) {

      releaseMaterialProgramReference( material );

      properties.remove( material );

    }


    function releaseMaterialProgramReference( material ) {

      var programInfo = properties.get( material ).program;

      material.program = undefined;

      if ( programInfo !== undefined ) {

        programCache.releaseProgram( programInfo );

      }

    }

    // Buffer rendering

    function renderObjectImmediate( object, program, material ) {

      object.render( function ( object ) {

        _this.renderBufferImmediate( object, program, material );

      } );

    }

    this.renderBufferImmediate = function ( object, program, material ) {

      state.initAttributes();

      var buffers = properties.get( object );

      if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
      if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
      if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
      if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

      var programAttributes = program.getAttributes();

      if ( object.hasPositions ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
        _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

        state.enableAttribute( programAttributes.position );
        _gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

      }

      if ( object.hasNormals ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

        if ( ! material.isMeshPhongMaterial &&
          ! material.isMeshStandardMaterial &&
          ! material.isMeshNormalMaterial &&
          material.flatShading === true ) {

          for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

            var array = object.normalArray;

            var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
            var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
            var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

            array[ i + 0 ] = nx;
            array[ i + 1 ] = ny;
            array[ i + 2 ] = nz;

            array[ i + 3 ] = nx;
            array[ i + 4 ] = ny;
            array[ i + 5 ] = nz;

            array[ i + 6 ] = nx;
            array[ i + 7 ] = ny;
            array[ i + 8 ] = nz;

          }

        }

        _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

        state.enableAttribute( programAttributes.normal );

        _gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

      }

      if ( object.hasUvs && material.map ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
        _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

        state.enableAttribute( programAttributes.uv );

        _gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

      }

      if ( object.hasColors && material.vertexColors !== NoColors ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
        _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

        state.enableAttribute( programAttributes.color );

        _gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

      }

      state.disableUnusedAttributes();

      _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

      object.count = 0;

    };

    this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

      state.setMaterial( material );

      var program = setProgram( camera, fog, material, object );
      var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

      var updateBuffers = false;

      if ( geometryProgram !== _currentGeometryProgram ) {

        _currentGeometryProgram = geometryProgram;
        updateBuffers = true;

      }

      if ( object.morphTargetInfluences ) {

        morphtargets.update( object, geometry, material, program );

        updateBuffers = true;

      }

      //

      var index = geometry.index;
      var position = geometry.attributes.position;
      var rangeFactor = 1;

      if ( material.wireframe === true ) {

        index = geometries.getWireframeAttribute( geometry );
        rangeFactor = 2;

      }

      var attribute;
      var renderer = bufferRenderer;

      if ( index !== null ) {

        attribute = attributes.get( index );

        renderer = indexedBufferRenderer;
        renderer.setIndex( attribute );

      }

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry );

        if ( index !== null ) {

          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

        }

      }

      //

      var dataCount = 0;

      if ( index !== null ) {

        dataCount = index.count;

      } else if ( position !== undefined ) {

        dataCount = position.count;

      }

      var rangeStart = geometry.drawRange.start * rangeFactor;
      var rangeCount = geometry.drawRange.count * rangeFactor;

      var groupStart = group !== null ? group.start * rangeFactor : 0;
      var groupCount = group !== null ? group.count * rangeFactor : Infinity;

      var drawStart = Math.max( rangeStart, groupStart );
      var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

      var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

      if ( drawCount === 0 ) return;

      //

      if ( object.isMesh ) {

        if ( material.wireframe === true ) {

          state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
          renderer.setMode( _gl.LINES );

        } else {

          switch ( object.drawMode ) {

            case TrianglesDrawMode:
              renderer.setMode( _gl.TRIANGLES );
              break;

            case TriangleStripDrawMode:
              renderer.setMode( _gl.TRIANGLE_STRIP );
              break;

            case TriangleFanDrawMode:
              renderer.setMode( _gl.TRIANGLE_FAN );
              break;

          }

        }


      } else if ( object.isLine ) {

        var lineWidth = material.linewidth;

        if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

        state.setLineWidth( lineWidth * getTargetPixelRatio() );

        if ( object.isLineSegments ) {

          renderer.setMode( _gl.LINES );

        } else if ( object.isLineLoop ) {

          renderer.setMode( _gl.LINE_LOOP );

        } else {

          renderer.setMode( _gl.LINE_STRIP );

        }

      } else if ( object.isPoints ) {

        renderer.setMode( _gl.POINTS );

      }

      if ( geometry && geometry.isInstancedBufferGeometry ) {

        if ( geometry.maxInstancedCount > 0 ) {

          renderer.renderInstances( geometry, drawStart, drawCount );

        }

      } else {

        renderer.render( drawStart, drawCount );

      }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

      if ( geometry && geometry.isInstancedBufferGeometry ) {

        if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

          console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
          return;

        }

      }

      if ( startIndex === undefined ) startIndex = 0;

      state.initAttributes();

      var geometryAttributes = geometry.attributes;

      var programAttributes = program.getAttributes();

      var materialDefaultAttributeValues = material.defaultAttributeValues;

      for ( var name in programAttributes ) {

        var programAttribute = programAttributes[ name ];

        if ( programAttribute >= 0 ) {

          var geometryAttribute = geometryAttributes[ name ];

          if ( geometryAttribute !== undefined ) {

            var normalized = geometryAttribute.normalized;
            var size = geometryAttribute.itemSize;

            var attribute = attributes.get( geometryAttribute );

            // TODO Attribute may not be available on context restore

            if ( attribute === undefined ) continue;

            var buffer = attribute.buffer;
            var type = attribute.type;
            var bytesPerElement = attribute.bytesPerElement;

            if ( geometryAttribute.isInterleavedBufferAttribute ) {

              var data = geometryAttribute.data;
              var stride = data.stride;
              var offset = geometryAttribute.offset;

              if ( data && data.isInstancedInterleavedBuffer ) {

                state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

                if ( geometry.maxInstancedCount === undefined ) {

                  geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                }

              } else {

                state.enableAttribute( programAttribute );

              }

              _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
              _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

            } else {

              if ( geometryAttribute.isInstancedBufferAttribute ) {

                state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

                if ( geometry.maxInstancedCount === undefined ) {

                  geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                }

              } else {

                state.enableAttribute( programAttribute );

              }

              _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
              _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

            }

          } else if ( materialDefaultAttributeValues !== undefined ) {

            var value = materialDefaultAttributeValues[ name ];

            if ( value !== undefined ) {

              switch ( value.length ) {

                case 2:
                  _gl.vertexAttrib2fv( programAttribute, value );
                  break;

                case 3:
                  _gl.vertexAttrib3fv( programAttribute, value );
                  break;

                case 4:
                  _gl.vertexAttrib4fv( programAttribute, value );
                  break;

                default:
                  _gl.vertexAttrib1fv( programAttribute, value );

              }

            }

          }

        }

      }

      state.disableUnusedAttributes();

    }

    // Compile

    this.compile = function ( scene, camera ) {

      lightsArray.length = 0;
      shadowsArray.length = 0;

      scene.traverse( function ( object ) {

        if ( object.isLight ) {

          lightsArray.push( object );

          if ( object.castShadow ) {

            shadowsArray.push( object );

          }

        }

      } );

      lights.setup( lightsArray, shadowsArray, camera );

      scene.traverse( function ( object ) {

        if ( object.material ) {

          if ( Array.isArray( object.material ) ) {

            for ( var i = 0; i < object.material.length; i ++ ) {

              initMaterial( object.material[ i ], scene.fog, object );

            }

          } else {

            initMaterial( object.material, scene.fog, object );

          }

        }

      } );

    };

    // Animation Loop

    var isAnimating = false;
    var onAnimationFrame = null;

    function start() {

      if ( isAnimating ) return;
      ( vr.getDevice() || window ).requestAnimationFrame( loop );
      isAnimating = true;

    }

    function loop( time ) {

      if ( onAnimationFrame !== null ) onAnimationFrame( time );
      ( vr.getDevice() || window ).requestAnimationFrame( loop );

    }

    this.animate = function ( callback ) {

      onAnimationFrame = callback;
      start();

    };

    // Rendering

    this.render = function ( scene, camera, renderTarget, forceClear ) {

      if ( ! ( camera && camera.isCamera ) ) {

        console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
        return;

      }

      if ( _isContextLost ) return;

      // reset caching for this frame

      _currentGeometryProgram = '';
      _currentMaterialId = - 1;
      _currentCamera = null;

      // update scene graph

      if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

      // update camera matrices and frustum

      if ( camera.parent === null ) camera.updateMatrixWorld();

      if ( vr.enabled ) {

        camera = vr.getCamera( camera );

      }

      _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );

      lightsArray.length = 0;
      shadowsArray.length = 0;

      spritesArray.length = 0;
      flaresArray.length = 0;

      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

      currentRenderList = renderLists.get( scene, camera );
      currentRenderList.init();

      projectObject( scene, camera, _this.sortObjects );

      if ( _this.sortObjects === true ) {

        currentRenderList.sort();

      }

      //

      if ( _clippingEnabled ) _clipping.beginShadows();

      shadowMap.render( shadowsArray, scene, camera );

      lights.setup( lightsArray, shadowsArray, camera );

      if ( _clippingEnabled ) _clipping.endShadows();

      //

      _infoRender.frame ++;
      _infoRender.calls = 0;
      _infoRender.vertices = 0;
      _infoRender.faces = 0;
      _infoRender.points = 0;

      if ( renderTarget === undefined ) {

        renderTarget = null;

      }

      this.setRenderTarget( renderTarget );

      //

      background.render( currentRenderList, scene, camera, forceClear );

      // render scene

      var opaqueObjects = currentRenderList.opaque;
      var transparentObjects = currentRenderList.transparent;

      if ( scene.overrideMaterial ) {

        var overrideMaterial = scene.overrideMaterial;

        if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
        if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

      } else {

        // opaque pass (front-to-back order)

        if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

        // transparent pass (back-to-front order)

        if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

      }

      // custom renderers

      spriteRenderer.render( spritesArray, scene, camera );
      flareRenderer.render( flaresArray, scene, camera, _currentViewport );

      // Generate mipmap if we're using any kind of mipmap filtering

      if ( renderTarget ) {

        textures.updateRenderTargetMipmap( renderTarget );

      }

      // Ensure depth buffer writing is enabled so it can be cleared on next render

      state.buffers.depth.setTest( true );
      state.buffers.depth.setMask( true );
      state.buffers.color.setMask( true );

      state.setPolygonOffset( false );

      if ( vr.enabled ) {

        vr.submitFrame();

      }

      // _gl.finish();

    };

    /*
    // TODO Duplicated code (Frustum)

    var _sphere = new Sphere();

    function isObjectViewable( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null )
        geometry.computeBoundingSphere();

      _sphere.copy( geometry.boundingSphere ).
      applyMatrix4( object.matrixWorld );

      return isSphereViewable( _sphere );

    }

    function isSpriteViewable( sprite ) {

      _sphere.center.set( 0, 0, 0 );
      _sphere.radius = 0.7071067811865476;
      _sphere.applyMatrix4( sprite.matrixWorld );

      return isSphereViewable( _sphere );

    }

    function isSphereViewable( sphere ) {

      if ( ! _frustum.intersectsSphere( sphere ) ) return false;

      var numPlanes = _clipping.numPlanes;

      if ( numPlanes === 0 ) return true;

      var planes = _this.clippingPlanes,

        center = sphere.center,
        negRad = - sphere.radius,
        i = 0;

      do {

        // out when deeper than radius in the negative halfspace
        if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

      } while ( ++ i !== numPlanes );

      return true;

    }
    */

    function projectObject( object, camera, sortObjects ) {

      if ( object.visible === false ) return;

      var visible = object.layers.test( camera.layers );

      if ( visible ) {

        if ( object.isLight ) {

          lightsArray.push( object );

          if ( object.castShadow ) {

            shadowsArray.push( object );

          }

        } else if ( object.isSprite ) {

          if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

            spritesArray.push( object );

          }

        } else if ( object.isLensFlare ) {

          flaresArray.push( object );

        } else if ( object.isImmediateRenderObject ) {

          if ( sortObjects ) {

            _vector3.setFromMatrixPosition( object.matrixWorld )
              .applyMatrix4( _projScreenMatrix );

          }

          currentRenderList.push( object, null, object.material, _vector3.z, null );

        } else if ( object.isMesh || object.isLine || object.isPoints ) {

          if ( object.isSkinnedMesh ) {

            object.skeleton.update();

          }

          if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

            if ( sortObjects ) {

              _vector3.setFromMatrixPosition( object.matrixWorld )
                .applyMatrix4( _projScreenMatrix );

            }

            var geometry = objects.update( object );
            var material = object.material;

            if ( Array.isArray( material ) ) {

              var groups = geometry.groups;

              for ( var i = 0, l = groups.length; i < l; i ++ ) {

                var group = groups[ i ];
                var groupMaterial = material[ group.materialIndex ];

                if ( groupMaterial && groupMaterial.visible ) {

                  currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

                }

              }

            } else if ( material.visible ) {

              currentRenderList.push( object, geometry, material, _vector3.z, null );

            }

          }

        }

      }

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        projectObject( children[ i ], camera, sortObjects );

      }

    }

    function renderObjects( renderList, scene, camera, overrideMaterial ) {

      for ( var i = 0, l = renderList.length; i < l; i ++ ) {

        var renderItem = renderList[ i ];

        var object = renderItem.object;
        var geometry = renderItem.geometry;
        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
        var group = renderItem.group;

        if ( camera.isArrayCamera ) {

          _currentArrayCamera = camera;

          var cameras = camera.cameras;

          for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

            var camera2 = cameras[ j ];

            if ( object.layers.test( camera2.layers ) ) {

              var bounds = camera2.bounds;

              var x = bounds.x * _width;
              var y = bounds.y * _height;
              var width = bounds.z * _width;
              var height = bounds.w * _height;

              state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

              renderObject( object, scene, camera2, geometry, material, group );

            }

          }

        } else {

          _currentArrayCamera = null;

          renderObject( object, scene, camera, geometry, material, group );

        }

      }

    }

    function renderObject( object, scene, camera, geometry, material, group ) {

      object.onBeforeRender( _this, scene, camera, geometry, material, group );

      object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
      object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

      if ( object.isImmediateRenderObject ) {

        state.setMaterial( material );

        var program = setProgram( camera, scene.fog, material, object );

        _currentGeometryProgram = '';

        renderObjectImmediate( object, program, material );

      } else {

        _this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

      }

      object.onAfterRender( _this, scene, camera, geometry, material, group );

    }

    function initMaterial( material, fog, object ) {

      var materialProperties = properties.get( material );

      var parameters = programCache.getParameters(
        material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

      var code = programCache.getProgramCode( material, parameters );

      var program = materialProperties.program;
      var programChange = true;

      if ( program === undefined ) {

        // new material
        material.addEventListener( 'dispose', onMaterialDispose );

      } else if ( program.code !== code ) {

        // changed glsl or parameters
        releaseMaterialProgramReference( material );

      } else if ( parameters.shaderID !== undefined ) {

        // same glsl and uniform list
        return;

      } else {

        // only rebuild uniform list
        programChange = false;

      }

      if ( programChange ) {

        if ( parameters.shaderID ) {

          var shader = ShaderLib[ parameters.shaderID ];

          materialProperties.shader = {
            name: material.type,
            uniforms: UniformsUtils.clone( shader.uniforms ),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          };

        } else {

          materialProperties.shader = {
            name: material.type,
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
          };

        }

        material.onBeforeCompile( materialProperties.shader );

        program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

        materialProperties.program = program;
        material.program = program;

      }

      var programAttributes = program.getAttributes();

      if ( material.morphTargets ) {

        material.numSupportedMorphTargets = 0;

        for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

          if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

            material.numSupportedMorphTargets ++;

          }

        }

      }

      if ( material.morphNormals ) {

        material.numSupportedMorphNormals = 0;

        for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

          if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

            material.numSupportedMorphNormals ++;

          }

        }

      }

      var uniforms = materialProperties.shader.uniforms;

      if ( ! material.isShaderMaterial &&
        ! material.isRawShaderMaterial ||
        material.clipping === true ) {

        materialProperties.numClippingPlanes = _clipping.numPlanes;
        materialProperties.numIntersection = _clipping.numIntersection;
        uniforms.clippingPlanes = _clipping.uniform;

      }

      materialProperties.fog = fog;

      // store the light setup it was created for

      materialProperties.lightsHash = lights.state.hash;

      if ( material.lights ) {

        // wire up the material to this renderer's lighting state

        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.pointLights.value = lights.state.point;
        uniforms.hemisphereLights.value = lights.state.hemi;

        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms

      }

      var progUniforms = materialProperties.program.getUniforms(),
        uniformsList =
          WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

      materialProperties.uniformsList = uniformsList;

    }

    function setProgram( camera, fog, material, object ) {

      _usedTextureUnits = 0;

      var materialProperties = properties.get( material );

      if ( _clippingEnabled ) {

        if ( _localClippingEnabled || camera !== _currentCamera ) {

          var useCache =
            camera === _currentCamera &&
            material.id === _currentMaterialId;

          // we might want to call this function with some ClippingGroup
          // object instead of the material, once it becomes feasible
          // (#8465, #8379)
          _clipping.setState(
            material.clippingPlanes, material.clipIntersection, material.clipShadows,
            camera, materialProperties, useCache );

        }

      }

      if ( material.needsUpdate === false ) {

        if ( materialProperties.program === undefined ) {

          material.needsUpdate = true;

        } else if ( material.fog && materialProperties.fog !== fog ) {

          material.needsUpdate = true;

        } else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {

          material.needsUpdate = true;

        } else if ( materialProperties.numClippingPlanes !== undefined &&
          ( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
          materialProperties.numIntersection !== _clipping.numIntersection ) ) {

          material.needsUpdate = true;

        }

      }

      if ( material.needsUpdate ) {

        initMaterial( material, fog, object );
        material.needsUpdate = false;

      }

      var refreshProgram = false;
      var refreshMaterial = false;
      var refreshLights = false;

      var program = materialProperties.program,
        p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.shader.uniforms;

      if ( state.useProgram( program.program ) ) {

        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;

      }

      if ( material.id !== _currentMaterialId ) {

        _currentMaterialId = material.id;

        refreshMaterial = true;

      }

      if ( refreshProgram || camera !== _currentCamera ) {

        p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

        if ( capabilities.logarithmicDepthBuffer ) {

          p_uniforms.setValue( _gl, 'logDepthBufFC',
            2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

        }

        // Avoid unneeded uniform updates per ArrayCamera's sub-camera

        if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

          _currentCamera = ( _currentArrayCamera || camera );

          // lighting uniforms depend on the camera so enforce an update
          // now, in case this material supports lights - or later, when
          // the next material that does gets activated:

          refreshMaterial = true;   // set to true on material change
          refreshLights = true;   // remains set until update done

        }

        // load material specific uniforms
        // (shader material also gets them for the sake of genericity)

        if ( material.isShaderMaterial ||
          material.isMeshPhongMaterial ||
          material.isMeshStandardMaterial ||
          material.envMap ) {

          var uCamPos = p_uniforms.map.cameraPosition;

          if ( uCamPos !== undefined ) {

            uCamPos.setValue( _gl,
              _vector3.setFromMatrixPosition( camera.matrixWorld ) );

          }

        }

        if ( material.isMeshPhongMaterial ||
          material.isMeshLambertMaterial ||
          material.isMeshBasicMaterial ||
          material.isMeshStandardMaterial ||
          material.isShaderMaterial ||
          material.skinning ) {

          p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

        }

      }

      // skinning uniforms must be set even if material didn't change
      // auto-setting of texture unit for bone texture must go before other textures
      // not sure why, but otherwise weird things happen

      if ( material.skinning ) {

        p_uniforms.setOptional( _gl, object, 'bindMatrix' );
        p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

        var skeleton = object.skeleton;

        if ( skeleton ) {

          var bones = skeleton.bones;

          if ( capabilities.floatVertexTextures ) {

            if ( skeleton.boneTexture === undefined ) {

              // layout (1 matrix = 4 pixels)
              //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
              //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
              //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
              //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
              //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


              var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
              size = _Math.ceilPowerOfTwo( size );
              size = Math.max( size, 4 );

              var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
              boneMatrices.set( skeleton.boneMatrices ); // copy current values

              var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size;

            }

            p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
            p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

          } else {

            p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

          }

        }

      }

      if ( refreshMaterial ) {

        p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
        p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

        if ( material.lights ) {

          // the current material requires lighting info

          // note: all lighting uniforms are always set correctly
          // they simply reference the renderer's state for their
          // values
          //
          // use the current material's .needsUpdate flags to set
          // the GL state when required

          markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

        }

        // refresh uniforms common to several materials

        if ( fog && material.fog ) {

          refreshUniformsFog( m_uniforms, fog );

        }

        if ( material.isMeshBasicMaterial ) {

          refreshUniformsCommon( m_uniforms, material );

        } else if ( material.isMeshLambertMaterial ) {

          refreshUniformsCommon( m_uniforms, material );
          refreshUniformsLambert( m_uniforms, material );

        } else if ( material.isMeshPhongMaterial ) {

          refreshUniformsCommon( m_uniforms, material );

          if ( material.isMeshToonMaterial ) {

            refreshUniformsToon( m_uniforms, material );

          } else {

            refreshUniformsPhong( m_uniforms, material );

          }

        } else if ( material.isMeshStandardMaterial ) {

          refreshUniformsCommon( m_uniforms, material );

          if ( material.isMeshPhysicalMaterial ) {

            refreshUniformsPhysical( m_uniforms, material );

          } else {

            refreshUniformsStandard( m_uniforms, material );

          }

        } else if ( material.isMeshDepthMaterial ) {

          refreshUniformsCommon( m_uniforms, material );
          refreshUniformsDepth( m_uniforms, material );

        } else if ( material.isMeshDistanceMaterial ) {

          refreshUniformsCommon( m_uniforms, material );
          refreshUniformsDistance( m_uniforms, material );

        } else if ( material.isMeshNormalMaterial ) {

          refreshUniformsCommon( m_uniforms, material );
          refreshUniformsNormal( m_uniforms, material );

        } else if ( material.isLineBasicMaterial ) {

          refreshUniformsLine( m_uniforms, material );

          if ( material.isLineDashedMaterial ) {

            refreshUniformsDash( m_uniforms, material );

          }

        } else if ( material.isPointsMaterial ) {

          refreshUniformsPoints( m_uniforms, material );

        } else if ( material.isShadowMaterial ) {

          m_uniforms.color.value = material.color;
          m_uniforms.opacity.value = material.opacity;

        }

        // RectAreaLight Texture
        // TODO (mrdoob): Find a nicer implementation

        if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
        if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

        WebGLUniforms.upload(
          _gl, materialProperties.uniformsList, m_uniforms, _this );

      }


      // common matrices

      p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
      p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
      p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

      return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon( uniforms, material ) {

      uniforms.opacity.value = material.opacity;

      if ( material.color ) {

        uniforms.diffuse.value = material.color;

      }

      if ( material.emissive ) {

        uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

      }

      if ( material.map ) {

        uniforms.map.value = material.map;

      }

      if ( material.alphaMap ) {

        uniforms.alphaMap.value = material.alphaMap;

      }

      if ( material.specularMap ) {

        uniforms.specularMap.value = material.specularMap;

      }

      if ( material.envMap ) {

        uniforms.envMap.value = material.envMap;

        // don't flip CubeTexture envMaps, flip everything else:
        //  WebGLRenderTargetCube will be flipped for backwards compatibility
        //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
        // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
        uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

      }

      if ( material.lightMap ) {

        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;

      }

      if ( material.aoMap ) {

        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;

      }

      // uv repeat and offset setting priorities
      // 1. color map
      // 2. specular map
      // 3. normal map
      // 4. bump map
      // 5. alpha map
      // 6. emissive map

      var uvScaleMap;

      if ( material.map ) {

        uvScaleMap = material.map;

      } else if ( material.specularMap ) {

        uvScaleMap = material.specularMap;

      } else if ( material.displacementMap ) {

        uvScaleMap = material.displacementMap;

      } else if ( material.normalMap ) {

        uvScaleMap = material.normalMap;

      } else if ( material.bumpMap ) {

        uvScaleMap = material.bumpMap;

      } else if ( material.roughnessMap ) {

        uvScaleMap = material.roughnessMap;

      } else if ( material.metalnessMap ) {

        uvScaleMap = material.metalnessMap;

      } else if ( material.alphaMap ) {

        uvScaleMap = material.alphaMap;

      } else if ( material.emissiveMap ) {

        uvScaleMap = material.emissiveMap;

      }

      if ( uvScaleMap !== undefined ) {

        // backwards compatibility
        if ( uvScaleMap.isWebGLRenderTarget ) {

          uvScaleMap = uvScaleMap.texture;

        }

        if ( uvScaleMap.matrixAutoUpdate === true ) {

          var offset = uvScaleMap.offset;
          var repeat = uvScaleMap.repeat;
          var rotation = uvScaleMap.rotation;
          var center = uvScaleMap.center;

          uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

        }

        uniforms.uvTransform.value.copy( uvScaleMap.matrix );

      }

    }

    function refreshUniformsLine( uniforms, material ) {

      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash( uniforms, material ) {

      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;

    }

    function refreshUniformsPoints( uniforms, material ) {

      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * _pixelRatio;
      uniforms.scale.value = _height * 0.5;

      uniforms.map.value = material.map;

      if ( material.map !== null ) {

        if ( material.map.matrixAutoUpdate === true ) {

          var offset = material.map.offset;
          var repeat = material.map.repeat;
          var rotation = material.map.rotation;
          var center = material.map.center;

          material.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

        }

        uniforms.uvTransform.value.copy( material.map.matrix );

      }

    }

    function refreshUniformsFog( uniforms, fog ) {

      uniforms.fogColor.value = fog.color;

      if ( fog.isFog ) {

        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;

      } else if ( fog.isFogExp2 ) {

        uniforms.fogDensity.value = fog.density;

      }

    }

    function refreshUniformsLambert( uniforms, material ) {

      if ( material.emissiveMap ) {

        uniforms.emissiveMap.value = material.emissiveMap;

      }

    }

    function refreshUniformsPhong( uniforms, material ) {

      uniforms.specular.value = material.specular;
      uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

      if ( material.emissiveMap ) {

        uniforms.emissiveMap.value = material.emissiveMap;

      }

      if ( material.bumpMap ) {

        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;

      }

      if ( material.normalMap ) {

        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy( material.normalScale );

      }

      if ( material.displacementMap ) {

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

      }

    }

    function refreshUniformsToon( uniforms, material ) {

      refreshUniformsPhong( uniforms, material );

      if ( material.gradientMap ) {

        uniforms.gradientMap.value = material.gradientMap;

      }

    }

    function refreshUniformsStandard( uniforms, material ) {

      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;

      if ( material.roughnessMap ) {

        uniforms.roughnessMap.value = material.roughnessMap;

      }

      if ( material.metalnessMap ) {

        uniforms.metalnessMap.value = material.metalnessMap;

      }

      if ( material.emissiveMap ) {

        uniforms.emissiveMap.value = material.emissiveMap;

      }

      if ( material.bumpMap ) {

        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;

      }

      if ( material.normalMap ) {

        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy( material.normalScale );

      }

      if ( material.displacementMap ) {

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

      }

      if ( material.envMap ) {

        //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;

      }

    }

    function refreshUniformsPhysical( uniforms, material ) {

      uniforms.clearCoat.value = material.clearCoat;
      uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

      refreshUniformsStandard( uniforms, material );

    }

    function refreshUniformsDepth( uniforms, material ) {

      if ( material.displacementMap ) {

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

      }

    }

    function refreshUniformsDistance( uniforms, material ) {

      if ( material.displacementMap ) {

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

      }

      uniforms.referencePosition.value.copy( material.referencePosition );
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;

    }

    function refreshUniformsNormal( uniforms, material ) {

      if ( material.bumpMap ) {

        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;

      }

      if ( material.normalMap ) {

        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy( material.normalScale );

      }

      if ( material.displacementMap ) {

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

      }

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate( uniforms, value ) {

      uniforms.ambientLightColor.needsUpdate = value;

      uniforms.directionalLights.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;

    }

    // GL state setting

    this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

      state.setCullFace( cullFace );
      state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

    };

    // Textures

    function allocTextureUnit() {

      var textureUnit = _usedTextureUnits;

      if ( textureUnit >= capabilities.maxTextures ) {

        console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

      }

      _usedTextureUnits += 1;

      return textureUnit;

    }

    this.allocTextureUnit = allocTextureUnit;

    // this.setTexture2D = setTexture2D;
    this.setTexture2D = ( function () {

      var warned = false;

      // backwards compatibility: peel texture.texture
      return function setTexture2D( texture, slot ) {

        if ( texture && texture.isWebGLRenderTarget ) {

          if ( ! warned ) {

            console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
            warned = true;

          }

          texture = texture.texture;

        }

        textures.setTexture2D( texture, slot );

      };

    }() );

    this.setTexture = ( function () {

      var warned = false;

      return function setTexture( texture, slot ) {

        if ( ! warned ) {

          console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
          warned = true;

        }

        textures.setTexture2D( texture, slot );

      };

    }() );

    this.setTextureCube = ( function () {

      var warned = false;

      return function setTextureCube( texture, slot ) {

        // backwards compatibility: peel texture.texture
        if ( texture && texture.isWebGLRenderTargetCube ) {

          if ( ! warned ) {

            console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
            warned = true;

          }

          texture = texture.texture;

        }

        // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
        // TODO: unify these code paths
        if ( ( texture && texture.isCubeTexture ) ||
          ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

          // CompressedTexture can have Array in image :/

          // this function alone should take care of cube textures
          textures.setTextureCube( texture, slot );

        } else {

          // assumed: texture property of THREE.WebGLRenderTargetCube

          textures.setTextureCubeDynamic( texture, slot );

        }

      };

    }() );

    this.getRenderTarget = function () {

      return _currentRenderTarget;

    };

    this.setRenderTarget = function ( renderTarget ) {

      _currentRenderTarget = renderTarget;

      if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

        textures.setupRenderTarget( renderTarget );

      }

      var framebuffer = null;
      var isCube = false;

      if ( renderTarget ) {

        var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

        if ( renderTarget.isWebGLRenderTargetCube ) {

          framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
          isCube = true;

        } else {

          framebuffer = __webglFramebuffer;

        }

        _currentViewport.copy( renderTarget.viewport );
        _currentScissor.copy( renderTarget.scissor );
        _currentScissorTest = renderTarget.scissorTest;

      } else {

        _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
        _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
        _currentScissorTest = _scissorTest;

      }

      if ( _currentFramebuffer !== framebuffer ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _currentFramebuffer = framebuffer;

      }

      state.viewport( _currentViewport );
      state.scissor( _currentScissor );
      state.setScissorTest( _currentScissorTest );

      if ( isCube ) {

        var textureProperties = properties.get( renderTarget.texture );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

      }

    };

    this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

      if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
        return;

      }

      var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

      if ( framebuffer ) {

        var restore = false;

        if ( framebuffer !== _currentFramebuffer ) {

          _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

          restore = true;

        }

        try {

          var texture = renderTarget.texture;
          var textureFormat = texture.format;
          var textureType = texture.type;

          if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
            return;

          }

          if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
            ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
            ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
            return;

          }

          if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

            // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

            if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

              _gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

            }

          } else {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

          }

        } finally {

          if ( restore ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

          }

        }

      }

    };

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function FogExp2( color, density ) {

    this.name = '';

    this.color = new Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

  }

  FogExp2.prototype.isFogExp2 = true;

  FogExp2.prototype.clone = function () {

    return new FogExp2( this.color.getHex(), this.density );

  };

  FogExp2.prototype.toJSON = function ( /* meta */ ) {

    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Fog( color, near, far ) {

    this.name = '';

    this.color = new Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

  }

  Fog.prototype.isFog = true;

  Fog.prototype.clone = function () {

    return new Fog( this.color.getHex(), this.near, this.far );

  };

  Fog.prototype.toJSON = function ( /* meta */ ) {

    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Scene() {

    Object3D.call( this );

    this.type = 'Scene';

    this.background = null;
    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

  }

  Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Scene,

    copy: function ( source, recursive ) {

      Object3D.prototype.copy.call( this, source, recursive );

      if ( source.background !== null ) this.background = source.background.clone();
      if ( source.fog !== null ) this.fog = source.fog.clone();
      if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;

      return this;

    },

    toJSON: function ( meta ) {

      var data = Object3D.prototype.toJSON.call( this, meta );

      if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
      if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

      return data;

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function LensFlare( texture, size, distance, blending, color ) {

    Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

      this.add( texture, size, distance, blending, color );

    }

  }

  LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: LensFlare,

    isLensFlare: true,

    copy: function ( source ) {

      Object3D.prototype.copy.call( this, source );

      this.positionScreen.copy( source.positionScreen );
      this.customUpdateCallback = source.customUpdateCallback;

      for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

      }

      return this;

    },

    add: function ( texture, size, distance, blending, color, opacity ) {

      if ( size === undefined ) size = - 1;
      if ( distance === undefined ) distance = 0;
      if ( opacity === undefined ) opacity = 1;
      if ( color === undefined ) color = new Color( 0xffffff );
      if ( blending === undefined ) blending = NormalBlending;

      distance = Math.min( distance, Math.max( 0, distance ) );

      this.lensFlares.push( {
        texture: texture, // THREE.Texture
        size: size,     // size in pixels (-1 = use texture.width)
        distance: distance,   // distance (0-1) from light source (0=at light source)
        x: 0, y: 0, z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1,     // scale
        rotation: 0,    // rotation
        opacity: opacity, // opacity
        color: color,   // color
        blending: blending  // blending
      } );

    },

    /*
     * Update lens flares update positions on all flares based on the screen position
     * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
     */

    updateLensFlares: function () {

      var f, fl = this.lensFlares.length;
      var flare;
      var vecX = - this.positionScreen.x * 2;
      var vecY = - this.positionScreen.y * 2;

      for ( f = 0; f < fl; f ++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

      }

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  uvOffset: new THREE.Vector2(),
   *  uvScale: new THREE.Vector2()
   * }
   */

  function SpriteMaterial( parameters ) {

    Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;
    this.lights = false;

    this.setValues( parameters );

  }

  SpriteMaterial.prototype = Object.create( Material.prototype );
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;

  SpriteMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    return this;

  };

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function Sprite( material ) {

    Object3D.call( this );

    this.type = 'Sprite';

    this.material = ( material !== undefined ) ? material : new SpriteMaterial();

  }

  Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Sprite,

    isSprite: true,

    raycast: ( function () {

      var intersectPoint = new Vector3();
      var worldPosition = new Vector3();
      var worldScale = new Vector3();

      return function raycast( raycaster, intersects ) {

        worldPosition.setFromMatrixPosition( this.matrixWorld );
        raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

        worldScale.setFromMatrixScale( this.matrixWorld );
        var guessSizeSq = worldScale.x * worldScale.y / 4;

        if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) return;

        intersects.push( {

          distance: distance,
          point: intersectPoint.clone(),
          face: null,
          object: this

        } );

      };

    }() ),

    clone: function () {

      return new this.constructor( this.material ).copy( this );

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function LOD() {

    Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
      levels: {
        enumerable: true,
        value: []
      }
    } );

  }

  LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: LOD,

    copy: function ( source ) {

      Object3D.prototype.copy.call( this, source, false );

      var levels = source.levels;

      for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

      }

      return this;

    },

    addLevel: function ( object, distance ) {

      if ( distance === undefined ) distance = 0;

      distance = Math.abs( distance );

      var levels = this.levels;

      for ( var l = 0; l < levels.length; l ++ ) {

        if ( distance < levels[ l ].distance ) {

          break;

        }

      }

      levels.splice( l, 0, { distance: distance, object: object } );

      this.add( object );

    },

    getObjectForDistance: function ( distance ) {

      var levels = this.levels;

      for ( var i = 1, l = levels.length; i < l; i ++ ) {

        if ( distance < levels[ i ].distance ) {

          break;

        }

      }

      return levels[ i - 1 ].object;

    },

    raycast: ( function () {

      var matrixPosition = new Vector3();

      return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

      };

    }() ),

    update: function () {

      var v1 = new Vector3();
      var v2 = new Vector3();

      return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

          v1.setFromMatrixPosition( camera.matrixWorld );
          v2.setFromMatrixPosition( this.matrixWorld );

          var distance = v1.distanceTo( v2 );

          levels[ 0 ].object.visible = true;

          for ( var i = 1, l = levels.length; i < l; i ++ ) {

            if ( distance >= levels[ i ].distance ) {

              levels[ i - 1 ].object.visible = false;
              levels[ i ].object.visible = true;

            } else {

              break;

            }

          }

          for ( ; i < l; i ++ ) {

            levels[ i ].object.visible = false;

          }

        }

      };

    }(),

    toJSON: function ( meta ) {

      var data = Object3D.prototype.toJSON.call( this, meta );

      data.object.levels = [];

      var levels = this.levels;

      for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
          object: level.object.uuid,
          distance: level.distance
        } );

      }

      return data;

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */

  function Skeleton( bones, boneInverses ) {

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );
    this.boneMatrices = new Float32Array( this.bones.length * 16 );

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

      this.calculateInverses();

    } else {

      if ( this.bones.length === boneInverses.length ) {

        this.boneInverses = boneInverses.slice( 0 );

      } else {

        console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

        this.boneInverses = [];

        for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

          this.boneInverses.push( new Matrix4() );

        }

      }

    }

  }

  Object.assign( Skeleton.prototype, {

    calculateInverses: function () {

      this.boneInverses = [];

      for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

        var inverse = new Matrix4();

        if ( this.bones[ i ] ) {

          inverse.getInverse( this.bones[ i ].matrixWorld );

        }

        this.boneInverses.push( inverse );

      }

    },

    pose: function () {

      var bone, i, il;

      // recover the bind-time world matrices

      for ( i = 0, il = this.bones.length; i < il; i ++ ) {

        bone = this.bones[ i ];

        if ( bone ) {

          bone.matrixWorld.getInverse( this.boneInverses[ i ] );

        }

      }

      // compute the local matrices, positions, rotations and scales

      for ( i = 0, il = this.bones.length; i < il; i ++ ) {

        bone = this.bones[ i ];

        if ( bone ) {

          if ( bone.parent && bone.parent.isBone ) {

            bone.matrix.getInverse( bone.parent.matrixWorld );
            bone.matrix.multiply( bone.matrixWorld );

          } else {

            bone.matrix.copy( bone.matrixWorld );

          }

          bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

      }

    },

    update: ( function () {

      var offsetMatrix = new Matrix4();
      var identityMatrix = new Matrix4();

      return function update() {

        var bones = this.bones;
        var boneInverses = this.boneInverses;
        var boneMatrices = this.boneMatrices;
        var boneTexture = this.boneTexture;

        // flatten bone matrices to array

        for ( var i = 0, il = bones.length; i < il; i ++ ) {

          // compute the offset between the current and the original transform

          var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

          offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
          offsetMatrix.toArray( boneMatrices, i * 16 );

        }

        if ( boneTexture !== undefined ) {

          boneTexture.needsUpdate = true;

        }

      };

    } )(),

    clone: function () {

      return new Skeleton( this.bones, this.boneInverses );

    }

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function Bone() {

    Object3D.call( this );

    this.type = 'Bone';

  }

  Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Bone,

    isBone: true

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function SkinnedMesh( geometry, material ) {

    Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();

    var bones = this.initBones();
    var skeleton = new Skeleton( bones );

    this.bind( skeleton, this.matrixWorld );

    this.normalizeSkinWeights();

  }

  SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

    constructor: SkinnedMesh,

    isSkinnedMesh: true,

    initBones: function () {

      var bones = [], bone, gbone;
      var i, il;

      if ( this.geometry && this.geometry.bones !== undefined ) {

        // first, create array of 'Bone' objects from geometry data

        for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

          gbone = this.geometry.bones[ i ];

          // create new 'Bone' object

          bone = new Bone();
          bones.push( bone );

          // apply values

          bone.name = gbone.name;
          bone.position.fromArray( gbone.pos );
          bone.quaternion.fromArray( gbone.rotq );
          if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        // second, create bone hierarchy

        for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

          gbone = this.geometry.bones[ i ];

          if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

            // subsequent bones in the hierarchy

            bones[ gbone.parent ].add( bones[ i ] );

          } else {

            // topmost bone, immediate child of the skinned mesh

            this.add( bones[ i ] );

          }

        }

      }

      // now the bones are part of the scene graph and children of the skinned mesh.
      // let's update the corresponding matrices

      this.updateMatrixWorld( true );

      return bones;

    },

    bind: function ( skeleton, bindMatrix ) {

      this.skeleton = skeleton;

      if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

      }

      this.bindMatrix.copy( bindMatrix );
      this.bindMatrixInverse.getInverse( bindMatrix );

    },

    pose: function () {

      this.skeleton.pose();

    },

    normalizeSkinWeights: function () {

      var scale, i;

      if ( this.geometry && this.geometry.isGeometry ) {

        for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

          var sw = this.geometry.skinWeights[ i ];

          scale = 1.0 / sw.lengthManhattan();

          if ( scale !== Infinity ) {

            sw.multiplyScalar( scale );

          } else {

            sw.set( 1, 0, 0, 0 ); // do something reasonable

          }

        }

      } else if ( this.geometry && this.geometry.isBufferGeometry ) {

        var vec = new Vector4();

        var skinWeight = this.geometry.attributes.skinWeight;

        for ( i = 0; i < skinWeight.count; i ++ ) {

          vec.x = skinWeight.getX( i );
          vec.y = skinWeight.getY( i );
          vec.z = skinWeight.getZ( i );
          vec.w = skinWeight.getW( i );

          scale = 1.0 / vec.lengthManhattan();

          if ( scale !== Infinity ) {

            vec.multiplyScalar( scale );

          } else {

            vec.set( 1, 0, 0, 0 ); // do something reasonable

          }

          skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

        }

      }

    },

    updateMatrixWorld: function ( force ) {

      Mesh.prototype.updateMatrixWorld.call( this, force );

      if ( this.bindMode === 'attached' ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

      } else if ( this.bindMode === 'detached' ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

      } else {

        console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

      }

    },

    clone: function () {

      return new this.constructor( this.geometry, this.material ).copy( this );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  function LineBasicMaterial( parameters ) {

    Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.lights = false;

    this.setValues( parameters );

  }

  LineBasicMaterial.prototype = Object.create( Material.prototype );
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;

  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  LineBasicMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Line( geometry, material, mode ) {

    if ( mode === 1 ) {

      console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
      return new LineSegments( geometry, material );

    }

    Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

  }

  Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Line,

    isLine: true,

    raycast: ( function () {

      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();

      return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( matrixWorld );

        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

        //

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new Vector3();
        var vEnd = new Vector3();
        var interSegment = new Vector3();
        var interRay = new Vector3();
        var step = ( this && this.isLineSegments ) ? 2 : 1;

        if ( geometry.isBufferGeometry ) {

          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;

          if ( index !== null ) {

            var indices = index.array;

            for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

              var a = indices[ i ];
              var b = indices[ i + 1 ];

              vStart.fromArray( positions, a * 3 );
              vEnd.fromArray( positions, b * 3 );

              var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

              if ( distSq > precisionSq ) continue;

              interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

              var distance = raycaster.ray.origin.distanceTo( interRay );

              if ( distance < raycaster.near || distance > raycaster.far ) continue;

              intersects.push( {

                distance: distance,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                index: i,
                face: null,
                faceIndex: null,
                object: this

              } );

            }

          } else {

            for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

              vStart.fromArray( positions, 3 * i );
              vEnd.fromArray( positions, 3 * i + 3 );

              var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

              if ( distSq > precisionSq ) continue;

              interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

              var distance = raycaster.ray.origin.distanceTo( interRay );

              if ( distance < raycaster.near || distance > raycaster.far ) continue;

              intersects.push( {

                distance: distance,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                index: i,
                face: null,
                faceIndex: null,
                object: this

              } );

            }

          }

        } else if ( geometry.isGeometry ) {

          var vertices = geometry.vertices;
          var nbVertices = vertices.length;

          for ( var i = 0; i < nbVertices - 1; i += step ) {

            var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

            if ( distSq > precisionSq ) continue;

            interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo( interRay );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4( this.matrixWorld ),
              index: i,
              face: null,
              faceIndex: null,
              object: this

            } );

          }

        }

      };

    }() ),

    clone: function () {

      return new this.constructor( this.geometry, this.material ).copy( this );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LineSegments( geometry, material ) {

    Line.call( this, geometry, material );

    this.type = 'LineSegments';

  }

  LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

    constructor: LineSegments,

    isLineSegments: true

  } );

  /**
   * @author mgreter / http://github.com/mgreter
   */

  function LineLoop( geometry, material ) {

    Line.call( this, geometry, material );

    this.type = 'LineLoop';

  }

  LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

    constructor: LineLoop,

    isLineLoop: true,

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  function PointsMaterial( parameters ) {

    Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.lights = false;

    this.setValues( parameters );

  }

  PointsMaterial.prototype = Object.create( Material.prototype );
  PointsMaterial.prototype.constructor = PointsMaterial;

  PointsMaterial.prototype.isPointsMaterial = true;

  PointsMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Points( geometry, material ) {

    Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

  }

  Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Points,

    isPoints: true,

    raycast: ( function () {

      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();

      return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( matrixWorld );
        sphere.radius += threshold;

        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

        //

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new Vector3();

        function testPoint( point, index ) {

          var rayPointDistanceSq = ray.distanceSqToPoint( point );

          if ( rayPointDistanceSq < localThresholdSq ) {

            var intersectPoint = ray.closestPointToPoint( point );
            intersectPoint.applyMatrix4( matrixWorld );

            var distance = raycaster.ray.origin.distanceTo( intersectPoint );

            if ( distance < raycaster.near || distance > raycaster.far ) return;

            intersects.push( {

              distance: distance,
              distanceToRay: Math.sqrt( rayPointDistanceSq ),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object

            } );

          }

        }

        if ( geometry.isBufferGeometry ) {

          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;

          if ( index !== null ) {

            var indices = index.array;

            for ( var i = 0, il = indices.length; i < il; i ++ ) {

              var a = indices[ i ];

              position.fromArray( positions, a * 3 );

              testPoint( position, a );

            }

          } else {

            for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

              position.fromArray( positions, i * 3 );

              testPoint( position, i );

            }

          }

        } else {

          var vertices = geometry.vertices;

          for ( var i = 0, l = vertices.length; i < l; i ++ ) {

            testPoint( vertices[ i ], i );

          }

        }

      };

    }() ),

    clone: function () {

      return new this.constructor( this.geometry, this.material ).copy( this );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Group() {

    Object3D.call( this );

    this.type = 'Group';

  }

  Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Group

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    function update() {

      if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

        scope.needsUpdate = true;

      }

      requestAnimationFrame( update );

    }

    requestAnimationFrame( update );

  }

  VideoTexture.prototype = Object.create( Texture.prototype );
  VideoTexture.prototype.constructor = VideoTexture;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    this.image = { width: width, height: height };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

  }

  CompressedTexture.prototype = Object.create( Texture.prototype );
  CompressedTexture.prototype.constructor = CompressedTexture;

  CompressedTexture.prototype.isCompressedTexture = true;

  /**
   * @author Matt DesLauriers / @mattdesl
   * @author atix / arthursilber.de
   */

  function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    format = format !== undefined ? format : DepthFormat;

    if ( format !== DepthFormat && format !== DepthStencilFormat ) {

      throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

    }

    if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
    if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = { width: width, height: height };

    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    this.flipY = false;
    this.generateMipmaps  = false;

  }

  DepthTexture.prototype = Object.create( Texture.prototype );
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WireframeGeometry( geometry ) {

    BufferGeometry.call( this );

    this.type = 'WireframeGeometry';

    // buffer

    var vertices = [];

    // helper variables

    var i, j, l, o, ol;
    var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
    var key, keys = [ 'a', 'b', 'c' ];
    var vertex;

    // different logic for Geometry and BufferGeometry

    if ( geometry && geometry.isGeometry ) {

      // create a data structure that contains all edges without duplicates

      var faces = geometry.faces;

      for ( i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( j = 0; j < 3; j ++ ) {

          edge1 = face[ keys[ j ] ];
          edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
          edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
          edge[ 1 ] = Math.max( edge1, edge2 );

          key = edge[ 0 ] + ',' + edge[ 1 ];

          if ( edges[ key ] === undefined ) {

            edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

          }

        }

      }

      // generate vertices

      for ( key in edges ) {

        e = edges[ key ];

        vertex = geometry.vertices[ e.index1 ];
        vertices.push( vertex.x, vertex.y, vertex.z );

        vertex = geometry.vertices[ e.index2 ];
        vertices.push( vertex.x, vertex.y, vertex.z );

      }

    } else if ( geometry && geometry.isBufferGeometry ) {

      var position, indices, groups;
      var group, start, count;
      var index1, index2;

      vertex = new Vector3();

      if ( geometry.index !== null ) {

        // indexed BufferGeometry

        position = geometry.attributes.position;
        indices = geometry.index;
        groups = geometry.groups;

        if ( groups.length === 0 ) {

          groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

        }

        // create a data structure that contains all eges without duplicates

        for ( o = 0, ol = groups.length; o < ol; ++ o ) {

          group = groups[ o ];

          start = group.start;
          count = group.count;

          for ( i = start, l = ( start + count ); i < l; i += 3 ) {

            for ( j = 0; j < 3; j ++ ) {

              edge1 = indices.getX( i + j );
              edge2 = indices.getX( i + ( j + 1 ) % 3 );
              edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
              edge[ 1 ] = Math.max( edge1, edge2 );

              key = edge[ 0 ] + ',' + edge[ 1 ];

              if ( edges[ key ] === undefined ) {

                edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

              }

            }

          }

        }

        // generate vertices

        for ( key in edges ) {

          e = edges[ key ];

          vertex.fromBufferAttribute( position, e.index1 );
          vertices.push( vertex.x, vertex.y, vertex.z );

          vertex.fromBufferAttribute( position, e.index2 );
          vertices.push( vertex.x, vertex.y, vertex.z );

        }

      } else {

        // non-indexed BufferGeometry

        position = geometry.attributes.position;

        for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

          for ( j = 0; j < 3; j ++ ) {

            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

            index1 = 3 * i + j;
            vertex.fromBufferAttribute( position, index1 );
            vertices.push( vertex.x, vertex.y, vertex.z );

            index2 = 3 * i + ( ( j + 1 ) % 3 );
            vertex.fromBufferAttribute( position, index2 );
            vertices.push( vertex.x, vertex.y, vertex.z );

          }

        }

      }

    }

    // build geometry

    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
  WireframeGeometry.prototype.constructor = WireframeGeometry;

  /**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
   */

  // ParametricGeometry

  function ParametricGeometry( func, slices, stacks ) {

    Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    };

    this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
    this.mergeVertices();

  }

  ParametricGeometry.prototype = Object.create( Geometry.prototype );
  ParametricGeometry.prototype.constructor = ParametricGeometry;

  // ParametricBufferGeometry

  function ParametricBufferGeometry( func, slices, stacks ) {

    BufferGeometry.call( this );

    this.type = 'ParametricBufferGeometry';

    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    };

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    var EPS = 0.00001;

    var normal = new Vector3();

    var p0 = new Vector3(), p1 = new Vector3();
    var pu = new Vector3(), pv = new Vector3();

    var i, j;

    // generate vertices, normals and uvs

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i ++ ) {

      var v = i / stacks;

      for ( j = 0; j <= slices; j ++ ) {

        var u = j / slices;

        // vertex

        p0 = func( u, v, p0 );
        vertices.push( p0.x, p0.y, p0.z );

        // normal

        // approximate tangent vectors via finite differences

        if ( u - EPS >= 0 ) {

          p1 = func( u - EPS, v, p1 );
          pu.subVectors( p0, p1 );

        } else {

          p1 = func( u + EPS, v, p1 );
          pu.subVectors( p1, p0 );

        }

        if ( v - EPS >= 0 ) {

          p1 = func( u, v - EPS, p1 );
          pv.subVectors( p0, p1 );

        } else {

          p1 = func( u, v + EPS, p1 );
          pv.subVectors( p1, p0 );

        }

        // cross product of tangent vectors returns surface normal

        normal.crossVectors( pu, pv ).normalize();
        normals.push( normal.x, normal.y, normal.z );

        // uv

        uvs.push( u, v );

      }

    }

    // generate indices

    for ( i = 0; i < stacks; i ++ ) {

      for ( j = 0; j < slices; j ++ ) {

        var a = i * sliceCount + j;
        var b = i * sliceCount + j + 1;
        var c = ( i + 1 ) * sliceCount + j + 1;
        var d = ( i + 1 ) * sliceCount + j;

        // faces one and two

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  /**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PolyhedronGeometry

  function PolyhedronGeometry( vertices, indices, radius, detail ) {

    Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };

    this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
    this.mergeVertices();

  }

  PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

    BufferGeometry.call( this );

    this.type = 'PolyhedronBufferGeometry';

    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    // default buffer data

    var vertexBuffer = [];
    var uvBuffer = [];

    // the subdivision creates the vertex buffer data

    subdivide( detail );

    // all vertices should lie on a conceptual sphere with a given radius

    appplyRadius( radius );

    // finally, create the uv data

    generateUVs();

    // build non-indexed geometry

    this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

    if ( detail === 0 ) {

      this.computeVertexNormals(); // flat normals

    } else {

      this.normalizeNormals(); // smooth normals

    }

    // helper functions

    function subdivide( detail ) {

      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();

      // iterate over all faces and apply a subdivison with the given detail value

      for ( var i = 0; i < indices.length; i += 3 ) {

        // get the vertices of the face

        getVertexByIndex( indices[ i + 0 ], a );
        getVertexByIndex( indices[ i + 1 ], b );
        getVertexByIndex( indices[ i + 2 ], c );

        // perform subdivision

        subdivideFace( a, b, c, detail );

      }

    }

    function subdivideFace( a, b, c, detail ) {

      var cols = Math.pow( 2, detail );

      // we use this multidimensional array as a data structure for creating the subdivision

      var v = [];

      var i, j;

      // construct all of the vertices for this subdivision

      for ( i = 0; i <= cols; i ++ ) {

        v[ i ] = [];

        var aj = a.clone().lerp( c, i / cols );
        var bj = b.clone().lerp( c, i / cols );

        var rows = cols - i;

        for ( j = 0; j <= rows; j ++ ) {

          if ( j === 0 && i === cols ) {

            v[ i ][ j ] = aj;

          } else {

            v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

          }

        }

      }

      // construct all of the faces

      for ( i = 0; i < cols; i ++ ) {

        for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

          var k = Math.floor( j / 2 );

          if ( j % 2 === 0 ) {

            pushVertex( v[ i ][ k + 1 ] );
            pushVertex( v[ i + 1 ][ k ] );
            pushVertex( v[ i ][ k ] );

          } else {

            pushVertex( v[ i ][ k + 1 ] );
            pushVertex( v[ i + 1 ][ k + 1 ] );
            pushVertex( v[ i + 1 ][ k ] );

          }

        }

      }

    }

    function appplyRadius( radius ) {

      var vertex = new Vector3();

      // iterate over the entire buffer and apply the radius to each vertex

      for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

        vertex.x = vertexBuffer[ i + 0 ];
        vertex.y = vertexBuffer[ i + 1 ];
        vertex.z = vertexBuffer[ i + 2 ];

        vertex.normalize().multiplyScalar( radius );

        vertexBuffer[ i + 0 ] = vertex.x;
        vertexBuffer[ i + 1 ] = vertex.y;
        vertexBuffer[ i + 2 ] = vertex.z;

      }

    }

    function generateUVs() {

      var vertex = new Vector3();

      for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

        vertex.x = vertexBuffer[ i + 0 ];
        vertex.y = vertexBuffer[ i + 1 ];
        vertex.z = vertexBuffer[ i + 2 ];

        var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
        var v = inclination( vertex ) / Math.PI + 0.5;
        uvBuffer.push( u, 1 - v );

      }

      correctUVs();

      correctSeam();

    }

    function correctSeam() {

      // handle case when face straddles the seam, see #3269

      for ( var i = 0; i < uvBuffer.length; i += 6 ) {

        // uv data of a single face

        var x0 = uvBuffer[ i + 0 ];
        var x1 = uvBuffer[ i + 2 ];
        var x2 = uvBuffer[ i + 4 ];

        var max = Math.max( x0, x1, x2 );
        var min = Math.min( x0, x1, x2 );

        // 0.9 is somewhat arbitrary

        if ( max > 0.9 && min < 0.1 ) {

          if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
          if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
          if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

        }

      }

    }

    function pushVertex( vertex ) {

      vertexBuffer.push( vertex.x, vertex.y, vertex.z );

    }

    function getVertexByIndex( index, vertex ) {

      var stride = index * 3;

      vertex.x = vertices[ stride + 0 ];
      vertex.y = vertices[ stride + 1 ];
      vertex.z = vertices[ stride + 2 ];

    }

    function correctUVs() {

      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();

      var centroid = new Vector3();

      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();

      for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

        a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
        b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
        c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

        uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
        uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
        uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

        centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

        var azi = azimuth( centroid );

        correctUV( uvA, j + 0, a, azi );
        correctUV( uvB, j + 2, b, azi );
        correctUV( uvC, j + 4, c, azi );

      }

    }

    function correctUV( uv, stride, vector, azimuth ) {

      if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

        uvBuffer[ stride ] = uv.x - 1;

      }

      if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

        uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

      }

    }

    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

      return Math.atan2( vector.z, - vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

      return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }

  }

  PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TetrahedronGeometry

  function TetrahedronGeometry( radius, detail ) {

    Geometry.call( this );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

    this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
    this.mergeVertices();

  }

  TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry( radius, detail ) {

    var vertices = [
      1, 1, 1,  - 1, - 1, 1,  - 1, 1, - 1,  1, - 1, - 1
    ];

    var indices = [
      2, 1, 0,  0, 3, 2,  1, 3, 0,  2, 3, 1
    ];

    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronBufferGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

  }

  TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // OctahedronGeometry

  function OctahedronGeometry( radius, detail ) {

    Geometry.call( this );

    this.type = 'OctahedronGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

    this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
    this.mergeVertices();

  }

  OctahedronGeometry.prototype = Object.create( Geometry.prototype );
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry( radius, detail ) {

    var vertices = [
      1, 0, 0,  - 1, 0, 0,  0, 1, 0,
      0, - 1, 0,  0, 0, 1,  0, 0, - 1
    ];

    var indices = [
      0, 2, 4,  0, 4, 3,  0, 3, 5,
      0, 5, 2,  1, 2, 5,  1, 5, 3,
      1, 3, 4,  1, 4, 2
    ];

    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronBufferGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

  }

  OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // IcosahedronGeometry

  function IcosahedronGeometry( radius, detail ) {

    Geometry.call( this );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

    this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
    this.mergeVertices();

  }

  IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [
      - 1, t, 0,    1, t, 0,  - 1, - t, 0,  1, - t, 0,
       0, - 1, t,   0, 1, t,  0, - 1, - t,  0, 1, - t,
       t, 0, - 1,   t, 0, 1,  - t, 0, - 1,  - t, 0, 1
    ];

    var indices = [
       0, 11, 5,  0, 5, 1,  0, 1, 7,  0, 7, 10,   0, 10, 11,
       1, 5, 9,   5, 11, 4, 11, 10, 2,  10, 7, 6, 7, 1, 8,
       3, 9, 4,   3, 4, 2,  3, 2, 6,  3, 6, 8,  3, 8, 9,
       4, 9, 5,   2, 4, 11, 6, 2, 10, 8, 6, 7,  9, 8, 1
    ];

    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronBufferGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

  }

  IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  /**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // DodecahedronGeometry

  function DodecahedronGeometry( radius, detail ) {

    Geometry.call( this );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

    this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
    this.mergeVertices();

  }

  DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

      // (1, 1, 1)
      - 1, - 1, - 1,  - 1, - 1, 1,
      - 1, 1, - 1, - 1, 1, 1,
      1, - 1, - 1, 1, - 1, 1,
      1, 1, - 1, 1, 1, 1,

      // (0, 1/, )
       0, - r, - t, 0, - r, t,
       0, r, - t, 0, r, t,

      // (1/, , 0)
      - r, - t, 0, - r, t, 0,
       r, - t, 0, r, t, 0,

      // (, 0, 1/)
      - t, 0, - r, t, 0, - r,
      - t, 0, r, t, 0, r
    ];

    var indices = [
      3, 11, 7,   3, 7, 15,   3, 15, 13,
      7, 19, 17,  7, 17, 6,   7, 6, 15,
      17, 4, 8,   17, 8, 10,  17, 10, 6,
      8, 0, 16,   8, 16, 2,   8, 2, 10,
      0, 12, 1,   0, 1, 18,   0, 18, 16,
      6, 10, 2,   6, 2, 13,   6, 13, 15,
      2, 16, 18,  2, 18, 3,   2, 3, 13,
      18, 1, 9,   18, 9, 11,  18, 11, 3,
      4, 14, 12,  4, 12, 0,   4, 0, 8,
      11, 9, 5,   11, 5, 19,  11, 19, 7,
      19, 5, 14,  19, 14, 4,  19, 4, 17,
      1, 12, 14,  1, 14, 5,   1, 5, 9
    ];

    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronBufferGeometry';

    this.parameters = {
      radius: radius,
      detail: detail
    };

  }

  DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  /**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */

  // TubeGeometry

  function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

    Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };

    if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

    var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

    // expose internals

    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals;

    // create geometry

    this.fromBufferGeometry( bufferGeometry );
    this.mergeVertices();

  }

  TubeGeometry.prototype = Object.create( Geometry.prototype );
  TubeGeometry.prototype.constructor = TubeGeometry;

  // TubeBufferGeometry

  function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

    BufferGeometry.call( this );

    this.type = 'TubeBufferGeometry';

    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };

    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;

    var frames = path.computeFrenetFrames( tubularSegments, closed );

    // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;

    // helper variables

    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();

    var i, j;

    // buffer

    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    // create buffer data

    generateBufferData();

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    // functions

    function generateBufferData() {

      for ( i = 0; i < tubularSegments; i ++ ) {

        generateSegment( i );

      }

      // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

      generateSegment( ( closed === false ) ? tubularSegments : 0 );

      // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs();

      // finally create faces

      generateIndices();

    }

    function generateSegment( i ) {

      // we use getPointAt to sample evenly distributed points from the given path

      var P = path.getPointAt( i / tubularSegments );

      // retrieve corresponding normal and binormal

      var N = frames.normals[ i ];
      var B = frames.binormals[ i ];

      // generate normals and vertices for the current segment

      for ( j = 0; j <= radialSegments; j ++ ) {

        var v = j / radialSegments * Math.PI * 2;

        var sin = Math.sin( v );
        var cos = - Math.cos( v );

        // normal

        normal.x = ( cos * N.x + sin * B.x );
        normal.y = ( cos * N.y + sin * B.y );
        normal.z = ( cos * N.z + sin * B.z );
        normal.normalize();

        normals.push( normal.x, normal.y, normal.z );

        // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;

        vertices.push( vertex.x, vertex.y, vertex.z );

      }

    }

    function generateIndices() {

      for ( j = 1; j <= tubularSegments; j ++ ) {

        for ( i = 1; i <= radialSegments; i ++ ) {

          var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
          var b = ( radialSegments + 1 ) * j + ( i - 1 );
          var c = ( radialSegments + 1 ) * j + i;
          var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

          // faces

          indices.push( a, b, d );
          indices.push( b, c, d );

        }

      }

    }

    function generateUVs() {

      for ( i = 0; i <= tubularSegments; i ++ ) {

        for ( j = 0; j <= radialSegments; j ++ ) {

          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;

          uvs.push( uv.x, uv.y );

        }

      }

    }

  }

  TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  /**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */

  // TorusKnotGeometry

  function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

    Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };

    if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

    this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
    this.mergeVertices();

  }

  TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

    BufferGeometry.call( this );

    this.type = 'TorusKnotBufferGeometry';

    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };

    radius = radius || 100;
    tube = tube || 40;
    tubularSegments = Math.floor( tubularSegments ) || 64;
    radialSegments = Math.floor( radialSegments ) || 8;
    p = p || 2;
    q = q || 3;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var i, j;

    var vertex = new Vector3();
    var normal = new Vector3();

    var P1 = new Vector3();
    var P2 = new Vector3();

    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();

    // generate vertices, normals and uvs

    for ( i = 0; i <= tubularSegments; ++ i ) {

      // the radian "u" is used to calculate the position on the torus curve of the current tubular segement

      var u = i / tubularSegments * p * Math.PI * 2;

      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve( u, p, q, radius, P1 );
      calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

      // calculate orthonormal basis

      T.subVectors( P2, P1 );
      N.addVectors( P2, P1 );
      B.crossVectors( T, N );
      N.crossVectors( B, T );

      // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for ( j = 0; j <= radialSegments; ++ j ) {

        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

        var v = j / radialSegments * Math.PI * 2;
        var cx = - tube * Math.cos( v );
        var cy = tube * Math.sin( v );

        // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

        vertex.x = P1.x + ( cx * N.x + cy * B.x );
        vertex.y = P1.y + ( cx * N.y + cy * B.y );
        vertex.z = P1.z + ( cx * N.z + cy * B.z );

        vertices.push( vertex.x, vertex.y, vertex.z );

        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors( vertex, P1 ).normalize();

        normals.push( normal.x, normal.y, normal.z );

        // uv

        uvs.push( i / tubularSegments );
        uvs.push( j / radialSegments );

      }

    }

    // generate indices

    for ( j = 1; j <= tubularSegments; j ++ ) {

      for ( i = 1; i <= radialSegments; i ++ ) {

        // indices

        var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
        var b = ( radialSegments + 1 ) * j + ( i - 1 );
        var c = ( radialSegments + 1 ) * j + i;
        var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

        // faces

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    // this function calculates the current position on the torus curve

    function calculatePositionOnCurve( u, p, q, radius, position ) {

      var cu = Math.cos( u );
      var su = Math.sin( u );
      var quOverP = q / p * u;
      var cs = Math.cos( quOverP );

      position.x = radius * ( 2 + cs ) * 0.5 * cu;
      position.y = radius * ( 2 + cs ) * su * 0.5;
      position.z = radius * Math.sin( quOverP ) * 0.5;

    }

  }

  TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  /**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TorusGeometry

  function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };

    this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
    this.mergeVertices();

  }

  TorusGeometry.prototype = Object.create( Geometry.prototype );
  TorusGeometry.prototype.constructor = TorusGeometry;

  // TorusBufferGeometry

  function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    BufferGeometry.call( this );

    this.type = 'TorusBufferGeometry';

    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = Math.floor( radialSegments ) || 8;
    tubularSegments = Math.floor( tubularSegments ) || 6;
    arc = arc || Math.PI * 2;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();

    var j, i;

    // generate vertices, normals and uvs

    for ( j = 0; j <= radialSegments; j ++ ) {

      for ( i = 0; i <= tubularSegments; i ++ ) {

        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;

        // vertex

        vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
        vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
        vertex.z = tube * Math.sin( v );

        vertices.push( vertex.x, vertex.y, vertex.z );

        // normal

        center.x = radius * Math.cos( u );
        center.y = radius * Math.sin( u );
        normal.subVectors( vertex, center ).normalize();

        normals.push( normal.x, normal.y, normal.z );

        // uv

        uvs.push( i / tubularSegments );
        uvs.push( j / radialSegments );

      }

    }

    // generate indices

    for ( j = 1; j <= radialSegments; j ++ ) {

      for ( i = 1; i <= tubularSegments; i ++ ) {

        // indices

        var a = ( tubularSegments + 1 ) * j + i - 1;
        var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
        var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
        var d = ( tubularSegments + 1 ) * j + i;

        // faces

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  var ShapeUtils = {

    // calculate area of the contour polygon

    area: function ( contour ) {

      var n = contour.length;
      var a = 0.0;

      for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

        a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

      }

      return a * 0.5;

    },

    triangulate: ( function () {

      /**
       * This code is a quick port of code written in C++ which was submitted to
       * flipcode.com by John W. Ratcliff  // July 22, 2000
       * See original code and more information here:
       * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
       *
       * ported to actionscript by Zevan Rosser
       * www.actionsnippet.com
       *
       * ported to javascript by Joshua Koo
       * http://www.lab4games.net/zz85/blog
       *
       */

      function snip( contour, u, v, w, n, verts ) {

        var p;
        var ax, ay, bx, by;
        var cx, cy, px, py;

        ax = contour[ verts[ u ] ].x;
        ay = contour[ verts[ u ] ].y;

        bx = contour[ verts[ v ] ].x;
        by = contour[ verts[ v ] ].y;

        cx = contour[ verts[ w ] ].x;
        cy = contour[ verts[ w ] ].y;

        if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

        var aX, aY, bX, bY, cX, cY;
        var apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        aX = cx - bx; aY = cy - by;
        bX = ax - cx; bY = ay - cy;
        cX = bx - ax; cY = by - ay;

        for ( p = 0; p < n; p ++ ) {

          px = contour[ verts[ p ] ].x;
          py = contour[ verts[ p ] ].y;

          if ( ( ( px === ax ) && ( py === ay ) ) ||
             ( ( px === bx ) && ( py === by ) ) ||
             ( ( px === cx ) && ( py === cy ) ) ) continue;

          apx = px - ax; apy = py - ay;
          bpx = px - bx; bpy = py - by;
          cpx = px - cx; cpy = py - cy;

          // see if p is inside triangle abc

          aCROSSbp = aX * bpy - aY * bpx;
          cCROSSap = cX * apy - cY * apx;
          bCROSScp = bX * cpy - bY * cpx;

          if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

        }

        return true;

      }

      // takes in an contour array and returns

      return function triangulate( contour, indices ) {

        var n = contour.length;

        if ( n < 3 ) return null;

        var result = [],
          verts = [],
          vertIndices = [];

        /* we want a counter-clockwise polygon in verts */

        var u, v, w;

        if ( ShapeUtils.area( contour ) > 0.0 ) {

          for ( v = 0; v < n; v ++ ) verts[ v ] = v;

        } else {

          for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

        }

        var nv = n;

        /*  remove nv - 2 vertices, creating 1 triangle every time */

        var count = 2 * nv; /* error detection */

        for ( v = nv - 1; nv > 2; ) {

          /* if we loop, it is probably a non-simple polygon */

          if ( ( count -- ) <= 0 ) {

            //** Triangulate: ERROR - probable bad polygon!

            //throw ( "Warning, unable to triangulate polygon!" );
            //return null;
            // Sometimes warning is fine, especially polygons are triangulated in reverse.
            console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

            if ( indices ) return vertIndices;
            return result;

          }

          /* three consecutive vertices in current polygon, <u,v,w> */

          u = v; if ( nv <= u ) u = 0; /* previous */
          v = u + 1; if ( nv <= v ) v = 0; /* new v    */
          w = v + 1; if ( nv <= w ) w = 0; /* next     */

          if ( snip( contour, u, v, w, nv, verts ) ) {

            var a, b, c, s, t;

            /* true names of the vertices */

            a = verts[ u ];
            b = verts[ v ];
            c = verts[ w ];

            /* output Triangle */

            result.push( [ contour[ a ],
              contour[ b ],
              contour[ c ] ] );


            vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

            /* remove v from the remaining polygon */

            for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

              verts[ s ] = verts[ t ];

            }

            nv --;

            /* reset error detection counter */

            count = 2 * nv;

          }

        }

        if ( indices ) return vertIndices;
        return result;

      };

    } )(),

    triangulateShape: function ( contour, holes ) {

      function removeDupEndPts( points ) {

        var l = points.length;

        if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

          points.pop();

        }

      }

      removeDupEndPts( contour );
      holes.forEach( removeDupEndPts );

      function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

        // inOtherPt needs to be collinear to the inSegment
        if ( inSegPt1.x !== inSegPt2.x ) {

          if ( inSegPt1.x < inSegPt2.x ) {

            return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

          } else {

            return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

          }

        } else {

          if ( inSegPt1.y < inSegPt2.y ) {

            return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

          } else {

            return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

          }

        }

      }

      function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

        var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
        var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

        var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
        var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

        var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
        var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

        if ( Math.abs( limit ) > Number.EPSILON ) {

          // not parallel

          var perpSeg2;
          if ( limit > 0 ) {

            if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];

          } else {

            if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];

          }

          // i.e. to reduce rounding errors
          // intersection at endpoint of segment#1?
          if ( perpSeg2 === 0 ) {

            if ( ( inExcludeAdjacentSegs ) &&
               ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
            return [ inSeg1Pt1 ];

          }
          if ( perpSeg2 === limit ) {

            if ( ( inExcludeAdjacentSegs ) &&
               ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
            return [ inSeg1Pt2 ];

          }
          // intersection at endpoint of segment#2?
          if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];
          if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

          // return real intersection point
          var factorSeg1 = perpSeg2 / limit;
          return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx, y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

        } else {

          // parallel or collinear
          if ( ( perpSeg1 !== 0 ) ||
             ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];

          // they are collinear or degenerate
          var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );  // segment1 is just a point?
          var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );  // segment2 is just a point?
          // both segments are points
          if ( seg1Pt && seg2Pt ) {

            if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
               ( inSeg1Pt1.y !== inSeg2Pt1.y ) )    return [];  // they are distinct  points
            return [ inSeg1Pt1 ];                             // they are the same point

          }
          // segment#1  is a single point
          if ( seg1Pt ) {

            if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )   return [];    // but not in segment#2
            return [ inSeg1Pt1 ];

          }
          // segment#2  is a single point
          if ( seg2Pt ) {

            if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )   return [];    // but not in segment#1
            return [ inSeg2Pt1 ];

          }

          // they are collinear segments, which might overlap
          var seg1min, seg1max, seg1minVal, seg1maxVal;
          var seg2min, seg2max, seg2minVal, seg2maxVal;
          if ( seg1dx !== 0 ) {

            // the segments are NOT on a vertical line
            if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

              seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
              seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

            } else {

              seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
              seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

            }
            if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

              seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
              seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

            } else {

              seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
              seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

            }

          } else {

            // the segments are on a vertical line
            if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

              seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
              seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

            } else {

              seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
              seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

            }
            if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

              seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
              seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

            } else {

              seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
              seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

            }

          }
          if ( seg1minVal <= seg2minVal ) {

            if ( seg1maxVal < seg2minVal )  return [];
            if ( seg1maxVal === seg2minVal )  {

              if ( inExcludeAdjacentSegs )    return [];
              return [ seg2min ];

            }
            if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
            return  [ seg2min, seg2max ];

          } else {

            if ( seg1minVal > seg2maxVal )  return [];
            if ( seg1minVal === seg2maxVal )  {

              if ( inExcludeAdjacentSegs )    return [];
              return [ seg1min ];

            }
            if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
            return  [ seg1min, seg2max ];

          }

        }

      }

      function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

        // The order of legs is important

        // translation of all points, so that Vertex is at (0,0)
        var legFromPtX  = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
        var legToPtX  = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y  - inVertex.y;
        var otherPtX  = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y  - inVertex.y;

        // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
        var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
        var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

        if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

          // angle != 180 deg.

          var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
          // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

          if ( from2toAngle > 0 ) {

            // main angle < 180 deg.
            return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

          } else {

            // main angle > 180 deg.
            return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

          }

        } else {

          // angle == 180 deg.
          // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
          return  ( from2otherAngle > 0 );

        }

      }


      function removeHoles( contour, holes ) {

        var shape = contour.concat(); // work on this shape
        var hole;

        function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

          // Check if hole point lies within angle around shape point
          var lastShapeIdx = shape.length - 1;

          var prevShapeIdx = inShapeIdx - 1;
          if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

          var nextShapeIdx = inShapeIdx + 1;
          if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

          var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
          if ( ! insideAngle ) {

            // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
            return  false;

          }

          // Check if shape point lies within angle around hole point
          var lastHoleIdx = hole.length - 1;

          var prevHoleIdx = inHoleIdx - 1;
          if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

          var nextHoleIdx = inHoleIdx + 1;
          if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

          insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
          if ( ! insideAngle ) {

            // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
            return  false;

          }

          return  true;

        }

        function intersectsShapeEdge( inShapePt, inHolePt ) {

          // checks for intersections with shape edges
          var sIdx, nextIdx, intersection;
          for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

            nextIdx = sIdx + 1; nextIdx %= shape.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
            if ( intersection.length > 0 )    return  true;

          }

          return  false;

        }

        var indepHoles = [];

        function intersectsHoleEdge( inShapePt, inHolePt ) {

          // checks for intersections with hole edges
          var ihIdx, chkHole,
            hIdx, nextIdx, intersection;
          for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

            chkHole = holes[ indepHoles[ ihIdx ] ];
            for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

              nextIdx = hIdx + 1; nextIdx %= chkHole.length;
              intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
              if ( intersection.length > 0 )    return  true;

            }

          }
          return  false;

        }

        var holeIndex, shapeIndex,
          shapePt, holePt,
          holeIdx, cutKey, failedCuts = [],
          tmpShape1, tmpShape2,
          tmpHole1, tmpHole2;

        for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

          indepHoles.push( h );

        }

        var minShapeIndex = 0;
        var counter = indepHoles.length * 2;
        while ( indepHoles.length > 0 ) {

          counter --;
          if ( counter < 0 ) {

            console.log( 'THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!' );
            break;

          }

          // search for shape-vertex and hole-vertex,
          // which can be connected without intersections
          for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

            shapePt = shape[ shapeIndex ];
            holeIndex = - 1;

            // search for hole which can be reached without intersections
            for ( var h = 0; h < indepHoles.length; h ++ ) {

              holeIdx = indepHoles[ h ];

              // prevent multiple checks
              cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
              if ( failedCuts[ cutKey ] !== undefined )     continue;

              hole = holes[ holeIdx ];
              for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

                holePt = hole[ h2 ];
                if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )    continue;
                if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
                if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

                holeIndex = h2;
                indepHoles.splice( h, 1 );

                tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                tmpShape2 = shape.slice( shapeIndex );
                tmpHole1 = hole.slice( holeIndex );
                tmpHole2 = hole.slice( 0, holeIndex + 1 );

                shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                minShapeIndex = shapeIndex;

                // Debug only, to show the selected cuts
                // glob_CutLines.push( [ shapePt, holePt ] );

                break;

              }
              if ( holeIndex >= 0 ) break;    // hole-vertex found

              failedCuts[ cutKey ] = true;      // remember failure

            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

          }

        }

        return shape;       /* shape with no holes */

      }


      var i, il, f, face,
        key, index,
        allPointsMap = {};

      // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

      var allpoints = contour.concat();

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        Array.prototype.push.apply( allpoints, holes[ h ] );

      }

      //console.log( "allpoints",allpoints, allpoints.length );

      // prepare all points map

      for ( i = 0, il = allpoints.length; i < il; i ++ ) {

        key = allpoints[ i ].x + ':' + allpoints[ i ].y;

        if ( allPointsMap[ key ] !== undefined ) {

          console.warn( 'THREE.ShapeUtils: Duplicate point', key, i );

        }

        allPointsMap[ key ] = i;

      }

      // remove holes by cutting paths to holes and adding them to the shape
      var shapeWithoutHoles = removeHoles( contour, holes );

      var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
      //console.log( "triangles",triangles, triangles.length );

      // check all face vertices against all points map

      for ( i = 0, il = triangles.length; i < il; i ++ ) {

        face = triangles[ i ];

        for ( f = 0; f < 3; f ++ ) {

          key = face[ f ].x + ':' + face[ f ].y;

          index = allPointsMap[ key ];

          if ( index !== undefined ) {

            face[ f ] = index;

          }

        }

      }

      return triangles.concat();

    },

    isClockWise: function ( pts ) {

      return ShapeUtils.area( pts ) < 0;

    }

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  amount: <int>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline is bevel
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *  frames: <Object> // containing arrays of tangents, normals, binormals
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  // ExtrudeGeometry

  function ExtrudeGeometry( shapes, options ) {

    Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    this.parameters = {
      shapes: shapes,
      options: options
    };

    this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
    this.mergeVertices();

  }

  ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry( shapes, options ) {

    if ( typeof ( shapes ) === "undefined" ) {

      return;

    }

    BufferGeometry.call( this );

    this.type = 'ExtrudeBufferGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeVertexNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

  }

  ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  ExtrudeBufferGeometry.prototype.getArrays = function () {

    var positionAttribute = this.getAttribute( "position" );
    var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

    var uvAttribute = this.getAttribute( "uv" );
    var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

    var IndexAttribute = this.index;
    var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

    return {
      position: verticesArray,
      uv: uvArray,
      index: indicesArray
    };

  };

  ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {

    var sl = shapes.length;
    options.arrays = this.getArrays();

    for ( var s = 0; s < sl; s ++ ) {

      var shape = shapes[ s ];
      this.addShape( shape, options );

    }

    this.setIndex( options.arrays.index );
    this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

  };

  ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {

    var arrays = options.arrays ? options.arrays : this.getArrays();
    var verticesArray = arrays.position;
    var indicesArray = arrays.index;
    var uvArray = arrays.uv;

    var placeholder = [];


    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

      extrudePts = extrudePath.getSpacedPoints( steps );

      extrudeByPath = true;
      bevelEnabled = false; // bevels not supported for path extrusion

      // SETUP TNB variables

      // TODO1 - have a .isClosed in spline?

      splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

      // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( ! bevelEnabled ) {

      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = ! ShapeUtils.isClockWise( vertices );

    if ( reverse ) {

      vertices = vertices.reverse();

      // Maybe we should also check if holes are in the opposite direction, just to be safe ...

      for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];

        if ( ShapeUtils.isClockWise( ahole ) ) {

          holes[ h ] = ahole.reverse();

        }

      }

    }


    var faces = ShapeUtils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      vertices = vertices.concat( ahole );

    }


    function scalePt2( pt, vec, size ) {

      if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

      return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
      vert, vlen = vertices.length,
      face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

      // computes for inPt the corresponding point inPt' on a new contour
      //   shifted by 1 unit (length of normalized vector) to the left
      // if we walk along contour clockwise, this new contour is outside the old one
      //
      // inPt' is the intersection of the two lines parallel to the two
      //  adjacent edges of inPt at a distance of 1 unit on the left side.

      var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

      // good reading for geometry algorithms (here: line-line intersection)
      // http://geomalgorithms.com/a05-_intersect-1.html

      var v_prev_x = inPt.x - inPrev.x,
        v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x,
        v_next_y = inNext.y - inPt.y;

      var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

      // check for collinear edges
      var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

      if ( Math.abs( collinear0 ) > Number.EPSILON ) {

        // not collinear

        // length of vectors for normalizing

        var v_prev_len = Math.sqrt( v_prev_lensq );
        var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

        // shift adjacent points by unit vectors to the left

        var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
        var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

        var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
        var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

        // scaling factor for v_prev to intersection point

        var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
          ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        // vector from inPt to intersection point

        v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
        v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

        // Don't normalize!, otherwise sharp corners become ugly
        //  but prevent crazy spikes
        var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
        if ( v_trans_lensq <= 2 ) {

          return new Vector2( v_trans_x, v_trans_y );

        } else {

          shrink_by = Math.sqrt( v_trans_lensq / 2 );

        }

      } else {

        // handle special case of collinear edges

        var direction_eq = false; // assumes: opposite
        if ( v_prev_x > Number.EPSILON ) {

          if ( v_next_x > Number.EPSILON ) {

            direction_eq = true;

          }

        } else {

          if ( v_prev_x < - Number.EPSILON ) {

            if ( v_next_x < - Number.EPSILON ) {

              direction_eq = true;

            }

          } else {

            if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

              direction_eq = true;

            }

          }

        }

        if ( direction_eq ) {

          // console.log("Warning: lines are a straight sequence");
          v_trans_x = - v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt( v_prev_lensq );

        } else {

          // console.log("Warning: lines are a straight spike");
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt( v_prev_lensq / 2 );

        }

      }

      return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      // console.log('i,j,k', i, j , k)

      contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [],
      oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      oneHoleMovements = [];

      for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

      }

      holesMovements.push( oneHoleMovements );
      verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b ++ ) {

      //for ( b = bevelSegments; b > 0; b -- ) {

      t = b / bevelSegments;
      z = bevelThickness * Math.cos( t * Math.PI / 2 );
      bs = bevelSize * Math.sin( t * Math.PI / 2 );

      // contract shape

      for ( i = 0, il = contour.length; i < il; i ++ ) {

        vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

        v( vert.x, vert.y, - z );

      }

      // expand holes

      for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];
        oneHoleMovements = holesMovements[ h ];

        for ( i = 0, il = ahole.length; i < il; i ++ ) {

          vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

          v( vert.x, vert.y, - z );

        }

      }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, 0 );

      } else {

        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

        normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s ++ ) {

      for ( i = 0; i < vlen; i ++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y, amount / steps * s );

        } else {

          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

          normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
          binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

          position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

          v( position2.x, position2.y, position2.z );

        }

      }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b -- ) {

      t = b / bevelSegments;
      z = bevelThickness * Math.cos( t * Math.PI / 2 );
      bs = bevelSize * Math.sin( t * Math.PI / 2 );

      // contract shape

      for ( i = 0, il = contour.length; i < il; i ++ ) {

        vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
        v( vert.x, vert.y, amount + z );

      }

      // expand holes

      for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];
        oneHoleMovements = holesMovements[ h ];

        for ( i = 0, il = ahole.length; i < il; i ++ ) {

          vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

          if ( ! extrudeByPath ) {

            v( vert.x, vert.y, amount + z );

          } else {

            v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

          }

        }

      }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

      var start = verticesArray.length / 3;

      if ( bevelEnabled ) {

        var layer = 0; // steps + 1
        var offset = vlen * layer;

        // Bottom faces

        for ( i = 0; i < flen; i ++ ) {

          face = faces[ i ];
          f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

        }

        layer = steps + bevelSegments * 2;
        offset = vlen * layer;

        // Top faces

        for ( i = 0; i < flen; i ++ ) {

          face = faces[ i ];
          f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

        }

      } else {

        // Bottom faces

        for ( i = 0; i < flen; i ++ ) {

          face = faces[ i ];
          f3( face[ 2 ], face[ 1 ], face[ 0 ] );

        }

        // Top faces

        for ( i = 0; i < flen; i ++ ) {

          face = faces[ i ];
          f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

        }

      }

      scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

      var start = verticesArray.length / 3;
      var layeroffset = 0;
      sidewalls( contour, layeroffset );
      layeroffset += contour.length;

      for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];
        sidewalls( ahole, layeroffset );

        //, true
        layeroffset += ahole.length;

      }


      scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );


    }

    function sidewalls( contour, layeroffset ) {

      var j, k;
      i = contour.length;

      while ( -- i >= 0 ) {

        j = i;
        k = i - 1;
        if ( k < 0 ) k = contour.length - 1;

        //console.log('b', i,j, i-1, k,vertices.length);

        var s = 0,
          sl = steps + bevelSegments * 2;

        for ( s = 0; s < sl; s ++ ) {

          var slen1 = vlen * s;
          var slen2 = vlen * ( s + 1 );

          var a = layeroffset + j + slen1,
            b = layeroffset + k + slen1,
            c = layeroffset + k + slen2,
            d = layeroffset + j + slen2;

          f4( a, b, c, d );

        }

      }

    }

    function v( x, y, z ) {

      placeholder.push( x );
      placeholder.push( y );
      placeholder.push( z );

    }


    function f3( a, b, c ) {

      addVertex( a );
      addVertex( b );
      addVertex( c );

      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

      addUV( uvs[ 0 ] );
      addUV( uvs[ 1 ] );
      addUV( uvs[ 2 ] );

    }

    function f4( a, b, c, d ) {

      addVertex( a );
      addVertex( b );
      addVertex( d );

      addVertex( b );
      addVertex( c );
      addVertex( d );


      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

      addUV( uvs[ 0 ] );
      addUV( uvs[ 1 ] );
      addUV( uvs[ 3 ] );

      addUV( uvs[ 1 ] );
      addUV( uvs[ 2 ] );
      addUV( uvs[ 3 ] );

    }

    function addVertex( index ) {

      indicesArray.push( verticesArray.length / 3 );
      verticesArray.push( placeholder[ index * 3 + 0 ] );
      verticesArray.push( placeholder[ index * 3 + 1 ] );
      verticesArray.push( placeholder[ index * 3 + 2 ] );

    }


    function addUV( vector2 ) {

      uvArray.push( vector2.x );
      uvArray.push( vector2.y );

    }

    if ( ! options.arrays ) {

      this.setIndex( indicesArray );
      this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
      this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

    }

  };

  ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

      var a_x = vertices[ indexA * 3 ];
      var a_y = vertices[ indexA * 3 + 1 ];
      var b_x = vertices[ indexB * 3 ];
      var b_y = vertices[ indexB * 3 + 1 ];
      var c_x = vertices[ indexC * 3 ];
      var c_y = vertices[ indexC * 3 + 1 ];

      return [
        new Vector2( a_x, a_y ),
        new Vector2( b_x, b_y ),
        new Vector2( c_x, c_y )
      ];

    },

    generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

      var a_x = vertices[ indexA * 3 ];
      var a_y = vertices[ indexA * 3 + 1 ];
      var a_z = vertices[ indexA * 3 + 2 ];
      var b_x = vertices[ indexB * 3 ];
      var b_y = vertices[ indexB * 3 + 1 ];
      var b_z = vertices[ indexB * 3 + 2 ];
      var c_x = vertices[ indexC * 3 ];
      var c_y = vertices[ indexC * 3 + 1 ];
      var c_z = vertices[ indexC * 3 + 2 ];
      var d_x = vertices[ indexD * 3 ];
      var d_y = vertices[ indexD * 3 + 1 ];
      var d_z = vertices[ indexD * 3 + 2 ];

      if ( Math.abs( a_y - b_y ) < 0.01 ) {

        return [
          new Vector2( a_x, 1 - a_z ),
          new Vector2( b_x, 1 - b_z ),
          new Vector2( c_x, 1 - c_z ),
          new Vector2( d_x, 1 - d_z )
        ];

      } else {

        return [
          new Vector2( a_y, 1 - a_z ),
          new Vector2( b_y, 1 - b_z ),
          new Vector2( c_y, 1 - c_z ),
          new Vector2( d_y, 1 - d_z )
        ];

      }

    }
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float> // how far from text outline is bevel
   * }
   */

  // TextGeometry

  function TextGeometry( text, parameters ) {

    Geometry.call( this );

    this.type = 'TextGeometry';

    this.parameters = {
      text: text,
      parameters: parameters
    };

    this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
    this.mergeVertices();

  }

  TextGeometry.prototype = Object.create( Geometry.prototype );
  TextGeometry.prototype.constructor = TextGeometry;

  // TextBufferGeometry

  function TextBufferGeometry( text, parameters ) {

    parameters = parameters || {};

    var font = parameters.font;

    if ( ! ( font && font.isFont ) ) {

      console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
      return new Geometry();

    }

    var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    ExtrudeBufferGeometry.call( this, shapes, parameters );

    this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */

  // SphereGeometry

  function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
    this.mergeVertices();

  }

  SphereGeometry.prototype = Object.create( Geometry.prototype );
  SphereGeometry.prototype.constructor = SphereGeometry;

  // SphereBufferGeometry

  function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var ix, iy;

    var index = 0;
    var grid = [];

    var vertex = new Vector3();
    var normal = new Vector3();

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // generate vertices, normals and uvs

    for ( iy = 0; iy <= heightSegments; iy ++ ) {

      var verticesRow = [];

      var v = iy / heightSegments;

      for ( ix = 0; ix <= widthSegments; ix ++ ) {

        var u = ix / widthSegments;

        // vertex

        vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
        vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
        vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

        vertices.push( vertex.x, vertex.y, vertex.z );

        // normal

        normal.set( vertex.x, vertex.y, vertex.z ).normalize();
        normals.push( normal.x, normal.y, normal.z );

        // uv

        uvs.push( u, 1 - v );

        verticesRow.push( index ++ );

      }

      grid.push( verticesRow );

    }

    // indices

    for ( iy = 0; iy < heightSegments; iy ++ ) {

      for ( ix = 0; ix < widthSegments; ix ++ ) {

        var a = grid[ iy ][ ix + 1 ];
        var b = grid[ iy ][ ix ];
        var c = grid[ iy + 1 ][ ix ];
        var d = grid[ iy + 1 ][ ix + 1 ];

        if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
        if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  /**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */

  // RingGeometry

  function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
    this.mergeVertices();

  }

  RingGeometry.prototype = Object.create( Geometry.prototype );
  RingGeometry.prototype.constructor = RingGeometry;

  // RingBufferGeometry

  function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    BufferGeometry.call( this );

    this.type = 'RingBufferGeometry';

    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    innerRadius = innerRadius || 20;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // some helper variables

    var segment;
    var radius = innerRadius;
    var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
    var vertex = new Vector3();
    var uv = new Vector2();
    var j, i;

    // generate vertices, normals and uvs

    for ( j = 0; j <= phiSegments; j ++ ) {

      for ( i = 0; i <= thetaSegments; i ++ ) {

        // values are generate from the inside of the ring to the outside

        segment = thetaStart + i / thetaSegments * thetaLength;

        // vertex

        vertex.x = radius * Math.cos( segment );
        vertex.y = radius * Math.sin( segment );

        vertices.push( vertex.x, vertex.y, vertex.z );

        // normal

        normals.push( 0, 0, 1 );

        // uv

        uv.x = ( vertex.x / outerRadius + 1 ) / 2;
        uv.y = ( vertex.y / outerRadius + 1 ) / 2;

        uvs.push( uv.x, uv.y );

      }

      // increase the radius for next row of vertices

      radius += radiusStep;

    }

    // indices

    for ( j = 0; j < phiSegments; j ++ ) {

      var thetaSegmentLevel = j * ( thetaSegments + 1 );

      for ( i = 0; i < thetaSegments; i ++ ) {

        segment = i + thetaSegmentLevel;

        var a = segment;
        var b = segment + thetaSegments + 1;
        var c = segment + thetaSegments + 2;
        var d = segment + 1;

        // faces

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  /**
   * @author astrodud / http://astrodud.isgreat.org/
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */

  // LatheGeometry

  function LatheGeometry( points, segments, phiStart, phiLength ) {

    Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };

    this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
    this.mergeVertices();

  }

  LatheGeometry.prototype = Object.create( Geometry.prototype );
  LatheGeometry.prototype.constructor = LatheGeometry;

  // LatheBufferGeometry

  function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

    BufferGeometry.call( this );

    this.type = 'LatheBufferGeometry';

    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };

    segments = Math.floor( segments ) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;

    // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


    // buffers

    var indices = [];
    var vertices = [];
    var uvs = [];

    // helper variables

    var base;
    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var i, j;

    // generate vertices and uvs

    for ( i = 0; i <= segments; i ++ ) {

      var phi = phiStart + i * inverseSegments * phiLength;

      var sin = Math.sin( phi );
      var cos = Math.cos( phi );

      for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

        // vertex

        vertex.x = points[ j ].x * sin;
        vertex.y = points[ j ].y;
        vertex.z = points[ j ].x * cos;

        vertices.push( vertex.x, vertex.y, vertex.z );

        // uv

        uv.x = i / segments;
        uv.y = j / ( points.length - 1 );

        uvs.push( uv.x, uv.y );


      }

    }

    // indices

    for ( i = 0; i < segments; i ++ ) {

      for ( j = 0; j < ( points.length - 1 ); j ++ ) {

        base = j + i * points.length;

        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1;

        // faces

        indices.push( a, b, d );
        indices.push( b, c, d );

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    // generate normals

    this.computeVertexNormals();

    // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).

    if ( phiLength === Math.PI * 2 ) {

      var normals = this.attributes.normal.array;
      var n1 = new Vector3();
      var n2 = new Vector3();
      var n = new Vector3();

      // this is the buffer offset for the last line of vertices

      base = segments * points.length * 3;

      for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

        // select the normal of the vertex in the first line

        n1.x = normals[ j + 0 ];
        n1.y = normals[ j + 1 ];
        n1.z = normals[ j + 2 ];

        // select the normal of the vertex in the last line

        n2.x = normals[ base + j + 0 ];
        n2.y = normals[ base + j + 1 ];
        n2.z = normals[ base + j + 2 ];

        // average normals

        n.addVectors( n1, n2 ).normalize();

        // assign the new values to both normals

        normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
        normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
        normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

      }

    }

  }

  LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  /**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // ShapeGeometry

  function ShapeGeometry( shapes, curveSegments ) {

    Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( typeof curveSegments === 'object' ) {

      console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

      curveSegments = curveSegments.curveSegments;

    }

    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };

    this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
    this.mergeVertices();

  }

  ShapeGeometry.prototype = Object.create( Geometry.prototype );
  ShapeGeometry.prototype.constructor = ShapeGeometry;

  // ShapeBufferGeometry

  function ShapeBufferGeometry( shapes, curveSegments ) {

    BufferGeometry.call( this );

    this.type = 'ShapeBufferGeometry';

    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };

    curveSegments = curveSegments || 12;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var groupStart = 0;
    var groupCount = 0;

    // allow single and array values for "shapes" parameter

    if ( Array.isArray( shapes ) === false ) {

      addShape( shapes );

    } else {

      for ( var i = 0; i < shapes.length; i ++ ) {

        addShape( shapes[ i ] );

        this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;

      }

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


    // helper functions

    function addShape( shape ) {

      var i, l, shapeHole;

      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints( curveSegments );

      var shapeVertices = points.shape;
      var shapeHoles = points.holes;

      // check direction of vertices

      if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

        shapeVertices = shapeVertices.reverse();

        // also check if holes are in the opposite direction

        for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

          shapeHole = shapeHoles[ i ];

          if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

            shapeHoles[ i ] = shapeHole.reverse();

          }

        }

      }

      var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

      // join vertices of inner and outer paths to a single array

      for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

        shapeHole = shapeHoles[ i ];
        shapeVertices = shapeVertices.concat( shapeHole );

      }

      // vertices, normals, uvs

      for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

        var vertex = shapeVertices[ i ];

        vertices.push( vertex.x, vertex.y, 0 );
        normals.push( 0, 0, 1 );
        uvs.push( vertex.x, vertex.y ); // world uvs

      }

      // incides

      for ( i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        var a = face[ 0 ] + indexOffset;
        var b = face[ 1 ] + indexOffset;
        var c = face[ 2 ] + indexOffset;

        indices.push( a, b, c );
        groupCount += 3;

      }

    }

  }

  ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  function EdgesGeometry( geometry, thresholdAngle ) {

    BufferGeometry.call( this );

    this.type = 'EdgesGeometry';

    this.parameters = {
      thresholdAngle: thresholdAngle
    };

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    // buffer

    var vertices = [];

    // helper variables

    var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
    var edge = [ 0, 0 ], edges = {}, edge1, edge2;
    var key, keys = [ 'a', 'b', 'c' ];

    // prepare source geometry

    var geometry2;

    if ( geometry.isBufferGeometry ) {

      geometry2 = new Geometry();
      geometry2.fromBufferGeometry( geometry );

    } else {

      geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var sourceVertices = geometry2.vertices;
    var faces = geometry2.faces;

    // now create a data structure where each entry represents an edge with its adjoining faces

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge1 = face[ keys[ j ] ];
        edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
        edge[ 0 ] = Math.min( edge1, edge2 );
        edge[ 1 ] = Math.max( edge1, edge2 );

        key = edge[ 0 ] + ',' + edge[ 1 ];

        if ( edges[ key ] === undefined ) {

          edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

        } else {

          edges[ key ].face2 = i;

        }

      }

    }

    // generate vertices

    for ( key in edges ) {

      var e = edges[ key ];

      // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

      if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

        var vertex = sourceVertices[ e.index1 ];
        vertices.push( vertex.x, vertex.y, vertex.z );

        vertex = sourceVertices[ e.index2 ];
        vertices.push( vertex.x, vertex.y, vertex.z );

      }

    }

    // build geometry

    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
  EdgesGeometry.prototype.constructor = EdgesGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // CylinderGeometry

  function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
    this.mergeVertices();

  }

  CylinderGeometry.prototype = Object.create( Geometry.prototype );
  CylinderGeometry.prototype.constructor = CylinderGeometry;

  // CylinderBufferGeometry

  function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    BufferGeometry.call( this );

    this.type = 'CylinderBufferGeometry';

    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    var scope = this;

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = Math.floor( radialSegments ) || 8;
    heightSegments = Math.floor( heightSegments ) || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var index = 0;
    var indexArray = [];
    var halfHeight = height / 2;
    var groupStart = 0;

    // generate geometry

    generateTorso();

    if ( openEnded === false ) {

      if ( radiusTop > 0 ) generateCap( true );
      if ( radiusBottom > 0 ) generateCap( false );

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    function generateTorso() {

      var x, y;
      var normal = new Vector3();
      var vertex = new Vector3();

      var groupCount = 0;

      // this will be used to calculate the normal
      var slope = ( radiusBottom - radiusTop ) / height;

      // generate vertices, normals and uvs

      for ( y = 0; y <= heightSegments; y ++ ) {

        var indexRow = [];

        var v = y / heightSegments;

        // calculate the radius of the current row

        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x ++ ) {

          var u = x / radialSegments;

          var theta = u * thetaLength + thetaStart;

          var sinTheta = Math.sin( theta );
          var cosTheta = Math.cos( theta );

          // vertex

          vertex.x = radius * sinTheta;
          vertex.y = - v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push( vertex.x, vertex.y, vertex.z );

          // normal

          normal.set( sinTheta, slope, cosTheta ).normalize();
          normals.push( normal.x, normal.y, normal.z );

          // uv

          uvs.push( u, 1 - v );

          // save index of vertex in respective row

          indexRow.push( index ++ );

        }

        // now save vertices of the row in our index array

        indexArray.push( indexRow );

      }

      // generate indices

      for ( x = 0; x < radialSegments; x ++ ) {

        for ( y = 0; y < heightSegments; y ++ ) {

          // we use the index array to access the correct indices

          var a = indexArray[ y ][ x ];
          var b = indexArray[ y + 1 ][ x ];
          var c = indexArray[ y + 1 ][ x + 1 ];
          var d = indexArray[ y ][ x + 1 ];

          // faces

          indices.push( a, b, d );
          indices.push( b, c, d );

          // update group counter

          groupCount += 6;

        }

      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup( groupStart, groupCount, 0 );

      // calculate new start value for groups

      groupStart += groupCount;

    }

    function generateCap( top ) {

      var x, centerIndexStart, centerIndexEnd;

      var uv = new Vector2();
      var vertex = new Vector3();

      var groupCount = 0;

      var radius = ( top === true ) ? radiusTop : radiusBottom;
      var sign = ( top === true ) ? 1 : - 1;

      // save the index of the first center vertex
      centerIndexStart = index;

      // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for ( x = 1; x <= radialSegments; x ++ ) {

        // vertex

        vertices.push( 0, halfHeight * sign, 0 );

        // normal

        normals.push( 0, sign, 0 );

        // uv

        uvs.push( 0.5, 0.5 );

        // increase index

        index ++;

      }

      // save the index of the last center vertex

      centerIndexEnd = index;

      // now we generate the surrounding vertices, normals and uvs

      for ( x = 0; x <= radialSegments; x ++ ) {

        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;

        var cosTheta = Math.cos( theta );
        var sinTheta = Math.sin( theta );

        // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push( vertex.x, vertex.y, vertex.z );

        // normal

        normals.push( 0, sign, 0 );

        // uv

        uv.x = ( cosTheta * 0.5 ) + 0.5;
        uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
        uvs.push( uv.x, uv.y );

        // increase index

        index ++;

      }

      // generate indices

      for ( x = 0; x < radialSegments; x ++ ) {

        var c = centerIndexStart + x;
        var i = centerIndexEnd + x;

        if ( top === true ) {

          // face top

          indices.push( i, i + 1, c );

        } else {

          // face bottom

          indices.push( i + 1, i, c );

        }

        groupCount += 3;

      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

      // calculate new start value for groups

      groupStart += groupCount;

    }

  }

  CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  /**
   * @author abelnation / http://github.com/abelnation
   */

  // ConeGeometry

  function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

    this.type = 'ConeGeometry';

    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

  }

  ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
  ConeGeometry.prototype.constructor = ConeGeometry;

  // ConeBufferGeometry

  function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

    this.type = 'ConeBufferGeometry';

    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

  }

  ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */

  // CircleGeometry

  function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

    Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
    this.mergeVertices();

  }

  CircleGeometry.prototype = Object.create( Geometry.prototype );
  CircleGeometry.prototype.constructor = CircleGeometry;

  // CircleBufferGeometry

  function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

    BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var i, s;
    var vertex = new Vector3();
    var uv = new Vector2();

    // center point

    vertices.push( 0, 0, 0 );
    normals.push( 0, 0, 1 );
    uvs.push( 0.5, 0.5 );

    for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

      var segment = thetaStart + s / segments * thetaLength;

      // vertex

      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      vertices.push( vertex.x, vertex.y, vertex.z );

      // normal

      normals.push( 0, 0, 1 );

      // uvs

      uv.x = ( vertices[ i ] / radius + 1 ) / 2;
      uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

      uvs.push( uv.x, uv.y );

    }

    // indices

    for ( i = 1; i <= segments; i ++ ) {

      indices.push( i, i + 1, 0 );

    }

    // build geometry

    this.setIndex( indices );
    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



  var Geometries = Object.freeze({
    WireframeGeometry: WireframeGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricBufferGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronBufferGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronBufferGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronBufferGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronBufferGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronBufferGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeBufferGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusBufferGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextBufferGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereBufferGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingBufferGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneBufferGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheBufferGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeBufferGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeBufferGeometry,
    EdgesGeometry: EdgesGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeBufferGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderBufferGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleBufferGeometry,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxBufferGeometry
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  color: <THREE.Color>,
   *  opacity: <float>
   * }
   */

  function ShadowMaterial( parameters ) {

    Material.call( this );

    this.type = 'ShadowMaterial';

    this.color = new Color( 0x000000 );
    this.opacity = 1.0;

    this.lights = true;
    this.transparent = true;

    this.setValues( parameters );

  }

  ShadowMaterial.prototype = Object.create( Material.prototype );
  ShadowMaterial.prototype.constructor = ShadowMaterial;

  ShadowMaterial.prototype.isShadowMaterial = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function RawShaderMaterial( parameters ) {

    ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;

  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshStandardMaterial( parameters ) {

    Material.call( this );

    this.defines = { 'STANDARD': '' };

    this.type = 'MeshStandardMaterial';

    this.color = new Color( 0xffffff ); // diffuse
    this.roughness = 0.5;
    this.metalness = 0.5;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissive = new Color( 0x000000 );
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.roughnessMap = null;

    this.metalnessMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.envMapIntensity = 1.0;

    this.refractionRatio = 0.98;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

  }

  MeshStandardMaterial.prototype = Object.create( Material.prototype );
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.defines = { 'STANDARD': '' };

    this.color.copy( source.color );
    this.roughness = source.roughness;
    this.metalness = source.metalness;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissive.copy( source.emissive );
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.roughnessMap = source.roughnessMap;

    this.metalnessMap = source.metalnessMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;

    this.refractionRatio = source.refractionRatio;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  reflectivity: <float>
   * }
   */

  function MeshPhysicalMaterial( parameters ) {

    MeshStandardMaterial.call( this );

    this.defines = { 'PHYSICAL': '' };

    this.type = 'MeshPhysicalMaterial';

    this.reflectivity = 0.5; // maps to F0 = 0.04

    this.clearCoat = 0.0;
    this.clearCoatRoughness = 0.0;

    this.setValues( parameters );

  }

  MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial.prototype.copy = function ( source ) {

    MeshStandardMaterial.prototype.copy.call( this, source );

    this.defines = { 'PHYSICAL': '' };

    this.reflectivity = source.reflectivity;

    this.clearCoat = source.clearCoat;
    this.clearCoatRoughness = source.clearCoatRoughness;

    return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshPhongMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new Color( 0xffffff ); // diffuse
    this.specular = new Color( 0x111111 );
    this.shininess = 30;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissive = new Color( 0x000000 );
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

  }

  MeshPhongMaterial.prototype = Object.create( Material.prototype );
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissive.copy( source.emissive );
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

  };

  /**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  gradientMap: new THREE.Texture( <Image> )
   * }
   */

  function MeshToonMaterial( parameters ) {

    MeshPhongMaterial.call( this );

    this.defines = { 'TOON': '' };

    this.type = 'MeshToonMaterial';

    this.gradientMap = null;

    this.setValues( parameters );

  }

  MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;

  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  MeshToonMaterial.prototype.copy = function ( source ) {

    MeshPhongMaterial.prototype.copy.call( this, source );

    this.gradientMap = source.gradientMap;

    return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshNormalMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshNormalMaterial';

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false;
    this.lights = false;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

  }

  MeshNormalMaterial.prototype = Object.create( Material.prototype );
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshLambertMaterial( parameters ) {

    Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new Color( 0xffffff ); // diffuse

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissive = new Color( 0x000000 );
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

  }

  MeshLambertMaterial.prototype = Object.create( Material.prototype );
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial.prototype.copy = function ( source ) {

    Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissive.copy( source.emissive );
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  function LineDashedMaterial( parameters ) {

    LineBasicMaterial.call( this );

    this.type = 'LineDashedMaterial';

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.setValues( parameters );

  }

  LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;

  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  LineDashedMaterial.prototype.copy = function ( source ) {

    LineBasicMaterial.prototype.copy.call( this, source );

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    return this;

  };



  var Materials = Object.freeze({
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var Cache = {

    enabled: false,

    files: {},

    add: function ( key, file ) {

      if ( this.enabled === false ) return;

      // console.log( 'THREE.Cache', 'Adding key:', key );

      this.files[ key ] = file;

    },

    get: function ( key ) {

      if ( this.enabled === false ) return;

      // console.log( 'THREE.Cache', 'Checking key:', key );

      return this.files[ key ];

    },

    remove: function ( key ) {

      delete this.files[ key ];

    },

    clear: function () {

      this.files = {};

    }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LoadingManager( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function ( url ) {

      itemsTotal ++;

      if ( isLoading === false ) {

        if ( scope.onStart !== undefined ) {

          scope.onStart( url, itemsLoaded, itemsTotal );

        }

      }

      isLoading = true;

    };

    this.itemEnd = function ( url ) {

      itemsLoaded ++;

      if ( scope.onProgress !== undefined ) {

        scope.onProgress( url, itemsLoaded, itemsTotal );

      }

      if ( itemsLoaded === itemsTotal ) {

        isLoading = false;

        if ( scope.onLoad !== undefined ) {

          scope.onLoad();

        }

      }

    };

    this.itemError = function ( url ) {

      if ( scope.onError !== undefined ) {

        scope.onError( url );

      }

    };

  }

  var DefaultLoadingManager = new LoadingManager();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FileLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( FileLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      if ( url === undefined ) url = '';

      if ( this.path !== undefined ) url = this.path + url;

      var scope = this;

      var cached = Cache.get( url );

      if ( cached !== undefined ) {

        scope.manager.itemStart( url );

        setTimeout( function () {

          if ( onLoad ) onLoad( cached );

          scope.manager.itemEnd( url );

        }, 0 );

        return cached;

      }

      // Check for data: URI
      var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      var dataUriRegexResult = url.match( dataUriRegex );

      // Safari can not handle Data URIs through XMLHttpRequest so process manually
      if ( dataUriRegexResult ) {

        var mimeType = dataUriRegexResult[ 1 ];
        var isBase64 = !! dataUriRegexResult[ 2 ];
        var data = dataUriRegexResult[ 3 ];

        data = window.decodeURIComponent( data );

        if ( isBase64 ) data = window.atob( data );

        try {

          var response;
          var responseType = ( this.responseType || '' ).toLowerCase();

          switch ( responseType ) {

            case 'arraybuffer':
            case 'blob':

              var view = new Uint8Array( data.length );

              for ( var i = 0; i < data.length; i ++ ) {

                view[ i ] = data.charCodeAt( i );

              }

              if ( responseType === 'blob' ) {

                response = new Blob( [ view.buffer ], { type: mimeType } );

              } else {

                response = view.buffer;

              }

              break;

            case 'document':

              var parser = new DOMParser();
              response = parser.parseFromString( data, mimeType );

              break;

            case 'json':

              response = JSON.parse( data );

              break;

            default: // 'text' or other

              response = data;

              break;

          }

          // Wait for next browser tick like standard XMLHttpRequest event dispatching does
          window.setTimeout( function () {

            if ( onLoad ) onLoad( response );

            scope.manager.itemEnd( url );

          }, 0 );

        } catch ( error ) {

          // Wait for next browser tick like standard XMLHttpRequest event dispatching does
          window.setTimeout( function () {

            if ( onError ) onError( error );

            scope.manager.itemEnd( url );
            scope.manager.itemError( url );

          }, 0 );

        }

      } else {

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function ( event ) {

          var response = event.target.response;

          Cache.add( url, response );

          if ( this.status === 200 ) {

            if ( onLoad ) onLoad( response );

            scope.manager.itemEnd( url );

          } else if ( this.status === 0 ) {

            // Some browsers return HTTP Status 0 when using non-http protocol
            // e.g. 'file://' or 'data://'. Handle as success.

            console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

            if ( onLoad ) onLoad( response );

            scope.manager.itemEnd( url );

          } else {

            if ( onError ) onError( event );

            scope.manager.itemEnd( url );
            scope.manager.itemError( url );

          }

        }, false );

        if ( onProgress !== undefined ) {

          request.addEventListener( 'progress', function ( event ) {

            onProgress( event );

          }, false );

        }

        request.addEventListener( 'error', function ( event ) {

          if ( onError ) onError( event );

          scope.manager.itemEnd( url );
          scope.manager.itemError( url );

        }, false );

        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

        for ( var header in this.requestHeader ) {

          request.setRequestHeader( header, this.requestHeader[ header ] );

        }

        request.send( null );

      }

      scope.manager.itemStart( url );

      return request;

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    },

    setResponseType: function ( value ) {

      this.responseType = value;
      return this;

    },

    setWithCredentials: function ( value ) {

      this.withCredentials = value;
      return this;

    },

    setMimeType: function ( value ) {

      this.mimeType = value;
      return this;

    },

    setRequestHeader: function ( value ) {

      this.requestHeader = value;
      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   */

  function CompressedTextureLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

  }

  Object.assign( CompressedTextureLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var images = [];

      var texture = new CompressedTexture();
      texture.image = images;

      var loader = new FileLoader( this.manager );
      loader.setPath( this.path );
      loader.setResponseType( 'arraybuffer' );

      function loadTexture( i ) {

        loader.load( url[ i ], function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          images[ i ] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };

          loaded += 1;

          if ( loaded === 6 ) {

            if ( texDatas.mipmapCount === 1 )
              texture.minFilter = LinearFilter;

            texture.format = texDatas.format;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        }, onProgress, onError );

      }

      if ( Array.isArray( url ) ) {

        var loaded = 0;

        for ( var i = 0, il = url.length; i < il; ++ i ) {

          loadTexture( i );

        }

      } else {

        // compressed cubemap texture stored in a single DDS file

        loader.load( url, function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          if ( texDatas.isCubemap ) {

            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

            for ( var f = 0; f < faces; f ++ ) {

              images[ f ] = { mipmaps: [] };

              for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

                images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                images[ f ].format = texDatas.format;
                images[ f ].width = texDatas.width;
                images[ f ].height = texDatas.height;

              }

            }

          } else {

            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;

          }

          if ( texDatas.mipmapCount === 1 ) {

            texture.minFilter = LinearFilter;

          }

          texture.format = texDatas.format;
          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }, onProgress, onError );

      }

      return texture;

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    }

  } );

  /**
   * @author Nikos M. / https://github.com/foo123/
   *
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   */

  function DataTextureLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

  }

  Object.assign( DataTextureLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var texture = new DataTexture();

      var loader = new FileLoader( this.manager );
      loader.setResponseType( 'arraybuffer' );

      loader.load( url, function ( buffer ) {

        var texData = scope._parser( buffer );

        if ( ! texData ) return;

        if ( undefined !== texData.image ) {

          texture.image = texData.image;

        } else if ( undefined !== texData.data ) {

          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;

        }

        texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

        texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
        texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

        texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

        if ( undefined !== texData.format ) {

          texture.format = texData.format;

        }
        if ( undefined !== texData.type ) {

          texture.type = texData.type;

        }

        if ( undefined !== texData.mipmaps ) {

          texture.mipmaps = texData.mipmaps;

        }

        if ( 1 === texData.mipmapCount ) {

          texture.minFilter = LinearFilter;

        }

        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture, texData );

      }, onProgress, onError );


      return texture;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ImageLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( ImageLoader.prototype, {

    crossOrigin: 'Anonymous',

    load: function ( url, onLoad, onProgress, onError ) {

      if ( url === undefined ) url = '';

      if ( this.path !== undefined ) url = this.path + url;

      var scope = this;

      var cached = Cache.get( url );

      if ( cached !== undefined ) {

        scope.manager.itemStart( url );

        setTimeout( function () {

          if ( onLoad ) onLoad( cached );

          scope.manager.itemEnd( url );

        }, 0 );

        return cached;

      }

      var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

      image.addEventListener( 'load', function () {

        Cache.add( url, this );

        if ( onLoad ) onLoad( this );

        scope.manager.itemEnd( url );

      }, false );

      /*
      image.addEventListener( 'progress', function ( event ) {

        if ( onProgress ) onProgress( event );

      }, false );
      */

      image.addEventListener( 'error', function ( event ) {

        if ( onError ) onError( event );

        scope.manager.itemEnd( url );
        scope.manager.itemError( url );

      }, false );

      if ( url.substr( 0, 5 ) !== 'data:' ) {

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

      }

      scope.manager.itemStart( url );

      image.src = url;

      return image;

    },

    setCrossOrigin: function ( value ) {

      this.crossOrigin = value;
      return this;

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTextureLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( CubeTextureLoader.prototype, {

    crossOrigin: 'Anonymous',

    load: function ( urls, onLoad, onProgress, onError ) {

      var texture = new CubeTexture();

      var loader = new ImageLoader( this.manager );
      loader.setCrossOrigin( this.crossOrigin );
      loader.setPath( this.path );

      var loaded = 0;

      function loadTexture( i ) {

        loader.load( urls[ i ], function ( image ) {

          texture.images[ i ] = image;

          loaded ++;

          if ( loaded === 6 ) {

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        }, undefined, onError );

      }

      for ( var i = 0; i < urls.length; ++ i ) {

        loadTexture( i );

      }

      return texture;

    },

    setCrossOrigin: function ( value ) {

      this.crossOrigin = value;
      return this;

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function TextureLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( TextureLoader.prototype, {

    crossOrigin: 'Anonymous',

    load: function ( url, onLoad, onProgress, onError ) {

      var loader = new ImageLoader( this.manager );
      loader.setCrossOrigin( this.crossOrigin );
      loader.setPath( this.path );

      var texture = new Texture();
      texture.image = loader.load( url, function () {

        // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
        var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

        texture.format = isJPEG ? RGBFormat : RGBAFormat;
        texture.needsUpdate = true;

        if ( onLoad !== undefined ) {

          onLoad( texture );

        }

      }, onProgress, onError );

      return texture;

    },

    setCrossOrigin: function ( value ) {

      this.crossOrigin = value;
      return this;

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Light( color, intensity ) {

    Object3D.call( this );

    this.type = 'Light';

    this.color = new Color( color );
    this.intensity = intensity !== undefined ? intensity : 1;

    this.receiveShadow = undefined;

  }

  Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Light,

    isLight: true,

    copy: function ( source ) {

      Object3D.prototype.copy.call( this, source );

      this.color.copy( source.color );
      this.intensity = source.intensity;

      return this;

    },

    toJSON: function ( meta ) {

      var data = Object3D.prototype.toJSON.call( this, meta );

      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;

      if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

      if ( this.distance !== undefined ) data.object.distance = this.distance;
      if ( this.angle !== undefined ) data.object.angle = this.angle;
      if ( this.decay !== undefined ) data.object.decay = this.decay;
      if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

      if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

      return data;

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function HemisphereLight( skyColor, groundColor, intensity ) {

    Light.call( this, skyColor, intensity );

    this.type = 'HemisphereLight';

    this.castShadow = undefined;

    this.position.copy( Object3D.DefaultUp );
    this.updateMatrix();

    this.groundColor = new Color( groundColor );

  }

  HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: HemisphereLight,

    isHemisphereLight: true,

    copy: function ( source ) {

      Light.prototype.copy.call( this, source );

      this.groundColor.copy( source.groundColor );

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LightShadow( camera ) {

    this.camera = camera;

    this.bias = 0;
    this.radius = 1;

    this.mapSize = new Vector2( 512, 512 );

    this.map = null;
    this.matrix = new Matrix4();

  }

  Object.assign( LightShadow.prototype, {

    copy: function ( source ) {

      this.camera = source.camera.clone();

      this.bias = source.bias;
      this.radius = source.radius;

      this.mapSize.copy( source.mapSize );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    toJSON: function () {

      var object = {};

      if ( this.bias !== 0 ) object.bias = this.bias;
      if ( this.radius !== 1 ) object.radius = this.radius;
      if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

      object.camera = this.camera.toJSON( false ).object;
      delete object.camera.matrix;

      return object;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function SpotLightShadow() {

    LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  }

  SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    constructor: SpotLightShadow,

    isSpotLightShadow: true,

    update: function ( light ) {

      var camera = this.camera;

      var fov = _Math.RAD2DEG * 2 * light.angle;
      var aspect = this.mapSize.width / this.mapSize.height;
      var far = light.distance || camera.far;

      if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

        camera.fov = fov;
        camera.aspect = aspect;
        camera.far = far;
        camera.updateProjectionMatrix();

      }

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

    Light.call( this, color, intensity );

    this.type = 'SpotLight';

    this.position.copy( Object3D.DefaultUp );
    this.updateMatrix();

    this.target = new Object3D();

    Object.defineProperty( this, 'power', {
      get: function () {

        // intensity = power per solid angle.
        // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
        return this.intensity * Math.PI;

      },
      set: function ( power ) {

        // intensity = power per solid angle.
        // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
        this.intensity = power / Math.PI;

      }
    } );

    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

    this.shadow = new SpotLightShadow();

  }

  SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: SpotLight,

    isSpotLight: true,

    copy: function ( source ) {

      Light.prototype.copy.call( this, source );

      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;

      this.target = source.target.clone();

      this.shadow = source.shadow.clone();

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function PointLight( color, intensity, distance, decay ) {

    Light.call( this, color, intensity );

    this.type = 'PointLight';

    Object.defineProperty( this, 'power', {
      get: function () {

        // intensity = power per solid angle.
        // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
        return this.intensity * 4 * Math.PI;

      },
      set: function ( power ) {

        // intensity = power per solid angle.
        // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
        this.intensity = power / ( 4 * Math.PI );

      }
    } );

    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

    this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  }

  PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: PointLight,

    isPointLight: true,

    copy: function ( source ) {

      Light.prototype.copy.call( this, source );

      this.distance = source.distance;
      this.decay = source.decay;

      this.shadow = source.shadow.clone();

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectionalLightShadow( ) {

    LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  }

  DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    constructor: DirectionalLightShadow

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function DirectionalLight( color, intensity ) {

    Light.call( this, color, intensity );

    this.type = 'DirectionalLight';

    this.position.copy( Object3D.DefaultUp );
    this.updateMatrix();

    this.target = new Object3D();

    this.shadow = new DirectionalLightShadow();

  }

  DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: DirectionalLight,

    isDirectionalLight: true,

    copy: function ( source ) {

      Light.prototype.copy.call( this, source );

      this.target = source.target.clone();

      this.shadow = source.shadow.clone();

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AmbientLight( color, intensity ) {

    Light.call( this, color, intensity );

    this.type = 'AmbientLight';

    this.castShadow = undefined;

  }

  AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: AmbientLight,

    isAmbientLight: true

  } );

  /**
   * @author abelnation / http://github.com/abelnation
   */

  function RectAreaLight( color, intensity, width, height ) {

    Light.call( this, color, intensity );

    this.type = 'RectAreaLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.width = ( width !== undefined ) ? width : 10;
    this.height = ( height !== undefined ) ? height : 10;

    // TODO (abelnation): distance/decay

    // TODO (abelnation): update method for RectAreaLight to update transform to lookat target

    // TODO (abelnation): shadows

  }

  // TODO (abelnation): RectAreaLight update when light shape is changed
  RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

    constructor: RectAreaLight,

    isRectAreaLight: true,

    copy: function ( source ) {

      Light.prototype.copy.call( this, source );

      this.width = source.width;
      this.height = source.height;

      return this;

    },

    toJSON: function ( meta ) {

      var data = Light.prototype.toJSON.call( this, meta );

      data.object.width = this.width;
      data.object.height = this.height;

      return data;

    }

  } );

  /**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  var AnimationUtils = {

    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function ( array, from, to ) {

      if ( AnimationUtils.isTypedArray( array ) ) {

        // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

      }

      return array.slice( from, to );

    },

    // converts an array to a specific type
    convertArray: function ( array, type, forceClone ) {

      if ( ! array || // let 'undefined' and 'null' pass
          ! forceClone && array.constructor === type ) return array;

      if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

        return new type( array ); // create typed array

      }

      return Array.prototype.slice.call( array ); // create Array

    },

    isTypedArray: function ( object ) {

      return ArrayBuffer.isView( object ) &&
          ! ( object instanceof DataView );

    },

    // returns an array by which times and values can be sorted
    getKeyframeOrder: function ( times ) {

      function compareTime( i, j ) {

        return times[ i ] - times[ j ];

      }

      var n = times.length;
      var result = new Array( n );
      for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

      result.sort( compareTime );

      return result;

    },

    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function ( values, stride, order ) {

      var nValues = values.length;
      var result = new values.constructor( nValues );

      for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

        var srcOffset = order[ i ] * stride;

        for ( var j = 0; j !== stride; ++ j ) {

          result[ dstOffset ++ ] = values[ srcOffset + j ];

        }

      }

      return result;

    },

    // function for parsing AOS keyframe formats
    flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

      var i = 1, key = jsonKeys[ 0 ];

      while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

        key = jsonKeys[ i ++ ];

      }

      if ( key === undefined ) return; // no data

      var value = key[ valuePropertyName ];
      if ( value === undefined ) return; // no data

      if ( Array.isArray( value ) ) {

        do {

          value = key[ valuePropertyName ];

          if ( value !== undefined ) {

            times.push( key.time );
            values.push.apply( values, value ); // push all elements

          }

          key = jsonKeys[ i ++ ];

        } while ( key !== undefined );

      } else if ( value.toArray !== undefined ) {

        // ...assume THREE.Math-ish

        do {

          value = key[ valuePropertyName ];

          if ( value !== undefined ) {

            times.push( key.time );
            value.toArray( values, values.length );

          }

          key = jsonKeys[ i ++ ];

        } while ( key !== undefined );

      } else {

        // otherwise push as-is

        do {

          value = key[ valuePropertyName ];

          if ( value !== undefined ) {

            times.push( key.time );
            values.push( value );

          }

          key = jsonKeys[ i ++ ];

        } while ( key !== undefined );

      }

    }

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   *    http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */

  function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;

    this.resultBuffer = resultBuffer !== undefined ?
      resultBuffer : new sampleValues.constructor( sampleSize );
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;

  }

  Object.assign( Interpolant.prototype, {

    evaluate: function ( t ) {

      var pp = this.parameterPositions,
        i1 = this._cachedIndex,

        t1 = pp[ i1 ],
        t0 = pp[ i1 - 1 ];

      validate_interval: {

        seek: {

          var right;

          linear_scan: {

            //- See http://jsperf.com/comparison-to-undefined/3
            //- slower code:
            //-
            //-         if ( t >= t1 || t1 === undefined ) {
            forward_scan: if ( ! ( t < t1 ) ) {

              for ( var giveUpAt = i1 + 2; ; ) {

                if ( t1 === undefined ) {

                  if ( t < t0 ) break forward_scan;

                  // after end

                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_( i1 - 1, t, t0 );

                }

                if ( i1 === giveUpAt ) break; // this loop

                t0 = t1;
                t1 = pp[ ++ i1 ];

                if ( t < t1 ) {

                  // we have arrived at the sought interval
                  break seek;

                }

              }

              // prepare binary search on the right side of the index
              right = pp.length;
              break linear_scan;

            }

            //- slower code:
            //-         if ( t < t0 || t0 === undefined ) {
            if ( ! ( t >= t0 ) ) {

              // looping?

              var t1global = pp[ 1 ];

              if ( t < t1global ) {

                i1 = 2; // + 1, using the scan for the details
                t0 = t1global;

              }

              // linear reverse scan

              for ( var giveUpAt = i1 - 2; ; ) {

                if ( t0 === undefined ) {

                  // before start

                  this._cachedIndex = 0;
                  return this.beforeStart_( 0, t, t1 );

                }

                if ( i1 === giveUpAt ) break; // this loop

                t1 = t0;
                t0 = pp[ -- i1 - 1 ];

                if ( t >= t0 ) {

                  // we have arrived at the sought interval
                  break seek;

                }

              }

              // prepare binary search on the left side of the index
              right = i1;
              i1 = 0;
              break linear_scan;

            }

            // the interval is valid

            break validate_interval;

          } // linear scan

          // binary search

          while ( i1 < right ) {

            var mid = ( i1 + right ) >>> 1;

            if ( t < pp[ mid ] ) {

              right = mid;

            } else {

              i1 = mid + 1;

            }

          }

          t1 = pp[ i1 ];
          t0 = pp[ i1 - 1 ];

          // check boundary cases, again

          if ( t0 === undefined ) {

            this._cachedIndex = 0;
            return this.beforeStart_( 0, t, t1 );

          }

          if ( t1 === undefined ) {

            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_( i1 - 1, t0, t );

          }

        } // seek

        this._cachedIndex = i1;

        this.intervalChanged_( i1, t0, t1 );

      } // validate_interval

      return this.interpolate_( i1, t0, t, t1 );

    },

    settings: null, // optional, subclass-specific settings structure
    // Note: The indirection allows central control of many interpolants.

    // --- Protected interface

    DefaultSettings_: {},

    getSettings_: function () {

      return this.settings || this.DefaultSettings_;

    },

    copySampleValue_: function ( index ) {

      // copies a sample value to the result buffer

      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = index * stride;

      for ( var i = 0; i !== stride; ++ i ) {

        result[ i ] = values[ offset + i ];

      }

      return result;

    },

    // Template methods for derived classes:

    interpolate_: function ( /* i1, t0, t, t1 */ ) {

      throw new Error( 'call to abstract method' );
      // implementations shall return this.resultBuffer

    },

    intervalChanged_: function ( /* i1, t0, t1 */ ) {

      // empty

    }

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( Interpolant.prototype, {

    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,

    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_,

  } );

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */

  function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    this._weightPrev = - 0;
    this._offsetPrev = - 0;
    this._weightNext = - 0;
    this._offsetNext = - 0;

  }

  CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

    constructor: CubicInterpolant,

    DefaultSettings_: {

      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding

    },

    intervalChanged_: function ( i1, t0, t1 ) {

      var pp = this.parameterPositions,
        iPrev = i1 - 2,
        iNext = i1 + 1,

        tPrev = pp[ iPrev ],
        tNext = pp[ iNext ];

      if ( tPrev === undefined ) {

        switch ( this.getSettings_().endingStart ) {

          case ZeroSlopeEnding:

            // f'(t0) = 0
            iPrev = i1;
            tPrev = 2 * t0 - t1;

            break;

          case WrapAroundEnding:

            // use the other end of the curve
            iPrev = pp.length - 2;
            tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

            break;

          default: // ZeroCurvatureEnding

            // f''(t0) = 0 a.k.a. Natural Spline
            iPrev = i1;
            tPrev = t1;

        }

      }

      if ( tNext === undefined ) {

        switch ( this.getSettings_().endingEnd ) {

          case ZeroSlopeEnding:

            // f'(tN) = 0
            iNext = i1;
            tNext = 2 * t1 - t0;

            break;

          case WrapAroundEnding:

            // use the other end of the curve
            iNext = 1;
            tNext = t1 + pp[ 1 ] - pp[ 0 ];

            break;

          default: // ZeroCurvatureEnding

            // f''(tN) = 0, a.k.a. Natural Spline
            iNext = i1 - 1;
            tNext = t0;

        }

      }

      var halfDt = ( t1 - t0 ) * 0.5,
        stride = this.valueSize;

      this._weightPrev = halfDt / ( t0 - tPrev );
      this._weightNext = halfDt / ( tNext - t1 );
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;

    },

    interpolate_: function ( i1, t0, t, t1 ) {

      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,

        o1 = i1 * stride,   o0 = o1 - stride,
        oP = this._offsetPrev,  oN = this._offsetNext,
        wP = this._weightPrev,  wN = this._weightNext,

        p = ( t - t0 ) / ( t1 - t0 ),
        pp = p * p,
        ppp = pp * p;

      // evaluate polynomials

      var sP = - wP * ppp + 2 * wP * pp - wP * p;
      var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
      var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
      var sN = wN * ppp - wN * pp;

      // combine data linearly

      for ( var i = 0; i !== stride; ++ i ) {

        result[ i ] =
            sP * values[ oP + i ] +
            s0 * values[ o0 + i ] +
            s1 * values[ o1 + i ] +
            sN * values[ oN + i ];

      }

      return result;

    }

  } );

  /**
   * @author tschw
   */

  function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

    constructor: LinearInterpolant,

    interpolate_: function ( i1, t0, t, t1 ) {

      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,

        offset1 = i1 * stride,
        offset0 = offset1 - stride,

        weight1 = ( t - t0 ) / ( t1 - t0 ),
        weight0 = 1 - weight1;

      for ( var i = 0; i !== stride; ++ i ) {

        result[ i ] =
            values[ offset0 + i ] * weight0 +
            values[ offset1 + i ] * weight1;

      }

      return result;

    }

  } );

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */

  function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

    constructor: DiscreteInterpolant,

    interpolate_: function ( i1 /*, t0, t, t1 */ ) {

      return this.copySampleValue_( i1 - 1 );

    }

  } );

  var KeyframeTrackPrototype;

  KeyframeTrackPrototype = {

    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,

    DefaultInterpolation: InterpolateLinear,

    InterpolantFactoryMethodDiscrete: function ( result ) {

      return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

    },

    InterpolantFactoryMethodLinear: function ( result ) {

      return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

    },

    InterpolantFactoryMethodSmooth: function ( result ) {

      return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

    },

    setInterpolation: function ( interpolation ) {

      var factoryMethod;

      switch ( interpolation ) {

        case InterpolateDiscrete:

          factoryMethod = this.InterpolantFactoryMethodDiscrete;

          break;

        case InterpolateLinear:

          factoryMethod = this.InterpolantFactoryMethodLinear;

          break;

        case InterpolateSmooth:

          factoryMethod = this.InterpolantFactoryMethodSmooth;

          break;

      }

      if ( factoryMethod === undefined ) {

        var message = "unsupported interpolation for " +
            this.ValueTypeName + " keyframe track named " + this.name;

        if ( this.createInterpolant === undefined ) {

          // fall back to default, unless the default itself is messed up
          if ( interpolation !== this.DefaultInterpolation ) {

            this.setInterpolation( this.DefaultInterpolation );

          } else {

            throw new Error( message ); // fatal, in this case

          }

        }

        console.warn( 'THREE.KeyframeTrackPrototype:', message );
        return;

      }

      this.createInterpolant = factoryMethod;

    },

    getInterpolation: function () {

      switch ( this.createInterpolant ) {

        case this.InterpolantFactoryMethodDiscrete:

          return InterpolateDiscrete;

        case this.InterpolantFactoryMethodLinear:

          return InterpolateLinear;

        case this.InterpolantFactoryMethodSmooth:

          return InterpolateSmooth;

      }

    },

    getValueSize: function () {

      return this.values.length / this.times.length;

    },

    // move all keyframes either forwards or backwards in time
    shift: function ( timeOffset ) {

      if ( timeOffset !== 0.0 ) {

        var times = this.times;

        for ( var i = 0, n = times.length; i !== n; ++ i ) {

          times[ i ] += timeOffset;

        }

      }

      return this;

    },

    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function ( timeScale ) {

      if ( timeScale !== 1.0 ) {

        var times = this.times;

        for ( var i = 0, n = times.length; i !== n; ++ i ) {

          times[ i ] *= timeScale;

        }

      }

      return this;

    },

    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function ( startTime, endTime ) {

      var times = this.times,
        nKeys = times.length,
        from = 0,
        to = nKeys - 1;

      while ( from !== nKeys && times[ from ] < startTime ) ++ from;
      while ( to !== - 1 && times[ to ] > endTime ) -- to;

      ++ to; // inclusive -> exclusive bound

      if ( from !== 0 || to !== nKeys ) {

        // empty tracks are forbidden, so keep at least one keyframe
        if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

        var stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice( times, from, to );
        this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

      }

      return this;

    },

    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate: function () {

      var valid = true;

      var valueSize = this.getValueSize();
      if ( valueSize - Math.floor( valueSize ) !== 0 ) {

        console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
        valid = false;

      }

      var times = this.times,
        values = this.values,

        nKeys = times.length;

      if ( nKeys === 0 ) {

        console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
        valid = false;

      }

      var prevTime = null;

      for ( var i = 0; i !== nKeys; i ++ ) {

        var currTime = times[ i ];

        if ( typeof currTime === 'number' && isNaN( currTime ) ) {

          console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this, i, currTime );
          valid = false;
          break;

        }

        if ( prevTime !== null && prevTime > currTime ) {

          console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this, i, currTime, prevTime );
          valid = false;
          break;

        }

        prevTime = currTime;

      }

      if ( values !== undefined ) {

        if ( AnimationUtils.isTypedArray( values ) ) {

          for ( var i = 0, n = values.length; i !== n; ++ i ) {

            var value = values[ i ];

            if ( isNaN( value ) ) {

              console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this, i, value );
              valid = false;
              break;

            }

          }

        }

      }

      return valid;

    },

    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize: function () {

      var times = this.times,
        values = this.values,
        stride = this.getValueSize(),

        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

        writeIndex = 1,
        lastIndex = times.length - 1;

      for ( var i = 1; i < lastIndex; ++ i ) {

        var keep = false;

        var time = times[ i ];
        var timeNext = times[ i + 1 ];

        // remove adjacent keyframes scheduled at the same time

        if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

          if ( ! smoothInterpolation ) {

            // remove unnecessary keyframes same as their neighbors

            var offset = i * stride,
              offsetP = offset - stride,
              offsetN = offset + stride;

            for ( var j = 0; j !== stride; ++ j ) {

              var value = values[ offset + j ];

              if ( value !== values[ offsetP + j ] ||
                  value !== values[ offsetN + j ] ) {

                keep = true;
                break;

              }

            }

          } else keep = true;

        }

        // in-place compaction

        if ( keep ) {

          if ( i !== writeIndex ) {

            times[ writeIndex ] = times[ i ];

            var readOffset = i * stride,
              writeOffset = writeIndex * stride;

            for ( var j = 0; j !== stride; ++ j )

              values[ writeOffset + j ] = values[ readOffset + j ];

          }

          ++ writeIndex;

        }

      }

      // flush last keyframe (compaction looks ahead)

      if ( lastIndex > 0 ) {

        times[ writeIndex ] = times[ lastIndex ];

        for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

          values[ writeOffset + j ] = values[ readOffset + j ];

        ++ writeIndex;

      }

      if ( writeIndex !== times.length ) {

        this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
        this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

      }

      return this;

    }

  };

  function KeyframeTrackConstructor( name, times, values, interpolation ) {

    if ( name === undefined ) throw new Error( 'track name is undefined' );

    if ( times === undefined || times.length === 0 ) {

      throw new Error( 'no keyframes in track named ' + name );

    }

    this.name = name;

    this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
    this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

    this.setInterpolation( interpolation || this.DefaultInterpolation );

    this.validate();
    this.optimize();

  }

  /**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function VectorKeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: VectorKeyframeTrack,

    ValueTypeName: 'vector'

    // ValueBufferType is inherited

    // DefaultInterpolation is inherited

  } );

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */

  function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

    constructor: QuaternionLinearInterpolant,

    interpolate_: function ( i1, t0, t, t1 ) {

      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,

        offset = i1 * stride,

        alpha = ( t - t0 ) / ( t1 - t0 );

      for ( var end = offset + stride; offset !== end; offset += 4 ) {

        Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

      }

      return result;

    }

  } );

  /**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function QuaternionKeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: QuaternionKeyframeTrack,

    ValueTypeName: 'quaternion',

    // ValueBufferType is inherited

    DefaultInterpolation: InterpolateLinear,

    InterpolantFactoryMethodLinear: function ( result ) {

      return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

    },

    InterpolantFactoryMethodSmooth: undefined // not yet implemented

  } );

  /**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function NumberKeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: NumberKeyframeTrack,

    ValueTypeName: 'number'

    // ValueBufferType is inherited

    // DefaultInterpolation is inherited

  } );

  /**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function StringKeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: StringKeyframeTrack,

    ValueTypeName: 'string',
    ValueBufferType: Array,

    DefaultInterpolation: InterpolateDiscrete,

    InterpolantFactoryMethodLinear: undefined,

    InterpolantFactoryMethodSmooth: undefined

  } );

  /**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function BooleanKeyframeTrack( name, times, values ) {

    KeyframeTrackConstructor.call( this, name, times, values );

  }

  BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: BooleanKeyframeTrack,

    ValueTypeName: 'bool',
    ValueBufferType: Array,

    DefaultInterpolation: InterpolateDiscrete,

    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined

    // Note: Actually this track could have a optimized / compressed
    // representation of a single value and a custom interpolant that
    // computes "firstValue ^ isOdd( index )".

  } );

  /**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function ColorKeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

    constructor: ColorKeyframeTrack,

    ValueTypeName: 'color'

    // ValueBufferType is inherited

    // DefaultInterpolation is inherited


    // Note: Very basic implementation and nothing special yet.
    // However, this is the place for color space parameterization.

  } );

  /**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function KeyframeTrack( name, times, values, interpolation ) {

    KeyframeTrackConstructor.apply( this, name, times, values, interpolation );

  }

  KeyframeTrack.prototype = KeyframeTrackPrototype;
  KeyframeTrackPrototype.constructor = KeyframeTrack;

  // Static methods:

  Object.assign( KeyframeTrack, {

    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):

    parse: function ( json ) {

      if ( json.type === undefined ) {

        throw new Error( 'track type undefined, can not parse' );

      }

      var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

      if ( json.times === undefined ) {

        var times = [], values = [];

        AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

        json.times = times;
        json.values = values;

      }

      // derived classes can define a static parse method
      if ( trackType.parse !== undefined ) {

        return trackType.parse( json );

      } else {

        // by default, we assume a constructor compatible with the base
        return new trackType( json.name, json.times, json.values, json.interpolation );

      }

    },

    toJSON: function ( track ) {

      var trackType = track.constructor;

      var json;

      // derived classes can define a static toJSON method
      if ( trackType.toJSON !== undefined ) {

        json = trackType.toJSON( track );

      } else {

        // by default, we assume the data can be serialized as-is
        json = {

          'name': track.name,
          'times': AnimationUtils.convertArray( track.times, Array ),
          'values': AnimationUtils.convertArray( track.values, Array )

        };

        var interpolation = track.getInterpolation();

        if ( interpolation !== track.DefaultInterpolation ) {

          json.interpolation = interpolation;

        }

      }

      json.type = track.ValueTypeName; // mandatory

      return json;

    },

    _getTrackTypeForValueTypeName: function ( typeName ) {

      switch ( typeName.toLowerCase() ) {

        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':

          return NumberKeyframeTrack;

        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':

          return VectorKeyframeTrack;

        case 'color':

          return ColorKeyframeTrack;

        case 'quaternion':

          return QuaternionKeyframeTrack;

        case 'bool':
        case 'boolean':

          return BooleanKeyframeTrack;

        case 'string':

          return StringKeyframeTrack;

      }

      throw new Error( 'Unsupported typeName: ' + typeName );

    }

  } );

  /**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  function AnimationClip( name, duration, tracks ) {

    this.name = name;
    this.tracks = tracks;
    this.duration = ( duration !== undefined ) ? duration : - 1;

    this.uuid = _Math.generateUUID();

    // this means it should figure out its duration by scanning the tracks
    if ( this.duration < 0 ) {

      this.resetDuration();

    }

    this.optimize();

  }

  Object.assign( AnimationClip, {

    parse: function ( json ) {

      var tracks = [],
        jsonTracks = json.tracks,
        frameTime = 1.0 / ( json.fps || 1.0 );

      for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

        tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

      }

      return new AnimationClip( json.name, json.duration, tracks );

    },

    toJSON: function ( clip ) {

      var tracks = [],
        clipTracks = clip.tracks;

      var json = {

        'name': clip.name,
        'duration': clip.duration,
        'tracks': tracks

      };

      for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

        tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

      }

      return json;

    },

    CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];

      for ( var i = 0; i < numMorphTargets; i ++ ) {

        var times = [];
        var values = [];

        times.push(
          ( i + numMorphTargets - 1 ) % numMorphTargets,
          i,
          ( i + 1 ) % numMorphTargets );

        values.push( 0, 1, 0 );

        var order = AnimationUtils.getKeyframeOrder( times );
        times = AnimationUtils.sortedArray( times, 1, order );
        values = AnimationUtils.sortedArray( values, 1, order );

        // if there is a key at the first frame, duplicate it as the
        // last frame as well for perfect loop.
        if ( ! noLoop && times[ 0 ] === 0 ) {

          times.push( numMorphTargets );
          values.push( values[ 0 ] );

        }

        tracks.push(
          new NumberKeyframeTrack(
            '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
            times, values
          ).scale( 1.0 / fps ) );

      }

      return new AnimationClip( name, - 1, tracks );

    },

    findByName: function ( objectOrClipArray, name ) {

      var clipArray = objectOrClipArray;

      if ( ! Array.isArray( objectOrClipArray ) ) {

        var o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;

      }

      for ( var i = 0; i < clipArray.length; i ++ ) {

        if ( clipArray[ i ].name === name ) {

          return clipArray[ i ];

        }

      }

      return null;

    },

    CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

      var animationToMorphTargets = {};

      // tested with https://regex101.com/ on trick sequences
      // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
      var pattern = /^([\w-]*?)([\d]+)$/;

      // sort morph target names into animation groups based
      // patterns like Walk_001, Walk_002, Run_001, Run_002
      for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

        var morphTarget = morphTargets[ i ];
        var parts = morphTarget.name.match( pattern );

        if ( parts && parts.length > 1 ) {

          var name = parts[ 1 ];

          var animationMorphTargets = animationToMorphTargets[ name ];
          if ( ! animationMorphTargets ) {

            animationToMorphTargets[ name ] = animationMorphTargets = [];

          }

          animationMorphTargets.push( morphTarget );

        }

      }

      var clips = [];

      for ( var name in animationToMorphTargets ) {

        clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

      }

      return clips;

    },

    // parse the animation.hierarchy format
    parseAnimation: function ( animation, bones ) {

      if ( ! animation ) {

        console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
        return null;

      }

      var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

        // only return track if there are actually keys.
        if ( animationKeys.length !== 0 ) {

          var times = [];
          var values = [];

          AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

          // empty keys are filtered out, so check again
          if ( times.length !== 0 ) {

            destTracks.push( new trackType( trackName, times, values ) );

          }

        }

      };

      var tracks = [];

      var clipName = animation.name || 'default';
      // automatic length determination in AnimationClip.
      var duration = animation.length || - 1;
      var fps = animation.fps || 30;

      var hierarchyTracks = animation.hierarchy || [];

      for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

        var animationKeys = hierarchyTracks[ h ].keys;

        // skip empty tracks
        if ( ! animationKeys || animationKeys.length === 0 ) continue;

        // process morph targets
        if ( animationKeys[ 0 ].morphTargets ) {

          // figure out all morph targets used in this track
          var morphTargetNames = {};

          for ( var k = 0; k < animationKeys.length; k ++ ) {

            if ( animationKeys[ k ].morphTargets ) {

              for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

                morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

              }

            }

          }

          // create a track for each morph target with all zero
          // morphTargetInfluences except for the keys in which
          // the morphTarget is named.
          for ( var morphTargetName in morphTargetNames ) {

            var times = [];
            var values = [];

            for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

              var animationKey = animationKeys[ k ];

              times.push( animationKey.time );
              values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

            }

            tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

          }

          duration = morphTargetNames.length * ( fps || 1.0 );

        } else {

          // ...assume skeletal animation

          var boneName = '.bones[' + bones[ h ].name + ']';

          addNonemptyTrack(
            VectorKeyframeTrack, boneName + '.position',
            animationKeys, 'pos', tracks );

          addNonemptyTrack(
            QuaternionKeyframeTrack, boneName + '.quaternion',
            animationKeys, 'rot', tracks );

          addNonemptyTrack(
            VectorKeyframeTrack, boneName + '.scale',
            animationKeys, 'scl', tracks );

        }

      }

      if ( tracks.length === 0 ) {

        return null;

      }

      var clip = new AnimationClip( clipName, duration, tracks );

      return clip;

    }

  } );

  Object.assign( AnimationClip.prototype, {

    resetDuration: function () {

      var tracks = this.tracks, duration = 0;

      for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

        var track = this.tracks[ i ];

        duration = Math.max( duration, track.times[ track.times.length - 1 ] );

      }

      this.duration = duration;

    },

    trim: function () {

      for ( var i = 0; i < this.tracks.length; i ++ ) {

        this.tracks[ i ].trim( 0, this.duration );

      }

      return this;

    },

    optimize: function () {

      for ( var i = 0; i < this.tracks.length; i ++ ) {

        this.tracks[ i ].optimize();

      }

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function MaterialLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
    this.textures = {};

  }

  Object.assign( MaterialLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var loader = new FileLoader( scope.manager );
      loader.load( url, function ( text ) {

        onLoad( scope.parse( JSON.parse( text ) ) );

      }, onProgress, onError );

    },

    setTextures: function ( value ) {

      this.textures = value;

    },

    parse: function ( json ) {

      var textures = this.textures;

      function getTexture( name ) {

        if ( textures[ name ] === undefined ) {

          console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

      }

      var material = new Materials[ json.type ]();

      if ( json.uuid !== undefined ) material.uuid = json.uuid;
      if ( json.name !== undefined ) material.name = json.name;
      if ( json.color !== undefined ) material.color.setHex( json.color );
      if ( json.roughness !== undefined ) material.roughness = json.roughness;
      if ( json.metalness !== undefined ) material.metalness = json.metalness;
      if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
      if ( json.specular !== undefined ) material.specular.setHex( json.specular );
      if ( json.shininess !== undefined ) material.shininess = json.shininess;
      if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
      if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
      if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
      if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
      if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
      if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
      if ( json.fog !== undefined ) material.fog = json.fog;
      if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
      if ( json.blending !== undefined ) material.blending = json.blending;
      if ( json.side !== undefined ) material.side = json.side;
      if ( json.opacity !== undefined ) material.opacity = json.opacity;
      if ( json.transparent !== undefined ) material.transparent = json.transparent;
      if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
      if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
      if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
      if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
      if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
      if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
      if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
      if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

      if ( json.rotation !== undefined ) material.rotation = json.rotation;

      if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
      if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
      if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
      if ( json.scale !== undefined ) material.scale = json.scale;

      if ( json.skinning !== undefined ) material.skinning = json.skinning;
      if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
      if ( json.dithering !== undefined ) material.dithering = json.dithering;

      if ( json.visible !== undefined ) material.visible = json.visible;
      if ( json.userData !== undefined ) material.userData = json.userData;

      // Deprecated

      if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

      // for PointsMaterial

      if ( json.size !== undefined ) material.size = json.size;
      if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

      // maps

      if ( json.map !== undefined ) material.map = getTexture( json.map );

      if ( json.alphaMap !== undefined ) {

        material.alphaMap = getTexture( json.alphaMap );
        material.transparent = true;

      }

      if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
      if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

      if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
      if ( json.normalScale !== undefined ) {

        var normalScale = json.normalScale;

        if ( Array.isArray( normalScale ) === false ) {

          // Blender exporter used to export a scalar. See #7459

          normalScale = [ normalScale, normalScale ];

        }

        material.normalScale = new Vector2().fromArray( normalScale );

      }

      if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
      if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
      if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

      if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
      if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

      if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
      if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

      if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

      if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

      if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

      if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
      if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

      if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
      if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

      if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

      return material;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometryLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( BufferGeometryLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var loader = new FileLoader( scope.manager );
      loader.load( url, function ( text ) {

        onLoad( scope.parse( JSON.parse( text ) ) );

      }, onProgress, onError );

    },

    parse: function ( json ) {

      var geometry = new BufferGeometry();

      var index = json.data.index;

      if ( index !== undefined ) {

        var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
        geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

      }

      var attributes = json.data.attributes;

      for ( var key in attributes ) {

        var attribute = attributes[ key ];
        var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

        geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

      }

      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

      if ( groups !== undefined ) {

        for ( var i = 0, n = groups.length; i !== n; ++ i ) {

          var group = groups[ i ];

          geometry.addGroup( group.start, group.count, group.materialIndex );

        }

      }

      var boundingSphere = json.data.boundingSphere;

      if ( boundingSphere !== undefined ) {

        var center = new Vector3();

        if ( boundingSphere.center !== undefined ) {

          center.fromArray( boundingSphere.center );

        }

        geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

      }

      return geometry;

    }

  } );

  var TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    // Workaround for IE11 pre KB2929437. See #11440
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Loader() {

    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {};

  }

  Loader.Handlers = {

    handlers: [],

    add: function ( regex, loader ) {

      this.handlers.push( regex, loader );

    },

    get: function ( file ) {

      var handlers = this.handlers;

      for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

        var regex = handlers[ i ];
        var loader = handlers[ i + 1 ];

        if ( regex.test( file ) ) {

          return loader;

        }

      }

      return null;

    }

  };

  Object.assign( Loader.prototype, {

    crossOrigin: undefined,

    extractUrlBase: function ( url ) {

      var parts = url.split( '/' );

      if ( parts.length === 1 ) return './';

      parts.pop();

      return parts.join( '/' ) + '/';

    },

    initMaterials: function ( materials, texturePath, crossOrigin ) {

      var array = [];

      for ( var i = 0; i < materials.length; ++ i ) {

        array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

      }

      return array;

    },

    createMaterial: ( function () {

      var BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
      };

      var color = new Color();
      var textureLoader = new TextureLoader();
      var materialLoader = new MaterialLoader();

      return function createMaterial( m, texturePath, crossOrigin ) {

        // convert from old material format

        var textures = {};

        function loadTexture( path, repeat, offset, wrap, anisotropy ) {

          var fullPath = texturePath + path;
          var loader = Loader.Handlers.get( fullPath );

          var texture;

          if ( loader !== null ) {

            texture = loader.load( fullPath );

          } else {

            textureLoader.setCrossOrigin( crossOrigin );
            texture = textureLoader.load( fullPath );

          }

          if ( repeat !== undefined ) {

            texture.repeat.fromArray( repeat );

            if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
            if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

          }

          if ( offset !== undefined ) {

            texture.offset.fromArray( offset );

          }

          if ( wrap !== undefined ) {

            if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
            if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

            if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
            if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

          }

          if ( anisotropy !== undefined ) {

            texture.anisotropy = anisotropy;

          }

          var uuid = _Math.generateUUID();

          textures[ uuid ] = texture;

          return uuid;

        }

        //

        var json = {
          uuid: _Math.generateUUID(),
          type: 'MeshLambertMaterial'
        };

        for ( var name in m ) {

          var value = m[ name ];

          switch ( name ) {

            case 'DbgColor':
            case 'DbgIndex':
            case 'opticalDensity':
            case 'illumination':
              break;
            case 'DbgName':
              json.name = value;
              break;
            case 'blending':
              json.blending = BlendingMode[ value ];
              break;
            case 'colorAmbient':
            case 'mapAmbient':
              console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
              break;
            case 'colorDiffuse':
              json.color = color.fromArray( value ).getHex();
              break;
            case 'colorSpecular':
              json.specular = color.fromArray( value ).getHex();
              break;
            case 'colorEmissive':
              json.emissive = color.fromArray( value ).getHex();
              break;
            case 'specularCoef':
              json.shininess = value;
              break;
            case 'shading':
              if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
              if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
              if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
              break;
            case 'mapDiffuse':
              json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
              break;
            case 'mapDiffuseRepeat':
            case 'mapDiffuseOffset':
            case 'mapDiffuseWrap':
            case 'mapDiffuseAnisotropy':
              break;
            case 'mapEmissive':
              json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
              break;
            case 'mapEmissiveRepeat':
            case 'mapEmissiveOffset':
            case 'mapEmissiveWrap':
            case 'mapEmissiveAnisotropy':
              break;
            case 'mapLight':
              json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
              break;
            case 'mapLightRepeat':
            case 'mapLightOffset':
            case 'mapLightWrap':
            case 'mapLightAnisotropy':
              break;
            case 'mapAO':
              json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
              break;
            case 'mapAORepeat':
            case 'mapAOOffset':
            case 'mapAOWrap':
            case 'mapAOAnisotropy':
              break;
            case 'mapBump':
              json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
              break;
            case 'mapBumpScale':
              json.bumpScale = value;
              break;
            case 'mapBumpRepeat':
            case 'mapBumpOffset':
            case 'mapBumpWrap':
            case 'mapBumpAnisotropy':
              break;
            case 'mapNormal':
              json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
              break;
            case 'mapNormalFactor':
              json.normalScale = [ value, value ];
              break;
            case 'mapNormalRepeat':
            case 'mapNormalOffset':
            case 'mapNormalWrap':
            case 'mapNormalAnisotropy':
              break;
            case 'mapSpecular':
              json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
              break;
            case 'mapSpecularRepeat':
            case 'mapSpecularOffset':
            case 'mapSpecularWrap':
            case 'mapSpecularAnisotropy':
              break;
            case 'mapMetalness':
              json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
              break;
            case 'mapMetalnessRepeat':
            case 'mapMetalnessOffset':
            case 'mapMetalnessWrap':
            case 'mapMetalnessAnisotropy':
              break;
            case 'mapRoughness':
              json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
              break;
            case 'mapRoughnessRepeat':
            case 'mapRoughnessOffset':
            case 'mapRoughnessWrap':
            case 'mapRoughnessAnisotropy':
              break;
            case 'mapAlpha':
              json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
              break;
            case 'mapAlphaRepeat':
            case 'mapAlphaOffset':
            case 'mapAlphaWrap':
            case 'mapAlphaAnisotropy':
              break;
            case 'flipSided':
              json.side = BackSide;
              break;
            case 'doubleSided':
              json.side = DoubleSide;
              break;
            case 'transparency':
              console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
              json.opacity = value;
              break;
            case 'depthTest':
            case 'depthWrite':
            case 'colorWrite':
            case 'opacity':
            case 'reflectivity':
            case 'transparent':
            case 'visible':
            case 'wireframe':
              json[ name ] = value;
              break;
            case 'vertexColors':
              if ( value === true ) json.vertexColors = VertexColors;
              if ( value === 'face' ) json.vertexColors = FaceColors;
              break;
            default:
              console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
              break;

          }

        }

        if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
        if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

        if ( json.opacity < 1 ) json.transparent = true;

        materialLoader.setTextures( textures );

        return materialLoader.parse( json );

      };

    } )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function JSONLoader( manager ) {

    if ( typeof manager === 'boolean' ) {

      console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
      manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    this.withCredentials = false;

  }

  Object.assign( JSONLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

      var loader = new FileLoader( this.manager );
      loader.setWithCredentials( this.withCredentials );
      loader.load( url, function ( text ) {

        var json = JSON.parse( text );
        var metadata = json.metadata;

        if ( metadata !== undefined ) {

          var type = metadata.type;

          if ( type !== undefined ) {

            if ( type.toLowerCase() === 'object' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
              return;

            }

            if ( type.toLowerCase() === 'scene' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
              return;

            }

          }

        }

        var object = scope.parse( json, texturePath );
        onLoad( object.geometry, object.materials );

      }, onProgress, onError );

    },

    setTexturePath: function ( value ) {

      this.texturePath = value;

    },

    parse: ( function () {

      function parseModel( json, geometry ) {

        function isBitSet( value, position ) {

          return value & ( 1 << position );

        }

        var i, j, fi,

          offset, zLength,

          colorIndex, normalIndex, uvIndex, materialIndex,

          type,
          isQuad,
          hasMaterial,
          hasFaceVertexUv,
          hasFaceNormal, hasFaceVertexNormal,
          hasFaceColor, hasFaceVertexColor,

          vertex, face, faceA, faceB, hex, normal,

          uvLayer, uv, u, v,

          faces = json.faces,
          vertices = json.vertices,
          normals = json.normals,
          colors = json.colors,

          scale = json.scale,

          nUvLayers = 0;


        if ( json.uvs !== undefined ) {

          // disregard empty arrays

          for ( i = 0; i < json.uvs.length; i ++ ) {

            if ( json.uvs[ i ].length ) nUvLayers ++;

          }

          for ( i = 0; i < nUvLayers; i ++ ) {

            geometry.faceVertexUvs[ i ] = [];

          }

        }

        offset = 0;
        zLength = vertices.length;

        while ( offset < zLength ) {

          vertex = new Vector3();

          vertex.x = vertices[ offset ++ ] * scale;
          vertex.y = vertices[ offset ++ ] * scale;
          vertex.z = vertices[ offset ++ ] * scale;

          geometry.vertices.push( vertex );

        }

        offset = 0;
        zLength = faces.length;

        while ( offset < zLength ) {

          type = faces[ offset ++ ];

          isQuad = isBitSet( type, 0 );
          hasMaterial = isBitSet( type, 1 );
          hasFaceVertexUv = isBitSet( type, 3 );
          hasFaceNormal = isBitSet( type, 4 );
          hasFaceVertexNormal = isBitSet( type, 5 );
          hasFaceColor = isBitSet( type, 6 );
          hasFaceVertexColor = isBitSet( type, 7 );

          // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

          if ( isQuad ) {

            faceA = new Face3();
            faceA.a = faces[ offset ];
            faceA.b = faces[ offset + 1 ];
            faceA.c = faces[ offset + 3 ];

            faceB = new Face3();
            faceB.a = faces[ offset + 1 ];
            faceB.b = faces[ offset + 2 ];
            faceB.c = faces[ offset + 3 ];

            offset += 4;

            if ( hasMaterial ) {

              materialIndex = faces[ offset ++ ];
              faceA.materialIndex = materialIndex;
              faceB.materialIndex = materialIndex;

            }

            // to get face <=> uv index correspondence

            fi = geometry.faces.length;

            if ( hasFaceVertexUv ) {

              for ( i = 0; i < nUvLayers; i ++ ) {

                uvLayer = json.uvs[ i ];

                geometry.faceVertexUvs[ i ][ fi ] = [];
                geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                for ( j = 0; j < 4; j ++ ) {

                  uvIndex = faces[ offset ++ ];

                  u = uvLayer[ uvIndex * 2 ];
                  v = uvLayer[ uvIndex * 2 + 1 ];

                  uv = new Vector2( u, v );

                  if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                  if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                }

              }

            }

            if ( hasFaceNormal ) {

              normalIndex = faces[ offset ++ ] * 3;

              faceA.normal.set(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );

              faceB.normal.copy( faceA.normal );

            }

            if ( hasFaceVertexNormal ) {

              for ( i = 0; i < 4; i ++ ) {

                normalIndex = faces[ offset ++ ] * 3;

                normal = new Vector3(
                  normals[ normalIndex ++ ],
                  normals[ normalIndex ++ ],
                  normals[ normalIndex ]
                );


                if ( i !== 2 ) faceA.vertexNormals.push( normal );
                if ( i !== 0 ) faceB.vertexNormals.push( normal );

              }

            }


            if ( hasFaceColor ) {

              colorIndex = faces[ offset ++ ];
              hex = colors[ colorIndex ];

              faceA.color.setHex( hex );
              faceB.color.setHex( hex );

            }


            if ( hasFaceVertexColor ) {

              for ( i = 0; i < 4; i ++ ) {

                colorIndex = faces[ offset ++ ];
                hex = colors[ colorIndex ];

                if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
                if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

              }

            }

            geometry.faces.push( faceA );
            geometry.faces.push( faceB );

          } else {

            face = new Face3();
            face.a = faces[ offset ++ ];
            face.b = faces[ offset ++ ];
            face.c = faces[ offset ++ ];

            if ( hasMaterial ) {

              materialIndex = faces[ offset ++ ];
              face.materialIndex = materialIndex;

            }

            // to get face <=> uv index correspondence

            fi = geometry.faces.length;

            if ( hasFaceVertexUv ) {

              for ( i = 0; i < nUvLayers; i ++ ) {

                uvLayer = json.uvs[ i ];

                geometry.faceVertexUvs[ i ][ fi ] = [];

                for ( j = 0; j < 3; j ++ ) {

                  uvIndex = faces[ offset ++ ];

                  u = uvLayer[ uvIndex * 2 ];
                  v = uvLayer[ uvIndex * 2 + 1 ];

                  uv = new Vector2( u, v );

                  geometry.faceVertexUvs[ i ][ fi ].push( uv );

                }

              }

            }

            if ( hasFaceNormal ) {

              normalIndex = faces[ offset ++ ] * 3;

              face.normal.set(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );

            }

            if ( hasFaceVertexNormal ) {

              for ( i = 0; i < 3; i ++ ) {

                normalIndex = faces[ offset ++ ] * 3;

                normal = new Vector3(
                  normals[ normalIndex ++ ],
                  normals[ normalIndex ++ ],
                  normals[ normalIndex ]
                );

                face.vertexNormals.push( normal );

              }

            }


            if ( hasFaceColor ) {

              colorIndex = faces[ offset ++ ];
              face.color.setHex( colors[ colorIndex ] );

            }


            if ( hasFaceVertexColor ) {

              for ( i = 0; i < 3; i ++ ) {

                colorIndex = faces[ offset ++ ];
                face.vertexColors.push( new Color( colors[ colorIndex ] ) );

              }

            }

            geometry.faces.push( face );

          }

        }

      }

      function parseSkin( json, geometry ) {

        var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

        if ( json.skinWeights ) {

          for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

            var x = json.skinWeights[ i ];
            var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
            var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
            var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

            geometry.skinWeights.push( new Vector4( x, y, z, w ) );

          }

        }

        if ( json.skinIndices ) {

          for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

            var a = json.skinIndices[ i ];
            var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
            var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
            var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

            geometry.skinIndices.push( new Vector4( a, b, c, d ) );

          }

        }

        geometry.bones = json.bones;

        if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

          console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
            geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

        }

      }

      function parseMorphing( json, geometry ) {

        var scale = json.scale;

        if ( json.morphTargets !== undefined ) {

          for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

            geometry.morphTargets[ i ] = {};
            geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
            geometry.morphTargets[ i ].vertices = [];

            var dstVertices = geometry.morphTargets[ i ].vertices;
            var srcVertices = json.morphTargets[ i ].vertices;

            for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

              var vertex = new Vector3();
              vertex.x = srcVertices[ v ] * scale;
              vertex.y = srcVertices[ v + 1 ] * scale;
              vertex.z = srcVertices[ v + 2 ] * scale;

              dstVertices.push( vertex );

            }

          }

        }

        if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

          console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

          var faces = geometry.faces;
          var morphColors = json.morphColors[ 0 ].colors;

          for ( var i = 0, l = faces.length; i < l; i ++ ) {

            faces[ i ].color.fromArray( morphColors, i * 3 );

          }

        }

      }

      function parseAnimations( json, geometry ) {

        var outputAnimations = [];

        // parse old style Bone/Hierarchy animations
        var animations = [];

        if ( json.animation !== undefined ) {

          animations.push( json.animation );

        }

        if ( json.animations !== undefined ) {

          if ( json.animations.length ) {

            animations = animations.concat( json.animations );

          } else {

            animations.push( json.animations );

          }

        }

        for ( var i = 0; i < animations.length; i ++ ) {

          var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
          if ( clip ) outputAnimations.push( clip );

        }

        // parse implicit morph animations
        if ( geometry.morphTargets ) {

          // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
          var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
          outputAnimations = outputAnimations.concat( morphAnimationClips );

        }

        if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

      }

      return function ( json, texturePath ) {

        if ( json.data !== undefined ) {

          // Geometry 4.0 spec
          json = json.data;

        }

        if ( json.scale !== undefined ) {

          json.scale = 1.0 / json.scale;

        } else {

          json.scale = 1.0;

        }

        var geometry = new Geometry();

        parseModel( json, geometry );
        parseSkin( json, geometry );
        parseMorphing( json, geometry );
        parseAnimations( json, geometry );

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        if ( json.materials === undefined || json.materials.length === 0 ) {

          return { geometry: geometry };

        } else {

          var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

          return { geometry: geometry, materials: materials };

        }

      };

    } )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ObjectLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
    this.texturePath = '';

  }

  Object.assign( ObjectLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      if ( this.texturePath === '' ) {

        this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

      }

      var scope = this;

      var loader = new FileLoader( scope.manager );
      loader.load( url, function ( text ) {

        var json = null;

        try {

          json = JSON.parse( text );

        } catch ( error ) {

          if ( onError !== undefined ) onError( error );

          console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

          return;

        }

        var metadata = json.metadata;

        if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

          console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
          return;

        }

        scope.parse( json, onLoad );

      }, onProgress, onError );

    },

    setTexturePath: function ( value ) {

      this.texturePath = value;

    },

    setCrossOrigin: function ( value ) {

      this.crossOrigin = value;

    },

    parse: function ( json, onLoad ) {

      var geometries = this.parseGeometries( json.geometries );

      var images = this.parseImages( json.images, function () {

        if ( onLoad !== undefined ) onLoad( object );

      } );

      var textures = this.parseTextures( json.textures, images );
      var materials = this.parseMaterials( json.materials, textures );

      var object = this.parseObject( json.object, geometries, materials );

      if ( json.animations ) {

        object.animations = this.parseAnimations( json.animations );

      }

      if ( json.images === undefined || json.images.length === 0 ) {

        if ( onLoad !== undefined ) onLoad( object );

      }

      return object;

    },

    parseGeometries: function ( json ) {

      var geometries = {};

      if ( json !== undefined ) {

        var geometryLoader = new JSONLoader();
        var bufferGeometryLoader = new BufferGeometryLoader();

        for ( var i = 0, l = json.length; i < l; i ++ ) {

          var geometry;
          var data = json[ i ];

          switch ( data.type ) {

            case 'PlaneGeometry':
            case 'PlaneBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.width,
                data.height,
                data.widthSegments,
                data.heightSegments
              );

              break;

            case 'BoxGeometry':
            case 'BoxBufferGeometry':
            case 'CubeGeometry': // backwards compatible

              geometry = new Geometries[ data.type ](
                data.width,
                data.height,
                data.depth,
                data.widthSegments,
                data.heightSegments,
                data.depthSegments
              );

              break;

            case 'CircleGeometry':
            case 'CircleBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.segments,
                data.thetaStart,
                data.thetaLength
              );

              break;

            case 'CylinderGeometry':
            case 'CylinderBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radiusTop,
                data.radiusBottom,
                data.height,
                data.radialSegments,
                data.heightSegments,
                data.openEnded,
                data.thetaStart,
                data.thetaLength
              );

              break;

            case 'ConeGeometry':
            case 'ConeBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.height,
                data.radialSegments,
                data.heightSegments,
                data.openEnded,
                data.thetaStart,
                data.thetaLength
              );

              break;

            case 'SphereGeometry':
            case 'SphereBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.widthSegments,
                data.heightSegments,
                data.phiStart,
                data.phiLength,
                data.thetaStart,
                data.thetaLength
              );

              break;

            case 'DodecahedronGeometry':
            case 'IcosahedronGeometry':
            case 'OctahedronGeometry':
            case 'TetrahedronGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.detail
              );

              break;

            case 'RingGeometry':
            case 'RingBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.innerRadius,
                data.outerRadius,
                data.thetaSegments,
                data.phiSegments,
                data.thetaStart,
                data.thetaLength
              );

              break;

            case 'TorusGeometry':
            case 'TorusBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.tube,
                data.radialSegments,
                data.tubularSegments,
                data.arc
              );

              break;

            case 'TorusKnotGeometry':
            case 'TorusKnotBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.radius,
                data.tube,
                data.tubularSegments,
                data.radialSegments,
                data.p,
                data.q
              );

              break;

            case 'LatheGeometry':
            case 'LatheBufferGeometry':

              geometry = new Geometries[ data.type ](
                data.points,
                data.segments,
                data.phiStart,
                data.phiLength
              );

              break;

            case 'BufferGeometry':

              geometry = bufferGeometryLoader.parse( data );

              break;

            case 'Geometry':

              geometry = geometryLoader.parse( data, this.texturePath ).geometry;

              break;

            default:

              console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

              continue;

          }

          geometry.uuid = data.uuid;

          if ( data.name !== undefined ) geometry.name = data.name;

          geometries[ data.uuid ] = geometry;

        }

      }

      return geometries;

    },

    parseMaterials: function ( json, textures ) {

      var materials = {};

      if ( json !== undefined ) {

        var loader = new MaterialLoader();
        loader.setTextures( textures );

        for ( var i = 0, l = json.length; i < l; i ++ ) {

          var data = json[ i ];

          if ( data.type === 'MultiMaterial' ) {

            // Deprecated

            var array = [];

            for ( var j = 0; j < data.materials.length; j ++ ) {

              array.push( loader.parse( data.materials[ j ] ) );

            }

            materials[ data.uuid ] = array;

          } else {

            materials[ data.uuid ] = loader.parse( data );

          }

        }

      }

      return materials;

    },

    parseAnimations: function ( json ) {

      var animations = [];

      for ( var i = 0; i < json.length; i ++ ) {

        var clip = AnimationClip.parse( json[ i ] );

        animations.push( clip );

      }

      return animations;

    },

    parseImages: function ( json, onLoad ) {

      var scope = this;
      var images = {};

      function loadImage( url ) {

        scope.manager.itemStart( url );

        return loader.load( url, function () {

          scope.manager.itemEnd( url );

        }, undefined, function () {

          scope.manager.itemEnd( url );
          scope.manager.itemError( url );

        } );

      }

      if ( json !== undefined && json.length > 0 ) {

        var manager = new LoadingManager( onLoad );

        var loader = new ImageLoader( manager );
        loader.setCrossOrigin( this.crossOrigin );

        for ( var i = 0, l = json.length; i < l; i ++ ) {

          var image = json[ i ];
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

          images[ image.uuid ] = loadImage( path );

        }

      }

      return images;

    },

    parseTextures: function ( json, images ) {

      function parseConstant( value, type ) {

        if ( typeof value === 'number' ) return value;

        console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

        return type[ value ];

      }

      var textures = {};

      if ( json !== undefined ) {

        for ( var i = 0, l = json.length; i < l; i ++ ) {

          var data = json[ i ];

          if ( data.image === undefined ) {

            console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

          }

          if ( images[ data.image ] === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

          }

          var texture = new Texture( images[ data.image ] );
          texture.needsUpdate = true;

          texture.uuid = data.uuid;

          if ( data.name !== undefined ) texture.name = data.name;

          if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

          if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
          if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
          if ( data.center !== undefined ) texture.center.fromArray( data.center );
          if ( data.rotation !== undefined ) texture.rotation = data.rotation;

          if ( data.wrap !== undefined ) {

            texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
            texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

          }

          if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
          if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
          if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

          if ( data.flipY !== undefined ) texture.flipY = data.flipY;

          textures[ data.uuid ] = texture;

        }

      }

      return textures;

    },

    parseObject: function () {

      var matrix = new Matrix4();

      return function parseObject( data, geometries, materials ) {

        var object;

        function getGeometry( name ) {

          if ( geometries[ name ] === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

          }

          return geometries[ name ];

        }

        function getMaterial( name ) {

          if ( name === undefined ) return undefined;

          if ( Array.isArray( name ) ) {

            var array = [];

            for ( var i = 0, l = name.length; i < l; i ++ ) {

              var uuid = name[ i ];

              if ( materials[ uuid ] === undefined ) {

                console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

              }

              array.push( materials[ uuid ] );

            }

            return array;

          }

          if ( materials[ name ] === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined material', name );

          }

          return materials[ name ];

        }

        switch ( data.type ) {

          case 'Scene':

            object = new Scene();

            if ( data.background !== undefined ) {

              if ( Number.isInteger( data.background ) ) {

                object.background = new Color( data.background );

              }

            }

            if ( data.fog !== undefined ) {

              if ( data.fog.type === 'Fog' ) {

                object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

              } else if ( data.fog.type === 'FogExp2' ) {

                object.fog = new FogExp2( data.fog.color, data.fog.density );

              }

            }

            break;

          case 'PerspectiveCamera':

            object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

            if ( data.focus !== undefined ) object.focus = data.focus;
            if ( data.zoom !== undefined ) object.zoom = data.zoom;
            if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
            if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
            if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

            break;

          case 'OrthographicCamera':

            object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

            break;

          case 'AmbientLight':

            object = new AmbientLight( data.color, data.intensity );

            break;

          case 'DirectionalLight':

            object = new DirectionalLight( data.color, data.intensity );

            break;

          case 'PointLight':

            object = new PointLight( data.color, data.intensity, data.distance, data.decay );

            break;

          case 'RectAreaLight':

            object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

            break;

          case 'SpotLight':

            object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

            break;

          case 'HemisphereLight':

            object = new HemisphereLight( data.color, data.groundColor, data.intensity );

            break;

          case 'SkinnedMesh':

            console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

          case 'Mesh':

            var geometry = getGeometry( data.geometry );
            var material = getMaterial( data.material );

            if ( geometry.bones && geometry.bones.length > 0 ) {

              object = new SkinnedMesh( geometry, material );

            } else {

              object = new Mesh( geometry, material );

            }

            break;

          case 'LOD':

            object = new LOD();

            break;

          case 'Line':

            object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

            break;

          case 'LineLoop':

            object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

            break;

          case 'LineSegments':

            object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

            break;

          case 'PointCloud':
          case 'Points':

            object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

            break;

          case 'Sprite':

            object = new Sprite( getMaterial( data.material ) );

            break;

          case 'Group':

            object = new Group();

            break;

          default:

            object = new Object3D();

        }

        object.uuid = data.uuid;

        if ( data.name !== undefined ) object.name = data.name;
        if ( data.matrix !== undefined ) {

          matrix.fromArray( data.matrix );
          matrix.decompose( object.position, object.quaternion, object.scale );

        } else {

          if ( data.position !== undefined ) object.position.fromArray( data.position );
          if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
          if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
          if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

        }

        if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
        if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

        if ( data.shadow ) {

          if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
          if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
          if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
          if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

        }

        if ( data.visible !== undefined ) object.visible = data.visible;
        if ( data.userData !== undefined ) object.userData = data.userData;

        if ( data.children !== undefined ) {

          var children = data.children;

          for ( var i = 0; i < children.length; i ++ ) {

            object.add( this.parseObject( children[ i ], geometries, materials ) );

          }

        }

        if ( data.type === 'LOD' ) {

          var levels = data.levels;

          for ( var l = 0; l < levels.length; l ++ ) {

            var level = levels[ l ];
            var child = object.getObjectByProperty( 'uuid', level.object );

            if ( child !== undefined ) {

              object.addLevel( child, level.distance );

            }

          }

        }

        return object;

      };

    }()

  } );

  var TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    SphericalReflectionMapping: SphericalReflectionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
  };

  var TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
  };

  var TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipMapNearestFilter: NearestMipMapNearestFilter,
    NearestMipMapLinearFilter: NearestMipMapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipMapNearestFilter: LinearMipMapNearestFilter,
    LinearMipMapLinearFilter: LinearMipMapLinearFilter
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bzier_curve
   */

  function CatmullRom( t, p0, p1, p2, p3 ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0( t, p ) {

    var k = 1 - t;
    return k * k * p;

  }

  function QuadraticBezierP1( t, p ) {

    return 2 * ( 1 - t ) * t * p;

  }

  function QuadraticBezierP2( t, p ) {

    return t * t * p;

  }

  function QuadraticBezier( t, p0, p1, p2 ) {

    return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
      QuadraticBezierP2( t, p2 );

  }

  //

  function CubicBezierP0( t, p ) {

    var k = 1 - t;
    return k * k * k * p;

  }

  function CubicBezierP1( t, p ) {

    var k = 1 - t;
    return 3 * k * k * t * p;

  }

  function CubicBezierP2( t, p ) {

    return 3 * ( 1 - t ) * t * t * p;

  }

  function CubicBezierP3( t, p ) {

    return t * t * t * p;

  }

  function CubicBezier( t, p0, p1, p2, p3 ) {

    return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
      CubicBezierP3( t, p3 );

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint(t), getTangent(t)
   * .getPointAt(u), getTangentAt(u)
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  /**************************************************************
   *  Abstract Curve base class
   **************************************************************/

  function Curve() {

    this.arcLengthDivisions = 200;

  }

  Object.assign( Curve.prototype, {

    // Virtual base class method to overwrite and implement in subclasses
    //  - t [0 .. 1]

    getPoint: function () {

      console.warn( 'THREE.Curve: .getPoint() not implemented.' );
      return null;

    },

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

    getPointAt: function ( u ) {

      var t = this.getUtoTmapping( u );
      return this.getPoint( t );

    },

    // Get sequence of points using getPoint( t )

    getPoints: function ( divisions ) {

      if ( divisions === undefined ) divisions = 5;

      var points = [];

      for ( var d = 0; d <= divisions; d ++ ) {

        points.push( this.getPoint( d / divisions ) );

      }

      return points;

    },

    // Get sequence of points using getPointAt( u )

    getSpacedPoints: function ( divisions ) {

      if ( divisions === undefined ) divisions = 5;

      var points = [];

      for ( var d = 0; d <= divisions; d ++ ) {

        points.push( this.getPointAt( d / divisions ) );

      }

      return points;

    },

    // Get total curve arc length

    getLength: function () {

      var lengths = this.getLengths();
      return lengths[ lengths.length - 1 ];

    },

    // Get list of cumulative segment lengths

    getLengths: function ( divisions ) {

      if ( divisions === undefined ) divisions = this.arcLengthDivisions;

      if ( this.cacheArcLengths &&
        ( this.cacheArcLengths.length === divisions + 1 ) &&
        ! this.needsUpdate ) {

        return this.cacheArcLengths;

      }

      this.needsUpdate = false;

      var cache = [];
      var current, last = this.getPoint( 0 );
      var p, sum = 0;

      cache.push( 0 );

      for ( p = 1; p <= divisions; p ++ ) {

        current = this.getPoint( p / divisions );
        sum += current.distanceTo( last );
        cache.push( sum );
        last = current;

      }

      this.cacheArcLengths = cache;

      return cache; // { sums: cache, sum: sum }; Sum is in the last element.

    },

    updateArcLengths: function () {

      this.needsUpdate = true;
      this.getLengths();

    },

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    getUtoTmapping: function ( u, distance ) {

      var arcLengths = this.getLengths();

      var i = 0, il = arcLengths.length;

      var targetArcLength; // The targeted u distance value to get

      if ( distance ) {

        targetArcLength = distance;

      } else {

        targetArcLength = u * arcLengths[ il - 1 ];

      }

      // binary search for the index with largest value smaller than target u distance

      var low = 0, high = il - 1, comparison;

      while ( low <= high ) {

        i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[ i ] - targetArcLength;

        if ( comparison < 0 ) {

          low = i + 1;

        } else if ( comparison > 0 ) {

          high = i - 1;

        } else {

          high = i;
          break;

          // DONE

        }

      }

      i = high;

      if ( arcLengths[ i ] === targetArcLength ) {

        return i / ( il - 1 );

      }

      // we could get finer grain at lengths, or use simple interpolation between two points

      var lengthBefore = arcLengths[ i ];
      var lengthAfter = arcLengths[ i + 1 ];

      var segmentLength = lengthAfter - lengthBefore;

      // determine where we are between the 'before' and 'after' points

      var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

      // add that fractional amount to t

      var t = ( i + segmentFraction ) / ( il - 1 );

      return t;

    },

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

    getTangent: function ( t ) {

      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;

      // Capping in case of danger

      if ( t1 < 0 ) t1 = 0;
      if ( t2 > 1 ) t2 = 1;

      var pt1 = this.getPoint( t1 );
      var pt2 = this.getPoint( t2 );

      var vec = pt2.clone().sub( pt1 );
      return vec.normalize();

    },

    getTangentAt: function ( u ) {

      var t = this.getUtoTmapping( u );
      return this.getTangent( t );

    },

    computeFrenetFrames: function ( segments, closed ) {

      // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

      var normal = new Vector3();

      var tangents = [];
      var normals = [];
      var binormals = [];

      var vec = new Vector3();
      var mat = new Matrix4();

      var i, u, theta;

      // compute the tangent vectors for each segment on the curve

      for ( i = 0; i <= segments; i ++ ) {

        u = i / segments;

        tangents[ i ] = this.getTangentAt( u );
        tangents[ i ].normalize();

      }

      // select an initial normal vector perpendicular to the first tangent vector,
      // and in the direction of the minimum tangent xyz component

      normals[ 0 ] = new Vector3();
      binormals[ 0 ] = new Vector3();
      var min = Number.MAX_VALUE;
      var tx = Math.abs( tangents[ 0 ].x );
      var ty = Math.abs( tangents[ 0 ].y );
      var tz = Math.abs( tangents[ 0 ].z );

      if ( tx <= min ) {

        min = tx;
        normal.set( 1, 0, 0 );

      }

      if ( ty <= min ) {

        min = ty;
        normal.set( 0, 1, 0 );

      }

      if ( tz <= min ) {

        normal.set( 0, 0, 1 );

      }

      vec.crossVectors( tangents[ 0 ], normal ).normalize();

      normals[ 0 ].crossVectors( tangents[ 0 ], vec );
      binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


      // compute the slowly-varying normal and binormal vectors for each segment on the curve

      for ( i = 1; i <= segments; i ++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > Number.EPSILON ) {

          vec.normalize();

          theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

          normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

      }

      // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

      if ( closed === true ) {

        theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
        theta /= segments;

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

          theta = - theta;

        }

        for ( i = 1; i <= segments; i ++ ) {

          // twist a little...
          normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
          binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

      }

      return {
        tangents: tangents,
        normals: normals,
        binormals: binormals
      };

    }

  } );

  function LineCurve( v1, v2 ) {

    Curve.call( this );

    this.v1 = v1;
    this.v2 = v2;

  }

  LineCurve.prototype = Object.create( Curve.prototype );
  LineCurve.prototype.constructor = LineCurve;

  LineCurve.prototype.isLineCurve = true;

  LineCurve.prototype.getPoint = function ( t ) {

    if ( t === 1 ) {

      return this.v2.clone();

    }

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve.prototype.getPointAt = function ( u ) {

    return this.getPoint( u );

  };

  LineCurve.prototype.getTangent = function ( /* t */ ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   **/

  /**************************************************************
   *  Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/

  function CurvePath() {

    Curve.call( this );

    this.curves = [];

    this.autoClose = false; // Automatically closes the path

  }

  CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

    constructor: CurvePath,

    add: function ( curve ) {

      this.curves.push( curve );

    },

    closePath: function () {

      // Add a line curve if start and end of lines are not connected
      var startPoint = this.curves[ 0 ].getPoint( 0 );
      var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

      if ( ! startPoint.equals( endPoint ) ) {

        this.curves.push( new LineCurve( endPoint, startPoint ) );

      }

    },

    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:

    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')

    getPoint: function ( t ) {

      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;

      // To think about boundaries points.

      while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

          var diff = curveLengths[ i ] - d;
          var curve = this.curves[ i ];

          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

          return curve.getPointAt( u );

        }

        i ++;

      }

      return null;

      // loop where sum != 0, sum > d , sum+1 <d

    },

    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength

    getLength: function () {

      var lens = this.getCurveLengths();
      return lens[ lens.length - 1 ];

    },

    // cacheLengths must be recalculated.
    updateArcLengths: function () {

      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();

    },

    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.

    getCurveLengths: function () {

      // We use cache values if curves and cache array are same length

      if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

      }

      // Get length of sub-curve
      // Push sums into cached array

      var lengths = [], sums = 0;

      for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

      }

      this.cacheLengths = lengths;

      return lengths;

    },

    getSpacedPoints: function ( divisions ) {

      if ( divisions === undefined ) divisions = 40;

      var points = [];

      for ( var i = 0; i <= divisions; i ++ ) {

        points.push( this.getPoint( i / divisions ) );

      }

      if ( this.autoClose ) {

        points.push( points[ 0 ] );

      }

      return points;

    },

    getPoints: function ( divisions ) {

      divisions = divisions || 12;

      var points = [], last;

      for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

        var curve = curves[ i ];
        var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
          : ( curve && curve.isLineCurve ) ? 1
            : ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
              : divisions;

        var pts = curve.getPoints( resolution );

        for ( var j = 0; j < pts.length; j ++ ) {

          var point = pts[ j ];

          if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

          points.push( point );
          last = point;

        }

      }

      if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

        points.push( points[ 0 ] );

      }

      return points;

    },

    /**************************************************************
     *  Create Geometries Helpers
     **************************************************************/

    /// Generate geometry from path points (for Line or Points objects)

    createPointsGeometry: function ( divisions ) {

      var pts = this.getPoints( divisions );
      return this.createGeometry( pts );

    },

    // Generate geometry from equidistant sampling along the path

    createSpacedPointsGeometry: function ( divisions ) {

      var pts = this.getSpacedPoints( divisions );
      return this.createGeometry( pts );

    },

    createGeometry: function ( points ) {

      var geometry = new Geometry();

      for ( var i = 0, l = points.length; i < l; i ++ ) {

        var point = points[ i ];
        geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

      }

      return geometry;

    }

  } );

  function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    Curve.call( this );

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

  }

  EllipseCurve.prototype = Object.create( Curve.prototype );
  EllipseCurve.prototype.constructor = EllipseCurve;

  EllipseCurve.prototype.isEllipseCurve = true;

  EllipseCurve.prototype.getPoint = function ( t ) {

    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    // ensures that deltaAngle is 0 .. 2 PI
    while ( deltaAngle < 0 ) deltaAngle += twoPi;
    while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    if ( deltaAngle < Number.EPSILON ) {

      if ( samePoints ) {

        deltaAngle = 0;

      } else {

        deltaAngle = twoPi;

      }

    }

    if ( this.aClockwise === true && ! samePoints ) {

      if ( deltaAngle === twoPi ) {

        deltaAngle = - twoPi;

      } else {

        deltaAngle = deltaAngle - twoPi;

      }

    }

    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

      var cos = Math.cos( this.aRotation );
      var sin = Math.sin( this.aRotation );

      var tx = x - this.aX;
      var ty = y - this.aY;

      // Rotate the point about the center of the ellipse.
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;

    }

    return new Vector2( x, y );

  };

  function SplineCurve( points /* array of Vector2 */ ) {

    Curve.call( this );

    this.points = ( points === undefined ) ? [] : points;

  }

  SplineCurve.prototype = Object.create( Curve.prototype );
  SplineCurve.prototype.constructor = SplineCurve;

  SplineCurve.prototype.isSplineCurve = true;

  SplineCurve.prototype.getPoint = function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    return new Vector2(
      CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
      CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
    );

  };

  function CubicBezierCurve( v0, v1, v2, v3 ) {

    Curve.call( this );

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  }

  CubicBezierCurve.prototype = Object.create( Curve.prototype );
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;

  CubicBezierCurve.prototype.getPoint = function ( t ) {

    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

    return new Vector2(
      CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
      CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
    );

  };

  function QuadraticBezierCurve( v0, v1, v2 ) {

    Curve.call( this );

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  }

  QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

  QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    var v0 = this.v0, v1 = this.v1, v2 = this.v2;

    return new Vector2(
      QuadraticBezier( t, v0.x, v1.x, v2.x ),
      QuadraticBezier( t, v0.y, v1.y, v2.y )
    );

  };

  var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

    fromPoints: function ( vectors ) {

      this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

      for ( var i = 1, l = vectors.length; i < l; i ++ ) {

        this.lineTo( vectors[ i ].x, vectors[ i ].y );

      }

    },

    moveTo: function ( x, y ) {

      this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    },

    lineTo: function ( x, y ) {

      var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
      this.curves.push( curve );

      this.currentPoint.set( x, y );

    },

    quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

      var curve = new QuadraticBezierCurve(
        this.currentPoint.clone(),
        new Vector2( aCPx, aCPy ),
        new Vector2( aX, aY )
      );

      this.curves.push( curve );

      this.currentPoint.set( aX, aY );

    },

    bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

      var curve = new CubicBezierCurve(
        this.currentPoint.clone(),
        new Vector2( aCP1x, aCP1y ),
        new Vector2( aCP2x, aCP2y ),
        new Vector2( aX, aY )
      );

      this.curves.push( curve );

      this.currentPoint.set( aX, aY );

    },

    splineThru: function ( pts /*Array of Vector*/ ) {

      var npts = [ this.currentPoint.clone() ].concat( pts );

      var curve = new SplineCurve( npts );
      this.curves.push( curve );

      this.currentPoint.copy( pts[ pts.length - 1 ] );

    },

    arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;

      this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

    },

    absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

      this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    },

    ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;

      this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    },

    absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

      var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

      if ( this.curves.length > 0 ) {

        // if a previous curve is present, attempt to join
        var firstPoint = curve.getPoint( 0 );

        if ( ! firstPoint.equals( this.currentPoint ) ) {

          this.lineTo( firstPoint.x, firstPoint.y );

        }

      }

      this.curves.push( curve );

      var lastPoint = curve.getPoint( 1 );
      this.currentPoint.copy( lastPoint );

    }

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Creates free form 2d path using series of points, lines or curves.
   **/

  function Path( points ) {

    CurvePath.call( this );
    this.currentPoint = new Vector2();

    if ( points ) {

      this.fromPoints( points );

    }

  }

  Path.prototype = PathPrototype;
  PathPrototype.constructor = Path;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Defines a 2d shape plane using paths.
   **/

  // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.

  function Shape() {

    Path.apply( this, arguments );

    this.holes = [];

  }

  Shape.prototype = Object.assign( Object.create( PathPrototype ), {

    constructor: Shape,

    getPointsHoles: function ( divisions ) {

      var holesPts = [];

      for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

        holesPts[ i ] = this.holes[ i ].getPoints( divisions );

      }

      return holesPts;

    },

    // Get points of shape and holes (keypoints based on segments parameter)

    extractAllPoints: function ( divisions ) {

      return {

        shape: this.getPoints( divisions ),
        holes: this.getPointsHoles( divisions )

      };

    },

    extractPoints: function ( divisions ) {

      return this.extractAllPoints( divisions );

    }

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
   **/

  function ShapePath() {

    this.subPaths = [];
    this.currentPath = null;

  }

  Object.assign( ShapePath.prototype, {

    moveTo: function ( x, y ) {

      this.currentPath = new Path();
      this.subPaths.push( this.currentPath );
      this.currentPath.moveTo( x, y );

    },

    lineTo: function ( x, y ) {

      this.currentPath.lineTo( x, y );

    },

    quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

      this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

    },

    bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

      this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

    },

    splineThru: function ( pts ) {

      this.currentPath.splineThru( pts );

    },

    toShapes: function ( isCCW, noHoles ) {

      function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

          var tmpPath = inSubpaths[ i ];

          var tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;

          shapes.push( tmpShape );

        }

        return shapes;

      }

      function isPointInsidePolygon( inPt, inPolygon ) {

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

          var edgeLowPt = inPolygon[ p ];
          var edgeHighPt = inPolygon[ q ];

          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;

          if ( Math.abs( edgeDy ) > Number.EPSILON ) {

            // not parallel
            if ( edgeDy < 0 ) {

              edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
              edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

            }
            if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

            if ( inPt.y === edgeLowPt.y ) {

              if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?
              // continue;        // no intersection or edgeLowPt => doesn't count !!!

            } else {

              var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
              if ( perpEdge === 0 )       return  true;   // inPt is on contour ?
              if ( perpEdge < 0 )         continue;
              inside = ! inside;    // true intersection left of inPt

            }

          } else {

            // parallel or collinear
            if ( inPt.y !== edgeLowPt.y )     continue;     // parallel
            // edge lies on the same horizontal line as inPt
            if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
               ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
            // continue;

          }

        }

        return  inside;

      }

      var isClockWise = ShapeUtils.isClockWise;

      var subPaths = this.subPaths;
      if ( subPaths.length === 0 ) return [];

      if ( noHoles === true ) return  toShapesNoHoles( subPaths );


      var solid, tmpPath, tmpShape, shapes = [];

      if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

      }

      var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
      holesFirst = isCCW ? ! holesFirst : holesFirst;

      // console.log("Holes first", holesFirst);

      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;

      newShapes[ mainIdx ] = undefined;
      newShapeHoles[ mainIdx ] = [];

      for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise( tmpPoints );
        solid = isCCW ? ! solid : solid;

        if ( solid ) {

          if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx ++;

          newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
          newShapes[ mainIdx ].s.curves = tmpPath.curves;

          if ( holesFirst ) mainIdx ++;
          newShapeHoles[ mainIdx ] = [];

          //console.log('cw', i);

        } else {

          newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

          //console.log('ccw', i);

        }

      }

      // only Holes? -> probably all Shapes with wrong orientation
      if ( ! newShapes[ 0 ] ) return  toShapesNoHoles( subPaths );


      if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

          betterShapeHoles[ sIdx ] = [];

        }

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

          var sho = newShapeHoles[ sIdx ];

          for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

            var ho = sho[ hIdx ];
            var hole_unassigned = true;

            for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

              if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
                if ( hole_unassigned ) {

                  hole_unassigned = false;
                  betterShapeHoles[ s2Idx ].push( ho );

                } else {

                  ambiguous = true;

                }

              }

            }
            if ( hole_unassigned ) {

              betterShapeHoles[ sIdx ].push( ho );

            }

          }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

          // console.log("to change: ", toChange);
          if ( ! ambiguous )  newShapeHoles = betterShapeHoles;

        }

      }

      var tmpHoles;

      for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];

        for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

          tmpShape.holes.push( tmpHoles[ j ].h );

        }

      }

      //console.log("shape", shapes);

      return shapes;

    }

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author mrdoob / http://mrdoob.com/
   */

  function Font( data ) {

    this.data = data;

  }

  Object.assign( Font.prototype, {

    isFont: true,

    generateShapes: function ( text, size, divisions ) {

      function createPaths( text ) {

        var chars = String( text ).split( '' );
        var scale = size / data.resolution;
        var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

        var offsetX = 0, offsetY = 0;

        var paths = [];

        for ( var i = 0; i < chars.length; i ++ ) {

          var char = chars[ i ];

          if ( char === '\n' ) {

            offsetX = 0;
            offsetY -= line_height;

          } else {

            var ret = createPath( char, scale, offsetX, offsetY );
            offsetX += ret.offsetX;
            paths.push( ret.path );

          }

        }

        return paths;

      }

      function createPath( c, scale, offsetX, offsetY ) {

        var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

        if ( ! glyph ) return;

        var path = new ShapePath();

        var pts = [];
        var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

        if ( glyph.o ) {

          var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

          for ( var i = 0, l = outline.length; i < l; ) {

            var action = outline[ i ++ ];

            switch ( action ) {

              case 'm': // moveTo

                x = outline[ i ++ ] * scale + offsetX;
                y = outline[ i ++ ] * scale + offsetY;

                path.moveTo( x, y );

                break;

              case 'l': // lineTo

                x = outline[ i ++ ] * scale + offsetX;
                y = outline[ i ++ ] * scale + offsetY;

                path.lineTo( x, y );

                break;

              case 'q': // quadraticCurveTo

                cpx = outline[ i ++ ] * scale + offsetX;
                cpy = outline[ i ++ ] * scale + offsetY;
                cpx1 = outline[ i ++ ] * scale + offsetX;
                cpy1 = outline[ i ++ ] * scale + offsetY;

                path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                laste = pts[ pts.length - 1 ];

                if ( laste ) {

                  cpx0 = laste.x;
                  cpy0 = laste.y;

                  for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

                    var t = i2 / divisions;
                    QuadraticBezier( t, cpx0, cpx1, cpx );
                    QuadraticBezier( t, cpy0, cpy1, cpy );

                  }

                }

                break;

              case 'b': // bezierCurveTo

                cpx = outline[ i ++ ] * scale + offsetX;
                cpy = outline[ i ++ ] * scale + offsetY;
                cpx1 = outline[ i ++ ] * scale + offsetX;
                cpy1 = outline[ i ++ ] * scale + offsetY;
                cpx2 = outline[ i ++ ] * scale + offsetX;
                cpy2 = outline[ i ++ ] * scale + offsetY;

                path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                laste = pts[ pts.length - 1 ];

                if ( laste ) {

                  cpx0 = laste.x;
                  cpy0 = laste.y;

                  for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

                    var t = i2 / divisions;
                    CubicBezier( t, cpx0, cpx1, cpx2, cpx );
                    CubicBezier( t, cpy0, cpy1, cpy2, cpy );

                  }

                }

                break;

            }

          }

        }

        return { offsetX: glyph.ha * scale, path: path };

      }

      //

      if ( size === undefined ) size = 100;
      if ( divisions === undefined ) divisions = 4;

      var data = this.data;

      var paths = createPaths( text );
      var shapes = [];

      for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

      }

      return shapes;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FontLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( FontLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var loader = new FileLoader( this.manager );
      loader.setPath( this.path );
      loader.load( url, function ( text ) {

        var json;

        try {

          json = JSON.parse( text );

        } catch ( e ) {

          console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
          json = JSON.parse( text.substring( 65, text.length - 2 ) );

        }

        var font = scope.parse( json );

        if ( onLoad ) onLoad( font );

      }, onProgress, onError );

    },

    parse: function ( json ) {

      return new Font( json );

    },

    setPath: function ( value ) {

      this.path = value;
      return this;

    }

  } );

  var context;

  var AudioContext = {

    getContext: function () {

      if ( context === undefined ) {

        context = new ( window.AudioContext || window.webkitAudioContext )();

      }

      return context;

    },

    setContext: function ( value ) {

      context = value;

    }

  };

  /**
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function AudioLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( AudioLoader.prototype, {

    load: function ( url, onLoad, onProgress, onError ) {

      var loader = new FileLoader( this.manager );
      loader.setResponseType( 'arraybuffer' );
      loader.load( url, function ( buffer ) {

        var context = AudioContext.getContext();

        context.decodeAudioData( buffer, function ( audioBuffer ) {

          onLoad( audioBuffer );

        } );

      }, onProgress, onError );

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function StereoCamera() {

    this.type = 'StereoCamera';

    this.aspect = 1;

    this.eyeSep = 0.064;

    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable( 1 );
    this.cameraL.matrixAutoUpdate = false;

    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable( 2 );
    this.cameraR.matrixAutoUpdate = false;

  }

  Object.assign( StereoCamera.prototype, {

    update: ( function () {

      var instance, focus, fov, aspect, near, far, zoom, eyeSep;

      var eyeRight = new Matrix4();
      var eyeLeft = new Matrix4();

      return function update( camera ) {

        var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
                          aspect !== camera.aspect * this.aspect || near !== camera.near ||
                          far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

        if ( needsUpdate ) {

          instance = this;
          focus = camera.focus;
          fov = camera.fov;
          aspect = camera.aspect * this.aspect;
          near = camera.near;
          far = camera.far;
          zoom = camera.zoom;

          // Off-axis stereoscopic effect based on
          // http://paulbourke.net/stereographics/stereorender/

          var projectionMatrix = camera.projectionMatrix.clone();
          eyeSep = this.eyeSep / 2;
          var eyeSepOnProjection = eyeSep * near / focus;
          var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
          var xmin, xmax;

          // translate xOffset

          eyeLeft.elements[ 12 ] = - eyeSep;
          eyeRight.elements[ 12 ] = eyeSep;

          // for left eye

          xmin = - ymax * aspect + eyeSepOnProjection;
          xmax = ymax * aspect + eyeSepOnProjection;

          projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
          projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

          this.cameraL.projectionMatrix.copy( projectionMatrix );

          // for right eye

          xmin = - ymax * aspect - eyeSepOnProjection;
          xmax = ymax * aspect - eyeSepOnProjection;

          projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
          projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

          this.cameraR.projectionMatrix.copy( projectionMatrix );

        }

        this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
        this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

      };

    } )()

  } );

  /**
   * Camera for rendering cube maps
   *  - renders scene into axis-aligned cube
   *
   * @author alteredq / http://alteredqualia.com/
   */

  function CubeCamera( near, far, cubeResolution ) {

    Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90, aspect = 1;

    var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, - 1, 0 );
    cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, - 1, 0 );
    cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, - 1 );
    cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, - 1, 0 );
    cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, - 1, 0 );
    cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
    this.add( cameraNZ );

    var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

    this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
    this.renderTarget.texture.name = "CubeCamera";

    this.update = function ( renderer, scene ) {

      if ( this.parent === null ) this.updateMatrixWorld();

      var renderTarget = this.renderTarget;
      var generateMipmaps = renderTarget.texture.generateMipmaps;

      renderTarget.texture.generateMipmaps = false;

      renderTarget.activeCubeFace = 0;
      renderer.render( scene, cameraPX, renderTarget );

      renderTarget.activeCubeFace = 1;
      renderer.render( scene, cameraNX, renderTarget );

      renderTarget.activeCubeFace = 2;
      renderer.render( scene, cameraPY, renderTarget );

      renderTarget.activeCubeFace = 3;
      renderer.render( scene, cameraNY, renderTarget );

      renderTarget.activeCubeFace = 4;
      renderer.render( scene, cameraPZ, renderTarget );

      renderTarget.texture.generateMipmaps = generateMipmaps;

      renderTarget.activeCubeFace = 5;
      renderer.render( scene, cameraNZ, renderTarget );

      renderer.setRenderTarget( null );

    };

    this.clear = function ( renderer, color, depth, stencil ) {

      var renderTarget = this.renderTarget;

      for ( var i = 0; i < 6; i ++ ) {

        renderTarget.activeCubeFace = i;
        renderer.setRenderTarget( renderTarget );

        renderer.clear( color, depth, stencil );

      }

      renderer.setRenderTarget( null );

    };

  }

  CubeCamera.prototype = Object.create( Object3D.prototype );
  CubeCamera.prototype.constructor = CubeCamera;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioListener() {

    Object3D.call( this );

    this.type = 'AudioListener';

    this.context = AudioContext.getContext();

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.filter = null;

  }

  AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: AudioListener,

    getInput: function () {

      return this.gain;

    },

    removeFilter: function ( ) {

      if ( this.filter !== null ) {

        this.gain.disconnect( this.filter );
        this.filter.disconnect( this.context.destination );
        this.gain.connect( this.context.destination );
        this.filter = null;

      }

    },

    getFilter: function () {

      return this.filter;

    },

    setFilter: function ( value ) {

      if ( this.filter !== null ) {

        this.gain.disconnect( this.filter );
        this.filter.disconnect( this.context.destination );

      } else {

        this.gain.disconnect( this.context.destination );

      }

      this.filter = value;
      this.gain.connect( this.filter );
      this.filter.connect( this.context.destination );

    },

    getMasterVolume: function () {

      return this.gain.gain.value;

    },

    setMasterVolume: function ( value ) {

      this.gain.gain.value = value;

    },

    updateMatrixWorld: ( function () {

      var position = new Vector3();
      var quaternion = new Quaternion();
      var scale = new Vector3();

      var orientation = new Vector3();

      return function updateMatrixWorld( force ) {

        Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

        if ( listener.positionX ) {

          listener.positionX.setValueAtTime( position.x, this.context.currentTime );
          listener.positionY.setValueAtTime( position.y, this.context.currentTime );
          listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
          listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
          listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
          listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
          listener.upX.setValueAtTime( up.x, this.context.currentTime );
          listener.upY.setValueAtTime( up.y, this.context.currentTime );
          listener.upZ.setValueAtTime( up.z, this.context.currentTime );

        } else {

          listener.setPosition( position.x, position.y, position.z );
          listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

        }

      };

    } )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function Audio( listener ) {

    Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;

    this.gain = this.context.createGain();
    this.gain.connect( listener.getInput() );

    this.autoplay = false;

    this.buffer = null;
    this.loop = false;
    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = 'empty';

    this.filters = [];

  }

  Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: Audio,

    getOutput: function () {

      return this.gain;

    },

    setNodeSource: function ( audioNode ) {

      this.hasPlaybackControl = false;
      this.sourceType = 'audioNode';
      this.source = audioNode;
      this.connect();

      return this;

    },

    setBuffer: function ( audioBuffer ) {

      this.buffer = audioBuffer;
      this.sourceType = 'buffer';

      if ( this.autoplay ) this.play();

      return this;

    },

    play: function () {

      if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

      }

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return;

      }

      var source = this.context.createBufferSource();

      source.buffer = this.buffer;
      source.loop = this.loop;
      source.onended = this.onEnded.bind( this );
      source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
      source.start( 0, this.startTime );

      this.isPlaying = true;

      this.source = source;

      return this.connect();

    },

    pause: function () {

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return;

      }

      this.source.stop();
      this.startTime = this.context.currentTime;
      this.isPlaying = false;

      return this;

    },

    stop: function () {

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return;

      }

      this.source.stop();
      this.startTime = 0;
      this.isPlaying = false;

      return this;

    },

    connect: function () {

      if ( this.filters.length > 0 ) {

        this.source.connect( this.filters[ 0 ] );

        for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

          this.filters[ i - 1 ].connect( this.filters[ i ] );

        }

        this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

      } else {

        this.source.connect( this.getOutput() );

      }

      return this;

    },

    disconnect: function () {

      if ( this.filters.length > 0 ) {

        this.source.disconnect( this.filters[ 0 ] );

        for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

          this.filters[ i - 1 ].disconnect( this.filters[ i ] );

        }

        this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

      } else {

        this.source.disconnect( this.getOutput() );

      }

      return this;

    },

    getFilters: function () {

      return this.filters;

    },

    setFilters: function ( value ) {

      if ( ! value ) value = [];

      if ( this.isPlaying === true ) {

        this.disconnect();
        this.filters = value;
        this.connect();

      } else {

        this.filters = value;

      }

      return this;

    },

    getFilter: function () {

      return this.getFilters()[ 0 ];

    },

    setFilter: function ( filter ) {

      return this.setFilters( filter ? [ filter ] : [] );

    },

    setPlaybackRate: function ( value ) {

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return;

      }

      this.playbackRate = value;

      if ( this.isPlaying === true ) {

        this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

      }

      return this;

    },

    getPlaybackRate: function () {

      return this.playbackRate;

    },

    onEnded: function () {

      this.isPlaying = false;

    },

    getLoop: function () {

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return false;

      }

      return this.loop;

    },

    setLoop: function ( value ) {

      if ( this.hasPlaybackControl === false ) {

        console.warn( 'THREE.Audio: this Audio has no playback control.' );
        return;

      }

      this.loop = value;

      if ( this.isPlaying === true ) {

        this.source.loop = this.loop;

      }

      return this;

    },

    getVolume: function () {

      return this.gain.gain.value;

    },

    setVolume: function ( value ) {

      this.gain.gain.value = value;

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function PositionalAudio( listener ) {

    Audio.call( this, listener );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

  }

  PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

    constructor: PositionalAudio,

    getOutput: function () {

      return this.panner;

    },

    getRefDistance: function () {

      return this.panner.refDistance;

    },

    setRefDistance: function ( value ) {

      this.panner.refDistance = value;

    },

    getRolloffFactor: function () {

      return this.panner.rolloffFactor;

    },

    setRolloffFactor: function ( value ) {

      this.panner.rolloffFactor = value;

    },

    getDistanceModel: function () {

      return this.panner.distanceModel;

    },

    setDistanceModel: function ( value ) {

      this.panner.distanceModel = value;

    },

    getMaxDistance: function () {

      return this.panner.maxDistance;

    },

    setMaxDistance: function ( value ) {

      this.panner.maxDistance = value;

    },

    updateMatrixWorld: ( function () {

      var position = new Vector3();

      return function updateMatrixWorld( force ) {

        Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

      };

    } )()


  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioAnalyser( audio, fftSize ) {

    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

    this.data = new Uint8Array( this.analyser.frequencyBinCount );

    audio.getOutput().connect( this.analyser );

  }

  Object.assign( AudioAnalyser.prototype, {

    getFrequencyData: function () {

      this.analyser.getByteFrequencyData( this.data );

      return this.data;

    },

    getAverageFrequency: function () {

      var value = 0, data = this.getFrequencyData();

      for ( var i = 0; i < data.length; i ++ ) {

        value += data[ i ];

      }

      return value / data.length;

    }

  } );

  /**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function PropertyMixer( binding, typeName, valueSize ) {

    this.binding = binding;
    this.valueSize = valueSize;

    var bufferType = Float64Array,
      mixFunction;

    switch ( typeName ) {

      case 'quaternion':
        mixFunction = this._slerp;
        break;

      case 'string':
      case 'bool':
        bufferType = Array;
        mixFunction = this._select;
        break;

      default:
        mixFunction = this._lerp;

    }

    this.buffer = new bufferType( valueSize * 4 );
    // layout: [ incoming | accu0 | accu1 | orig ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property

    this._mixBufferRegion = mixFunction;

    this.cumulativeWeight = 0;

    this.useCount = 0;
    this.referenceCount = 0;

  }

  Object.assign( PropertyMixer.prototype, {

    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate: function ( accuIndex, weight ) {

      // note: happily accumulating nothing when weight = 0, the caller knows
      // the weight and shouldn't have made the call in the first place

      var buffer = this.buffer,
        stride = this.valueSize,
        offset = accuIndex * stride + stride,

        currentWeight = this.cumulativeWeight;

      if ( currentWeight === 0 ) {

        // accuN := incoming * weight

        for ( var i = 0; i !== stride; ++ i ) {

          buffer[ offset + i ] = buffer[ i ];

        }

        currentWeight = weight;

      } else {

        // accuN := accuN + incoming * weight

        currentWeight += weight;
        var mix = weight / currentWeight;
        this._mixBufferRegion( buffer, offset, 0, mix, stride );

      }

      this.cumulativeWeight = currentWeight;

    },

    // apply the state of 'accu<i>' to the binding when accus differ
    apply: function ( accuIndex ) {

      var stride = this.valueSize,
        buffer = this.buffer,
        offset = accuIndex * stride + stride,

        weight = this.cumulativeWeight,

        binding = this.binding;

      this.cumulativeWeight = 0;

      if ( weight < 1 ) {

        // accuN := accuN + original * ( 1 - cumulativeWeight )

        var originalValueOffset = stride * 3;

        this._mixBufferRegion(
          buffer, offset, originalValueOffset, 1 - weight, stride );

      }

      for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

        if ( buffer[ i ] !== buffer[ i + stride ] ) {

          // value has changed -> update scene graph

          binding.setValue( buffer, offset );
          break;

        }

      }

    },

    // remember the state of the bound property and copy it to both accus
    saveOriginalState: function () {

      var binding = this.binding;

      var buffer = this.buffer,
        stride = this.valueSize,

        originalValueOffset = stride * 3;

      binding.getValue( buffer, originalValueOffset );

      // accu[0..1] := orig -- initially detect changes against the original
      for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

        buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

      }

      this.cumulativeWeight = 0;

    },

    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState: function () {

      var originalValueOffset = this.valueSize * 3;
      this.binding.setValue( this.buffer, originalValueOffset );

    },


    // mix functions

    _select: function ( buffer, dstOffset, srcOffset, t, stride ) {

      if ( t >= 0.5 ) {

        for ( var i = 0; i !== stride; ++ i ) {

          buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

        }

      }

    },

    _slerp: function ( buffer, dstOffset, srcOffset, t ) {

      Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

    },

    _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

      var s = 1 - t;

      for ( var i = 0; i !== stride; ++ i ) {

        var j = dstOffset + i;

        buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

      }

    }

  } );

  /**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function Composite( targetGroup, path, optionalParsedPath ) {

    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_( path, parsedPath );

  }

  Object.assign( Composite.prototype, {

    getValue: function ( array, offset ) {

      this.bind(); // bind all binding

      var firstValidIndex = this._targetGroup.nCachedObjects_,
        binding = this._bindings[ firstValidIndex ];

      // and only call .getValue on the first
      if ( binding !== undefined ) binding.getValue( array, offset );

    },

    setValue: function ( array, offset ) {

      var bindings = this._bindings;

      for ( var i = this._targetGroup.nCachedObjects_,
            n = bindings.length; i !== n; ++ i ) {

        bindings[ i ].setValue( array, offset );

      }

    },

    bind: function () {

      var bindings = this._bindings;

      for ( var i = this._targetGroup.nCachedObjects_,
            n = bindings.length; i !== n; ++ i ) {

        bindings[ i ].bind();

      }

    },

    unbind: function () {

      var bindings = this._bindings;

      for ( var i = this._targetGroup.nCachedObjects_,
            n = bindings.length; i !== n; ++ i ) {

        bindings[ i ].unbind();

      }

    }

  } );


  function PropertyBinding( rootNode, path, parsedPath ) {

    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

    this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

    this.rootNode = rootNode;

  }

  Object.assign( PropertyBinding, {

    Composite: Composite,

    create: function ( root, path, parsedPath ) {

      if ( ! ( root && root.isAnimationObjectGroup ) ) {

        return new PropertyBinding( root, path, parsedPath );

      } else {

        return new PropertyBinding.Composite( root, path, parsedPath );

      }

    },

    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param  {string} name Node name to be sanitized.
     * @return {string}
     */
    sanitizeNodeName: function ( name ) {

      return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );

    },

    parseTrackName: function () {

      // Parent directories, delimited by '/' or ':'. Currently unused, but must
      // be matched to parse the rest of the track name.
      var directoryRe = /((?:[\w-]+[\/:])*)/;

      // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
      var nodeRe = /([\w-\.]+)?/;

      // Object on target node, and accessor. Name may contain only word
      // characters. Accessor may contain any character except closing bracket.
      var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

      // Property and accessor. May contain only word characters. Accessor may
      // contain any non-bracket characters.
      var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

      var trackRe = new RegExp( ''
        + '^'
        + directoryRe.source
        + nodeRe.source
        + objectRe.source
        + propertyRe.source
        + '$'
      );

      var supportedObjectNames = [ 'material', 'materials', 'bones' ];

      return function ( trackName ) {

        var matches = trackRe.exec( trackName );

        if ( ! matches ) {

          throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

        }

        var results = {
          // directoryName: matches[ 1 ], // (tschw) currently unused
          nodeName: matches[ 2 ],
          objectName: matches[ 3 ],
          objectIndex: matches[ 4 ],
          propertyName: matches[ 5 ], // required
          propertyIndex: matches[ 6 ]
        };

        var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

        if ( lastDot !== undefined && lastDot !== - 1 ) {

          var objectName = results.nodeName.substring( lastDot + 1 );

          // Object names must be checked against a whitelist. Otherwise, there
          // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
          // 'bar' could be the objectName, or part of a nodeName (which can
          // include '.' characters).
          if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

            results.nodeName = results.nodeName.substring( 0, lastDot );
            results.objectName = objectName;

          }

        }

        if ( results.propertyName === null || results.propertyName.length === 0 ) {

          throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

        }

        return results;

      };

    }(),

    findNode: function ( root, nodeName ) {

      if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

        return root;

      }

      // search into skeleton bones.
      if ( root.skeleton ) {

        var searchSkeleton = function ( skeleton ) {

          for ( var i = 0; i < skeleton.bones.length; i ++ ) {

            var bone = skeleton.bones[ i ];

            if ( bone.name === nodeName ) {

              return bone;

            }

          }

          return null;

        };

        var bone = searchSkeleton( root.skeleton );

        if ( bone ) {

          return bone;

        }

      }

      // search into node subtree.
      if ( root.children ) {

        var searchNodeSubtree = function ( children ) {

          for ( var i = 0; i < children.length; i ++ ) {

            var childNode = children[ i ];

            if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

              return childNode;

            }

            var result = searchNodeSubtree( childNode.children );

            if ( result ) return result;

          }

          return null;

        };

        var subTreeNode = searchNodeSubtree( root.children );

        if ( subTreeNode ) {

          return subTreeNode;

        }

      }

      return null;

    }

  } );

  Object.assign( PropertyBinding.prototype, { // prototype, continued

    // these are used to "bind" a nonexistent property
    _getValue_unavailable: function () {},
    _setValue_unavailable: function () {},

    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },

    Versioning: {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },

    GetterByBindingType: [

      function getValue_direct( buffer, offset ) {

        buffer[ offset ] = this.node[ this.propertyName ];

      },

      function getValue_array( buffer, offset ) {

        var source = this.resolvedProperty;

        for ( var i = 0, n = source.length; i !== n; ++ i ) {

          buffer[ offset ++ ] = source[ i ];

        }

      },

      function getValue_arrayElement( buffer, offset ) {

        buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

      },

      function getValue_toArray( buffer, offset ) {

        this.resolvedProperty.toArray( buffer, offset );

      }

    ],

    SetterByBindingTypeAndVersioning: [

      [
        // Direct

        function setValue_direct( buffer, offset ) {

          this.targetObject[ this.propertyName ] = buffer[ offset ];

        },

        function setValue_direct_setNeedsUpdate( buffer, offset ) {

          this.targetObject[ this.propertyName ] = buffer[ offset ];
          this.targetObject.needsUpdate = true;

        },

        function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

          this.targetObject[ this.propertyName ] = buffer[ offset ];
          this.targetObject.matrixWorldNeedsUpdate = true;

        }

      ], [

        // EntireArray

        function setValue_array( buffer, offset ) {

          var dest = this.resolvedProperty;

          for ( var i = 0, n = dest.length; i !== n; ++ i ) {

            dest[ i ] = buffer[ offset ++ ];

          }

        },

        function setValue_array_setNeedsUpdate( buffer, offset ) {

          var dest = this.resolvedProperty;

          for ( var i = 0, n = dest.length; i !== n; ++ i ) {

            dest[ i ] = buffer[ offset ++ ];

          }

          this.targetObject.needsUpdate = true;

        },

        function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

          var dest = this.resolvedProperty;

          for ( var i = 0, n = dest.length; i !== n; ++ i ) {

            dest[ i ] = buffer[ offset ++ ];

          }

          this.targetObject.matrixWorldNeedsUpdate = true;

        }

      ], [

        // ArrayElement

        function setValue_arrayElement( buffer, offset ) {

          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

        },

        function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
          this.targetObject.needsUpdate = true;

        },

        function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
          this.targetObject.matrixWorldNeedsUpdate = true;

        }

      ], [

        // HasToFromArray

        function setValue_fromArray( buffer, offset ) {

          this.resolvedProperty.fromArray( buffer, offset );

        },

        function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

          this.resolvedProperty.fromArray( buffer, offset );
          this.targetObject.needsUpdate = true;

        },

        function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

          this.resolvedProperty.fromArray( buffer, offset );
          this.targetObject.matrixWorldNeedsUpdate = true;

        }

      ]

    ],

    getValue: function getValue_unbound( targetArray, offset ) {

      this.bind();
      this.getValue( targetArray, offset );

      // Note: This class uses a State pattern on a per-method basis:
      // 'bind' sets 'this.getValue' / 'setValue' and shadows the
      // prototype version of these methods with one that represents
      // the bound state. When the property is not found, the methods
      // become no-ops.

    },

    setValue: function getValue_unbound( sourceArray, offset ) {

      this.bind();
      this.setValue( sourceArray, offset );

    },

    // create getter / setter pair for a property in the scene graph
    bind: function () {

      var targetObject = this.node,
        parsedPath = this.parsedPath,

        objectName = parsedPath.objectName,
        propertyName = parsedPath.propertyName,
        propertyIndex = parsedPath.propertyIndex;

      if ( ! targetObject ) {

        targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

        this.node = targetObject;

      }

      // set fail state so we can just 'return' on error
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;

      // ensure there is a value node
      if ( ! targetObject ) {

        console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
        return;

      }

      if ( objectName ) {

        var objectIndex = parsedPath.objectIndex;

        // special cases were we need to reach deeper into the hierarchy to get the face materials....
        switch ( objectName ) {

          case 'materials':

            if ( ! targetObject.material ) {

              console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
              return;

            }

            if ( ! targetObject.material.materials ) {

              console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
              return;

            }

            targetObject = targetObject.material.materials;

            break;

          case 'bones':

            if ( ! targetObject.skeleton ) {

              console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
              return;

            }

            // potential future optimization: skip this if propertyIndex is already an integer
            // and convert the integer string to a true integer.

            targetObject = targetObject.skeleton.bones;

            // support resolving morphTarget names into indices.
            for ( var i = 0; i < targetObject.length; i ++ ) {

              if ( targetObject[ i ].name === objectIndex ) {

                objectIndex = i;
                break;

              }

            }

            break;

          default:

            if ( targetObject[ objectName ] === undefined ) {

              console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
              return;

            }

            targetObject = targetObject[ objectName ];

        }


        if ( objectIndex !== undefined ) {

          if ( targetObject[ objectIndex ] === undefined ) {

            console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
            return;

          }

          targetObject = targetObject[ objectIndex ];

        }

      }

      // resolve property
      var nodeProperty = targetObject[ propertyName ];

      if ( nodeProperty === undefined ) {

        var nodeName = parsedPath.nodeName;

        console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
          '.' + propertyName + ' but it wasn\'t found.', targetObject );
        return;

      }

      // determine versioning scheme
      var versioning = this.Versioning.None;

      if ( targetObject.needsUpdate !== undefined ) { // material

        versioning = this.Versioning.NeedsUpdate;
        this.targetObject = targetObject;

      } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

        versioning = this.Versioning.MatrixWorldNeedsUpdate;
        this.targetObject = targetObject;

      }

      // determine how the property gets bound
      var bindingType = this.BindingType.Direct;

      if ( propertyIndex !== undefined ) {

        // access a sub element of the property array (only primitives are supported right now)

        if ( propertyName === "morphTargetInfluences" ) {

          // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

          // support resolving morphTarget names into indices.
          if ( ! targetObject.geometry ) {

            console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
            return;

          }

          if ( targetObject.geometry.isBufferGeometry ) {

            if ( ! targetObject.geometry.morphAttributes ) {

              console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
              return;

            }

            for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

              if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

                propertyIndex = i;
                break;

              }

            }


          } else {

            if ( ! targetObject.geometry.morphTargets ) {

              console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
              return;

            }

            for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

              if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

                propertyIndex = i;
                break;

              }

            }

          }

        }

        bindingType = this.BindingType.ArrayElement;

        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;

      } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

        // must use copy for Object3D.Euler/Quaternion

        bindingType = this.BindingType.HasFromToArray;

        this.resolvedProperty = nodeProperty;

      } else if ( Array.isArray( nodeProperty ) ) {

        bindingType = this.BindingType.EntireArray;

        this.resolvedProperty = nodeProperty;

      } else {

        this.propertyName = propertyName;

      }

      // select getter / setter
      this.getValue = this.GetterByBindingType[ bindingType ];
      this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

    },

    unbind: function () {

      this.node = null;

      // back to the prototype version of getValue / setValue
      // note: avoiding to mutate the shape of 'this' via 'delete'
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;

    }

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( PropertyBinding.prototype, {

    // initial state of these methods that calls 'bind'
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue,

  } );

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   *  - Add objects you would otherwise pass as 'root' to the
   *    constructor or the .clipAction method of AnimationMixer.
   *
   *  - Instead pass this object as 'root'.
   *
   *  - You can also add and remove objects later when the mixer
   *    is running.
   *
   * Note:
   *
   *    Objects of this class appear as one object to the mixer,
   *    so cache control of the individual objects must be done
   *    on the group.
   *
   * Limitation:
   *
   *  -   The animated properties must be compatible among the
   *    all objects in the group.
   *
   *  - A single property can either be controlled through a
   *    target group or directly, but not both.
   *
   * @author tschw
   */

  function AnimationObjectGroup() {

    this.uuid = _Math.generateUUID();

    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call( arguments );

    this.nCachedObjects_ = 0;     // threshold
    // note: read by PropertyBinding.Composite

    var indices = {};
    this._indicesByUUID = indices;    // for bookkeeping

    for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

      indices[ arguments[ i ].uuid ] = i;

    }

    this._paths = [];         // inside: string
    this._parsedPaths = [];       // inside: { we don't care, here }
    this._bindings = [];        // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {};   // inside: indices in these arrays

    var scope = this;

    this.stats = {

      objects: {
        get total() {

          return scope._objects.length;

        },
        get inUse() {

          return this.total - scope.nCachedObjects_;

        }
      },
      get bindingsPerObject() {

        return scope._bindings.length;

      }

    };

  }

  Object.assign( AnimationObjectGroup.prototype, {

    isAnimationObjectGroup: true,

    add: function () {

      var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        nBindings = bindings.length;

      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

        var object = arguments[ i ],
          uuid = object.uuid,
          index = indicesByUUID[ uuid ],
          knownObject = undefined;

        if ( index === undefined ) {

          // unknown object -> add it to the ACTIVE region

          index = nObjects ++;
          indicesByUUID[ uuid ] = index;
          objects.push( object );

          // accounting is done, now do the same for all bindings

          for ( var j = 0, m = nBindings; j !== m; ++ j ) {

            bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

          }

        } else if ( index < nCachedObjects ) {

          knownObject = objects[ index ];

          // move existing object to the ACTIVE region

          var firstActiveIndex = -- nCachedObjects,
            lastCachedObject = objects[ firstActiveIndex ];

          indicesByUUID[ lastCachedObject.uuid ] = index;
          objects[ index ] = lastCachedObject;

          indicesByUUID[ uuid ] = firstActiveIndex;
          objects[ firstActiveIndex ] = object;

          // accounting is done, now do the same for all bindings

          for ( var j = 0, m = nBindings; j !== m; ++ j ) {

            var bindingsForPath = bindings[ j ],
              lastCached = bindingsForPath[ firstActiveIndex ],
              binding = bindingsForPath[ index ];

            bindingsForPath[ index ] = lastCached;

            if ( binding === undefined ) {

              // since we do not bother to create new bindings
              // for objects that are cached, the binding may
              // or may not exist

              binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

            }

            bindingsForPath[ firstActiveIndex ] = binding;

          }

        } else if ( objects[ index ] !== knownObject ) {

          console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
              'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

        } // else the object is already where we want it to be

      } // for arguments

      this.nCachedObjects_ = nCachedObjects;

    },

    remove: function () {

      var objects = this._objects,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

        var object = arguments[ i ],
          uuid = object.uuid,
          index = indicesByUUID[ uuid ];

        if ( index !== undefined && index >= nCachedObjects ) {

          // move existing object into the CACHED region

          var lastCachedIndex = nCachedObjects ++,
            firstActiveObject = objects[ lastCachedIndex ];

          indicesByUUID[ firstActiveObject.uuid ] = index;
          objects[ index ] = firstActiveObject;

          indicesByUUID[ uuid ] = lastCachedIndex;
          objects[ lastCachedIndex ] = object;

          // accounting is done, now do the same for all bindings

          for ( var j = 0, m = nBindings; j !== m; ++ j ) {

            var bindingsForPath = bindings[ j ],
              firstActive = bindingsForPath[ lastCachedIndex ],
              binding = bindingsForPath[ index ];

            bindingsForPath[ index ] = firstActive;
            bindingsForPath[ lastCachedIndex ] = binding;

          }

        }

      } // for arguments

      this.nCachedObjects_ = nCachedObjects;

    },

    // remove & forget
    uncache: function () {

      var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

        var object = arguments[ i ],
          uuid = object.uuid,
          index = indicesByUUID[ uuid ];

        if ( index !== undefined ) {

          delete indicesByUUID[ uuid ];

          if ( index < nCachedObjects ) {

            // object is cached, shrink the CACHED region

            var firstActiveIndex = -- nCachedObjects,
              lastCachedObject = objects[ firstActiveIndex ],
              lastIndex = -- nObjects,
              lastObject = objects[ lastIndex ];

            // last cached object takes this object's place
            indicesByUUID[ lastCachedObject.uuid ] = index;
            objects[ index ] = lastCachedObject;

            // last object goes to the activated slot and pop
            indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
            objects[ firstActiveIndex ] = lastObject;
            objects.pop();

            // accounting is done, now do the same for all bindings

            for ( var j = 0, m = nBindings; j !== m; ++ j ) {

              var bindingsForPath = bindings[ j ],
                lastCached = bindingsForPath[ firstActiveIndex ],
                last = bindingsForPath[ lastIndex ];

              bindingsForPath[ index ] = lastCached;
              bindingsForPath[ firstActiveIndex ] = last;
              bindingsForPath.pop();

            }

          } else {

            // object is active, just swap with the last and pop

            var lastIndex = -- nObjects,
              lastObject = objects[ lastIndex ];

            indicesByUUID[ lastObject.uuid ] = index;
            objects[ index ] = lastObject;
            objects.pop();

            // accounting is done, now do the same for all bindings

            for ( var j = 0, m = nBindings; j !== m; ++ j ) {

              var bindingsForPath = bindings[ j ];

              bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
              bindingsForPath.pop();

            }

          } // cached or active

        } // if object is known

      } // for arguments

      this.nCachedObjects_ = nCachedObjects;

    },

    // Internal interface used by befriended PropertyBinding.Composite:

    subscribe_: function ( path, parsedPath ) {

      // returns an array of bindings for the given path that is changed
      // according to the contained objects in the group

      var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[ path ],
        bindings = this._bindings;

      if ( index !== undefined ) return bindings[ index ];

      var paths = this._paths,
        parsedPaths = this._parsedPaths,
        objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        bindingsForPath = new Array( nObjects );

      index = bindings.length;

      indicesByPath[ path ] = index;

      paths.push( path );
      parsedPaths.push( parsedPath );
      bindings.push( bindingsForPath );

      for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

        var object = objects[ i ];
        bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

      }

      return bindingsForPath;

    },

    unsubscribe_: function ( path ) {

      // tells the group to forget about a property path and no longer
      // update the array previously obtained with 'subscribe_'

      var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[ path ];

      if ( index !== undefined ) {

        var paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          lastBindingsIndex = bindings.length - 1,
          lastBindings = bindings[ lastBindingsIndex ],
          lastBindingsPath = path[ lastBindingsIndex ];

        indicesByPath[ lastBindingsPath ] = index;

        bindings[ index ] = lastBindings;
        bindings.pop();

        parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
        parsedPaths.pop();

        paths[ index ] = paths[ lastBindingsIndex ];
        paths.pop();

      }

    }

  } );

  /**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */

  function AnimationAction( mixer, clip, localRoot ) {

    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;

    var tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array( nTracks );

    var interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };

    for ( var i = 0; i !== nTracks; ++ i ) {

      var interpolant = tracks[ i ].createInterpolant( null );
      interpolants[ i ] = interpolant;
      interpolant.settings = interpolantSettings;

    }

    this._interpolantSettings = interpolantSettings;

    this._interpolants = interpolants;  // bound by the mixer

    // inside: PropertyMixer (managed by the mixer)
    this._propertyBindings = new Array( nTracks );

    this._cacheIndex = null;      // for the memory manager
    this._byClipCacheIndex = null;    // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;

    this.loop = LoopRepeat;
    this._loopCount = - 1;

    // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action
    this._startTime = null;

    // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop
    this.time = 0;

    this.timeScale = 1;
    this._effectiveTimeScale = 1;

    this.weight = 1;
    this._effectiveWeight = 1;

    this.repetitions = Infinity;    // no. of repetitions when looping

    this.paused = false;        // true -> zero effective time scale
    this.enabled = true;        // false -> zero effective weight

    this.clampWhenFinished  = false;  // keep feeding the last frame?

    this.zeroSlopeAtStart   = true;   // for smooth interpolation w/o separate
    this.zeroSlopeAtEnd   = true;   // clips for start, loop and end

  }

  Object.assign( AnimationAction.prototype, {

    // State & Scheduling

    play: function () {

      this._mixer._activateAction( this );

      return this;

    },

    stop: function () {

      this._mixer._deactivateAction( this );

      return this.reset();

    },

    reset: function () {

      this.paused = false;
      this.enabled = true;

      this.time = 0;      // restart clip
      this._loopCount = - 1;  // forget previous loops
      this._startTime = null; // forget scheduling

      return this.stopFading().stopWarping();

    },

    isRunning: function () {

      return this.enabled && ! this.paused && this.timeScale !== 0 &&
          this._startTime === null && this._mixer._isActiveAction( this );

    },

    // return true when play has been called
    isScheduled: function () {

      return this._mixer._isActiveAction( this );

    },

    startAt: function ( time ) {

      this._startTime = time;

      return this;

    },

    setLoop: function ( mode, repetitions ) {

      this.loop = mode;
      this.repetitions = repetitions;

      return this;

    },

    // Weight

    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight: function ( weight ) {

      this.weight = weight;

      // note: same logic as when updated at runtime
      this._effectiveWeight = this.enabled ? weight : 0;

      return this.stopFading();

    },

    // return the weight considering fading and .enabled
    getEffectiveWeight: function () {

      return this._effectiveWeight;

    },

    fadeIn: function ( duration ) {

      return this._scheduleFading( duration, 0, 1 );

    },

    fadeOut: function ( duration ) {

      return this._scheduleFading( duration, 1, 0 );

    },

    crossFadeFrom: function ( fadeOutAction, duration, warp ) {

      fadeOutAction.fadeOut( duration );
      this.fadeIn( duration );

      if ( warp ) {

        var fadeInDuration = this._clip.duration,
          fadeOutDuration = fadeOutAction._clip.duration,

          startEndRatio = fadeOutDuration / fadeInDuration,
          endStartRatio = fadeInDuration / fadeOutDuration;

        fadeOutAction.warp( 1.0, startEndRatio, duration );
        this.warp( endStartRatio, 1.0, duration );

      }

      return this;

    },

    crossFadeTo: function ( fadeInAction, duration, warp ) {

      return fadeInAction.crossFadeFrom( this, duration, warp );

    },

    stopFading: function () {

      var weightInterpolant = this._weightInterpolant;

      if ( weightInterpolant !== null ) {

        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant( weightInterpolant );

      }

      return this;

    },

    // Time Scale Control

    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale: function ( timeScale ) {

      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;

      return this.stopWarping();

    },

    // return the time scale considering warping and .paused
    getEffectiveTimeScale: function () {

      return this._effectiveTimeScale;

    },

    setDuration: function ( duration ) {

      this.timeScale = this._clip.duration / duration;

      return this.stopWarping();

    },

    syncWith: function ( action ) {

      this.time = action.time;
      this.timeScale = action.timeScale;

      return this.stopWarping();

    },

    halt: function ( duration ) {

      return this.warp( this._effectiveTimeScale, 0, duration );

    },

    warp: function ( startTimeScale, endTimeScale, duration ) {

      var mixer = this._mixer, now = mixer.time,
        interpolant = this._timeScaleInterpolant,

        timeScale = this.timeScale;

      if ( interpolant === null ) {

        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;

      }

      var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;

      times[ 0 ] = now;
      times[ 1 ] = now + duration;

      values[ 0 ] = startTimeScale / timeScale;
      values[ 1 ] = endTimeScale / timeScale;

      return this;

    },

    stopWarping: function () {

      var timeScaleInterpolant = this._timeScaleInterpolant;

      if ( timeScaleInterpolant !== null ) {

        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

      }

      return this;

    },

    // Object Accessors

    getMixer: function () {

      return this._mixer;

    },

    getClip: function () {

      return this._clip;

    },

    getRoot: function () {

      return this._localRoot || this._mixer._root;

    },

    // Interna

    _update: function ( time, deltaTime, timeDirection, accuIndex ) {

      // called by the mixer

      if ( ! this.enabled ) {

        // call ._updateWeight() to update ._effectiveWeight

        this._updateWeight( time );
        return;

      }

      var startTime = this._startTime;

      if ( startTime !== null ) {

        // check for scheduled start of action

        var timeRunning = ( time - startTime ) * timeDirection;
        if ( timeRunning < 0 || timeDirection === 0 ) {

          return; // yet to come / don't decide when delta = 0

        }

        // start

        this._startTime = null; // unschedule
        deltaTime = timeDirection * timeRunning;

      }

      // apply time scale and advance time

      deltaTime *= this._updateTimeScale( time );
      var clipTime = this._updateTime( deltaTime );

      // note: _updateTime may disable the action resulting in
      // an effective weight of 0

      var weight = this._updateWeight( time );

      if ( weight > 0 ) {

        var interpolants = this._interpolants;
        var propertyMixers = this._propertyBindings;

        for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

          interpolants[ j ].evaluate( clipTime );
          propertyMixers[ j ].accumulate( accuIndex, weight );

        }

      }

    },

    _updateWeight: function ( time ) {

      var weight = 0;

      if ( this.enabled ) {

        weight = this.weight;
        var interpolant = this._weightInterpolant;

        if ( interpolant !== null ) {

          var interpolantValue = interpolant.evaluate( time )[ 0 ];

          weight *= interpolantValue;

          if ( time > interpolant.parameterPositions[ 1 ] ) {

            this.stopFading();

            if ( interpolantValue === 0 ) {

              // faded out, disable
              this.enabled = false;

            }

          }

        }

      }

      this._effectiveWeight = weight;
      return weight;

    },

    _updateTimeScale: function ( time ) {

      var timeScale = 0;

      if ( ! this.paused ) {

        timeScale = this.timeScale;

        var interpolant = this._timeScaleInterpolant;

        if ( interpolant !== null ) {

          var interpolantValue = interpolant.evaluate( time )[ 0 ];

          timeScale *= interpolantValue;

          if ( time > interpolant.parameterPositions[ 1 ] ) {

            this.stopWarping();

            if ( timeScale === 0 ) {

              // motion has halted, pause
              this.paused = true;

            } else {

              // warp done - apply final time scale
              this.timeScale = timeScale;

            }

          }

        }

      }

      this._effectiveTimeScale = timeScale;
      return timeScale;

    },

    _updateTime: function ( deltaTime ) {

      var time = this.time + deltaTime;

      if ( deltaTime === 0 ) return time;

      var duration = this._clip.duration,

        loop = this.loop,
        loopCount = this._loopCount;

      if ( loop === LoopOnce ) {

        if ( loopCount === - 1 ) {

          // just started

          this._loopCount = 0;
          this._setEndings( true, true, false );

        }

        handle_stop: {

          if ( time >= duration ) {

            time = duration;

          } else if ( time < 0 ) {

            time = 0;

          } else break handle_stop;

          if ( this.clampWhenFinished ) this.paused = true;
          else this.enabled = false;

          this._mixer.dispatchEvent( {
            type: 'finished', action: this,
            direction: deltaTime < 0 ? - 1 : 1
          } );

        }

      } else { // repetitive Repeat or PingPong

        var pingPong = ( loop === LoopPingPong );

        if ( loopCount === - 1 ) {

          // just started

          if ( deltaTime >= 0 ) {

            loopCount = 0;

            this._setEndings( true, this.repetitions === 0, pingPong );

          } else {

            // when looping in reverse direction, the initial
            // transition through zero counts as a repetition,
            // so leave loopCount at -1

            this._setEndings( this.repetitions === 0, true, pingPong );

          }

        }

        if ( time >= duration || time < 0 ) {

          // wrap around

          var loopDelta = Math.floor( time / duration ); // signed
          time -= duration * loopDelta;

          loopCount += Math.abs( loopDelta );

          var pending = this.repetitions - loopCount;

          if ( pending < 0 ) {

            // have to stop (switch state, clamp time, fire event)

            if ( this.clampWhenFinished ) this.paused = true;
            else this.enabled = false;

            time = deltaTime > 0 ? duration : 0;

            this._mixer.dispatchEvent( {
              type: 'finished', action: this,
              direction: deltaTime > 0 ? 1 : - 1
            } );

          } else {

            // keep running

            if ( pending === 0 ) {

              // entering the last round

              var atStart = deltaTime < 0;
              this._setEndings( atStart, ! atStart, pingPong );

            } else {

              this._setEndings( false, false, pingPong );

            }

            this._loopCount = loopCount;

            this._mixer.dispatchEvent( {
              type: 'loop', action: this, loopDelta: loopDelta
            } );

          }

        }

        if ( pingPong && ( loopCount & 1 ) === 1 ) {

          // invert time for the "pong round"

          this.time = time;
          return duration - time;

        }

      }

      this.time = time;
      return time;

    },

    _setEndings: function ( atStart, atEnd, pingPong ) {

      var settings = this._interpolantSettings;

      if ( pingPong ) {

        settings.endingStart  = ZeroSlopeEnding;
        settings.endingEnd    = ZeroSlopeEnding;

      } else {

        // assuming for LoopOnce atStart == atEnd == true

        if ( atStart ) {

          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

        } else {

          settings.endingStart = WrapAroundEnding;

        }

        if ( atEnd ) {

          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

        } else {

          settings.endingEnd   = WrapAroundEnding;

        }

      }

    },

    _scheduleFading: function ( duration, weightNow, weightThen ) {

      var mixer = this._mixer, now = mixer.time,
        interpolant = this._weightInterpolant;

      if ( interpolant === null ) {

        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;

      }

      var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;

      times[ 0 ] = now;         values[ 0 ] = weightNow;
      times[ 1 ] = now + duration;  values[ 1 ] = weightThen;

      return this;

    }

  } );

  /**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function AnimationMixer( root ) {

    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;

    this.time = 0;

    this.timeScale = 1.0;

  }

  Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

    _bindAction: function ( action, prototypeAction ) {

      var root = action._localRoot || this._root,
        tracks = action._clip.tracks,
        nTracks = tracks.length,
        bindings = action._propertyBindings,
        interpolants = action._interpolants,
        rootUuid = root.uuid,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingsByName = bindingsByRoot[ rootUuid ];

      if ( bindingsByName === undefined ) {

        bindingsByName = {};
        bindingsByRoot[ rootUuid ] = bindingsByName;

      }

      for ( var i = 0; i !== nTracks; ++ i ) {

        var track = tracks[ i ],
          trackName = track.name,
          binding = bindingsByName[ trackName ];

        if ( binding !== undefined ) {

          bindings[ i ] = binding;

        } else {

          binding = bindings[ i ];

          if ( binding !== undefined ) {

            // existing binding, make sure the cache knows

            if ( binding._cacheIndex === null ) {

              ++ binding.referenceCount;
              this._addInactiveBinding( binding, rootUuid, trackName );

            }

            continue;

          }

          var path = prototypeAction && prototypeAction.
            _propertyBindings[ i ].binding.parsedPath;

          binding = new PropertyMixer(
            PropertyBinding.create( root, trackName, path ),
            track.ValueTypeName, track.getValueSize() );

          ++ binding.referenceCount;
          this._addInactiveBinding( binding, rootUuid, trackName );

          bindings[ i ] = binding;

        }

        interpolants[ i ].resultBuffer = binding.buffer;

      }

    },

    _activateAction: function ( action ) {

      if ( ! this._isActiveAction( action ) ) {

        if ( action._cacheIndex === null ) {

          // this action has been forgotten by the cache, but the user
          // appears to be still using it -> rebind

          var rootUuid = ( action._localRoot || this._root ).uuid,
            clipUuid = action._clip.uuid,
            actionsForClip = this._actionsByClip[ clipUuid ];

          this._bindAction( action,
            actionsForClip && actionsForClip.knownActions[ 0 ] );

          this._addInactiveAction( action, clipUuid, rootUuid );

        }

        var bindings = action._propertyBindings;

        // increment reference counts / sort out state
        for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

          var binding = bindings[ i ];

          if ( binding.useCount ++ === 0 ) {

            this._lendBinding( binding );
            binding.saveOriginalState();

          }

        }

        this._lendAction( action );

      }

    },

    _deactivateAction: function ( action ) {

      if ( this._isActiveAction( action ) ) {

        var bindings = action._propertyBindings;

        // decrement reference counts / sort out state
        for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

          var binding = bindings[ i ];

          if ( -- binding.useCount === 0 ) {

            binding.restoreOriginalState();
            this._takeBackBinding( binding );

          }

        }

        this._takeBackAction( action );

      }

    },

    // Memory manager

    _initMemoryManager: function () {

      this._actions = []; // 'nActiveActions' followed by inactive ones
      this._nActiveActions = 0;

      this._actionsByClip = {};
      // inside:
      // {
      //    knownActions: Array< AnimationAction >  - used as prototypes
      //    actionByRoot: AnimationAction     - lookup
      // }


      this._bindings = []; // 'nActiveBindings' followed by inactive ones
      this._nActiveBindings = 0;

      this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


      this._controlInterpolants = []; // same game as above
      this._nActiveControlInterpolants = 0;

      var scope = this;

      this.stats = {

        actions: {
          get total() {

            return scope._actions.length;

          },
          get inUse() {

            return scope._nActiveActions;

          }
        },
        bindings: {
          get total() {

            return scope._bindings.length;

          },
          get inUse() {

            return scope._nActiveBindings;

          }
        },
        controlInterpolants: {
          get total() {

            return scope._controlInterpolants.length;

          },
          get inUse() {

            return scope._nActiveControlInterpolants;

          }
        }

      };

    },

    // Memory management for AnimationAction objects

    _isActiveAction: function ( action ) {

      var index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;

    },

    _addInactiveAction: function ( action, clipUuid, rootUuid ) {

      var actions = this._actions,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[ clipUuid ];

      if ( actionsForClip === undefined ) {

        actionsForClip = {

          knownActions: [ action ],
          actionByRoot: {}

        };

        action._byClipCacheIndex = 0;

        actionsByClip[ clipUuid ] = actionsForClip;

      } else {

        var knownActions = actionsForClip.knownActions;

        action._byClipCacheIndex = knownActions.length;
        knownActions.push( action );

      }

      action._cacheIndex = actions.length;
      actions.push( action );

      actionsForClip.actionByRoot[ rootUuid ] = action;

    },

    _removeInactiveAction: function ( action ) {

      var actions = this._actions,
        lastInactiveAction = actions[ actions.length - 1 ],
        cacheIndex = action._cacheIndex;

      lastInactiveAction._cacheIndex = cacheIndex;
      actions[ cacheIndex ] = lastInactiveAction;
      actions.pop();

      action._cacheIndex = null;


      var clipUuid = action._clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[ clipUuid ],
        knownActionsForClip = actionsForClip.knownActions,

        lastKnownAction =
          knownActionsForClip[ knownActionsForClip.length - 1 ],

        byClipCacheIndex = action._byClipCacheIndex;

      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
      knownActionsForClip.pop();

      action._byClipCacheIndex = null;


      var actionByRoot = actionsForClip.actionByRoot,
        rootUuid = ( action._localRoot || this._root ).uuid;

      delete actionByRoot[ rootUuid ];

      if ( knownActionsForClip.length === 0 ) {

        delete actionsByClip[ clipUuid ];

      }

      this._removeInactiveBindingsForAction( action );

    },

    _removeInactiveBindingsForAction: function ( action ) {

      var bindings = action._propertyBindings;
      for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

        var binding = bindings[ i ];

        if ( -- binding.referenceCount === 0 ) {

          this._removeInactiveBinding( binding );

        }

      }

    },

    _lendAction: function ( action ) {

      // [ active actions |  inactive actions  ]
      // [  active actions >| inactive actions ]
      //                 s        a
      //                  <-swap->
      //                 a        s

      var actions = this._actions,
        prevIndex = action._cacheIndex,

        lastActiveIndex = this._nActiveActions ++,

        firstInactiveAction = actions[ lastActiveIndex ];

      action._cacheIndex = lastActiveIndex;
      actions[ lastActiveIndex ] = action;

      firstInactiveAction._cacheIndex = prevIndex;
      actions[ prevIndex ] = firstInactiveAction;

    },

    _takeBackAction: function ( action ) {

      // [  active actions  | inactive actions ]
      // [ active actions |< inactive actions  ]
      //        a        s
      //         <-swap->
      //        s        a

      var actions = this._actions,
        prevIndex = action._cacheIndex,

        firstInactiveIndex = -- this._nActiveActions,

        lastActiveAction = actions[ firstInactiveIndex ];

      action._cacheIndex = firstInactiveIndex;
      actions[ firstInactiveIndex ] = action;

      lastActiveAction._cacheIndex = prevIndex;
      actions[ prevIndex ] = lastActiveAction;

    },

    // Memory management for PropertyMixer objects

    _addInactiveBinding: function ( binding, rootUuid, trackName ) {

      var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[ rootUuid ],

        bindings = this._bindings;

      if ( bindingByName === undefined ) {

        bindingByName = {};
        bindingsByRoot[ rootUuid ] = bindingByName;

      }

      bindingByName[ trackName ] = binding;

      binding._cacheIndex = bindings.length;
      bindings.push( binding );

    },

    _removeInactiveBinding: function ( binding ) {

      var bindings = this._bindings,
        propBinding = binding.binding,
        rootUuid = propBinding.rootNode.uuid,
        trackName = propBinding.path,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[ rootUuid ],

        lastInactiveBinding = bindings[ bindings.length - 1 ],
        cacheIndex = binding._cacheIndex;

      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[ cacheIndex ] = lastInactiveBinding;
      bindings.pop();

      delete bindingByName[ trackName ];

      remove_empty_map: {

        for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

        delete bindingsByRoot[ rootUuid ];

      }

    },

    _lendBinding: function ( binding ) {

      var bindings = this._bindings,
        prevIndex = binding._cacheIndex,

        lastActiveIndex = this._nActiveBindings ++,

        firstInactiveBinding = bindings[ lastActiveIndex ];

      binding._cacheIndex = lastActiveIndex;
      bindings[ lastActiveIndex ] = binding;

      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[ prevIndex ] = firstInactiveBinding;

    },

    _takeBackBinding: function ( binding ) {

      var bindings = this._bindings,
        prevIndex = binding._cacheIndex,

        firstInactiveIndex = -- this._nActiveBindings,

        lastActiveBinding = bindings[ firstInactiveIndex ];

      binding._cacheIndex = firstInactiveIndex;
      bindings[ firstInactiveIndex ] = binding;

      lastActiveBinding._cacheIndex = prevIndex;
      bindings[ prevIndex ] = lastActiveBinding;

    },


    // Memory management of Interpolants for weight and time scale

    _lendControlInterpolant: function () {

      var interpolants = this._controlInterpolants,
        lastActiveIndex = this._nActiveControlInterpolants ++,
        interpolant = interpolants[ lastActiveIndex ];

      if ( interpolant === undefined ) {

        interpolant = new LinearInterpolant(
          new Float32Array( 2 ), new Float32Array( 2 ),
          1, this._controlInterpolantsResultBuffer );

        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[ lastActiveIndex ] = interpolant;

      }

      return interpolant;

    },

    _takeBackControlInterpolant: function ( interpolant ) {

      var interpolants = this._controlInterpolants,
        prevIndex = interpolant.__cacheIndex,

        firstInactiveIndex = -- this._nActiveControlInterpolants,

        lastActiveInterpolant = interpolants[ firstInactiveIndex ];

      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[ firstInactiveIndex ] = interpolant;

      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[ prevIndex ] = lastActiveInterpolant;

    },

    _controlInterpolantsResultBuffer: new Float32Array( 1 ),

    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction: function ( clip, optionalRoot ) {

      var root = optionalRoot || this._root,
        rootUuid = root.uuid,

        clipObject = typeof clip === 'string' ?
          AnimationClip.findByName( root, clip ) : clip,

        clipUuid = clipObject !== null ? clipObject.uuid : clip,

        actionsForClip = this._actionsByClip[ clipUuid ],
        prototypeAction = null;

      if ( actionsForClip !== undefined ) {

        var existingAction =
            actionsForClip.actionByRoot[ rootUuid ];

        if ( existingAction !== undefined ) {

          return existingAction;

        }

        // we know the clip, so we don't have to parse all
        // the bindings again but can just copy
        prototypeAction = actionsForClip.knownActions[ 0 ];

        // also, take the clip from the prototype action
        if ( clipObject === null )
          clipObject = prototypeAction._clip;

      }

      // clip must be known when specified via string
      if ( clipObject === null ) return null;

      // allocate all resources required to run it
      var newAction = new AnimationAction( this, clipObject, optionalRoot );

      this._bindAction( newAction, prototypeAction );

      // and make the action known to the memory manager
      this._addInactiveAction( newAction, clipUuid, rootUuid );

      return newAction;

    },

    // get an existing action
    existingAction: function ( clip, optionalRoot ) {

      var root = optionalRoot || this._root,
        rootUuid = root.uuid,

        clipObject = typeof clip === 'string' ?
          AnimationClip.findByName( root, clip ) : clip,

        clipUuid = clipObject ? clipObject.uuid : clip,

        actionsForClip = this._actionsByClip[ clipUuid ];

      if ( actionsForClip !== undefined ) {

        return actionsForClip.actionByRoot[ rootUuid ] || null;

      }

      return null;

    },

    // deactivates all previously scheduled actions
    stopAllAction: function () {

      var actions = this._actions,
        nActions = this._nActiveActions,
        bindings = this._bindings,
        nBindings = this._nActiveBindings;

      this._nActiveActions = 0;
      this._nActiveBindings = 0;

      for ( var i = 0; i !== nActions; ++ i ) {

        actions[ i ].reset();

      }

      for ( var i = 0; i !== nBindings; ++ i ) {

        bindings[ i ].useCount = 0;

      }

      return this;

    },

    // advance the time and update apply the animation
    update: function ( deltaTime ) {

      deltaTime *= this.timeScale;

      var actions = this._actions,
        nActions = this._nActiveActions,

        time = this.time += deltaTime,
        timeDirection = Math.sign( deltaTime ),

        accuIndex = this._accuIndex ^= 1;

      // run active actions

      for ( var i = 0; i !== nActions; ++ i ) {

        var action = actions[ i ];

        action._update( time, deltaTime, timeDirection, accuIndex );

      }

      // update scene graph

      var bindings = this._bindings,
        nBindings = this._nActiveBindings;

      for ( var i = 0; i !== nBindings; ++ i ) {

        bindings[ i ].apply( accuIndex );

      }

      return this;

    },

    // return this mixer's root target object
    getRoot: function () {

      return this._root;

    },

    // free all resources specific to a particular clip
    uncacheClip: function ( clip ) {

      var actions = this._actions,
        clipUuid = clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[ clipUuid ];

      if ( actionsForClip !== undefined ) {

        // note: just calling _removeInactiveAction would mess up the
        // iteration state and also require updating the state we can
        // just throw away

        var actionsToRemove = actionsForClip.knownActions;

        for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

          var action = actionsToRemove[ i ];

          this._deactivateAction( action );

          var cacheIndex = action._cacheIndex,
            lastInactiveAction = actions[ actions.length - 1 ];

          action._cacheIndex = null;
          action._byClipCacheIndex = null;

          lastInactiveAction._cacheIndex = cacheIndex;
          actions[ cacheIndex ] = lastInactiveAction;
          actions.pop();

          this._removeInactiveBindingsForAction( action );

        }

        delete actionsByClip[ clipUuid ];

      }

    },

    // free all resources specific to a particular root target object
    uncacheRoot: function ( root ) {

      var rootUuid = root.uuid,
        actionsByClip = this._actionsByClip;

      for ( var clipUuid in actionsByClip ) {

        var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
          action = actionByRoot[ rootUuid ];

        if ( action !== undefined ) {

          this._deactivateAction( action );
          this._removeInactiveAction( action );

        }

      }

      var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[ rootUuid ];

      if ( bindingByName !== undefined ) {

        for ( var trackName in bindingByName ) {

          var binding = bindingByName[ trackName ];
          binding.restoreOriginalState();
          this._removeInactiveBinding( binding );

        }

      }

    },

    // remove a targeted clip from the cache
    uncacheAction: function ( clip, optionalRoot ) {

      var action = this.existingAction( clip, optionalRoot );

      if ( action !== null ) {

        this._deactivateAction( action );
        this._removeInactiveAction( action );

      }

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Uniform( value ) {

    if ( typeof value === 'string' ) {

      console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
      value = arguments[ 1 ];

    }

    this.value = value;

  }

  Uniform.prototype.clone = function () {

    return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  };

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferGeometry() {

    BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

  }

  InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

    constructor: InstancedBufferGeometry,

    isInstancedBufferGeometry: true,

    copy: function ( source ) {

      BufferGeometry.prototype.copy.call( this, source );

      this.maxInstancedCount = source.maxInstancedCount;

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    }

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

    this.uuid = _Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

    this.normalized = normalized === true;

  }

  Object.defineProperties( InterleavedBufferAttribute.prototype, {

    count: {

      get: function () {

        return this.data.count;

      }

    },

    array: {

      get: function () {

        return this.data.array;

      }

    }

  } );

  Object.assign( InterleavedBufferAttribute.prototype, {

    isInterleavedBufferAttribute: true,

    setX: function ( index, x ) {

      this.data.array[ index * this.data.stride + this.offset ] = x;

      return this;

    },

    setY: function ( index, y ) {

      this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

      return this;

    },

    setZ: function ( index, z ) {

      this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

      return this;

    },

    setW: function ( index, w ) {

      this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

      return this;

    },

    getX: function ( index ) {

      return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function ( index ) {

      return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function ( index ) {

      return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function ( index ) {

      return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function ( index, x, y ) {

      index = index * this.data.stride + this.offset;

      this.data.array[ index + 0 ] = x;
      this.data.array[ index + 1 ] = y;

      return this;

    },

    setXYZ: function ( index, x, y, z ) {

      index = index * this.data.stride + this.offset;

      this.data.array[ index + 0 ] = x;
      this.data.array[ index + 1 ] = y;
      this.data.array[ index + 2 ] = z;

      return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

      index = index * this.data.stride + this.offset;

      this.data.array[ index + 0 ] = x;
      this.data.array[ index + 1 ] = y;
      this.data.array[ index + 2 ] = z;
      this.data.array[ index + 3 ] = w;

      return this;

    }

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBuffer( array, stride ) {

    this.uuid = _Math.generateUUID();

    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.onUploadCallback = function () {};

    this.version = 0;

  }

  Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

    set: function ( value ) {

      if ( value === true ) this.version ++;

    }

  } );

  Object.assign( InterleavedBuffer.prototype, {

    isInterleavedBuffer: true,

    setArray: function ( array ) {

      if ( Array.isArray( array ) ) {

        throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

      }

      this.count = array !== undefined ? array.length / this.stride : 0;
      this.array = array;

    },

    setDynamic: function ( value ) {

      this.dynamic = value;

      return this;

    },

    copy: function ( source ) {

      this.array = new source.array.constructor( source.array );
      this.count = source.count;
      this.stride = source.stride;
      this.dynamic = source.dynamic;

      return this;

    },

    copyAt: function ( index1, attribute, index2 ) {

      index1 *= this.stride;
      index2 *= attribute.stride;

      for ( var i = 0, l = this.stride; i < l; i ++ ) {

        this.array[ index1 + i ] = attribute.array[ index2 + i ];

      }

      return this;

    },

    set: function ( value, offset ) {

      if ( offset === undefined ) offset = 0;

      this.array.set( value, offset );

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    onUpload: function ( callback ) {

      this.onUploadCallback = callback;

      return this;

    }

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

    InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

    constructor: InstancedInterleavedBuffer,

    isInstancedInterleavedBuffer: true,

    copy: function ( source ) {

      InterleavedBuffer.prototype.copy.call( this, source );

      this.meshPerAttribute = source.meshPerAttribute;

      return this;

    }

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

    BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

    constructor: InstancedBufferAttribute,

    isInstancedBufferAttribute: true,

    copy: function ( source ) {

      BufferAttribute.prototype.copy.call( this, source );

      this.meshPerAttribute = source.meshPerAttribute;

      return this;

    }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author bhouston / http://clara.io/
   * @author stephomi / http://stephaneginier.com/
   */

  function Raycaster( origin, direction, near, far ) {

    this.ray = new Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };

    Object.defineProperties( this.params, {
      PointCloud: {
        get: function () {

          console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
          return this.Points;

        }
      }
    } );

  }

  function ascSort( a, b ) {

    return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

    if ( object.visible === false ) return;

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  }

  Object.assign( Raycaster.prototype, {

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( ( camera && camera.isPerspectiveCamera ) ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( ( camera && camera.isOrthographicCamera ) ) {

        this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( ascSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( ascSort );

      return intersects;

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Clock( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

  }

  Object.assign( Clock.prototype, {

    start: function () {

      this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;

    },

    stop: function () {

      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;

    },

    getElapsedTime: function () {

      this.getDelta();
      return this.elapsedTime;

    },

    getDelta: function () {

      var diff = 0;

      if ( this.autoStart && ! this.running ) {

        this.start();
        return 0;

      }

      if ( this.running ) {

        var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

        diff = ( newTime - this.oldTime ) / 1000;
        this.oldTime = newTime;

        this.elapsedTime += diff;

      }

      return diff;

    }

  } );

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The poles (phi) are at the positive and negative y axis.
   * The equator starts at positive z.
   */

  function Spherical( radius, phi, theta ) {

    this.radius = ( radius !== undefined ) ? radius : 1.0;
    this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
    this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

    return this;

  }

  Object.assign( Spherical.prototype, {

    set: function ( radius, phi, theta ) {

      this.radius = radius;
      this.phi = phi;
      this.theta = theta;

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( other ) {

      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;

      return this;

    },

    // restrict phi to be betwee EPS and PI-EPS
    makeSafe: function () {

      var EPS = 0.000001;
      this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

      return this;

    },

    setFromVector3: function ( vec3 ) {

      this.radius = vec3.length();

      if ( this.radius === 0 ) {

        this.theta = 0;
        this.phi = 0;

      } else {

        this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
        this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

      }

      return this;

    }

  } );

  /**
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   *
   */

  function Cylindrical( radius, theta, y ) {

    this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
    this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

    return this;

  }

  Object.assign( Cylindrical.prototype, {

    set: function ( radius, theta, y ) {

      this.radius = radius;
      this.theta = theta;
      this.y = y;

      return this;

    },

    clone: function () {

      return new this.constructor().copy( this );

    },

    copy: function ( other ) {

      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;

      return this;

    },

    setFromVector3: function ( vec3 ) {

      this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
      this.theta = Math.atan2( vec3.x, vec3.z );
      this.y = vec3.y;

      return this;

    }

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function ImmediateRenderObject( material ) {

    Object3D.call( this );

    this.material = material;
    this.render = function ( /* renderCallback */ ) {};

  }

  ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function VertexNormalsHelper( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry && objGeometry.isGeometry ) {

      nNormals = objGeometry.faces.length * 3;

    } else if ( objGeometry && objGeometry.isBufferGeometry ) {

      nNormals = objGeometry.attributes.normal.count;

    }

    //

    var geometry = new BufferGeometry();

    var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

  }

  VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
  VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

  VertexNormalsHelper.prototype.update = ( function () {

    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();

    return function update() {

      var keys = [ 'a', 'b', 'c' ];

      this.object.updateMatrixWorld( true );

      normalMatrix.getNormalMatrix( this.object.matrixWorld );

      var matrixWorld = this.object.matrixWorld;

      var position = this.geometry.attributes.position;

      //

      var objGeometry = this.object.geometry;

      if ( objGeometry && objGeometry.isGeometry ) {

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

          var face = faces[ i ];

          for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

            var vertex = vertices[ face[ keys[ j ] ] ];

            var normal = face.vertexNormals[ j ];

            v1.copy( vertex ).applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

          }

        }

      } else if ( objGeometry && objGeometry.isBufferGeometry ) {

        var objPos = objGeometry.attributes.position;

        var objNorm = objGeometry.attributes.normal;

        var idx = 0;

        // for simplicity, ignore index and drawcalls, and render every normal

        for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

          v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

          v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

          v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

          position.setXYZ( idx, v1.x, v1.y, v1.z );

          idx = idx + 1;

          position.setXYZ( idx, v2.x, v2.y, v2.z );

          idx = idx + 1;

        }

      }

      position.needsUpdate = true;

    };

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function SpotLightHelper( light, color ) {

    Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.color = color;

    var geometry = new BufferGeometry();

    var positions = [
      0, 0, 0,  0, 0, 1,
      0, 0, 0,  1, 0, 1,
      0, 0, 0,  - 1, 0, 1,
      0, 0, 0,  0, 1, 1,
      0, 0, 0,  0, - 1, 1
    ];

    for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

      var p1 = ( i / l ) * Math.PI * 2;
      var p2 = ( j / l ) * Math.PI * 2;

      positions.push(
        Math.cos( p1 ), Math.sin( p1 ), 1,
        Math.cos( p2 ), Math.sin( p2 ), 1
      );

    }

    geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

    var material = new LineBasicMaterial( { fog: false } );

    this.cone = new LineSegments( geometry, material );
    this.add( this.cone );

    this.update();

  }

  SpotLightHelper.prototype = Object.create( Object3D.prototype );
  SpotLightHelper.prototype.constructor = SpotLightHelper;

  SpotLightHelper.prototype.dispose = function () {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

  };

  SpotLightHelper.prototype.update = function () {

    var vector = new Vector3();
    var vector2 = new Vector3();

    return function update() {

      this.light.updateMatrixWorld();

      var coneLength = this.light.distance ? this.light.distance : 1000;
      var coneWidth = coneLength * Math.tan( this.light.angle );

      this.cone.scale.set( coneWidth, coneWidth, coneLength );

      vector.setFromMatrixPosition( this.light.matrixWorld );
      vector2.setFromMatrixPosition( this.light.target.matrixWorld );

      this.cone.lookAt( vector2.sub( vector ) );

      if ( this.color !== undefined ) {

        this.cone.material.color.set( this.color );

      } else {

        this.cone.material.color.copy( this.light.color );

      }

    };

  }();

  /**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  function getBoneList( object ) {

    var boneList = [];

    if ( object && object.isBone ) {

      boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i ++ ) {

      boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

    }

    return boneList;

  }

  function SkeletonHelper( object ) {

    var bones = getBoneList( object );

    var geometry = new BufferGeometry();

    var vertices = [];
    var colors = [];

    var color1 = new Color( 0, 0, 1 );
    var color2 = new Color( 0, 1, 0 );

    for ( var i = 0; i < bones.length; i ++ ) {

      var bone = bones[ i ];

      if ( bone.parent && bone.parent.isBone ) {

        vertices.push( 0, 0, 0 );
        vertices.push( 0, 0, 0 );
        colors.push( color1.r, color1.g, color1.b );
        colors.push( color2.r, color2.g, color2.b );

      }

    }

    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

    var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    LineSegments.call( this, geometry, material );

    this.root = object;
    this.bones = bones;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

  }

  SkeletonHelper.prototype = Object.create( LineSegments.prototype );
  SkeletonHelper.prototype.constructor = SkeletonHelper;

  SkeletonHelper.prototype.updateMatrixWorld = function () {

    var vector = new Vector3();

    var boneMatrix = new Matrix4();
    var matrixWorldInv = new Matrix4();

    return function updateMatrixWorld( force ) {

      var bones = this.bones;

      var geometry = this.geometry;
      var position = geometry.getAttribute( 'position' );

      matrixWorldInv.getInverse( this.root.matrixWorld );

      for ( var i = 0, j = 0; i < bones.length; i ++ ) {

        var bone = bones[ i ];

        if ( bone.parent && bone.parent.isBone ) {

          boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
          vector.setFromMatrixPosition( boneMatrix );
          position.setXYZ( j, vector.x, vector.y, vector.z );

          boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
          vector.setFromMatrixPosition( boneMatrix );
          position.setXYZ( j + 1, vector.x, vector.y, vector.z );

          j += 2;

        }

      }

      geometry.getAttribute( 'position' ).needsUpdate = true;

      Object3D.prototype.updateMatrixWorld.call( this, force );

    };

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function PointLightHelper( light, sphereSize, color ) {

    this.light = light;
    this.light.updateMatrixWorld();

    this.color = color;

    var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
    var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

    Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();


    /*
    var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    var d = light.distance;

    if ( d === 0.0 ) {

      this.lightDistance.visible = false;

    } else {

      this.lightDistance.scale.set( d, d, d );

    }

    this.add( this.lightDistance );
    */

  }

  PointLightHelper.prototype = Object.create( Mesh.prototype );
  PointLightHelper.prototype.constructor = PointLightHelper;

  PointLightHelper.prototype.dispose = function () {

    this.geometry.dispose();
    this.material.dispose();

  };

  PointLightHelper.prototype.update = function () {

    if ( this.color !== undefined ) {

      this.material.color.set( this.color );

    } else {

      this.material.color.copy( this.light.color );

    }

    /*
    var d = this.light.distance;

    if ( d === 0.0 ) {

      this.lightDistance.visible = false;

    } else {

      this.lightDistance.visible = true;
      this.lightDistance.scale.set( d, d, d );

    }
    */

  };

  /**
   * @author abelnation / http://github.com/abelnation
   * @author Mugen87 / http://github.com/Mugen87
   * @author WestLangley / http://github.com/WestLangley
   */

  function RectAreaLightHelper( light, color ) {

    Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.color = color;

    var material = new LineBasicMaterial( { fog: false } );

    var geometry = new BufferGeometry();

    geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

    this.line = new Line( geometry, material );
    this.add( this.line );


    this.update();

  }

  RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
  RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

  RectAreaLightHelper.prototype.dispose = function () {

    this.children[ 0 ].geometry.dispose();
    this.children[ 0 ].material.dispose();

  };

  RectAreaLightHelper.prototype.update = function () {

    // calculate new dimensions of the helper

    var hx = this.light.width * 0.5;
    var hy = this.light.height * 0.5;

    var position = this.line.geometry.attributes.position;
    var array = position.array;

    // update vertices

    array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
    array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
    array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
    array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
    array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

    position.needsUpdate = true;

    if ( this.color !== undefined ) {

      this.line.material.color.set( this.color );

    } else {

      this.line.material.color.copy( this.light.color );

    }

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function HemisphereLightHelper( light, size, color ) {

    Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.color = color;

    var geometry = new OctahedronBufferGeometry( size );
    geometry.rotateY( Math.PI * 0.5 );

    this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    if ( this.color === undefined ) this.material.vertexColors = VertexColors;

    var position = geometry.getAttribute( 'position' );
    var colors = new Float32Array( position.count * 3 );

    geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

    this.add( new Mesh( geometry, this.material ) );

    this.update();

  }

  HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  HemisphereLightHelper.prototype.dispose = function () {

    this.children[ 0 ].geometry.dispose();
    this.children[ 0 ].material.dispose();

  };

  HemisphereLightHelper.prototype.update = function () {

    var vector = new Vector3();

    var color1 = new Color();
    var color2 = new Color();

    return function update() {

      var mesh = this.children[ 0 ];

      if ( this.color !== undefined ) {

        this.material.color.set( this.color );

      } else {

        var colors = mesh.geometry.getAttribute( 'color' );

        color1.copy( this.light.color );
        color2.copy( this.light.groundColor );

        for ( var i = 0, l = colors.count; i < l; i ++ ) {

          var color = ( i < ( l / 2 ) ) ? color1 : color2;

          colors.setXYZ( i, color.r, color.g, color.b );

        }

        colors.needsUpdate = true;

      }

      mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

    };

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function GridHelper( size, divisions, color1, color2 ) {

    size = size || 10;
    divisions = divisions || 10;
    color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    var center = divisions / 2;
    var step = size / divisions;
    var halfSize = size / 2;

    var vertices = [], colors = [];

    for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

      vertices.push( - halfSize, 0, k, halfSize, 0, k );
      vertices.push( k, 0, - halfSize, k, 0, halfSize );

      var color = i === center ? color1 : color2;

      color.toArray( colors, j ); j += 3;
      color.toArray( colors, j ); j += 3;
      color.toArray( colors, j ); j += 3;
      color.toArray( colors, j ); j += 3;

    }

    var geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

    var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    LineSegments.call( this, geometry, material );

  }

  GridHelper.prototype = Object.create( LineSegments.prototype );
  GridHelper.prototype.constructor = GridHelper;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   * @author Hectate / http://www.github.com/Hectate
   */

  function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    var vertices = [];
    var colors = [];

    var x, z;
    var v, i, j, r, color;

    // create the radials

    for ( i = 0; i <= radials; i ++ ) {

      v = ( i / radials ) * ( Math.PI * 2 );

      x = Math.sin( v ) * radius;
      z = Math.cos( v ) * radius;

      vertices.push( 0, 0, 0 );
      vertices.push( x, 0, z );

      color = ( i & 1 ) ? color1 : color2;

      colors.push( color.r, color.g, color.b );
      colors.push( color.r, color.g, color.b );

    }

    // create the circles

    for ( i = 0; i <= circles; i ++ ) {

      color = ( i & 1 ) ? color1 : color2;

      r = radius - ( radius / circles * i );

      for ( j = 0; j < divisions; j ++ ) {

        // first vertex

        v = ( j / divisions ) * ( Math.PI * 2 );

        x = Math.sin( v ) * r;
        z = Math.cos( v ) * r;

        vertices.push( x, 0, z );
        colors.push( color.r, color.g, color.b );

        // second vertex

        v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

        x = Math.sin( v ) * r;
        z = Math.cos( v ) * r;

        vertices.push( x, 0, z );
        colors.push( color.r, color.g, color.b );

      }

    }

    var geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

    var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    LineSegments.call( this, geometry, material );

  }

  PolarGridHelper.prototype = Object.create( LineSegments.prototype );
  PolarGridHelper.prototype.constructor = PolarGridHelper;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function FaceNormalsHelper( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry && objGeometry.isGeometry ) {

      nNormals = objGeometry.faces.length;

    } else {

      console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new BufferGeometry();

    var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

  }

  FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
  FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

  FaceNormalsHelper.prototype.update = ( function () {

    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();

    return function update() {

      this.object.updateMatrixWorld( true );

      normalMatrix.getNormalMatrix( this.object.matrixWorld );

      var matrixWorld = this.object.matrixWorld;

      var position = this.geometry.attributes.position;

      //

      var objGeometry = this.object.geometry;

      var vertices = objGeometry.vertices;

      var faces = objGeometry.faces;

      var idx = 0;

      for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        var normal = face.normal;

        v1.copy( vertices[ face.a ] )
          .add( vertices[ face.b ] )
          .add( vertices[ face.c ] )
          .divideScalar( 3 )
          .applyMatrix4( matrixWorld );

        v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

        position.setXYZ( idx, v1.x, v1.y, v1.z );

        idx = idx + 1;

        position.setXYZ( idx, v2.x, v2.y, v2.z );

        idx = idx + 1;

      }

      position.needsUpdate = true;

    };

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function DirectionalLightHelper( light, size, color ) {

    Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.color = color;

    if ( size === undefined ) size = 1;

    var geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( [
      - size, size, 0,
      size, size, 0,
      size, - size, 0,
      - size, - size, 0,
      - size, size, 0
    ], 3 ) );

    var material = new LineBasicMaterial( { fog: false } );

    this.lightPlane = new Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

    this.targetLine = new Line( geometry, material );
    this.add( this.targetLine );

    this.update();

  }

  DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  DirectionalLightHelper.prototype.dispose = function () {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

  };

  DirectionalLightHelper.prototype.update = function () {

    var v1 = new Vector3();
    var v2 = new Vector3();
    var v3 = new Vector3();

    return function update() {

      v1.setFromMatrixPosition( this.light.matrixWorld );
      v2.setFromMatrixPosition( this.light.target.matrixWorld );
      v3.subVectors( v2, v1 );

      this.lightPlane.lookAt( v3 );

      if ( this.color !== undefined ) {

        this.lightPlane.material.color.set( this.color );
        this.targetLine.material.color.set( this.color );

      } else {

        this.lightPlane.material.color.copy( this.light.color );
        this.targetLine.material.color.copy( this.light.color );

      }

      this.targetLine.lookAt( v3 );
      this.targetLine.scale.z = v3.length();

    };

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author Mugen87 / https://github.com/Mugen87
   *
   *  - shows frustum, line of sight and up of the camera
   *  - suitable for fast updates
   *  - based on frustum visualization in lightgl.js shadowmap example
   *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */

  function CameraHelper( camera ) {

    var geometry = new BufferGeometry();
    var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

    var vertices = [];
    var colors = [];

    var pointMap = {};

    // colors

    var colorFrustum = new Color( 0xffaa00 );
    var colorCone = new Color( 0xff0000 );
    var colorUp = new Color( 0x00aaff );
    var colorTarget = new Color( 0xffffff );
    var colorCross = new Color( 0x333333 );

    // near

    addLine( 'n1', 'n2', colorFrustum );
    addLine( 'n2', 'n4', colorFrustum );
    addLine( 'n4', 'n3', colorFrustum );
    addLine( 'n3', 'n1', colorFrustum );

    // far

    addLine( 'f1', 'f2', colorFrustum );
    addLine( 'f2', 'f4', colorFrustum );
    addLine( 'f4', 'f3', colorFrustum );
    addLine( 'f3', 'f1', colorFrustum );

    // sides

    addLine( 'n1', 'f1', colorFrustum );
    addLine( 'n2', 'f2', colorFrustum );
    addLine( 'n3', 'f3', colorFrustum );
    addLine( 'n4', 'f4', colorFrustum );

    // cone

    addLine( 'p', 'n1', colorCone );
    addLine( 'p', 'n2', colorCone );
    addLine( 'p', 'n3', colorCone );
    addLine( 'p', 'n4', colorCone );

    // up

    addLine( 'u1', 'u2', colorUp );
    addLine( 'u2', 'u3', colorUp );
    addLine( 'u3', 'u1', colorUp );

    // target

    addLine( 'c', 't', colorTarget );
    addLine( 'p', 'c', colorCross );

    // cross

    addLine( 'cn1', 'cn2', colorCross );
    addLine( 'cn3', 'cn4', colorCross );

    addLine( 'cf1', 'cf2', colorCross );
    addLine( 'cf3', 'cf4', colorCross );

    function addLine( a, b, color ) {

      addPoint( a, color );
      addPoint( b, color );

    }

    function addPoint( id, color ) {

      vertices.push( 0, 0, 0 );
      colors.push( color.r, color.g, color.b );

      if ( pointMap[ id ] === undefined ) {

        pointMap[ id ] = [];

      }

      pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

    }

    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

    LineSegments.call( this, geometry, material );

    this.camera = camera;
    if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

  }

  CameraHelper.prototype = Object.create( LineSegments.prototype );
  CameraHelper.prototype.constructor = CameraHelper;

  CameraHelper.prototype.update = function () {

    var geometry, pointMap;

    var vector = new Vector3();
    var camera = new Camera();

    function setPoint( point, x, y, z ) {

      vector.set( x, y, z ).unproject( camera );

      var points = pointMap[ point ];

      if ( points !== undefined ) {

        var position = geometry.getAttribute( 'position' );

        for ( var i = 0, l = points.length; i < l; i ++ ) {

          position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

        }

      }

    }

    return function update() {

      geometry = this.geometry;
      pointMap = this.pointMap;

      var w = 1, h = 1;

      // we need just camera projection matrix
      // world matrix must be identity

      camera.projectionMatrix.copy( this.camera.projectionMatrix );

      // center / target

      setPoint( 'c', 0, 0, - 1 );
      setPoint( 't', 0, 0, 1 );

      // near

      setPoint( 'n1', - w, - h, - 1 );
      setPoint( 'n2', w, - h, - 1 );
      setPoint( 'n3', - w, h, - 1 );
      setPoint( 'n4', w, h, - 1 );

      // far

      setPoint( 'f1', - w, - h, 1 );
      setPoint( 'f2', w, - h, 1 );
      setPoint( 'f3', - w, h, 1 );
      setPoint( 'f4', w, h, 1 );

      // up

      setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
      setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
      setPoint( 'u3', 0, h * 2, - 1 );

      // cross

      setPoint( 'cf1', - w, 0, 1 );
      setPoint( 'cf2', w, 0, 1 );
      setPoint( 'cf3', 0, - h, 1 );
      setPoint( 'cf4', 0, h, 1 );

      setPoint( 'cn1', - w, 0, - 1 );
      setPoint( 'cn2', w, 0, - 1 );
      setPoint( 'cn3', 0, - h, - 1 );
      setPoint( 'cn4', 0, h, - 1 );

      geometry.getAttribute( 'position' ).needsUpdate = true;

    };

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */

  function BoxHelper( object, color ) {

    this.object = object;

    if ( color === undefined ) color = 0xffff00;

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new BufferGeometry();
    geometry.setIndex( new BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    this.matrixAutoUpdate = false;

    this.update();

  }

  BoxHelper.prototype = Object.create( LineSegments.prototype );
  BoxHelper.prototype.constructor = BoxHelper;

  BoxHelper.prototype.update = ( function () {

    var box = new Box3();

    return function update( object ) {

      if ( object !== undefined ) {

        console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

      }

      if ( this.object !== undefined ) {

        box.setFromObject( this.object );

      }

      if ( box.isEmpty() ) return;

      var min = box.min;
      var max = box.max;

      /*
        5____4
      1/___0/|
      | 6__|_7
      2/___3/

      0: max.x, max.y, max.z
      1: min.x, max.y, max.z
      2: min.x, min.y, max.z
      3: max.x, min.y, max.z
      4: max.x, max.y, min.z
      5: min.x, max.y, min.z
      6: min.x, min.y, min.z
      7: max.x, min.y, min.z
      */

      var position = this.geometry.attributes.position;
      var array = position.array;

      array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
      array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
      array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
      array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
      array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
      array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
      array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
      array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

      position.needsUpdate = true;

      this.geometry.computeBoundingSphere();

    };

  } )();

  BoxHelper.prototype.setFromObject = function ( object ) {

    this.object = object;
    this.update();

    return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3Helper( box, hex ) {

    this.type = 'Box3Helper';

    this.box = box;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

    var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

    var geometry = new BufferGeometry();

    geometry.setIndex( new BufferAttribute( indices, 1 ) );

    geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    this.geometry.computeBoundingSphere();

  }

  Box3Helper.prototype = Object.create( LineSegments.prototype );
  Box3Helper.prototype.constructor = Box3Helper;

  Box3Helper.prototype.updateMatrixWorld = function ( force ) {

    var box = this.box;

    if ( box.isEmpty() ) return;

    box.getCenter( this.position );

    box.getSize( this.scale );

    this.scale.multiplyScalar( 0.5 );

    Object3D.prototype.updateMatrixWorld.call( this, force );

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function PlaneHelper( plane, size, hex ) {

    this.type = 'PlaneHelper';

    this.plane = plane;

    this.size = ( size === undefined ) ? 1 : size;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

    var geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
    geometry.computeBoundingSphere();

    Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    //

    var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

    var geometry2 = new BufferGeometry();
    geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
    geometry2.computeBoundingSphere();

    this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

  }

  PlaneHelper.prototype = Object.create( Line.prototype );
  PlaneHelper.prototype.constructor = PlaneHelper;

  PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

    var scale = - this.plane.constant;

    if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

    this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

    this.lookAt( this.plane.normal );

    Object3D.prototype.updateMatrixWorld.call( this, force );

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author zz85 / http://github.com/zz85
   * @author bhouston / http://clara.io
   *
   * Creates an arrow for visualizing directions
   *
   * Parameters:
   *  dir - Vector3
   *  origin - Vector3
   *  length - Number
   *  color - color in hex value
   *  headLength - Number
   *  headWidth - Number
   */

  var lineGeometry;
  var coneGeometry;

  function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( lineGeometry === undefined ) {

      lineGeometry = new BufferGeometry();
      lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

      coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
      coneGeometry.translate( 0, - 0.5, 0 );

    }

    this.position.copy( origin );

    this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

  ArrowHelper.prototype = Object.create( Object3D.prototype );
  ArrowHelper.prototype.constructor = ArrowHelper;

  ArrowHelper.prototype.setDirection = ( function () {

    var axis = new Vector3();
    var radians;

    return function setDirection( dir ) {

      // dir is assumed to be normalized

      if ( dir.y > 0.99999 ) {

        this.quaternion.set( 0, 0, 0, 1 );

      } else if ( dir.y < - 0.99999 ) {

        this.quaternion.set( 1, 0, 0, 0 );

      } else {

        axis.set( dir.z, 0, - dir.x ).normalize();

        radians = Math.acos( dir.y );

        this.quaternion.setFromAxisAngle( axis, radians );

      }

    };

  }() );

  ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
    this.line.updateMatrix();

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

  };

  ArrowHelper.prototype.setColor = function ( color ) {

    this.line.material.color.copy( color );
    this.cone.material.color.copy( color );

  };

  /**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */

  function AxisHelper( size ) {

    size = size || 1;

    var vertices = [
      0, 0, 0,  size, 0, 0,
      0, 0, 0,  0, size, 0,
      0, 0, 0,  0, 0, size
    ];

    var colors = [
      1, 0, 0,  1, 0.6, 0,
      0, 1, 0,  0.6, 1, 0,
      0, 0, 1,  0, 0.6, 1
    ];

    var geometry = new BufferGeometry();
    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

    var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    LineSegments.call( this, geometry, material );

  }

  AxisHelper.prototype = Object.create( LineSegments.prototype );
  AxisHelper.prototype.constructor = AxisHelper;

  /**
   * @author zz85 https://github.com/zz85
   *
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */


  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

    var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    function init( x0, x1, t0, t1 ) {

      c0 = x0;
      c1 = t0;
      c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;

    }

    return {

      initCatmullRom: function ( x0, x1, x2, x3, tension ) {

        init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

      },

      initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        init( x1, x2, t1, t2 );

      },

      calc: function ( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;

      }

    };

  }

  //

  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();

  function CatmullRomCurve3( points ) {

    Curve.call( this );

    if ( points.length < 2 ) console.warn( 'THREE.CatmullRomCurve3: Points array needs at least two entries.' );

    this.points = points || [];
    this.closed = false;

  }

  CatmullRomCurve3.prototype = Object.create( Curve.prototype );
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

  CatmullRomCurve3.prototype.getPoint = function ( t ) {

    var points = this.points;
    var l = points.length;

    var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    if ( this.closed ) {

      intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    } else if ( weight === 0 && intPoint === l - 1 ) {

      intPoint = l - 2;
      weight = 1;

    }

    var p0, p1, p2, p3; // 4 points

    if ( this.closed || intPoint > 0 ) {

      p0 = points[ ( intPoint - 1 ) % l ];

    } else {

      // extrapolate first point
      tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
      p0 = tmp;

    }

    p1 = points[ intPoint % l ];
    p2 = points[ ( intPoint + 1 ) % l ];

    if ( this.closed || intPoint + 2 < l ) {

      p3 = points[ ( intPoint + 2 ) % l ];

    } else {

      // extrapolate last point
      tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
      p3 = tmp;

    }

    if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

      // init Centripetal / Chordal Catmull-Rom
      var pow = this.type === 'chordal' ? 0.5 : 0.25;
      var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
      var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
      var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

      // safety check for repeated points
      if ( dt1 < 1e-4 ) dt1 = 1.0;
      if ( dt0 < 1e-4 ) dt0 = dt1;
      if ( dt2 < 1e-4 ) dt2 = dt1;

      px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
      py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
      pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    } else if ( this.type === 'catmullrom' ) {

      var tension = this.tension !== undefined ? this.tension : 0.5;
      px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
      py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
      pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

    }

    return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );

  };

  function CubicBezierCurve3( v0, v1, v2, v3 ) {

    Curve.call( this );

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  }

  CubicBezierCurve3.prototype = Object.create( Curve.prototype );
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

  CubicBezierCurve3.prototype.getPoint = function ( t ) {

    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

    return new Vector3(
      CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
      CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
      CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
    );

  };

  function QuadraticBezierCurve3( v0, v1, v2 ) {

    Curve.call( this );

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  }

  QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

  QuadraticBezierCurve3.prototype.getPoint = function ( t ) {

    var v0 = this.v0, v1 = this.v1, v2 = this.v2;

    return new Vector3(
      QuadraticBezier( t, v0.x, v1.x, v2.x ),
      QuadraticBezier( t, v0.y, v1.y, v2.y ),
      QuadraticBezier( t, v0.z, v1.z, v2.z )
    );

  };

  function LineCurve3( v1, v2 ) {

    Curve.call( this );

    this.v1 = v1;
    this.v2 = v2;

  }

  LineCurve3.prototype = Object.create( Curve.prototype );
  LineCurve3.prototype.constructor = LineCurve3;

  LineCurve3.prototype.getPoint = function ( t ) {

    if ( t === 1 ) {

      return this.v2.clone();

    }

    var vector = new Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  };

  function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  }

  ArcCurve.prototype = Object.create( EllipseCurve.prototype );
  ArcCurve.prototype.constructor = ArcCurve;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  var SceneUtils = {

    createMultiMaterialObject: function ( geometry, materials ) {

      var group = new Group();

      for ( var i = 0, l = materials.length; i < l; i ++ ) {

        group.add( new Mesh( geometry, materials[ i ] ) );

      }

      return group;

    },

    detach: function ( child, parent, scene ) {

      child.applyMatrix( parent.matrixWorld );
      parent.remove( child );
      scene.add( child );

    },

    attach: function ( child, scene, parent ) {

      child.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );

      scene.remove( child );
      parent.add( child );

    }

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Face4( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new Face3( a, b, c, normal, color, materialIndex );

  }

  var LineStrip = 0;

  var LinePieces = 1;

  function MeshFaceMaterial( materials ) {

    console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
    return materials;

  }

  function MultiMaterial( materials ) {

    if ( materials === undefined ) materials = [];

    console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function () {

      return materials.slice();

    };
    return materials;

  }

  function PointCloud( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new Points( geometry, material );

  }

  function Particle( material ) {

    console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
    return new Sprite( material );

  }

  function ParticleSystem( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new Points( geometry, material );

  }

  function PointCloudMaterial( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new PointsMaterial( parameters );

  }

  function ParticleBasicMaterial( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new PointsMaterial( parameters );

  }

  function ParticleSystemMaterial( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new PointsMaterial( parameters );

  }

  function Vertex( x, y, z ) {

    console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
    return new Vector3( x, y, z );

  }

  //

  function DynamicBufferAttribute( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new BufferAttribute( array, itemSize ).setDynamic( true );

  }

  function Int8Attribute( array, itemSize ) {

    console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
    return new Int8BufferAttribute( array, itemSize );

  }

  function Uint8Attribute( array, itemSize ) {

    console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
    return new Uint8BufferAttribute( array, itemSize );

  }

  function Uint8ClampedAttribute( array, itemSize ) {

    console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
    return new Uint8ClampedBufferAttribute( array, itemSize );

  }

  function Int16Attribute( array, itemSize ) {

    console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
    return new Int16BufferAttribute( array, itemSize );

  }

  function Uint16Attribute( array, itemSize ) {

    console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
    return new Uint16BufferAttribute( array, itemSize );

  }

  function Int32Attribute( array, itemSize ) {

    console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
    return new Int32BufferAttribute( array, itemSize );

  }

  function Uint32Attribute( array, itemSize ) {

    console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
    return new Uint32BufferAttribute( array, itemSize );

  }

  function Float32Attribute( array, itemSize ) {

    console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
    return new Float32BufferAttribute( array, itemSize );

  }

  function Float64Attribute( array, itemSize ) {

    console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
    return new Float64BufferAttribute( array, itemSize );

  }

  //

  Curve.create = function ( construct, getPoint ) {

    console.log( 'THREE.Curve.create() has been deprecated' );

    construct.prototype = Object.create( Curve.prototype );
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;

    return construct;

  };

  //

  function ClosedSplineCurve3( points ) {

    console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

    CatmullRomCurve3.call( this, points );
    this.type = 'catmullrom';
    this.closed = true;

  }

  ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

  //

  function SplineCurve3( points ) {

    console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

    CatmullRomCurve3.call( this, points );
    this.type = 'catmullrom';

  }

  SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

  //

  function Spline( points ) {

    console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

    CatmullRomCurve3.call( this, points );
    this.type = 'catmullrom';

  }

  Spline.prototype = Object.create( CatmullRomCurve3.prototype );

  Object.assign( Spline.prototype, {

    initFromArray: function ( /* a */ ) {

      console.error( 'THREE.Spline: .initFromArray() has been removed.' );

    },
    getControlPointsArray: function ( /* optionalTarget */ ) {

      console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

    },
    reparametrizeByArcLength: function ( /* samplingCoef */ ) {

      console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

    }

  } );

  //
  function BoundingBoxHelper( object, color ) {

    console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
    return new BoxHelper( object, color );

  }

  function EdgesHelper( object, hex ) {

    console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
    return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  }

  GridHelper.prototype.setColors = function () {

    console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

  };

  SkeletonHelper.prototype.update = function () {

    console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

  };

  function WireframeHelper( object, hex ) {

    console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
    return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  }

  //

  function XHRLoader( manager ) {

    console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
    return new FileLoader( manager );

  }

  function BinaryTextureLoader( manager ) {

    console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
    return new DataTextureLoader( manager );

  }

  //

  Object.assign( Box2.prototype, {

    center: function ( optionalTarget ) {

      console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
      return this.getCenter( optionalTarget );

    },
    empty: function () {

      console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
      return this.isEmpty();

    },
    isIntersectionBox: function ( box ) {

      console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );

    },
    size: function ( optionalTarget ) {

      console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
      return this.getSize( optionalTarget );

    }
  } );

  Object.assign( Box3.prototype, {

    center: function ( optionalTarget ) {

      console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
      return this.getCenter( optionalTarget );

    },
    empty: function () {

      console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
      return this.isEmpty();

    },
    isIntersectionBox: function ( box ) {

      console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );

    },
    isIntersectionSphere: function ( sphere ) {

      console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
      return this.intersectsSphere( sphere );

    },
    size: function ( optionalTarget ) {

      console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
      return this.getSize( optionalTarget );

    }
  } );

  Line3.prototype.center = function ( optionalTarget ) {

    console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
    return this.getCenter( optionalTarget );

  };

  Object.assign( _Math, {

    random16: function () {

      console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
      return Math.random();

    },

    nearestPowerOfTwo: function ( value ) {

      console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
      return _Math.floorPowerOfTwo( value );

    },

    nextPowerOfTwo: function ( value ) {

      console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
      return _Math.ceilPowerOfTwo( value );

    }

  } );

  Object.assign( Matrix3.prototype, {

    flattenToArrayOffset: function ( array, offset ) {

      console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
      return this.toArray( array, offset );

    },
    multiplyVector3: function ( vector ) {

      console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
      return vector.applyMatrix3( this );

    },
    multiplyVector3Array: function ( /* a */ ) {

      console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

    },
    applyToBuffer: function ( buffer /*, offset, length */ ) {

      console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
      return this.applyToBufferAttribute( buffer );

    },
    applyToVector3Array: function ( /* array, offset, length */ ) {

      console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

    }

  } );

  Object.assign( Matrix4.prototype, {

    extractPosition: function ( m ) {

      console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
      return this.copyPosition( m );

    },
    flattenToArrayOffset: function ( array, offset ) {

      console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
      return this.toArray( array, offset );

    },
    getPosition: function () {

      var v1;

      return function getPosition() {

        if ( v1 === undefined ) v1 = new Vector3();
        console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
        return v1.setFromMatrixColumn( this, 3 );

      };

    }(),
    setRotationFromQuaternion: function ( q ) {

      console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
      return this.makeRotationFromQuaternion( q );

    },
    multiplyToArray: function () {

      console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

    },
    multiplyVector3: function ( vector ) {

      console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
      return vector.applyMatrix4( this );

    },
    multiplyVector4: function ( vector ) {

      console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
      return vector.applyMatrix4( this );

    },
    multiplyVector3Array: function ( /* a */ ) {

      console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

    },
    rotateAxis: function ( v ) {

      console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
      v.transformDirection( this );

    },
    crossVector: function ( vector ) {

      console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
      return vector.applyMatrix4( this );

    },
    translate: function () {

      console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },
    rotateX: function () {

      console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },
    rotateY: function () {

      console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },
    rotateZ: function () {

      console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },
    rotateByAxis: function () {

      console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },
    applyToBuffer: function ( buffer /*, offset, length */ ) {

      console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
      return this.applyToBufferAttribute( buffer );

    },
    applyToVector3Array: function ( /* array, offset, length */ ) {

      console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

    },
    makeFrustum: function ( left, right, bottom, top, near, far ) {

      console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
      return this.makePerspective( left, right, top, bottom, near, far );

    }

  } );

  Plane.prototype.isIntersectionLine = function ( line ) {

    console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
    return this.intersectsLine( line );

  };

  Quaternion.prototype.multiplyVector3 = function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  };

  Object.assign( Ray.prototype, {

    isIntersectionBox: function ( box ) {

      console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );

    },
    isIntersectionPlane: function ( plane ) {

      console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
      return this.intersectsPlane( plane );

    },
    isIntersectionSphere: function ( sphere ) {

      console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
      return this.intersectsSphere( sphere );

    }

  } );

  Object.assign( Shape.prototype, {

    extrude: function ( options ) {

      console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
      return new ExtrudeGeometry( this, options );

    },
    makeGeometry: function ( options ) {

      console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
      return new ShapeGeometry( this, options );

    }

  } );

  Object.assign( Vector2.prototype, {

    fromAttribute: function ( attribute, index, offset ) {

      console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
      return this.fromBufferAttribute( attribute, index, offset );

    }

  } );

  Object.assign( Vector3.prototype, {

    setEulerFromRotationMatrix: function () {

      console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },
    setEulerFromQuaternion: function () {

      console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },
    getPositionFromMatrix: function ( m ) {

      console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
      return this.setFromMatrixPosition( m );

    },
    getScaleFromMatrix: function ( m ) {

      console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
      return this.setFromMatrixScale( m );

    },
    getColumnFromMatrix: function ( index, matrix ) {

      console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
      return this.setFromMatrixColumn( matrix, index );

    },
    applyProjection: function ( m ) {

      console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
      return this.applyMatrix4( m );

    },
    fromAttribute: function ( attribute, index, offset ) {

      console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
      return this.fromBufferAttribute( attribute, index, offset );

    }

  } );

  Object.assign( Vector4.prototype, {

    fromAttribute: function ( attribute, index, offset ) {

      console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
      return this.fromBufferAttribute( attribute, index, offset );

    }

  } );

  //

  Geometry.prototype.computeTangents = function () {

    console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

  };

  Object.assign( Object3D.prototype, {

    getChildByName: function ( name ) {

      console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
      return this.getObjectByName( name );

    },
    renderDepth: function () {

      console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },
    translate: function ( distance, axis ) {

      console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
      return this.translateOnAxis( axis, distance );

    }

  } );

  Object.defineProperties( Object3D.prototype, {

    eulerOrder: {
      get: function () {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
        return this.rotation.order;

      },
      set: function ( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
        this.rotation.order = value;

      }
    },
    useQuaternion: {
      get: function () {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

      },
      set: function () {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

      }
    }

  } );

  Object.defineProperties( LOD.prototype, {

    objects: {
      get: function () {

        console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
        return this.levels;

      }
    }

  } );

  Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

    get: function () {

      console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

    },
    set: function () {

      console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

    }

  } );

  Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

    get: function () {

      console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
      return this.arcLengthDivisions;

    },
    set: function ( value ) {

      console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
      this.arcLengthDivisions = value;

    }

  } );

  //

  PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

    console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
        "Use .setFocalLength and .filmGauge for a photographic setup." );

    if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
    this.setFocalLength( focalLength );

  };

  //

  Object.defineProperties( Light.prototype, {
    onlyShadow: {
      set: function () {

        console.warn( 'THREE.Light: .onlyShadow has been removed.' );

      }
    },
    shadowCameraFov: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
        this.shadow.camera.fov = value;

      }
    },
    shadowCameraLeft: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
        this.shadow.camera.left = value;

      }
    },
    shadowCameraRight: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
        this.shadow.camera.right = value;

      }
    },
    shadowCameraTop: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
        this.shadow.camera.top = value;

      }
    },
    shadowCameraBottom: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
        this.shadow.camera.bottom = value;

      }
    },
    shadowCameraNear: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
        this.shadow.camera.near = value;

      }
    },
    shadowCameraFar: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
        this.shadow.camera.far = value;

      }
    },
    shadowCameraVisible: {
      set: function () {

        console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

      }
    },
    shadowBias: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
        this.shadow.bias = value;

      }
    },
    shadowDarkness: {
      set: function () {

        console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

      }
    },
    shadowMapWidth: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
        this.shadow.mapSize.width = value;

      }
    },
    shadowMapHeight: {
      set: function ( value ) {

        console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
        this.shadow.mapSize.height = value;

      }
    }
  } );

  //

  Object.defineProperties( BufferAttribute.prototype, {

    length: {
      get: function () {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
        return this.array.length;

      }
    }

  } );

  Object.assign( BufferGeometry.prototype, {

    addIndex: function ( index ) {

      console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
      this.setIndex( index );

    },
    addDrawCall: function ( start, count, indexOffset ) {

      if ( indexOffset !== undefined ) {

        console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

      }
      console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
      this.addGroup( start, count );

    },
    clearDrawCalls: function () {

      console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
      this.clearGroups();

    },
    computeTangents: function () {

      console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },
    computeOffsets: function () {

      console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

    }

  } );

  Object.defineProperties( BufferGeometry.prototype, {

    drawcalls: {
      get: function () {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

      }
    },
    offsets: {
      get: function () {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

      }
    }

  } );

  //

  Object.defineProperties( Uniform.prototype, {

    dynamic: {
      set: function () {

        console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

      }
    },
    onUpdate: {
      value: function () {

        console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
        return this;

      }
    }

  } );

  //

  Object.defineProperties( Material.prototype, {

    wrapAround: {
      get: function () {

        console.warn( 'THREE.Material: .wrapAround has been removed.' );

      },
      set: function () {

        console.warn( 'THREE.Material: .wrapAround has been removed.' );

      }
    },
    wrapRGB: {
      get: function () {

        console.warn( 'THREE.Material: .wrapRGB has been removed.' );
        return new Color();

      }
    },

    shading: {
      get: function () {

        console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

      },
      set: function ( value ) {

        console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
        this.flatShading = ( value === FlatShading );

      }
    }

  } );

  Object.defineProperties( MeshPhongMaterial.prototype, {

    metal: {
      get: function () {

        console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
        return false;

      },
      set: function () {

        console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

      }
    }

  } );

  Object.defineProperties( ShaderMaterial.prototype, {

    derivatives: {
      get: function () {

        console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
        return this.extensions.derivatives;

      },
      set: function ( value ) {

        console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
        this.extensions.derivatives = value;

      }
    }

  } );

  //

  Object.assign( WebGLRenderer.prototype, {

    getCurrentRenderTarget: function () {

      console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
      return this.getRenderTarget();

    },

    getMaxAnisotropy: function () {

      console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
      return this.capabilities.getMaxAnisotropy();

    },

    getPrecision: function () {

      console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
      return this.capabilities.precision;

    },

    resetGLState: function () {

      console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
      return this.state.reset();

    },

    supportsFloatTextures: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
      return this.extensions.get( 'OES_texture_float' );

    },
    supportsHalfFloatTextures: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
      return this.extensions.get( 'OES_texture_half_float' );

    },
    supportsStandardDerivatives: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
      return this.extensions.get( 'OES_standard_derivatives' );

    },
    supportsCompressedTextureS3TC: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
      return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

    },
    supportsCompressedTexturePVRTC: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
      return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    },
    supportsBlendMinMax: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
      return this.extensions.get( 'EXT_blend_minmax' );

    },
    supportsVertexTextures: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
      return this.capabilities.vertexTextures;

    },
    supportsInstancedArrays: function () {

      console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
      return this.extensions.get( 'ANGLE_instanced_arrays' );

    },
    enableScissorTest: function ( boolean ) {

      console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
      this.setScissorTest( boolean );

    },
    initMaterial: function () {

      console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    },
    addPrePlugin: function () {

      console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    },
    addPostPlugin: function () {

      console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    },
    updateShadowMap: function () {

      console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    }

  } );

  Object.defineProperties( WebGLRenderer.prototype, {

    shadowMapEnabled: {
      get: function () {

        return this.shadowMap.enabled;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
        this.shadowMap.enabled = value;

      }
    },
    shadowMapType: {
      get: function () {

        return this.shadowMap.type;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
        this.shadowMap.type = value;

      }
    },
    shadowMapCullFace: {
      get: function () {

        return this.shadowMap.cullFace;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
        this.shadowMap.cullFace = value;

      }
    }
  } );

  Object.defineProperties( WebGLShadowMap.prototype, {

    cullFace: {
      get: function () {

        return this.renderReverseSided ? CullFaceFront : CullFaceBack;

      },
      set: function ( cullFace ) {

        var value = ( cullFace !== CullFaceBack );
        console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
        this.renderReverseSided = value;

      }
    }

  } );

  //

  Object.defineProperties( WebGLRenderTarget.prototype, {

    wrapS: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
        return this.texture.wrapS;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
        this.texture.wrapS = value;

      }
    },
    wrapT: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
        return this.texture.wrapT;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
        this.texture.wrapT = value;

      }
    },
    magFilter: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
        return this.texture.magFilter;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
        this.texture.magFilter = value;

      }
    },
    minFilter: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
        return this.texture.minFilter;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
        this.texture.minFilter = value;

      }
    },
    anisotropy: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
        return this.texture.anisotropy;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
        this.texture.anisotropy = value;

      }
    },
    offset: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
        return this.texture.offset;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
        this.texture.offset = value;

      }
    },
    repeat: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
        return this.texture.repeat;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
        this.texture.repeat = value;

      }
    },
    format: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
        return this.texture.format;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
        this.texture.format = value;

      }
    },
    type: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
        return this.texture.type;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
        this.texture.type = value;

      }
    },
    generateMipmaps: {
      get: function () {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
        return this.texture.generateMipmaps;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
        this.texture.generateMipmaps = value;

      }
    }

  } );

  //

  Audio.prototype.load = function ( file ) {

    console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
    var scope = this;
    var audioLoader = new AudioLoader();
    audioLoader.load( file, function ( buffer ) {

      scope.setBuffer( buffer );

    } );
    return this;

  };

  AudioAnalyser.prototype.getData = function () {

    console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
    return this.getFrequencyData();

  };

  //

  CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

    console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
    return this.update( renderer, scene );

  };

  //

  var GeometryUtils = {

    merge: function ( geometry1, geometry2, materialIndexOffset ) {

      console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
      var matrix;

      if ( geometry2.isMesh ) {

        geometry2.matrixAutoUpdate && geometry2.updateMatrix();

        matrix = geometry2.matrix;
        geometry2 = geometry2.geometry;

      }

      geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function ( geometry ) {

      console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
      return geometry.center();

    }

  };

  var ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function ( url, mapping, onLoad, onError ) {

      console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

      var loader = new TextureLoader();
      loader.setCrossOrigin( this.crossOrigin );

      var texture = loader.load( url, onLoad, undefined, onError );

      if ( mapping ) texture.mapping = mapping;

      return texture;

    },

    loadTextureCube: function ( urls, mapping, onLoad, onError ) {

      console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

      var loader = new CubeTextureLoader();
      loader.setCrossOrigin( this.crossOrigin );

      var texture = loader.load( urls, onLoad, undefined, onError );

      if ( mapping ) texture.mapping = mapping;

      return texture;

    },

    loadCompressedTexture: function () {

      console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

    },

    loadCompressedTextureCube: function () {

      console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

    }

  };

  //

  function Projector() {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function ( vector, camera ) {

      console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
      vector.project( camera );

    };

    this.unprojectVector = function ( vector, camera ) {

      console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
      vector.unproject( camera );

    };

    this.pickingRay = function () {

      console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

  }

  //

  function CanvasRenderer() {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    this.clear = function () {};
    this.render = function () {};
    this.setClearColor = function () {};
    this.setSize = function () {};

  }

  exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
  exports.WebGLRenderTarget = WebGLRenderTarget;
  exports.WebGLRenderer = WebGLRenderer;
  exports.ShaderLib = ShaderLib;
  exports.UniformsLib = UniformsLib;
  exports.UniformsUtils = UniformsUtils;
  exports.ShaderChunk = ShaderChunk;
  exports.FogExp2 = FogExp2;
  exports.Fog = Fog;
  exports.Scene = Scene;
  exports.LensFlare = LensFlare;
  exports.Sprite = Sprite;
  exports.LOD = LOD;
  exports.SkinnedMesh = SkinnedMesh;
  exports.Skeleton = Skeleton;
  exports.Bone = Bone;
  exports.Mesh = Mesh;
  exports.LineSegments = LineSegments;
  exports.LineLoop = LineLoop;
  exports.Line = Line;
  exports.Points = Points;
  exports.Group = Group;
  exports.VideoTexture = VideoTexture;
  exports.DataTexture = DataTexture;
  exports.CompressedTexture = CompressedTexture;
  exports.CubeTexture = CubeTexture;
  exports.CanvasTexture = CanvasTexture;
  exports.DepthTexture = DepthTexture;
  exports.Texture = Texture;
  exports.CompressedTextureLoader = CompressedTextureLoader;
  exports.DataTextureLoader = DataTextureLoader;
  exports.CubeTextureLoader = CubeTextureLoader;
  exports.TextureLoader = TextureLoader;
  exports.ObjectLoader = ObjectLoader;
  exports.MaterialLoader = MaterialLoader;
  exports.BufferGeometryLoader = BufferGeometryLoader;
  exports.DefaultLoadingManager = DefaultLoadingManager;
  exports.LoadingManager = LoadingManager;
  exports.JSONLoader = JSONLoader;
  exports.ImageLoader = ImageLoader;
  exports.FontLoader = FontLoader;
  exports.FileLoader = FileLoader;
  exports.Loader = Loader;
  exports.Cache = Cache;
  exports.AudioLoader = AudioLoader;
  exports.SpotLightShadow = SpotLightShadow;
  exports.SpotLight = SpotLight;
  exports.PointLight = PointLight;
  exports.RectAreaLight = RectAreaLight;
  exports.HemisphereLight = HemisphereLight;
  exports.DirectionalLightShadow = DirectionalLightShadow;
  exports.DirectionalLight = DirectionalLight;
  exports.AmbientLight = AmbientLight;
  exports.LightShadow = LightShadow;
  exports.Light = Light;
  exports.StereoCamera = StereoCamera;
  exports.PerspectiveCamera = PerspectiveCamera;
  exports.OrthographicCamera = OrthographicCamera;
  exports.CubeCamera = CubeCamera;
  exports.ArrayCamera = ArrayCamera;
  exports.Camera = Camera;
  exports.AudioListener = AudioListener;
  exports.PositionalAudio = PositionalAudio;
  exports.AudioContext = AudioContext;
  exports.AudioAnalyser = AudioAnalyser;
  exports.Audio = Audio;
  exports.VectorKeyframeTrack = VectorKeyframeTrack;
  exports.StringKeyframeTrack = StringKeyframeTrack;
  exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
  exports.NumberKeyframeTrack = NumberKeyframeTrack;
  exports.ColorKeyframeTrack = ColorKeyframeTrack;
  exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
  exports.PropertyMixer = PropertyMixer;
  exports.PropertyBinding = PropertyBinding;
  exports.KeyframeTrack = KeyframeTrack;
  exports.AnimationUtils = AnimationUtils;
  exports.AnimationObjectGroup = AnimationObjectGroup;
  exports.AnimationMixer = AnimationMixer;
  exports.AnimationClip = AnimationClip;
  exports.Uniform = Uniform;
  exports.InstancedBufferGeometry = InstancedBufferGeometry;
  exports.BufferGeometry = BufferGeometry;
  exports.Geometry = Geometry;
  exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
  exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
  exports.InterleavedBuffer = InterleavedBuffer;
  exports.InstancedBufferAttribute = InstancedBufferAttribute;
  exports.Face3 = Face3;
  exports.Object3D = Object3D;
  exports.Raycaster = Raycaster;
  exports.Layers = Layers;
  exports.EventDispatcher = EventDispatcher;
  exports.Clock = Clock;
  exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
  exports.LinearInterpolant = LinearInterpolant;
  exports.DiscreteInterpolant = DiscreteInterpolant;
  exports.CubicInterpolant = CubicInterpolant;
  exports.Interpolant = Interpolant;
  exports.Triangle = Triangle;
  exports.Math = _Math;
  exports.Spherical = Spherical;
  exports.Cylindrical = Cylindrical;
  exports.Plane = Plane;
  exports.Frustum = Frustum;
  exports.Sphere = Sphere;
  exports.Ray = Ray;
  exports.Matrix4 = Matrix4;
  exports.Matrix3 = Matrix3;
  exports.Box3 = Box3;
  exports.Box2 = Box2;
  exports.Line3 = Line3;
  exports.Euler = Euler;
  exports.Vector4 = Vector4;
  exports.Vector3 = Vector3;
  exports.Vector2 = Vector2;
  exports.Quaternion = Quaternion;
  exports.Color = Color;
  exports.ImmediateRenderObject = ImmediateRenderObject;
  exports.VertexNormalsHelper = VertexNormalsHelper;
  exports.SpotLightHelper = SpotLightHelper;
  exports.SkeletonHelper = SkeletonHelper;
  exports.PointLightHelper = PointLightHelper;
  exports.RectAreaLightHelper = RectAreaLightHelper;
  exports.HemisphereLightHelper = HemisphereLightHelper;
  exports.GridHelper = GridHelper;
  exports.PolarGridHelper = PolarGridHelper;
  exports.FaceNormalsHelper = FaceNormalsHelper;
  exports.DirectionalLightHelper = DirectionalLightHelper;
  exports.CameraHelper = CameraHelper;
  exports.BoxHelper = BoxHelper;
  exports.Box3Helper = Box3Helper;
  exports.PlaneHelper = PlaneHelper;
  exports.ArrowHelper = ArrowHelper;
  exports.AxisHelper = AxisHelper;
  exports.CatmullRomCurve3 = CatmullRomCurve3;
  exports.CubicBezierCurve3 = CubicBezierCurve3;
  exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
  exports.LineCurve3 = LineCurve3;
  exports.ArcCurve = ArcCurve;
  exports.EllipseCurve = EllipseCurve;
  exports.SplineCurve = SplineCurve;
  exports.CubicBezierCurve = CubicBezierCurve;
  exports.QuadraticBezierCurve = QuadraticBezierCurve;
  exports.LineCurve = LineCurve;
  exports.Shape = Shape;
  exports.Path = Path;
  exports.ShapePath = ShapePath;
  exports.Font = Font;
  exports.CurvePath = CurvePath;
  exports.Curve = Curve;
  exports.ShapeUtils = ShapeUtils;
  exports.SceneUtils = SceneUtils;
  exports.WebGLUtils = WebGLUtils;
  exports.WireframeGeometry = WireframeGeometry;
  exports.ParametricGeometry = ParametricGeometry;
  exports.ParametricBufferGeometry = ParametricBufferGeometry;
  exports.TetrahedronGeometry = TetrahedronGeometry;
  exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
  exports.OctahedronGeometry = OctahedronGeometry;
  exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
  exports.IcosahedronGeometry = IcosahedronGeometry;
  exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
  exports.DodecahedronGeometry = DodecahedronGeometry;
  exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
  exports.PolyhedronGeometry = PolyhedronGeometry;
  exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
  exports.TubeGeometry = TubeGeometry;
  exports.TubeBufferGeometry = TubeBufferGeometry;
  exports.TorusKnotGeometry = TorusKnotGeometry;
  exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
  exports.TorusGeometry = TorusGeometry;
  exports.TorusBufferGeometry = TorusBufferGeometry;
  exports.TextGeometry = TextGeometry;
  exports.TextBufferGeometry = TextBufferGeometry;
  exports.SphereGeometry = SphereGeometry;
  exports.SphereBufferGeometry = SphereBufferGeometry;
  exports.RingGeometry = RingGeometry;
  exports.RingBufferGeometry = RingBufferGeometry;
  exports.PlaneGeometry = PlaneGeometry;
  exports.PlaneBufferGeometry = PlaneBufferGeometry;
  exports.LatheGeometry = LatheGeometry;
  exports.LatheBufferGeometry = LatheBufferGeometry;
  exports.ShapeGeometry = ShapeGeometry;
  exports.ShapeBufferGeometry = ShapeBufferGeometry;
  exports.ExtrudeGeometry = ExtrudeGeometry;
  exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
  exports.EdgesGeometry = EdgesGeometry;
  exports.ConeGeometry = ConeGeometry;
  exports.ConeBufferGeometry = ConeBufferGeometry;
  exports.CylinderGeometry = CylinderGeometry;
  exports.CylinderBufferGeometry = CylinderBufferGeometry;
  exports.CircleGeometry = CircleGeometry;
  exports.CircleBufferGeometry = CircleBufferGeometry;
  exports.BoxGeometry = BoxGeometry;
  exports.BoxBufferGeometry = BoxBufferGeometry;
  exports.ShadowMaterial = ShadowMaterial;
  exports.SpriteMaterial = SpriteMaterial;
  exports.RawShaderMaterial = RawShaderMaterial;
  exports.ShaderMaterial = ShaderMaterial;
  exports.PointsMaterial = PointsMaterial;
  exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
  exports.MeshStandardMaterial = MeshStandardMaterial;
  exports.MeshPhongMaterial = MeshPhongMaterial;
  exports.MeshToonMaterial = MeshToonMaterial;
  exports.MeshNormalMaterial = MeshNormalMaterial;
  exports.MeshLambertMaterial = MeshLambertMaterial;
  exports.MeshDepthMaterial = MeshDepthMaterial;
  exports.MeshDistanceMaterial = MeshDistanceMaterial;
  exports.MeshBasicMaterial = MeshBasicMaterial;
  exports.LineDashedMaterial = LineDashedMaterial;
  exports.LineBasicMaterial = LineBasicMaterial;
  exports.Material = Material;
  exports.Float64BufferAttribute = Float64BufferAttribute;
  exports.Float32BufferAttribute = Float32BufferAttribute;
  exports.Uint32BufferAttribute = Uint32BufferAttribute;
  exports.Int32BufferAttribute = Int32BufferAttribute;
  exports.Uint16BufferAttribute = Uint16BufferAttribute;
  exports.Int16BufferAttribute = Int16BufferAttribute;
  exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
  exports.Uint8BufferAttribute = Uint8BufferAttribute;
  exports.Int8BufferAttribute = Int8BufferAttribute;
  exports.BufferAttribute = BufferAttribute;
  exports.REVISION = REVISION;
  exports.MOUSE = MOUSE;
  exports.CullFaceNone = CullFaceNone;
  exports.CullFaceBack = CullFaceBack;
  exports.CullFaceFront = CullFaceFront;
  exports.CullFaceFrontBack = CullFaceFrontBack;
  exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
  exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
  exports.BasicShadowMap = BasicShadowMap;
  exports.PCFShadowMap = PCFShadowMap;
  exports.PCFSoftShadowMap = PCFSoftShadowMap;
  exports.FrontSide = FrontSide;
  exports.BackSide = BackSide;
  exports.DoubleSide = DoubleSide;
  exports.FlatShading = FlatShading;
  exports.SmoothShading = SmoothShading;
  exports.NoColors = NoColors;
  exports.FaceColors = FaceColors;
  exports.VertexColors = VertexColors;
  exports.NoBlending = NoBlending;
  exports.NormalBlending = NormalBlending;
  exports.AdditiveBlending = AdditiveBlending;
  exports.SubtractiveBlending = SubtractiveBlending;
  exports.MultiplyBlending = MultiplyBlending;
  exports.CustomBlending = CustomBlending;
  exports.AddEquation = AddEquation;
  exports.SubtractEquation = SubtractEquation;
  exports.ReverseSubtractEquation = ReverseSubtractEquation;
  exports.MinEquation = MinEquation;
  exports.MaxEquation = MaxEquation;
  exports.ZeroFactor = ZeroFactor;
  exports.OneFactor = OneFactor;
  exports.SrcColorFactor = SrcColorFactor;
  exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
  exports.SrcAlphaFactor = SrcAlphaFactor;
  exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
  exports.DstAlphaFactor = DstAlphaFactor;
  exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
  exports.DstColorFactor = DstColorFactor;
  exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
  exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
  exports.NeverDepth = NeverDepth;
  exports.AlwaysDepth = AlwaysDepth;
  exports.LessDepth = LessDepth;
  exports.LessEqualDepth = LessEqualDepth;
  exports.EqualDepth = EqualDepth;
  exports.GreaterEqualDepth = GreaterEqualDepth;
  exports.GreaterDepth = GreaterDepth;
  exports.NotEqualDepth = NotEqualDepth;
  exports.MultiplyOperation = MultiplyOperation;
  exports.MixOperation = MixOperation;
  exports.AddOperation = AddOperation;
  exports.NoToneMapping = NoToneMapping;
  exports.LinearToneMapping = LinearToneMapping;
  exports.ReinhardToneMapping = ReinhardToneMapping;
  exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
  exports.CineonToneMapping = CineonToneMapping;
  exports.UVMapping = UVMapping;
  exports.CubeReflectionMapping = CubeReflectionMapping;
  exports.CubeRefractionMapping = CubeRefractionMapping;
  exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
  exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
  exports.SphericalReflectionMapping = SphericalReflectionMapping;
  exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
  exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
  exports.RepeatWrapping = RepeatWrapping;
  exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
  exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
  exports.NearestFilter = NearestFilter;
  exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
  exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
  exports.LinearFilter = LinearFilter;
  exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
  exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
  exports.UnsignedByteType = UnsignedByteType;
  exports.ByteType = ByteType;
  exports.ShortType = ShortType;
  exports.UnsignedShortType = UnsignedShortType;
  exports.IntType = IntType;
  exports.UnsignedIntType = UnsignedIntType;
  exports.FloatType = FloatType;
  exports.HalfFloatType = HalfFloatType;
  exports.UnsignedShort4444Type = UnsignedShort4444Type;
  exports.UnsignedShort5551Type = UnsignedShort5551Type;
  exports.UnsignedShort565Type = UnsignedShort565Type;
  exports.UnsignedInt248Type = UnsignedInt248Type;
  exports.AlphaFormat = AlphaFormat;
  exports.RGBFormat = RGBFormat;
  exports.RGBAFormat = RGBAFormat;
  exports.LuminanceFormat = LuminanceFormat;
  exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
  exports.RGBEFormat = RGBEFormat;
  exports.DepthFormat = DepthFormat;
  exports.DepthStencilFormat = DepthStencilFormat;
  exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
  exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
  exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
  exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
  exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
  exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
  exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
  exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
  exports.RGB_ETC1_Format = RGB_ETC1_Format;
  exports.LoopOnce = LoopOnce;
  exports.LoopRepeat = LoopRepeat;
  exports.LoopPingPong = LoopPingPong;
  exports.InterpolateDiscrete = InterpolateDiscrete;
  exports.InterpolateLinear = InterpolateLinear;
  exports.InterpolateSmooth = InterpolateSmooth;
  exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
  exports.ZeroSlopeEnding = ZeroSlopeEnding;
  exports.WrapAroundEnding = WrapAroundEnding;
  exports.TrianglesDrawMode = TrianglesDrawMode;
  exports.TriangleStripDrawMode = TriangleStripDrawMode;
  exports.TriangleFanDrawMode = TriangleFanDrawMode;
  exports.LinearEncoding = LinearEncoding;
  exports.sRGBEncoding = sRGBEncoding;
  exports.GammaEncoding = GammaEncoding;
  exports.RGBEEncoding = RGBEEncoding;
  exports.LogLuvEncoding = LogLuvEncoding;
  exports.RGBM7Encoding = RGBM7Encoding;
  exports.RGBM16Encoding = RGBM16Encoding;
  exports.RGBDEncoding = RGBDEncoding;
  exports.BasicDepthPacking = BasicDepthPacking;
  exports.RGBADepthPacking = RGBADepthPacking;
  exports.CubeGeometry = BoxGeometry;
  exports.Face4 = Face4;
  exports.LineStrip = LineStrip;
  exports.LinePieces = LinePieces;
  exports.MeshFaceMaterial = MeshFaceMaterial;
  exports.MultiMaterial = MultiMaterial;
  exports.PointCloud = PointCloud;
  exports.Particle = Particle;
  exports.ParticleSystem = ParticleSystem;
  exports.PointCloudMaterial = PointCloudMaterial;
  exports.ParticleBasicMaterial = ParticleBasicMaterial;
  exports.ParticleSystemMaterial = ParticleSystemMaterial;
  exports.Vertex = Vertex;
  exports.DynamicBufferAttribute = DynamicBufferAttribute;
  exports.Int8Attribute = Int8Attribute;
  exports.Uint8Attribute = Uint8Attribute;
  exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
  exports.Int16Attribute = Int16Attribute;
  exports.Uint16Attribute = Uint16Attribute;
  exports.Int32Attribute = Int32Attribute;
  exports.Uint32Attribute = Uint32Attribute;
  exports.Float32Attribute = Float32Attribute;
  exports.Float64Attribute = Float64Attribute;
  exports.ClosedSplineCurve3 = ClosedSplineCurve3;
  exports.SplineCurve3 = SplineCurve3;
  exports.Spline = Spline;
  exports.BoundingBoxHelper = BoundingBoxHelper;
  exports.EdgesHelper = EdgesHelper;
  exports.WireframeHelper = WireframeHelper;
  exports.XHRLoader = XHRLoader;
  exports.BinaryTextureLoader = BinaryTextureLoader;
  exports.GeometryUtils = GeometryUtils;
  exports.ImageUtils = ImageUtils;
  exports.Projector = Projector;
  exports.CanvasRenderer = CanvasRenderer;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

// system.js - http://github.com/mrdoob/system.js
'use strict';var System={browser:function(){var a=navigator.userAgent;return/Arora/i.test(a)?"Arora":/Chrome/i.test(a)?"Chrome":/Epiphany/i.test(a)?"Epiphany":/Firefox/i.test(a)?"Firefox":/Mobile(\/.*)? Safari/i.test(a)?"Mobile Safari":/MSIE/i.test(a)?"Internet Explorer":/Midori/i.test(a)?"Midori":/Opera/.test(a)?"Opera":/Safari/i.test(a)?"Safari":!1}(),os:function(){var a=navigator.userAgent;return/Android/i.test(a)?"Android":/CrOS/i.test(a)?"Chrome OS":/iP[ao]d|iPhone/i.test(a)?"iOS":/Linux/i.test(a)?
"Linux":/Mac OS/i.test(a)?"Mac OS":/windows/i.test(a)?"Windows":!1}(),support:{canvas:!!window.CanvasRenderingContext2D,localStorage:function(){try{return!!window.localStorage.getItem}catch(a){return!1}}(),file:!!window.File&&!!window.FileReader&&!!window.FileList&&!!window.Blob,fileSystem:!!window.requestFileSystem||!!window.webkitRequestFileSystem,getUserMedia:!!window.navigator.getUserMedia||!!window.navigator.webkitGetUserMedia||!!window.navigator.mozGetUserMedia||!!window.navigator.msGetUserMedia,
requestAnimationFrame:!!window.mozRequestAnimationFrame||!!window.webkitRequestAnimationFrame||!!window.oRequestAnimationFrame||!!window.msRequestAnimationFrame,sessionStorage:function(){try{return!!window.sessionStorage.getItem}catch(a){return!1}}(),webgl:function(){try{return!!window.WebGLRenderingContext&&!!document.createElement("canvas").getContext("experimental-webgl")}catch(a){return!1}}(),worker:!!window.Worker}};

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EditorControls = function ( object, domElement ) {

  domElement = ( domElement !== undefined ) ? domElement : document;

  // API

  this.enabled = true;
  this.center = new THREE.Vector3();
  this.panSpeed = 0.001;
  this.zoomSpeed = 0.001;
  this.rotationSpeed = 0.005;

  // internals

  var scope = this;
  var vector = new THREE.Vector3();

  var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2 };
  var state = STATE.NONE;

  var center = this.center;
  var normalMatrix = new THREE.Matrix3();
  var pointer = new THREE.Vector2();
  var pointerOld = new THREE.Vector2();
  var spherical = new THREE.Spherical();

  // events

  var changeEvent = { type: 'change' };

  this.focus = function ( target ) {

    var box = new THREE.Box3().setFromObject( target );
    object.lookAt( center.copy( box.getCenter() ) );
    scope.dispatchEvent( changeEvent );

  };

  this.pan = function ( delta ) {

    var distance = object.position.distanceTo( center );

    delta.multiplyScalar( distance * scope.panSpeed );
    delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );

    object.position.add( delta );
    center.add( delta );

    scope.dispatchEvent( changeEvent );

  };

  this.zoom = function ( delta ) {

    var distance = object.position.distanceTo( center );

    delta.multiplyScalar( distance * scope.zoomSpeed );

    if ( delta.length() > distance ) return;

    delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );

    object.position.add( delta );

    scope.dispatchEvent( changeEvent );

  };

  this.rotate = function ( delta ) {

    vector.copy( object.position ).sub( center );

    spherical.setFromVector3( vector );

    spherical.theta += delta.x;
    spherical.phi += delta.y;

    spherical.makeSafe();

    vector.setFromSpherical( spherical );

    object.position.copy( center ).add( vector );

    object.lookAt( center );

    scope.dispatchEvent( changeEvent );

  };

  // mouse

  function onMouseDown( event ) {

    if ( scope.enabled === false ) return;

    if ( event.button === 0 ) {

      state = STATE.ROTATE;

    } else if ( event.button === 1 ) {

      state = STATE.ZOOM;

    } else if ( event.button === 2 ) {

      state = STATE.PAN;

    }

    pointerOld.set( event.clientX, event.clientY );

    domElement.addEventListener( 'mousemove', onMouseMove, false );
    domElement.addEventListener( 'mouseup', onMouseUp, false );
    domElement.addEventListener( 'mouseout', onMouseUp, false );
    domElement.addEventListener( 'dblclick', onMouseUp, false );

  }

  function onMouseMove( event ) {

    if ( scope.enabled === false ) return;

    pointer.set( event.clientX, event.clientY );

    var movementX = pointer.x - pointerOld.x;
    var movementY = pointer.y - pointerOld.y;

    if ( state === STATE.ROTATE ) {

      scope.rotate( new THREE.Vector3( - movementX * scope.rotationSpeed, - movementY * scope.rotationSpeed, 0 ) );

    } else if ( state === STATE.ZOOM ) {

      scope.zoom( new THREE.Vector3( 0, 0, movementY ) );

    } else if ( state === STATE.PAN ) {

      scope.pan( new THREE.Vector3( - movementX, movementY, 0 ) );

    }

    pointerOld.set( event.clientX, event.clientY );

  }

  function onMouseUp( event ) {

    domElement.removeEventListener( 'mousemove', onMouseMove, false );
    domElement.removeEventListener( 'mouseup', onMouseUp, false );
    domElement.removeEventListener( 'mouseout', onMouseUp, false );
    domElement.removeEventListener( 'dblclick', onMouseUp, false );

    state = STATE.NONE;

  }

  function onMouseWheel( event ) {

    event.preventDefault();

    // if ( scope.enabled === false ) return;

    scope.zoom( new THREE.Vector3( 0, 0, event.deltaY ) );

  }

  function contextmenu( event ) {

    event.preventDefault();

  }

  this.dispose = function() {

    domElement.removeEventListener( 'contextmenu', contextmenu, false );
    domElement.removeEventListener( 'mousedown', onMouseDown, false );
    domElement.removeEventListener( 'wheel', onMouseWheel, false );

    domElement.removeEventListener( 'mousemove', onMouseMove, false );
    domElement.removeEventListener( 'mouseup', onMouseUp, false );
    domElement.removeEventListener( 'mouseout', onMouseUp, false );
    domElement.removeEventListener( 'dblclick', onMouseUp, false );

    domElement.removeEventListener( 'touchstart', touchStart, false );
    domElement.removeEventListener( 'touchmove', touchMove, false );

  };

  domElement.addEventListener( 'contextmenu', contextmenu, false );
  domElement.addEventListener( 'mousedown', onMouseDown, false );
  domElement.addEventListener( 'wheel', onMouseWheel, false );

  // touch

  var touches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
  var prevTouches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

  var prevDistance = null;

  function touchStart( event ) {

    if ( scope.enabled === false ) return;

    switch ( event.touches.length ) {

      case 1:
        touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        touches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        break;

      case 2:
        touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        touches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );
        prevDistance = touches[ 0 ].distanceTo( touches[ 1 ] );
        break;

    }

    prevTouches[ 0 ].copy( touches[ 0 ] );
    prevTouches[ 1 ].copy( touches[ 1 ] );

  }


  function touchMove( event ) {

    if ( scope.enabled === false ) return;

    event.preventDefault();
    event.stopPropagation();

    function getClosest( touch, touches ) {

      var closest = touches[ 0 ];

      for ( var i in touches ) {

        if ( closest.distanceTo( touch ) > touches[ i ].distanceTo( touch ) ) closest = touches[ i ];

      }

      return closest;

    }

    switch ( event.touches.length ) {

      case 1:
        touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        touches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        scope.rotate( touches[ 0 ].sub( getClosest( touches[ 0 ], prevTouches ) ).multiplyScalar( - scope.rotationSpeed ) );
        break;

      case 2:
        touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
        touches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );
        var distance = touches[ 0 ].distanceTo( touches[ 1 ] );
        scope.zoom( new THREE.Vector3( 0, 0, prevDistance - distance ) );
        prevDistance = distance;


        var offset0 = touches[ 0 ].clone().sub( getClosest( touches[ 0 ], prevTouches ) );
        var offset1 = touches[ 1 ].clone().sub( getClosest( touches[ 1 ], prevTouches ) );
        offset0.x = - offset0.x;
        offset1.x = - offset1.x;

        scope.pan( offset0.add( offset1 ).multiplyScalar( 0.5 ) );

        break;

    }

    prevTouches[ 0 ].copy( touches[ 0 ] );
    prevTouches[ 1 ].copy( touches[ 1 ] );

  }

  domElement.addEventListener( 'touchstart', touchStart, false );
  domElement.addEventListener( 'touchmove', touchMove, false );

};

THREE.EditorControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.EditorControls.prototype.constructor = THREE.EditorControls;

/**
 * @author arodic / https://github.com/arodic
 */

( function () {

  'use strict';

  var GizmoMaterial = function ( parameters ) {

    THREE.MeshBasicMaterial.call( this );

    this.depthTest = false;
    this.depthWrite = false;
    this.side = THREE.FrontSide;
    this.transparent = true;

    this.setValues( parameters );

    this.oldColor = this.color.clone();
    this.oldOpacity = this.opacity;

    this.highlight = function( highlighted ) {

      if ( highlighted ) {

        this.color.setRGB( 1, 1, 0 );
        this.opacity = 1;

      } else {

        this.color.copy( this.oldColor );
        this.opacity = this.oldOpacity;

      }

    };

  };

  GizmoMaterial.prototype = Object.create( THREE.MeshBasicMaterial.prototype );
  GizmoMaterial.prototype.constructor = GizmoMaterial;


  var GizmoLineMaterial = function ( parameters ) {

    THREE.LineBasicMaterial.call( this );

    this.depthTest = false;
    this.depthWrite = false;
    this.transparent = true;
    this.linewidth = 1;

    this.setValues( parameters );

    this.oldColor = this.color.clone();
    this.oldOpacity = this.opacity;

    this.highlight = function( highlighted ) {

      if ( highlighted ) {

        this.color.setRGB( 1, 1, 0 );
        this.opacity = 1;

      } else {

        this.color.copy( this.oldColor );
        this.opacity = this.oldOpacity;

      }

    };

  };

  GizmoLineMaterial.prototype = Object.create( THREE.LineBasicMaterial.prototype );
  GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;


  var pickerMaterial = new GizmoMaterial( { visible: false, transparent: false } );


  THREE.TransformGizmo = function () {

    this.init = function () {

      THREE.Object3D.call( this );

      this.handles = new THREE.Object3D();
      this.pickers = new THREE.Object3D();
      this.planes = new THREE.Object3D();

      this.add( this.handles );
      this.add( this.pickers );
      this.add( this.planes );

      //// PLANES

      var planeGeometry = new THREE.PlaneBufferGeometry( 50, 50, 2, 2 );
      var planeMaterial = new THREE.MeshBasicMaterial( { visible: false, side: THREE.DoubleSide } );

      var planes = {
        "XY":   new THREE.Mesh( planeGeometry, planeMaterial ),
        "YZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
        "XZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
        "XYZE": new THREE.Mesh( planeGeometry, planeMaterial )
      };

      this.activePlane = planes[ "XYZE" ];

      planes[ "YZ" ].rotation.set( 0, Math.PI / 2, 0 );
      planes[ "XZ" ].rotation.set( - Math.PI / 2, 0, 0 );

      for ( var i in planes ) {

        planes[ i ].name = i;
        this.planes.add( planes[ i ] );
        this.planes[ i ] = planes[ i ];

      }

      //// HANDLES AND PICKERS

      var setupGizmos = function( gizmoMap, parent ) {

        for ( var name in gizmoMap ) {

          for ( i = gizmoMap[ name ].length; i --; ) {

            var object = gizmoMap[ name ][ i ][ 0 ];
            var position = gizmoMap[ name ][ i ][ 1 ];
            var rotation = gizmoMap[ name ][ i ][ 2 ];

            object.name = name;

            if ( position ) object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );
            if ( rotation ) object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );

            parent.add( object );

          }

        }

      };

      setupGizmos( this.handleGizmos, this.handles );
      setupGizmos( this.pickerGizmos, this.pickers );

      // reset Transformations

      this.traverse( function ( child ) {

        if ( child instanceof THREE.Mesh ) {

          child.updateMatrix();

          var tempGeometry = child.geometry.clone();
          tempGeometry.applyMatrix( child.matrix );
          child.geometry = tempGeometry;

          child.position.set( 0, 0, 0 );
          child.rotation.set( 0, 0, 0 );
          child.scale.set( 1, 1, 1 );

        }

      } );

    };

    this.highlight = function ( axis ) {

      this.traverse( function( child ) {

        if ( child.material && child.material.highlight ) {

          if ( child.name === axis ) {

            child.material.highlight( true );

          } else {

            child.material.highlight( false );

          }

        }

      } );

    };

  };

  THREE.TransformGizmo.prototype = Object.create( THREE.Object3D.prototype );
  THREE.TransformGizmo.prototype.constructor = THREE.TransformGizmo;

  THREE.TransformGizmo.prototype.update = function ( rotation, eye ) {

    var vec1 = new THREE.Vector3( 0, 0, 0 );
    var vec2 = new THREE.Vector3( 0, 1, 0 );
    var lookAtMatrix = new THREE.Matrix4();

    this.traverse( function( child ) {

      if ( child.name.search( "E" ) !== - 1 ) {

        child.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( eye, vec1, vec2 ) );

      } else if ( child.name.search( "X" ) !== - 1 || child.name.search( "Y" ) !== - 1 || child.name.search( "Z" ) !== - 1 ) {

        child.quaternion.setFromEuler( rotation );

      }

    } );

  };

  THREE.TransformGizmoTranslate = function () {

    THREE.TransformGizmo.call( this );

    var arrowGeometry = new THREE.Geometry();
    var mesh = new THREE.Mesh( new THREE.CylinderGeometry( 0, 0.05, 0.2, 12, 1, false ) );
    mesh.position.y = 0.5;
    mesh.updateMatrix();

    arrowGeometry.merge( mesh.geometry, mesh.matrix );

    var lineXGeometry = new THREE.BufferGeometry();
    lineXGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  1, 0, 0 ], 3 ) );

    var lineYGeometry = new THREE.BufferGeometry();
    lineYGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  0, 1, 0 ], 3 ) );

    var lineZGeometry = new THREE.BufferGeometry();
    lineZGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  0, 0, 1 ], 3 ) );

    this.handleGizmos = {

      X: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ] ],
        [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
      ],

      Y: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],
        [ new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
      ],

      Z: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ] ],
        [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
      ],

      XYZ: [
        [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.1, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]
      ],

      XY: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.15, 0.15, 0 ] ]
      ],

      YZ: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ] ]
      ],

      XZ: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ] ]
      ]

    };

    this.pickerGizmos = {

      X: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0.6, 0, 0 ], [ 0, 0, - Math.PI / 2 ] ]
      ],

      Y: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0, 0.6, 0 ] ]
      ],

      Z: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ] ]
      ],

      XYZ: [
        [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.2, 0 ), pickerMaterial ) ]
      ],

      XY: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), pickerMaterial ), [ 0.2, 0.2, 0 ] ]
      ],

      YZ: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), pickerMaterial ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ] ]
      ],

      XZ: [
        [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), pickerMaterial ), [ 0.2, 0, 0.2 ], [ - Math.PI / 2, 0, 0 ] ]
      ]

    };

    this.setActivePlane = function ( axis, eye ) {

      var tempMatrix = new THREE.Matrix4();
      eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

      if ( axis === "X" ) {

        this.activePlane = this.planes[ "XY" ];

        if ( Math.abs( eye.y ) > Math.abs( eye.z ) ) this.activePlane = this.planes[ "XZ" ];

      }

      if ( axis === "Y" ) {

        this.activePlane = this.planes[ "XY" ];

        if ( Math.abs( eye.x ) > Math.abs( eye.z ) ) this.activePlane = this.planes[ "YZ" ];

      }

      if ( axis === "Z" ) {

        this.activePlane = this.planes[ "XZ" ];

        if ( Math.abs( eye.x ) > Math.abs( eye.y ) ) this.activePlane = this.planes[ "YZ" ];

      }

      if ( axis === "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

      if ( axis === "XY" ) this.activePlane = this.planes[ "XY" ];

      if ( axis === "YZ" ) this.activePlane = this.planes[ "YZ" ];

      if ( axis === "XZ" ) this.activePlane = this.planes[ "XZ" ];

    };

    this.init();

  };

  THREE.TransformGizmoTranslate.prototype = Object.create( THREE.TransformGizmo.prototype );
  THREE.TransformGizmoTranslate.prototype.constructor = THREE.TransformGizmoTranslate;

  THREE.TransformGizmoRotate = function () {

    THREE.TransformGizmo.call( this );

    var CircleGeometry = function ( radius, facing, arc ) {

      var geometry = new THREE.BufferGeometry();
      var vertices = [];
      arc = arc ? arc : 1;

      for ( var i = 0; i <= 64 * arc; ++ i ) {

        if ( facing === 'x' ) vertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );
        if ( facing === 'y' ) vertices.push( Math.cos( i / 32 * Math.PI ) * radius, 0, Math.sin( i / 32 * Math.PI ) * radius );
        if ( facing === 'z' ) vertices.push( Math.sin( i / 32 * Math.PI ) * radius, Math.cos( i / 32 * Math.PI ) * radius, 0 );

      }

      geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
      return geometry;

    };

    this.handleGizmos = {

      X: [
        [ new THREE.Line( new CircleGeometry( 1, 'x', 0.5 ), new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
      ],

      Y: [
        [ new THREE.Line( new CircleGeometry( 1, 'y', 0.5 ), new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
      ],

      Z: [
        [ new THREE.Line( new CircleGeometry( 1, 'z', 0.5 ), new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
      ],

      E: [
        [ new THREE.Line( new CircleGeometry( 1.25, 'z', 1 ), new GizmoLineMaterial( { color: 0xcccc00 } ) ) ]
      ],

      XYZE: [
        [ new THREE.Line( new CircleGeometry( 1, 'z', 1 ), new GizmoLineMaterial( { color: 0x787878 } ) ) ]
      ]

    };

    this.pickerGizmos = {

      X: [
        [ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.12, 4, 12, Math.PI ), pickerMaterial ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ] ]
      ],

      Y: [
        [ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.12, 4, 12, Math.PI ), pickerMaterial ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ] ]
      ],

      Z: [
        [ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.12, 4, 12, Math.PI ), pickerMaterial ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ] ]
      ],

      E: [
        [ new THREE.Mesh( new THREE.TorusBufferGeometry( 1.25, 0.12, 2, 24 ), pickerMaterial ) ]
      ],

      XYZE: [
        [ new THREE.Mesh() ]// TODO
      ]

    };

    this.setActivePlane = function ( axis ) {

      if ( axis === "E" ) this.activePlane = this.planes[ "XYZE" ];

      if ( axis === "X" ) this.activePlane = this.planes[ "YZ" ];

      if ( axis === "Y" ) this.activePlane = this.planes[ "XZ" ];

      if ( axis === "Z" ) this.activePlane = this.planes[ "XY" ];

    };

    this.update = function ( rotation, eye2 ) {

      THREE.TransformGizmo.prototype.update.apply( this, arguments );

      var tempMatrix = new THREE.Matrix4();
      var worldRotation = new THREE.Euler( 0, 0, 1 );
      var tempQuaternion = new THREE.Quaternion();
      var unitX = new THREE.Vector3( 1, 0, 0 );
      var unitY = new THREE.Vector3( 0, 1, 0 );
      var unitZ = new THREE.Vector3( 0, 0, 1 );
      var quaternionX = new THREE.Quaternion();
      var quaternionY = new THREE.Quaternion();
      var quaternionZ = new THREE.Quaternion();
      var eye = eye2.clone();

      worldRotation.copy( this.planes[ "XY" ].rotation );
      tempQuaternion.setFromEuler( worldRotation );

      tempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );
      eye.applyMatrix4( tempMatrix );

      this.traverse( function( child ) {

        tempQuaternion.setFromEuler( worldRotation );

        if ( child.name === "X" ) {

          quaternionX.setFromAxisAngle( unitX, Math.atan2( - eye.y, eye.z ) );
          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
          child.quaternion.copy( tempQuaternion );

        }

        if ( child.name === "Y" ) {

          quaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );
          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
          child.quaternion.copy( tempQuaternion );

        }

        if ( child.name === "Z" ) {

          quaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );
          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );
          child.quaternion.copy( tempQuaternion );

        }

      } );

    };

    this.init();

  };

  THREE.TransformGizmoRotate.prototype = Object.create( THREE.TransformGizmo.prototype );
  THREE.TransformGizmoRotate.prototype.constructor = THREE.TransformGizmoRotate;

  THREE.TransformGizmoScale = function () {

    THREE.TransformGizmo.call( this );

    var arrowGeometry = new THREE.Geometry();
    var mesh = new THREE.Mesh( new THREE.BoxGeometry( 0.125, 0.125, 0.125 ) );
    mesh.position.y = 0.5;
    mesh.updateMatrix();

    arrowGeometry.merge( mesh.geometry, mesh.matrix );

    var lineXGeometry = new THREE.BufferGeometry();
    lineXGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  1, 0, 0 ], 3 ) );

    var lineYGeometry = new THREE.BufferGeometry();
    lineYGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  0, 1, 0 ], 3 ) );

    var lineZGeometry = new THREE.BufferGeometry();
    lineZGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,  0, 0, 1 ], 3 ) );

    this.handleGizmos = {

      X: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ] ],
        [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
      ],

      Y: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],
        [ new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
      ],

      Z: [
        [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ] ],
        [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
      ],

      XYZ: [
        [ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.125, 0.125, 0.125 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
      ]

    };

    this.pickerGizmos = {

      X: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0.6, 0, 0 ], [ 0, 0, - Math.PI / 2 ] ]
      ],

      Y: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0, 0.6, 0 ] ]
      ],

      Z: [
        [ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), pickerMaterial ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ] ]
      ],

      XYZ: [
        [ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.4, 0.4, 0.4 ), pickerMaterial ) ]
      ]

    };

    this.setActivePlane = function ( axis, eye ) {

      var tempMatrix = new THREE.Matrix4();
      eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

      if ( axis === "X" ) {

        this.activePlane = this.planes[ "XY" ];
        if ( Math.abs( eye.y ) > Math.abs( eye.z ) ) this.activePlane = this.planes[ "XZ" ];

      }

      if ( axis === "Y" ) {

        this.activePlane = this.planes[ "XY" ];
        if ( Math.abs( eye.x ) > Math.abs( eye.z ) ) this.activePlane = this.planes[ "YZ" ];

      }

      if ( axis === "Z" ) {

        this.activePlane = this.planes[ "XZ" ];
        if ( Math.abs( eye.x ) > Math.abs( eye.y ) ) this.activePlane = this.planes[ "YZ" ];

      }

      if ( axis === "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

    };

    this.init();

  };

  THREE.TransformGizmoScale.prototype = Object.create( THREE.TransformGizmo.prototype );
  THREE.TransformGizmoScale.prototype.constructor = THREE.TransformGizmoScale;

  THREE.TransformControls = function ( camera, domElement ) {

    // TODO: Make non-uniform scale and rotate play nice in hierarchies
    // TODO: ADD RXYZ contol

    THREE.Object3D.call( this );

    domElement = ( domElement !== undefined ) ? domElement : document;

    this.object = undefined;
    this.visible = false;
    this.translationSnap = null;
    this.rotationSnap = null;
    this.space = "world";
    this.size = 1;
    this.axis = null;

    var scope = this;

    var _mode = "translate";
    var _dragging = false;
    var _gizmo = {

      "translate": new THREE.TransformGizmoTranslate(),
      "rotate": new THREE.TransformGizmoRotate(),
      "scale": new THREE.TransformGizmoScale()
    };

    for ( var type in _gizmo ) {

      var gizmoObj = _gizmo[ type ];

      gizmoObj.visible = ( type === _mode );
      this.add( gizmoObj );

    }

    var changeEvent = { type: "change" };
    var mouseDownEvent = { type: "mouseDown" };
    var mouseUpEvent = { type: "mouseUp", mode: _mode };
    var objectChangeEvent = { type: "objectChange" };

    var ray = new THREE.Raycaster();
    var pointerVector = new THREE.Vector2();

    var point = new THREE.Vector3();
    var offset = new THREE.Vector3();

    var rotation = new THREE.Vector3();
    var offsetRotation = new THREE.Vector3();
    var scale = 1;

    var lookAtMatrix = new THREE.Matrix4();
    var eye = new THREE.Vector3();

    var tempMatrix = new THREE.Matrix4();
    var tempVector = new THREE.Vector3();
    var tempQuaternion = new THREE.Quaternion();
    var unitX = new THREE.Vector3( 1, 0, 0 );
    var unitY = new THREE.Vector3( 0, 1, 0 );
    var unitZ = new THREE.Vector3( 0, 0, 1 );

    var quaternionXYZ = new THREE.Quaternion();
    var quaternionX = new THREE.Quaternion();
    var quaternionY = new THREE.Quaternion();
    var quaternionZ = new THREE.Quaternion();
    var quaternionE = new THREE.Quaternion();

    var oldPosition = new THREE.Vector3();
    var oldScale = new THREE.Vector3();
    var oldRotationMatrix = new THREE.Matrix4();

    var parentRotationMatrix  = new THREE.Matrix4();
    var parentScale = new THREE.Vector3();

    var worldPosition = new THREE.Vector3();
    var worldRotation = new THREE.Euler();
    var worldRotationMatrix  = new THREE.Matrix4();
    var camPosition = new THREE.Vector3();
    var camRotation = new THREE.Euler();

    domElement.addEventListener( "mousedown", onPointerDown, false );
    domElement.addEventListener( "touchstart", onPointerDown, false );

    domElement.addEventListener( "mousemove", onPointerHover, false );
    domElement.addEventListener( "touchmove", onPointerHover, false );

    domElement.addEventListener( "mousemove", onPointerMove, false );
    domElement.addEventListener( "touchmove", onPointerMove, false );

    domElement.addEventListener( "mouseup", onPointerUp, false );
    domElement.addEventListener( "mouseout", onPointerUp, false );
    domElement.addEventListener( "touchend", onPointerUp, false );
    domElement.addEventListener( "touchcancel", onPointerUp, false );
    domElement.addEventListener( "touchleave", onPointerUp, false );

    this.dispose = function () {

      domElement.removeEventListener( "mousedown", onPointerDown );
      domElement.removeEventListener( "touchstart", onPointerDown );

      domElement.removeEventListener( "mousemove", onPointerHover );
      domElement.removeEventListener( "touchmove", onPointerHover );

      domElement.removeEventListener( "mousemove", onPointerMove );
      domElement.removeEventListener( "touchmove", onPointerMove );

      domElement.removeEventListener( "mouseup", onPointerUp );
      domElement.removeEventListener( "mouseout", onPointerUp );
      domElement.removeEventListener( "touchend", onPointerUp );
      domElement.removeEventListener( "touchcancel", onPointerUp );
      domElement.removeEventListener( "touchleave", onPointerUp );

    };

    this.attach = function ( object ) {

      this.object = object;
      this.visible = true;
      this.update();

    };

    this.detach = function () {

      this.object = undefined;
      this.visible = false;
      this.axis = null;

    };

    this.getMode = function () {

      return _mode;

    };

    this.setMode = function ( mode ) {

      _mode = mode ? mode : _mode;

      if ( _mode === "scale" ) scope.space = "local";

      for ( var type in _gizmo ) _gizmo[ type ].visible = ( type === _mode );

      this.update();
      scope.dispatchEvent( changeEvent );

    };

    this.setTranslationSnap = function ( translationSnap ) {

      scope.translationSnap = translationSnap;

    };

    this.setRotationSnap = function ( rotationSnap ) {

      scope.rotationSnap = rotationSnap;

    };

    this.setSize = function ( size ) {

      scope.size = size;
      this.update();
      scope.dispatchEvent( changeEvent );

    };

    this.setSpace = function ( space ) {

      scope.space = space;
      this.update();
      scope.dispatchEvent( changeEvent );

    };

    this.update = function () {

      if ( scope.object === undefined ) return;

      scope.object.updateMatrixWorld();
      worldPosition.setFromMatrixPosition( scope.object.matrixWorld );
      worldRotation.setFromRotationMatrix( tempMatrix.extractRotation( scope.object.matrixWorld ) );

      camera.updateMatrixWorld();
      camPosition.setFromMatrixPosition( camera.matrixWorld );
      camRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );

      scale = worldPosition.distanceTo( camPosition ) / 6 * scope.size;
      this.position.copy( worldPosition );
      this.scale.set( scale, scale, scale );

      if ( camera instanceof THREE.PerspectiveCamera ) {

        eye.copy( camPosition ).sub( worldPosition ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        eye.copy( camPosition ).normalize();

      }

      if ( scope.space === "local" ) {

        _gizmo[ _mode ].update( worldRotation, eye );

      } else if ( scope.space === "world" ) {

        _gizmo[ _mode ].update( new THREE.Euler(), eye );

      }

      _gizmo[ _mode ].highlight( scope.axis );

    };

    function onPointerHover( event ) {

      if ( scope.object === undefined || _dragging === true || ( event.button !== undefined && event.button !== 0 ) ) return;

      var pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;

      var intersect = intersectObjects( pointer, _gizmo[ _mode ].pickers.children );

      var axis = null;

      if ( intersect ) {

        axis = intersect.object.name;

        event.preventDefault();

      }

      if ( scope.axis !== axis ) {

        scope.axis = axis;
        scope.update();
        scope.dispatchEvent( changeEvent );

      }

    }

    function onPointerDown( event ) {

      if ( scope.object === undefined || _dragging === true || ( event.button !== undefined && event.button !== 0 ) ) return;

      var pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;

      if ( pointer.button === 0 || pointer.button === undefined ) {

        var intersect = intersectObjects( pointer, _gizmo[ _mode ].pickers.children );

        if ( intersect ) {

          event.preventDefault();
          event.stopPropagation();

          scope.dispatchEvent( mouseDownEvent );

          scope.axis = intersect.object.name;

          scope.update();

          eye.copy( camPosition ).sub( worldPosition ).normalize();

          _gizmo[ _mode ].setActivePlane( scope.axis, eye );

          var planeIntersect = intersectObjects( pointer, [ _gizmo[ _mode ].activePlane ] );

          if ( planeIntersect ) {

            oldPosition.copy( scope.object.position );
            oldScale.copy( scope.object.scale );

            oldRotationMatrix.extractRotation( scope.object.matrix );
            worldRotationMatrix.extractRotation( scope.object.matrixWorld );

            parentRotationMatrix.extractRotation( scope.object.parent.matrixWorld );
            parentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.parent.matrixWorld ) );

            offset.copy( planeIntersect.point );

          }

        }

      }

      _dragging = true;

    }

    function onPointerMove( event ) {

      if ( scope.object === undefined || scope.axis === null || _dragging === false || ( event.button !== undefined && event.button !== 0 ) ) return;

      var pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;

      var planeIntersect = intersectObjects( pointer, [ _gizmo[ _mode ].activePlane ] );

      if ( planeIntersect === false ) return;

      event.preventDefault();
      event.stopPropagation();

      point.copy( planeIntersect.point );

      if ( _mode === "translate" ) {

        point.sub( offset );
        point.multiply( parentScale );

        if ( scope.space === "local" ) {

          point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

          if ( scope.axis.search( "X" ) === - 1 ) point.x = 0;
          if ( scope.axis.search( "Y" ) === - 1 ) point.y = 0;
          if ( scope.axis.search( "Z" ) === - 1 ) point.z = 0;

          point.applyMatrix4( oldRotationMatrix );

          scope.object.position.copy( oldPosition );
          scope.object.position.add( point );

        }

        if ( scope.space === "world" || scope.axis.search( "XYZ" ) !== - 1 ) {

          if ( scope.axis.search( "X" ) === - 1 ) point.x = 0;
          if ( scope.axis.search( "Y" ) === - 1 ) point.y = 0;
          if ( scope.axis.search( "Z" ) === - 1 ) point.z = 0;

          point.applyMatrix4( tempMatrix.getInverse( parentRotationMatrix ) );

          scope.object.position.copy( oldPosition );
          scope.object.position.add( point );

        }

        if ( scope.translationSnap !== null ) {

          if ( scope.space === "local" ) {

            scope.object.position.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

          }

          if ( scope.axis.search( "X" ) !== - 1 ) scope.object.position.x = Math.round( scope.object.position.x / scope.translationSnap ) * scope.translationSnap;
          if ( scope.axis.search( "Y" ) !== - 1 ) scope.object.position.y = Math.round( scope.object.position.y / scope.translationSnap ) * scope.translationSnap;
          if ( scope.axis.search( "Z" ) !== - 1 ) scope.object.position.z = Math.round( scope.object.position.z / scope.translationSnap ) * scope.translationSnap;

          if ( scope.space === "local" ) {

            scope.object.position.applyMatrix4( worldRotationMatrix );

          }

        }

      } else if ( _mode === "scale" ) {

        point.sub( offset );
        point.multiply( parentScale );

        if ( scope.space === "local" ) {

          if ( scope.axis === "XYZ" ) {

            scale = 1 + ( ( point.y ) / Math.max( oldScale.x, oldScale.y, oldScale.z ) );

            scope.object.scale.x = oldScale.x * scale;
            scope.object.scale.y = oldScale.y * scale;
            scope.object.scale.z = oldScale.z * scale;

          } else {

            point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

            if ( scope.axis === "X" ) scope.object.scale.x = oldScale.x * ( 1 + point.x / oldScale.x );
            if ( scope.axis === "Y" ) scope.object.scale.y = oldScale.y * ( 1 + point.y / oldScale.y );
            if ( scope.axis === "Z" ) scope.object.scale.z = oldScale.z * ( 1 + point.z / oldScale.z );

          }

        }

      } else if ( _mode === "rotate" ) {

        point.sub( worldPosition );
        point.multiply( parentScale );
        tempVector.copy( offset ).sub( worldPosition );
        tempVector.multiply( parentScale );

        if ( scope.axis === "E" ) {

          point.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );
          tempVector.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );

          rotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );
          offsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );

          tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

          quaternionE.setFromAxisAngle( eye, rotation.z - offsetRotation.z );
          quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionE );
          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

          scope.object.quaternion.copy( tempQuaternion );

        } else if ( scope.axis === "XYZE" ) {

          quaternionE.setFromEuler( point.clone().cross( tempVector ).normalize() ); // rotation axis

          tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );
          quaternionX.setFromAxisAngle( quaternionE, - point.clone().angleTo( tempVector ) );
          quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

          scope.object.quaternion.copy( tempQuaternion );

        } else if ( scope.space === "local" ) {

          point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

          tempVector.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

          rotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );
          offsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );

          quaternionXYZ.setFromRotationMatrix( oldRotationMatrix );

          if ( scope.rotationSnap !== null ) {

            quaternionX.setFromAxisAngle( unitX, Math.round( ( rotation.x - offsetRotation.x ) / scope.rotationSnap ) * scope.rotationSnap );
            quaternionY.setFromAxisAngle( unitY, Math.round( ( rotation.y - offsetRotation.y ) / scope.rotationSnap ) * scope.rotationSnap );
            quaternionZ.setFromAxisAngle( unitZ, Math.round( ( rotation.z - offsetRotation.z ) / scope.rotationSnap ) * scope.rotationSnap );

          } else {

            quaternionX.setFromAxisAngle( unitX, rotation.x - offsetRotation.x );
            quaternionY.setFromAxisAngle( unitY, rotation.y - offsetRotation.y );
            quaternionZ.setFromAxisAngle( unitZ, rotation.z - offsetRotation.z );

          }

          if ( scope.axis === "X" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionX );
          if ( scope.axis === "Y" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionY );
          if ( scope.axis === "Z" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionZ );

          scope.object.quaternion.copy( quaternionXYZ );

        } else if ( scope.space === "world" ) {

          rotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );
          offsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );

          tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

          if ( scope.rotationSnap !== null ) {

            quaternionX.setFromAxisAngle( unitX, Math.round( ( rotation.x - offsetRotation.x ) / scope.rotationSnap ) * scope.rotationSnap );
            quaternionY.setFromAxisAngle( unitY, Math.round( ( rotation.y - offsetRotation.y ) / scope.rotationSnap ) * scope.rotationSnap );
            quaternionZ.setFromAxisAngle( unitZ, Math.round( ( rotation.z - offsetRotation.z ) / scope.rotationSnap ) * scope.rotationSnap );

          } else {

            quaternionX.setFromAxisAngle( unitX, rotation.x - offsetRotation.x );
            quaternionY.setFromAxisAngle( unitY, rotation.y - offsetRotation.y );
            quaternionZ.setFromAxisAngle( unitZ, rotation.z - offsetRotation.z );

          }

          quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

          if ( scope.axis === "X" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
          if ( scope.axis === "Y" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
          if ( scope.axis === "Z" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );

          tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

          scope.object.quaternion.copy( tempQuaternion );

        }

      }

      scope.update();
      scope.dispatchEvent( changeEvent );
      scope.dispatchEvent( objectChangeEvent );

    }

    function onPointerUp( event ) {

      event.preventDefault(); // Prevent MouseEvent on mobile

      if ( event.button !== undefined && event.button !== 0 ) return;

      if ( _dragging && ( scope.axis !== null ) ) {

        mouseUpEvent.mode = _mode;
        scope.dispatchEvent( mouseUpEvent );

      }

      _dragging = false;

      if ( 'TouchEvent' in window && event instanceof TouchEvent ) {

        // Force "rollover"

        scope.axis = null;
        scope.update();
        scope.dispatchEvent( changeEvent );

      } else {

        onPointerHover( event );

      }

    }

    function intersectObjects( pointer, objects ) {

      var rect = domElement.getBoundingClientRect();
      var x = ( pointer.clientX - rect.left ) / rect.width;
      var y = ( pointer.clientY - rect.top ) / rect.height;

      pointerVector.set( ( x * 2 ) - 1, - ( y * 2 ) + 1 );
      ray.setFromCamera( pointerVector, camera );

      var intersections = ray.intersectObjects( objects, true );
      return intersections[ 0 ] ? intersections[ 0 ] : false;

    }

  };

  THREE.TransformControls.prototype = Object.create( THREE.Object3D.prototype );
  THREE.TransformControls.prototype.constructor = THREE.TransformControls;

}() );

/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;"undefined"!=typeof window?b=window:"undefined"!=typeof global?b=global:"undefined"!=typeof self&&(b=self),b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,f,g,h,i,j="",k=0;k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),e=a.charCodeAt(k++),f=b>>2,g=(3&b)<<4|c>>4,h=(15&c)<<2|e>>6,i=63&e,isNaN(c)?h=i=64:isNaN(e)&&(i=64),j=j+d.charAt(f)+d.charAt(g)+d.charAt(h)+d.charAt(i);return j},c.decode=function(a){var b,c,e,f,g,h,i,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)f=d.indexOf(a.charAt(k++)),g=d.indexOf(a.charAt(k++)),h=d.indexOf(a.charAt(k++)),i=d.indexOf(a.charAt(k++)),b=f<<2|g>>4,c=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(b),64!=h&&(j+=String.fromCharCode(c)),64!=i&&(j+=String.fromCharCode(e));return j}},{}],2:[function(a,b){"use strict";function c(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}c.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=c},{}],3:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":8}],4:[function(a,b){"use strict";var c=a("./utils"),d=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var e="string"!==c.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=e?a[i]:a.charCodeAt(i),g=255&(b^h),f=d[g],b=b>>>8^f;return-1^b}},{"./utils":21}],5:[function(a,b){"use strict";function c(){this.data=null,this.length=0,this.index=0}var d=a("./utils");c.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return d.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=c},{"./utils":21}],6:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.comment=null},{}],7:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":21}],8:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a){return e.deflateRaw(a)},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:24}],9:[function(a,b){"use strict";function c(a,b){return this instanceof c?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new c;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new c(a,b)}var d=a("./base64");c.prototype=a("./object"),c.prototype.load=a("./load"),c.support=a("./support"),c.defaults=a("./defaults"),c.utils=a("./deprecatedPublicUtils"),c.base64={encode:function(a){return d.encode(a)},decode:function(a){return d.decode(a)}},c.compressions=a("./compressions"),b.exports=c},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(a,b){"use strict";var c=a("./base64"),d=a("./zipEntries");b.exports=function(a,b){var e,f,g,h;for(b=b||{},b.base64&&(a=c.decode(a)),f=new d(a,b),e=f.files,g=0;g<e.length;g++)h=e[g],this.file(h.fileName,h.decompressed,{binary:!0,optimizedBinaryString:!0,date:h.date,dir:h.dir,comment:h.fileComment.length?h.fileComment:null,createFolders:b.createFolders});return f.zipComment.length&&(this.comment=f.zipComment),this}},{"./base64":1,"./zipEntries":22}],11:[function(a,b){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],12:[function(a,b){"use strict";function c(a){this.data=a,this.length=this.data.length,this.index=0}var d=a("./uint8ArrayReader");c.prototype=new d,c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./uint8ArrayReader":18}],13:[function(a,b){"use strict";var c=a("./support"),d=a("./utils"),e=a("./crc32"),f=a("./signature"),g=a("./defaults"),h=a("./base64"),i=a("./compressions"),j=a("./compressedObject"),k=a("./nodeBuffer"),l=a("./utf8"),m=a("./stringWriter"),n=a("./uint8ArrayWriter"),o=function(a){if(a._data instanceof j&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===d.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},p=function(a){var b=o(a),e=d.getTypeOf(b);return"string"===e?!a.options.binary&&c.nodebuffer?k(b,"utf-8"):a.asBinary():b},q=function(a){var b=o(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=h.decode(b)),b=a&&this.options.binary?A.utf8decode(b):d.transformTo("string",b),a||this.options.binary||(b=d.transformTo("string",A.utf8encode(b))),b)},r=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};r.prototype={asText:function(){return q.call(this,!0)},asBinary:function(){return q.call(this,!1)},asNodeBuffer:function(){var a=p(this);return d.transformTo("nodebuffer",a)},asUint8Array:function(){var a=p(this);return d.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var s=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},t=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=t(a,g),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var e,f=d.getTypeOf(b);if(c=u(c),c.createFolders&&(e=w(a))&&x.call(this,e,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=d.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof j))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=d.transformTo("uint8array",b))}var g=new r(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a,b){return"/"!=a.slice(-1)&&(a+="/"),b="undefined"!=typeof b?b:!1,this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},y=function(a,b){var c,f=new j;return a._data instanceof j?(f.uncompressedSize=a._data.uncompressedSize,f.crc32=a._data.crc32,0===f.uncompressedSize||a.dir?(b=i.STORE,f.compressedContent="",f.crc32=0):a._data.compressionMethod===b.magic?f.compressedContent=a._data.getCompressedContent():(c=a._data.getContent(),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c)))):(c=p(a),(!c||0===c.length||a.dir)&&(b=i.STORE,c=""),f.uncompressedSize=c.length,f.crc32=e(c),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c))),f.compressedSize=f.compressedContent.length,f.compressionMethod=b.magic,f},z=function(a,b,c,g){var h,i,j,k,m=(c.compressedContent,d.transformTo("string",l.utf8encode(b.name))),n=b.comment||"",o=d.transformTo("string",l.utf8encode(n)),p=m.length!==b.name.length,q=o.length!==n.length,r=b.options,t="",u="",v="";j=b._initialMetadata.dir!==b.dir?b.dir:r.dir,k=b._initialMetadata.date!==b.date?b.date:r.date,h=k.getHours(),h<<=6,h|=k.getMinutes(),h<<=5,h|=k.getSeconds()/2,i=k.getFullYear()-1980,i<<=4,i|=k.getMonth()+1,i<<=5,i|=k.getDate(),p&&(u=s(1,1)+s(e(m),4)+m,t+="up"+s(u.length,2)+u),q&&(v=s(1,1)+s(this.crc32(o),4)+o,t+="uc"+s(v.length,2)+v);var w="";w+="\n\x00",w+=p||q?"\x00\b":"\x00\x00",w+=c.compressionMethod,w+=s(h,2),w+=s(i,2),w+=s(c.crc32,4),w+=s(c.compressedSize,4),w+=s(c.uncompressedSize,4),w+=s(m.length,2),w+=s(t.length,2);var x=f.LOCAL_FILE_HEADER+w+m+t,y=f.CENTRAL_FILE_HEADER+"\x00"+w+s(o.length,2)+"\x00\x00\x00\x00"+(j===!0?"\x00\x00\x00":"\x00\x00\x00\x00")+s(g,4)+m+t+o;return{fileRecord:x,dirRecord:y,compressedObject:c}},A={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,e,f=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],e=new r(d.name,d._data,t(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,e)&&f.push(e));return f},file:function(a,b,c){if(1===arguments.length){if(d.isRegExp(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=x.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=t(a||{},{base64:!0,compression:"STORE",type:"base64",comment:null}),d.checkSupport(a.type);var b,c,e=[],g=0,j=0,k=d.transformTo("string",this.utf8encode(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var o=this.files[l],p=o.options.compression||a.compression.toUpperCase(),q=i[p];if(!q)throw new Error(p+" is not a valid compression method !");var r=y.call(this,o,q),u=z.call(this,l,o,r,g);g+=u.fileRecord.length+r.compressedSize,j+=u.dirRecord.length,e.push(u)}var v="";v=f.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+s(e.length,2)+s(e.length,2)+s(j,4)+s(g,4)+s(k.length,2)+k;var w=a.type.toLowerCase();for(b="uint8array"===w||"arraybuffer"===w||"blob"===w||"nodebuffer"===w?new n(g+j+v.length):new m(g+j+v.length),c=0;c<e.length;c++)b.append(e[c].fileRecord),b.append(e[c].compressedObject.compressedContent);for(c=0;c<e.length;c++)b.append(e[c].dirRecord);b.append(v);var x=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return d.transformTo(a.type.toLowerCase(),x);case"blob":return d.arrayBuffer2Blob(d.transformTo("arraybuffer",x));case"base64":return a.base64?h.encode(x):x;default:return x}},crc32:function(a,b){return e(a,b)},utf8encode:function(a){return d.transformTo("string",l.utf8encode(a))},utf8decode:function(a){return l.utf8decode(a)}};b.exports=A},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],15:[function(a,b){"use strict";function c(a,b){this.data=a,b||(this.data=e.string2binary(this.data)),this.length=this.data.length,this.index=0}var d=a("./dataReader"),e=a("./utils");c.prototype=new d,c.prototype.byteAt=function(a){return this.data.charCodeAt(a)},c.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5,"./utils":21}],16:[function(a,b){"use strict";var c=a("./utils"),d=function(){this.data=[]};d.prototype={append:function(a){a=c.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=d},{"./utils":21}],17:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],18:[function(a,b){"use strict";function c(a){a&&(this.data=a,this.length=this.data.length,this.index=0)}var d=a("./dataReader");c.prototype=new d,c.prototype.byteAt=function(a){return this.data[a]},c.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f;return-1},c.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5}],19:[function(a,b){"use strict";var c=a("./utils"),d=function(a){this.data=new Uint8Array(a),this.index=0};d.prototype={append:function(a){0!==a.length&&(a=c.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=d},{"./utils":21}],20:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;h>b;)if(e=a[b++],128>e)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&h>b;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:65536>e?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;f>c;){var h=j(a,Math.min(c+g,f));b.push(e.uint8array?k(a.subarray(c,h)):k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{d.push("array"===f||"nodebuffer"===f?String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e))):String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a){c.checkSupport("blob");try{return new Blob([a],{type:"application/zip"})}catch(b){try{var d=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,e=new d;return e.append(a),e.getBlob("application/zip")}catch(b){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(a,b){"use strict";function c(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var d=a("./stringReader"),e=a("./nodeBufferReader"),f=a("./uint8ArrayReader"),g=a("./utils"),h=a("./signature"),i=a("./zipEntry"),j=a("./support"),k=a("./object");c.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+g.pretty(b)+", expected "+g.pretty(a)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength),this.zipComment=k.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(h.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===h.CENTRAL_FILE_HEADER;)a=new i({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if(-1===a)throw new Error("Corrupted zip : can't find end of central directory");if(this.reader.setIndex(a),this.checkSignature(h.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===g.MAX_VALUE_16BITS||this.diskWithCentralDirStart===g.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===g.MAX_VALUE_16BITS||this.centralDirRecords===g.MAX_VALUE_16BITS||this.centralDirSize===g.MAX_VALUE_32BITS||this.centralDirOffset===g.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),-1===a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(a){var b=g.getTypeOf(a);this.reader="string"!==b||j.uint8array?"nodebuffer"===b?new e(a):new f(g.transformTo("uint8array",a)):new d(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=c},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(a,b){"use strict";function c(a,b){this.options=a,this.loadOptions=b}var d=a("./stringReader"),e=a("./utils"),f=a("./compressedObject"),g=a("./object");c.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,f){return function(){var a=e.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==f)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readString(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=e.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+e.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new f,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=e.transformTo("string",this.decompressed.getContent()),g.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readString(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readString(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readString(this.fileCommentLength),this.dir=16&this.externalFileAttributes?!0:!1},parseZIP64ExtraField:function(){if(this.extraFields[1]){var a=new d(this.extraFields[1].value);this.uncompressedSize===e.MAX_VALUE_32BITS&&(this.uncompressedSize=a.readInt(8)),this.compressedSize===e.MAX_VALUE_32BITS&&(this.compressedSize=a.readInt(8)),this.localHeaderOffset===e.MAX_VALUE_32BITS&&(this.localHeaderOffset=a.readInt(8)),this.diskNumberStart===e.MAX_VALUE_32BITS&&(this.diskNumberStart=a.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){if(this.useUTF8())this.fileName=g.utf8decode(this.fileName),this.fileComment=g.utf8decode(this.fileComment);else{var a=this.findExtraFieldUnicodePath();null!==a&&(this.fileName=a);var b=this.findExtraFieldUnicodeComment();null!==b&&(this.fileComment=b)}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileName)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileComment)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null}},b.exports=c},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(a,b){"use strict";var c=a("./lib/utils/common").assign,d=a("./lib/deflate"),e=a("./lib/inflate"),f=a("./lib/zlib/constants"),g={};c(g,d,e,f),b.exports=g},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(a,b,c){"use strict";function d(a,b){var c=new s(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}function f(a,b){return b=b||{},b.gzip=!0,d(a,b)}var g=a("./zlib/deflate.js"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=0,m=4,n=0,o=1,p=-1,q=0,r=8,s=function(a){this.options=h.assign({level:p,method:r,chunkSize:16384,windowBits:15,memLevel:8,strategy:q,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=g.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==n)throw new Error(j[c]);b.header&&g.deflateSetHeader(this.strm,b.header)
};s.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?m:l,e.input="string"==typeof a?i.string2buf(a):a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new h.Buf8(f),e.next_out=0,e.avail_out=f),c=g.deflate(e,d),c!==o&&c!==n)return this.onEnd(c),this.ended=!0,!1;(0===e.avail_out||0===e.avail_in&&d===m)&&this.onData("string"===this.options.to?i.buf2binstring(h.shrinkBuf(e.output,e.next_out)):h.shrinkBuf(e.output,e.next_out))}while((e.avail_in>0||0===e.avail_out)&&c!==o);return d===m?(c=g.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===n):!0},s.prototype.onData=function(a){this.chunks.push(a)},s.prototype.onEnd=function(a){a===n&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=s,c.deflate=d,c.deflateRaw=e,c.gzip=f},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(a,b,c){"use strict";function d(a,b){var c=new m(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}var f=a("./zlib/inflate.js"),g=a("./utils/common"),h=a("./utils/strings"),i=a("./zlib/constants"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=a("./zlib/gzheader"),m=function(a){this.options=g.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=f.inflateInit2(this.strm,b.windowBits);if(c!==i.Z_OK)throw new Error(j[c]);this.header=new l,f.inflateGetHeader(this.strm,this.header)};m.prototype.push=function(a,b){var c,d,e,j,k,l=this.strm,m=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?i.Z_FINISH:i.Z_NO_FLUSH,l.input="string"==typeof a?h.binstring2buf(a):a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new g.Buf8(m),l.next_out=0,l.avail_out=m),c=f.inflate(l,i.Z_NO_FLUSH),c!==i.Z_STREAM_END&&c!==i.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0===l.avail_out||c===i.Z_STREAM_END||0===l.avail_in&&d===i.Z_FINISH)&&("string"===this.options.to?(e=h.utf8border(l.output,l.next_out),j=l.next_out-e,k=h.buf2string(l.output,e),l.next_out=j,l.avail_out=m-j,j&&g.arraySet(l.output,l.output,e,j,0),this.onData(k)):this.onData(g.shrinkBuf(l.output,l.next_out)))}while(l.avail_in>0&&c!==i.Z_STREAM_END);return c===i.Z_STREAM_END&&(d=i.Z_FINISH),d===i.Z_FINISH?(c=f.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===i.Z_OK):!0},m.prototype.onData=function(a){this.chunks.push(a)},m.prototype.onEnd=function(a){a===i.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):g.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=m,c.inflate=d,c.inflateRaw=e,c.ungzip=d},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],28:[function(a,b,c){"use strict";function d(a,b){if(65537>b&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;b>d;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;256>j;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new e.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;d>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;h>c;)if(f=a[c++],128>f)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&h>c;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:65536>f?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":27}],29:[function(a,b){"use strict";function c(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=c},{}],30:[function(a,b){b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(a,b){"use strict";function c(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function d(a,b,c,d){var f=e,g=d+c;a=-1^a;for(var h=d;g>h;h++)a=a>>>8^f[255&(a^b[h])];return-1^a}var e=c();b.exports=d},{}],32:[function(a,b,c){"use strict";function d(a,b){return a.msg=G[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(C.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){D._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,C.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=E(a.adler,b,e,c):2===a.state.wrap&&(a.adler=F(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-jb?a.strstart-(a.w_size-jb):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ib,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ib-(m-f),f=m-ib,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-jb)){C.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=hb)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+hb-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<hb)););}while(a.lookahead<jb&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===H)return sb;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return sb;if(a.strstart-a.block_start>=a.w_size-jb&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?sb:sb}function o(a,b){for(var c,d;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c)),a.match_length>=hb)if(d=D._tr_tally(a,a.strstart-a.match_start,a.match_length-hb),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=hb){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function p(a,b){for(var c,d,e;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=hb-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===S||a.match_length===hb&&a.strstart-a.match_start>4096)&&(a.match_length=hb-1)),a.prev_length>=hb&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-hb,d=D._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-hb),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=hb-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return sb}else if(a.match_available){if(d=D._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return sb}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=D._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ib){if(m(a),a.lookahead<=ib&&b===H)return sb;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=hb&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ib;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ib-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=hb?(c=D._tr_tally(a,1,a.match_length-hb),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===H)return sb;break}if(a.match_length=0,c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function s(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=B[a.level].max_lazy,a.good_match=B[a.level].good_length,a.nice_match=B[a.level].nice_length,a.max_chain_length=B[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=hb-1,a.match_available=0,a.ins_h=0}function t(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new C.Buf16(2*fb),this.dyn_dtree=new C.Buf16(2*(2*db+1)),this.bl_tree=new C.Buf16(2*(2*eb+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new C.Buf16(gb+1),this.heap=new C.Buf16(2*cb+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new C.Buf16(2*cb+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function u(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=X,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?lb:qb,a.adler=2===b.wrap?0:1,b.last_flush=H,D._tr_init(b),M):d(a,O)}function v(a){var b=u(a);return b===M&&s(a.state),b}function w(a,b){return a&&a.state?2!==a.state.wrap?O:(a.state.gzhead=b,M):O}function x(a,b,c,e,f,g){if(!a)return O;var h=1;if(b===R&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>Z||c!==Y||8>e||e>15||0>b||b>9||0>g||g>V)return d(a,O);8===e&&(e=9);var i=new t;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+hb-1)/hb),i.window=new C.Buf8(2*i.w_size),i.head=new C.Buf16(i.hash_size),i.prev=new C.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new C.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,v(a)}function y(a,b){return x(a,b,Y,$,_,W)}function z(a,b){var c,h,k,l;if(!a||!a.state||b>L||0>b)return a?d(a,O):O;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===rb&&b!==K)return d(a,0===a.avail_out?Q:O);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===lb)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=F(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=mb):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,wb),h.status=qb);else{var m=Y+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=T||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=kb),m+=31-m%31,h.status=qb,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===mb)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=nb)}else h.status=nb;if(h.status===nb)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=ob)}else h.status=ob;if(h.status===ob)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=pb)}else h.status=pb;if(h.status===pb&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=qb)):h.status=qb),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,M}else if(0===a.avail_in&&e(b)<=e(c)&&b!==K)return d(a,Q);if(h.status===rb&&0!==a.avail_in)return d(a,Q);if(0!==a.avail_in||0!==h.lookahead||b!==H&&h.status!==rb){var o=h.strategy===T?r(h,b):h.strategy===U?q(h,b):B[h.level].func(h,b);if((o===ub||o===vb)&&(h.status=rb),o===sb||o===ub)return 0===a.avail_out&&(h.last_flush=-1),M;if(o===tb&&(b===I?D._tr_align(h):b!==L&&(D._tr_stored_block(h,0,0,!1),b===J&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,M}return b!==K?M:h.wrap<=0?N:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?M:N)}function A(a){var b;return a&&a.state?(b=a.state.status,b!==lb&&b!==mb&&b!==nb&&b!==ob&&b!==pb&&b!==qb&&b!==rb?d(a,O):(a.state=null,b===qb?d(a,P):M)):O}var B,C=a("../utils/common"),D=a("./trees"),E=a("./adler32"),F=a("./crc32"),G=a("./messages"),H=0,I=1,J=3,K=4,L=5,M=0,N=1,O=-2,P=-3,Q=-5,R=-1,S=1,T=2,U=3,V=4,W=0,X=2,Y=8,Z=9,$=15,_=8,ab=29,bb=256,cb=bb+1+ab,db=30,eb=19,fb=2*cb+1,gb=15,hb=3,ib=258,jb=ib+hb+1,kb=32,lb=42,mb=69,nb=73,ob=91,pb=103,qb=113,rb=666,sb=1,tb=2,ub=3,vb=4,wb=3,xb=function(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e};B=[new xb(0,0,0,0,n),new xb(4,4,8,4,o),new xb(4,5,16,8,o),new xb(4,6,32,32,o),new xb(4,4,16,16,p),new xb(8,16,32,32,p),new xb(8,16,128,128,p),new xb(8,32,128,256,p),new xb(32,128,258,1024,p),new xb(32,258,258,4096,p)],c.deflateInit=y,c.deflateInit2=x,c.deflateReset=v,c.deflateResetKeep=u,c.deflateSetHeader=w,c.deflate=z,c.deflateEnd=A,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(a,b){"use strict";function c(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=c},{}],34:[function(a,b){"use strict";var c=30,d=12;b.exports=function(a,b){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;e=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=e.dmax,l=e.wsize,m=e.whave,n=e.wnext,o=e.window,p=e.hold,q=e.bits,r=e.lencode,s=e.distcode,t=(1<<e.lenbits)-1,u=(1<<e.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){e.mode=d;break a}a.msg="invalid literal/length code",e.mode=c;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",e.mode=c;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",e.mode=c;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&e.sane){a.msg="invalid distance too far back",e.mode=c;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),e.hold=p,e.bits=q}},{}],35:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(ob),b.distcode=b.distdyn=new r.Buf32(pb),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,rb)}function k(a){if(sb){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sb=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,ob,pb,qb,rb,sb,tb,ub,vb,wb,xb,yb,zb,Ab=0,Bb=new r.Buf8(4),Cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xb=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=lb;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=lb;break}if(m>>>=4,n-=4,wb=(15&m)+8,0===c.wbits)c.wbits=wb;else if(wb>c.wbits){a.msg="invalid window size",c.mode=lb;break}c.dmax=1<<wb,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=lb;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=lb;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,Bb[2]=m>>>16&255,Bb[3]=m>>>24&255,c.check=t(c.check,Bb,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wb=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wb)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.name+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.comment+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=lb;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ib;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=bb,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=lb}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=lb;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=lb;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Cb[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Cb[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,yb={bits:c.lenbits},xb=v(w,c.lens,0,19,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid code lengths set",c.mode=lb;break}c.have=0,c.mode=ab;case ab:for(;c.have<c.nlen+c.ndist;){for(;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sb)m>>>=qb,n-=qb,c.lens[c.have++]=sb;else{if(16===sb){for(zb=qb+2;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qb,n-=qb,0===c.have){a.msg="invalid bit length repeat",c.mode=lb;break}wb=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sb){for(zb=qb+3;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=3+(7&m),m>>>=3,n-=3}else{for(zb=qb+7;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=lb;break}for(;q--;)c.lens[c.have++]=wb}}if(c.mode===lb)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=lb;break}if(c.lenbits=9,yb={bits:c.lenbits},xb=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid literal/lengths set",c.mode=lb;break}if(c.distbits=6,c.distcode=c.distdyn,yb={bits:c.distbits},xb=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,yb),c.distbits=yb.bits,xb){a.msg="invalid distances set",c.mode=lb;break}if(c.mode=bb,b===B)break a;case bb:c.mode=cb;case cb:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);break}for(c.back=0;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(rb&&0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.lencode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,c.length=sb,0===rb){c.mode=hb;break}if(32&rb){c.back=-1,c.mode=V;break}if(64&rb){a.msg="invalid literal/length code",c.mode=lb;break}c.extra=15&rb,c.mode=db;case db:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=eb;case eb:for(;Ab=c.distcode[m&(1<<c.distbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.distcode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,64&rb){a.msg="invalid distance code",c.mode=lb;break}c.offset=sb,c.extra=15&rb,c.mode=fb;case fb:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=lb;break}c.mode=gb;case gb:if(0===j)break a;
if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=lb;break}q>c.wnext?(q-=c.wnext,ob=c.wsize-q):ob=c.wnext-q,q>c.length&&(q=c.length),pb=c.window}else pb=f,ob=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pb[ob++];while(--q);0===c.length&&(c.mode=cb);break;case hb:if(0===j)break a;f[h++]=c.length,j--,c.mode=cb;break;case ib:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=lb;break}m=0,n=0}c.mode=jb;case jb:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=lb;break}m=0,n=0}c.mode=kb;case kb:xb=D;break a;case lb:xb=G;break a;case mb:return H;case nb:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<lb&&(c.mode<ib||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=mb,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===bb||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xb===C&&(xb=I),xb)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,ab=19,bb=20,cb=21,db=22,eb=23,fb=24,gb=25,hb=26,ib=27,jb=28,kb=29,lb=30,mb=31,nb=32,ob=852,pb=592,qb=15,rb=qb,sb=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(a,b){"use strict";var c=a("../utils/common"),d=15,e=852,f=592,g=0,h=1,i=2,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],k=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],m=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,n,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new c.Buf16(d+1),Q=new c.Buf16(d+1),R=null,S=0;for(D=0;d>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[n+E]]++;for(H=C,G=d;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;d>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===g||1!==G))return-1;for(Q[1]=0,D=1;d>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[n+E]&&(r[Q[b[n+E]]++]=E);if(a===g?(N=R=r,y=19):a===h?(N=j,O-=257,R=k,S-=257,y=256):(N=l,R=m,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===h&&L>e||a===i&&L>f)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[n+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===h&&L>e||a===i&&L>f)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":27}],37:[function(a,b){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a){return 256>a?gb[a]:gb[256+(a>>>7)]}function f(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function g(a,b,c){a.bi_valid>V-c?(a.bi_buf|=b<<a.bi_valid&65535,f(a,a.bi_buf),a.bi_buf=b>>V-a.bi_valid,a.bi_valid+=c-V):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function h(a,b,c){g(a,c[2*b],c[2*b+1])}function i(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function j(a){16===a.bi_valid?(f(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function k(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;U>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;T>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function l(a,b,c){var d,e,f=new Array(U+1),g=0;for(d=1;U>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=i(f[h]++,h))}}function m(){var a,b,c,d,e,f=new Array(U+1);for(c=0,d=0;O-1>d;d++)for(ib[d]=c,a=0;a<1<<_[d];a++)hb[c++]=d;for(hb[c-1]=d,e=0,d=0;16>d;d++)for(jb[d]=e,a=0;a<1<<ab[d];a++)gb[e++]=d;for(e>>=7;R>d;d++)for(jb[d]=e<<7,a=0;a<1<<ab[d]-7;a++)gb[256+e++]=d;for(b=0;U>=b;b++)f[b]=0;for(a=0;143>=a;)eb[2*a+1]=8,a++,f[8]++;for(;255>=a;)eb[2*a+1]=9,a++,f[9]++;for(;279>=a;)eb[2*a+1]=7,a++,f[7]++;for(;287>=a;)eb[2*a+1]=8,a++,f[8]++;for(l(eb,Q+1,f),a=0;R>a;a++)fb[2*a+1]=5,fb[2*a]=i(a,5);kb=new nb(eb,_,P+1,Q,U),lb=new nb(fb,ab,0,R,U),mb=new nb(new Array(0),bb,0,S,W)}function n(a){var b;for(b=0;Q>b;b++)a.dyn_ltree[2*b]=0;for(b=0;R>b;b++)a.dyn_dtree[2*b]=0;for(b=0;S>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*X]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function o(a){a.bi_valid>8?f(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function p(a,b,c,d){o(a),d&&(f(a,c),f(a,~c)),E.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function q(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function r(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&q(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!q(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function s(a,b,c){var d,f,i,j,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],f=a.pending_buf[a.l_buf+k],k++,0===d?h(a,f,b):(i=hb[f],h(a,i+P+1,b),j=_[i],0!==j&&(f-=ib[i],g(a,f,j)),d--,i=e(d),h(a,i,c),j=ab[i],0!==j&&(d-=jb[i],g(a,d,j)));while(k<a.last_lit);h(a,X,b)}function t(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=T,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)r(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],r(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,r(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],k(a,b),l(f,j,a.bl_count)}function u(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*Y]++):10>=h?a.bl_tree[2*Z]++:a.bl_tree[2*$]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function v(a,b,c){var d,e,f=-1,i=b[1],j=0,k=7,l=4;for(0===i&&(k=138,l=3),d=0;c>=d;d++)if(e=i,i=b[2*(d+1)+1],!(++j<k&&e===i)){if(l>j){do h(a,e,a.bl_tree);while(0!==--j)}else 0!==e?(e!==f&&(h(a,e,a.bl_tree),j--),h(a,Y,a.bl_tree),g(a,j-3,2)):10>=j?(h(a,Z,a.bl_tree),g(a,j-3,3)):(h(a,$,a.bl_tree),g(a,j-11,7));j=0,f=e,0===i?(k=138,l=3):e===i?(k=6,l=3):(k=7,l=4)}}function w(a){var b;for(u(a,a.dyn_ltree,a.l_desc.max_code),u(a,a.dyn_dtree,a.d_desc.max_code),t(a,a.bl_desc),b=S-1;b>=3&&0===a.bl_tree[2*cb[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function x(a,b,c,d){var e;for(g(a,b-257,5),g(a,c-1,5),g(a,d-4,4),e=0;d>e;e++)g(a,a.bl_tree[2*cb[e]+1],3);v(a,a.dyn_ltree,b-1),v(a,a.dyn_dtree,c-1)}function y(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return G;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return H;for(b=32;P>b;b++)if(0!==a.dyn_ltree[2*b])return H;return G}function z(a){pb||(m(),pb=!0),a.l_desc=new ob(a.dyn_ltree,kb),a.d_desc=new ob(a.dyn_dtree,lb),a.bl_desc=new ob(a.bl_tree,mb),a.bi_buf=0,a.bi_valid=0,n(a)}function A(a,b,c,d){g(a,(J<<1)+(d?1:0),3),p(a,b,c,!0)}function B(a){g(a,K<<1,3),h(a,X,eb),j(a)}function C(a,b,c,d){var e,f,h=0;a.level>0?(a.strm.data_type===I&&(a.strm.data_type=y(a)),t(a,a.l_desc),t(a,a.d_desc),h=w(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?A(a,b,c,d):a.strategy===F||f===e?(g(a,(K<<1)+(d?1:0),3),s(a,eb,fb)):(g(a,(L<<1)+(d?1:0),3),x(a,a.l_desc.max_code+1,a.d_desc.max_code+1,h+1),s(a,a.dyn_ltree,a.dyn_dtree)),n(a),d&&o(a)}function D(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(hb[c]+P+1)]++,a.dyn_dtree[2*e(b)]++),a.last_lit===a.lit_bufsize-1}var E=a("../utils/common"),F=4,G=0,H=1,I=2,J=0,K=1,L=2,M=3,N=258,O=29,P=256,Q=P+1+O,R=30,S=19,T=2*Q+1,U=15,V=16,W=7,X=256,Y=16,Z=17,$=18,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],bb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],db=512,eb=new Array(2*(Q+2));d(eb);var fb=new Array(2*R);d(fb);var gb=new Array(db);d(gb);var hb=new Array(N-M+1);d(hb);var ib=new Array(O);d(ib);var jb=new Array(R);d(jb);var kb,lb,mb,nb=function(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length},ob=function(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b},pb=!1;c._tr_init=z,c._tr_stored_block=A,c._tr_flush_block=C,c._tr_tally=D,c._tr_align=B},{"../utils/common":27}],39:[function(a,b){"use strict";function c(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=c},{}]},{},[9])(9)});
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';var m=this;function q(c,d){var a=c.split("."),b=m;!(a[0]in b)&&b.execScript&&b.execScript("var "+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&void 0!==d?b[e]=d:b=b[e]?b[e]:b[e]={}};var s="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function t(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,l,p,n,r,K;for(n=0;n<d;++n)c[n]>a&&(a=c[n]),c[n]<b&&(b=c[n]);e=1<<a;f=new (s?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(n=0;n<d;++n)if(c[n]===g){l=0;p=h;for(r=0;r<g;++r)l=l<<1|p&1,p>>=1;K=g<<16|n;for(r=l;r<e;r+=k)f[r]=K;++h}++g;h<<=1;k<<=1}return[f,a,b]};function u(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=s?new Uint8Array(c):c;this.m=!1;this.i=v;this.s=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.s=d.resize);switch(this.i){case w:this.b=32768;this.c=new (s?Uint8Array:Array)(32768+this.h+258);break;case v:this.b=0;this.c=new (s?Uint8Array:Array)(this.h);this.e=this.A;this.n=this.w;this.j=this.z;break;default:throw Error("invalid inflate mode");
}}var w=0,v=1,x={u:w,t:v};
u.prototype.k=function(){for(;!this.m;){var c=y(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=void 0,h=void 0,k=b.length,l=void 0;this.d=this.f=0;if(a+1>=f)throw Error("invalid uncompressed block header: LEN");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error("invalid uncompressed block header: NLEN");h=d[a++]|d[a++]<<8;if(g===~h)throw Error("invalid uncompressed block header: length verify");if(a+g>d.length)throw Error("input buffer is broken");switch(this.i){case w:for(;e+
g>b.length;){l=k-e;g-=l;if(s)b.set(d.subarray(a,a+l),e),e+=l,a+=l;else for(;l--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case v:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error("invalid inflate mode");}if(s)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(z,A);break;case 2:B(this);break;default:throw Error("unknown BTYPE: "+c);}}return this.n()};
var C=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=s?new Uint16Array(C):C,E=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],F=s?new Uint16Array(E):E,G=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],H=s?new Uint8Array(G):G,I=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],J=s?new Uint16Array(I):I,L=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,
13],M=s?new Uint8Array(L):L,N=new (s?Uint8Array:Array)(288),O,P;O=0;for(P=N.length;O<P;++O)N[O]=143>=O?8:255>=O?9:279>=O?7:8;var z=t(N),Q=new (s?Uint8Array:Array)(30),R,S;R=0;for(S=Q.length;R<S;++R)Q[R]=5;var A=t(Q);function y(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error("input buffer is broken");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}
function T(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],l,p;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;l=h[a&(1<<k)-1];p=l>>>16;c.f=a>>p;c.d=b-p;c.a=f;return l&65535}
function B(c){function d(a,c,b){var d,e=this.q,f,g;for(g=0;g<a;)switch(d=T(this,c),d){case 16:for(f=3+y(this,2);f--;)b[g++]=e;break;case 17:for(f=3+y(this,3);f--;)b[g++]=0;e=0;break;case 18:for(f=11+y(this,7);f--;)b[g++]=0;e=0;break;default:e=b[g++]=d}this.q=e;return b}var a=y(c,5)+257,b=y(c,5)+1,e=y(c,4)+4,f=new (s?Uint8Array:Array)(D.length),g,h,k,l;for(l=0;l<e;++l)f[D[l]]=y(c,3);if(!s){l=e;for(e=f.length;l<e;++l)f[D[l]]=0}g=t(f);h=new (s?Uint8Array:Array)(a);k=new (s?Uint8Array:Array)(b);c.q=0;
c.j(t(d.call(c,a,g,h)),t(d.call(c,b,g,k)))}u.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=T(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=F[g];0<H[g]&&(k+=y(this,H[g]));f=T(this,d);h=J[f];0<M[f]&&(h+=y(this,M[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
u.prototype.z=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=T(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=F[g];0<H[g]&&(k+=y(this,H[g]));f=T(this,d);h=J[f];0<M[f]&&(h+=y(this,M[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
u.prototype.e=function(){var c=new (s?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(s)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(s)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};
u.prototype.A=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&("number"===typeof c.p&&(a=c.p),"number"===typeof c.v&&(a+=c.v));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;s?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};
u.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (s?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return s?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};
u.prototype.w=function(){var c,d=this.b;s?this.s?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function U(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.B=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case V:this.method=V;break;default:throw Error("unsupported compression method");}if(0!==((a<<8)+b)%31)throw Error("invalid fcheck flag:"+((a<<8)+b)%31);if(b&32)throw Error("fdict flag is not supported");this.r=new u(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}
U.prototype.k=function(){var c=this.input,d,a;d=this.r.k();this.a=this.r.a;if(this.B){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if("string"===typeof b){var e=b.split(""),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,l=b.length,p,n=0;0<l;){p=1024<l?1024:l;l-=p;do h+=b[n++],k+=h;while(--p);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error("invalid adler-32 checksum");}return d};var V=8;q("Zlib.Inflate",U);q("Zlib.Inflate.prototype.decompress",U.prototype.k);var W={ADAPTIVE:x.t,BLOCK:x.u},X,Y,Z,$;if(Object.keys)X=Object.keys(W);else for(Y in X=[],Z=0,W)X[Z++]=Y;Z=0;for($=X.length;Z<$;++Z)Y=X[Z],q("Zlib.Inflate.BufferType."+Y,W[Y]);}).call(this);

/*
 * @author tamarintech / https://tamarintech.com
 *
 * Description: Early release of an AMF Loader following the pattern of the
 * example loaders in the three.js project.
 *
 * More information about the AMF format: http://amf.wikispaces.com
 *
 * Usage:
 *  var loader = new AMFLoader();
 *  loader.load('/path/to/project.amf', function(objecttree) {
 *    scene.add(objecttree);
 *  });
 *
 * Materials now supported, material colors supported
 * Zip support, requires jszip
 * TextDecoder polyfill required by some browsers (particularly IE, Edge)
 * No constellation support (yet)!
 *
 */

THREE.AMFLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.AMFLoader.prototype = {

  constructor: THREE.AMFLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  parse: function ( data ) {

    function loadDocument( data ) {

      var view = new DataView( data );
      var magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );

      if ( magic === 'PK' ) {

        var zip = null;
        var file = null;

        console.log( 'THREE.AMFLoader: Loading Zip' );

        try {

          zip = new JSZip( data ); // eslint-disable-line no-undef

        } catch ( e ) {

          if ( e instanceof ReferenceError ) {

            console.log( 'THREE.AMFLoader: jszip missing and file is compressed.' );
            return null;

          }

        }

        for ( file in zip.files ) {

          if ( file.toLowerCase().substr( - 4 ) === '.amf' ) {

            break;

          }

        }

        console.log( 'THREE.AMFLoader: Trying to load file asset: ' + file );
        view = new DataView( zip.file( file ).asArrayBuffer() );

      }

      if ( window.TextDecoder === undefined ) {

        console.log( 'THREE.AMFLoader: TextDecoder not present. Please use TextDecoder polyfill.' );
        return null;

      }

      var fileText = new TextDecoder( 'utf-8' ).decode( view );
      var xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );

      if ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {

        console.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' );
        return null;

      }

      return xmlData;

    }

    function loadDocumentScale( node ) {

      var scale = 1.0;
      var unit = 'millimeter';

      if ( node.documentElement.attributes.unit !== undefined ) {

        unit = node.documentElement.attributes.unit.value.toLowerCase();

      }

      var scaleUnits = {
        millimeter: 1.0,
        inch: 25.4,
        feet: 304.8,
        meter: 1000.0,
        micron: 0.001
      };

      if ( scaleUnits[ unit ] !== undefined ) {

        scale = scaleUnits[ unit ];

      }

      console.log( 'THREE.AMFLoader: Unit scale: ' + scale );
      return scale;

    }

    function loadMaterials( node ) {

      var matName = 'AMF Material';
      var matId = node.attributes.id.textContent;
      var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

      var loadedMaterial = null;

      for ( var i = 0; i < node.childNodes.length; i ++ ) {

        var matChildEl = node.childNodes[ i ];

        if ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {

          if ( matChildEl.attributes.type.value === 'name' ) {

            matName = matChildEl.textContent;

          }

        } else if ( matChildEl.nodeName === 'color' ) {

          color = loadColor( matChildEl );

        }

      }

      loadedMaterial = new THREE.MeshPhongMaterial( {
        flatShading: true,
        color: new THREE.Color( color.r, color.g, color.b ),
        name: matName
      } );

      if ( color.a !== 1.0 ) {

        loadedMaterial.transparent = true;
        loadedMaterial.opacity = color.a;

      }

      return { id: matId, material: loadedMaterial };

    }

    function loadColor( node ) {

      var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

      for ( var i = 0; i < node.childNodes.length; i ++ ) {

        var matColor = node.childNodes[ i ];

        if ( matColor.nodeName === 'r' ) {

          color.r = matColor.textContent;

        } else if ( matColor.nodeName === 'g' ) {

          color.g = matColor.textContent;

        } else if ( matColor.nodeName === 'b' ) {

          color.b = matColor.textContent;

        } else if ( matColor.nodeName === 'a' ) {

          color.a = matColor.textContent;

        }

      }

      return color;

    }

    function loadMeshVolume( node ) {

      var volume = { name: '', triangles: [], materialid: null };

      var currVolumeNode = node.firstElementChild;

      if ( node.attributes.materialid !== undefined ) {

        volume.materialId = node.attributes.materialid.nodeValue;

      }

      while ( currVolumeNode ) {

        if ( currVolumeNode.nodeName === 'metadata' ) {

          if ( currVolumeNode.attributes.type !== undefined ) {

            if ( currVolumeNode.attributes.type.value === 'name' ) {

              volume.name = currVolumeNode.textContent;

            }

          }

        } else if ( currVolumeNode.nodeName === 'triangle' ) {

          var v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;
          var v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;
          var v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;

          volume.triangles.push( v1, v2, v3 );

        }

        currVolumeNode = currVolumeNode.nextElementSibling;

      }

      return volume;

    }

    function loadMeshVertices( node ) {

      var vertArray = [];
      var normalArray = [];
      var currVerticesNode = node.firstElementChild;

      while ( currVerticesNode ) {

        if ( currVerticesNode.nodeName === 'vertex' ) {

          var vNode = currVerticesNode.firstElementChild;

          while ( vNode ) {

            if ( vNode.nodeName === 'coordinates' ) {

              var x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;
              var y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;
              var z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;

              vertArray.push( x, y, z );

            } else if ( vNode.nodeName === 'normal' ) {

              var nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;
              var ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;
              var nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;

              normalArray.push( nx, ny, nz );

            }

            vNode = vNode.nextElementSibling;

          }

        }
        currVerticesNode = currVerticesNode.nextElementSibling;

      }

      return { 'vertices': vertArray, 'normals': normalArray };

    }

    function loadObject( node ) {

      var objId = node.attributes.id.textContent;
      var loadedObject = { name: 'amfobject', meshes: [] };
      var currColor = null;
      var currObjNode = node.firstElementChild;

      while ( currObjNode ) {

        if ( currObjNode.nodeName === 'metadata' ) {

          if ( currObjNode.attributes.type !== undefined ) {

            if ( currObjNode.attributes.type.value === 'name' ) {

              loadedObject.name = currObjNode.textContent;

            }

          }

        } else if ( currObjNode.nodeName === 'color' ) {

          currColor = loadColor( currObjNode );

        } else if ( currObjNode.nodeName === 'mesh' ) {

          var currMeshNode = currObjNode.firstElementChild;
          var mesh = { vertices: [], normals: [], volumes: [], color: currColor };

          while ( currMeshNode ) {

            if ( currMeshNode.nodeName === 'vertices' ) {

              var loadedVertices = loadMeshVertices( currMeshNode );

              mesh.normals = mesh.normals.concat( loadedVertices.normals );
              mesh.vertices = mesh.vertices.concat( loadedVertices.vertices );

            } else if ( currMeshNode.nodeName === 'volume' ) {

              mesh.volumes.push( loadMeshVolume( currMeshNode ) );

            }

            currMeshNode = currMeshNode.nextElementSibling;

          }

          loadedObject.meshes.push( mesh );

        }

        currObjNode = currObjNode.nextElementSibling;

      }

      return { 'id': objId, 'obj': loadedObject };

    }

    var xmlData = loadDocument( data );
    var amfName = '';
    var amfAuthor = '';
    var amfScale = loadDocumentScale( xmlData );
    var amfMaterials = {};
    var amfObjects = {};
    var childNodes = xmlData.documentElement.childNodes;

    var i, j;

    for ( i = 0; i < childNodes.length; i ++ ) {

      var child = childNodes[ i ];

      if ( child.nodeName === 'metadata' ) {

        if ( child.attributes.type !== undefined ) {

          if ( child.attributes.type.value === 'name' ) {

            amfName = child.textContent;

          } else if ( child.attributes.type.value === 'author' ) {

            amfAuthor = child.textContent;

          }

        }

      } else if ( child.nodeName === 'material' ) {

        var loadedMaterial = loadMaterials( child );

        amfMaterials[ loadedMaterial.id ] = loadedMaterial.material;

      } else if ( child.nodeName === 'object' ) {

        var loadedObject = loadObject( child );

        amfObjects[ loadedObject.id ] = loadedObject.obj;

      }

    }

    var sceneObject = new THREE.Group();
    var defaultMaterial = new THREE.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );

    sceneObject.name = amfName;
    sceneObject.userData.author = amfAuthor;
    sceneObject.userData.loader = 'AMF';

    for ( var id in amfObjects ) {

      var part = amfObjects[ id ];
      var meshes = part.meshes;
      var newObject = new THREE.Group();
      newObject.name = part.name || '';

      for ( i = 0; i < meshes.length; i ++ ) {

        var objDefaultMaterial = defaultMaterial;
        var mesh = meshes[ i ];
        var vertices = new THREE.Float32BufferAttribute( mesh.vertices, 3 );
        var normals = null;

        if ( mesh.normals.length ) {

          normals = new THREE.Float32BufferAttribute( mesh.normals, 3 );

        }

        if ( mesh.color ) {

          var color = mesh.color;

          objDefaultMaterial = defaultMaterial.clone();
          objDefaultMaterial.color = new THREE.Color( color.r, color.g, color.b );

          if ( color.a !== 1.0 ) {

            objDefaultMaterial.transparent = true;
            objDefaultMaterial.opacity = color.a;

          }

        }

        var volumes = mesh.volumes;

        for ( j = 0; j < volumes.length; j ++ ) {

          var volume = volumes[ j ];
          var newGeometry = new THREE.BufferGeometry();
          var material = objDefaultMaterial;

          newGeometry.setIndex( volume.triangles );
          newGeometry.addAttribute( 'position', vertices.clone() );

          if ( normals ) {

            newGeometry.addAttribute( 'normal', normals.clone() );

          }

          if ( amfMaterials[ volume.materialId ] !== undefined ) {

            material = amfMaterials[ volume.materialId ];

          }

          newGeometry.scale( amfScale, amfScale, amfScale );
          newObject.add( new THREE.Mesh( newGeometry, material.clone() ) );

        }

      }

      sceneObject.add( newObject );

    }

    return sceneObject;

  }

};

/**
 * Author: Pierre Lepers
 * Date: 09/12/2013 17:21
 */

( function () {

  var UNCOMPRESSED = 0,
    DEFLATE = 1,
    LZMA = 2,

    AWD_FIELD_INT8 = 1,
    AWD_FIELD_INT16 = 2,
    AWD_FIELD_INT32 = 3,
    AWD_FIELD_UINT8 = 4,
    AWD_FIELD_UINT16 = 5,
    AWD_FIELD_UINT32 = 6,
    AWD_FIELD_FLOAT32 = 7,
    AWD_FIELD_FLOAT64 = 8,
    AWD_FIELD_BOOL = 21,
    AWD_FIELD_COLOR = 22,
    AWD_FIELD_BADDR = 23,
    AWD_FIELD_STRING = 31,
    AWD_FIELD_BYTEARRAY = 32,
    AWD_FIELD_VECTOR2x1 = 41,
    AWD_FIELD_VECTOR3x1 = 42,
    AWD_FIELD_VECTOR4x1 = 43,
    AWD_FIELD_MTX3x2 = 44,
    AWD_FIELD_MTX3x3 = 45,
    AWD_FIELD_MTX4x3 = 46,
    AWD_FIELD_MTX4x4 = 47,

    BOOL = 21,
    COLOR = 22,
    BADDR = 23,

    INT8 = 1,
    INT16 = 2,
    INT32 = 3,
    UINT8 = 4,
    UINT16 = 5,
    UINT32 = 6,
    FLOAT32 = 7,
    FLOAT64 = 8;

  var littleEndian = true;

  function Block() {

    this.id = 0;
    this.data = null;

  }

  function AWDProperties() {}

  AWDProperties.prototype = {
    set: function ( key, value ) {

      this[ key ] = value;

    },

    get: function ( key, fallback ) {

      if ( this.hasOwnProperty( key ) ) {

        return this[ key ];

      } else {

        return fallback;

      }

    }
  };

  THREE.AWDLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.trunk = new THREE.Object3D();

    this.materialFactory = undefined;

    this._url = '';
    this._baseDir = '';

    this._data = undefined;
    this._ptr = 0;

    this._version = [];
    this._streaming = false;
    this._optimized_for_accuracy = false;
    this._compression = 0;
    this._bodylen = 0xFFFFFFFF;

    this._blocks = [ new Block() ];

    this._accuracyMatrix = false;
    this._accuracyGeo = false;
    this._accuracyProps = false;

  };

  THREE.AWDLoader.prototype = {

    constructor: THREE.AWDLoader,

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      this._url = url;
      this._baseDir = url.substr( 0, url.lastIndexOf( '/' ) + 1 );

      var loader = new THREE.FileLoader( this.manager );
      loader.setResponseType( 'arraybuffer' );
      loader.load( url, function ( text ) {

        onLoad( scope.parse( text ) );

      }, onProgress, onError );

    },

    parse: function ( data ) {

      var blen = data.byteLength;

      this._ptr = 0;
      this._data = new DataView( data );

      this._parseHeader( );

      if ( this._compression != 0 ) {

        console.error( 'compressed AWD not supported' );

      }

      if ( ! this._streaming && this._bodylen != data.byteLength - this._ptr ) {

        console.error( 'AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr );

      }

      while ( this._ptr < blen ) {

        this.parseNextBlock();

      }

      return this.trunk;

    },

    parseNextBlock: function () {

      var assetData,
        ns, type, len, block,
        blockId = this.readU32(),
        ns = this.readU8(),
        type = this.readU8(),
        flags = this.readU8(),
        len = this.readU32();


      switch ( type ) {

        case 1:
          assetData = this.parseMeshData( len );
          break;

        case 22:
          assetData = this.parseContainer( len );
          break;

        case 23:
          assetData = this.parseMeshInstance( len );
          break;

        case 81:
          assetData = this.parseMaterial( len );
          break;

        case 82:
          assetData = this.parseTexture( len );
          break;

        case 101:
          assetData = this.parseSkeleton( len );
          break;

      //  case 111:
      //    assetData = this.parseMeshPoseAnimation(len, true);
      //    break;

        case 112:
          assetData = this.parseMeshPoseAnimation( len, false );
          break;

        case 113:
          assetData = this.parseVertexAnimationSet( len );
          break;

        case 102:
          assetData = this.parseSkeletonPose( len );
          break;

        case 103:
          assetData = this.parseSkeletonAnimation( len );
          break;

        case 122:
          assetData = this.parseAnimatorSet( len );
          break;

        // case 121:
        //  assetData = parseUVAnimation(len);
        //  break;

        default:
          //debug('Ignoring block!',type, len);
          this._ptr += len;
          break;

      }


      // Store block reference for later use
      this._blocks[ blockId ] = block = new Block();
      block.data = assetData;
      block.id = blockId;


    },

    _parseHeader: function () {

      var version = this._version,
        awdmagic = ( this.readU8() << 16 ) | ( this.readU8() << 8 ) | this.readU8();

      if ( awdmagic != 4282180 )
        throw new Error( "AWDLoader - bad magic" );

      version[ 0 ] = this.readU8();
      version[ 1 ] = this.readU8();

      var flags = this.readU16();

      this._streaming = ( flags & 0x1 ) == 0x1;

      if ( ( version[ 0 ] === 2 ) && ( version[ 1 ] === 1 ) ) {

        this._accuracyMatrix = ( flags & 0x2 ) === 0x2;
        this._accuracyGeo = ( flags & 0x4 ) === 0x4;
        this._accuracyProps = ( flags & 0x8 ) === 0x8;

      }

      this._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;
      this._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;
      this._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;

      this._optimized_for_accuracy = ( flags & 0x2 ) === 0x2;

      this._compression = this.readU8();
      this._bodylen = this.readU32();

    },

    parseContainer: function ( len ) {

      var parent,
        ctr = new THREE.Object3D(),
        par_id = this.readU32(),
        mtx = this.parseMatrix4();

      ctr.name = this.readUTF();
      ctr.applyMatrix( mtx );

      parent = this._blocks[ par_id ].data || this.trunk;
      parent.add( ctr );

      this.parseProperties( {
        1: this._matrixNrType,
        2: this._matrixNrType,
        3: this._matrixNrType,
        4: UINT8
      } );

      ctr.extra = this.parseUserAttributes();

      return ctr;

    },

    parseMeshInstance: function ( len ) {

      var name,
        mesh, geometries, meshLen, meshes,
        par_id, data_id,
        mtx,
        materials, mat, mat_id,
        num_materials,
        parent,
        i;

      par_id = this.readU32();
      mtx = this.parseMatrix4();
      name = this.readUTF();
      data_id = this.readU32();
      num_materials = this.readU16();

      geometries = this.getBlock( data_id );

      materials = [];

      for ( i = 0; i < num_materials; i ++ ) {

        mat_id = this.readU32();
        mat = this.getBlock( mat_id );
        materials.push( mat );

      }

      meshLen = geometries.length;
      meshes = [];

      // TODO : BufferGeometry don't support "geometryGroups" for now.
      // so we create sub meshes for each groups
      if ( meshLen > 1 ) {

        mesh = new THREE.Object3D();
        for ( i = 0; i < meshLen; i ++ ) {

          var sm = new THREE.Mesh( geometries[ i ] );
          meshes.push( sm );
          mesh.add( sm );

        }

      } else {

        mesh = new THREE.Mesh( geometries[ 0 ] );
        meshes.push( mesh );

      }

      mesh.applyMatrix( mtx );
      mesh.name = name;


      parent = this.getBlock( par_id ) || this.trunk;
      parent.add( mesh );


      var matLen = materials.length;
      var maxLen = Math.max( meshLen, matLen );
      for ( i = 0; i < maxLen; i ++ )
        meshes[ i % meshLen ].material = materials[ i % matLen ];


      // Ignore for now
      this.parseProperties( null );
      mesh.extra = this.parseUserAttributes();

      return mesh;

    },

    parseMaterial: function ( len ) {

      var name,
        type,
        props,
        mat,
        attributes,
        finalize,
        num_methods,
        methods_parsed;

      name = this.readUTF();
      type = this.readU8();
      num_methods = this.readU8();

      //log( "AWDLoader parseMaterial ",name )

      // Read material numerical properties
      // (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
      props = this.parseProperties( {
        1: AWD_FIELD_INT32,
        2: AWD_FIELD_BADDR,
        11: AWD_FIELD_BOOL,
        12: AWD_FIELD_FLOAT32,
        13: AWD_FIELD_BOOL
      } );

      methods_parsed = 0;

      while ( methods_parsed < num_methods ) {

        var method_type = this.readU16();
        this.parseProperties( null );
        this.parseUserAttributes();

      }

      attributes = this.parseUserAttributes();

      if ( this.materialFactory !== undefined ) {

        mat = this.materialFactory( name );
        if ( mat ) return mat;

      }

      mat = new THREE.MeshPhongMaterial();

      if ( type === 1 ) {

        // Color material
        mat.color.setHex( props.get( 1, 0xcccccc ) );

      } else if ( type === 2 ) {

        // Bitmap material
        var tex_addr = props.get( 2, 0 );
        mat.map = this.getBlock( tex_addr );

      }

      mat.extra = attributes;
      mat.alphaThreshold = props.get( 12, 0.0 );
      mat.repeat = props.get( 13, false );


      return mat;

    },

    parseTexture: function ( len ) {

      var name = this.readUTF(),
        type = this.readU8(),
        asset,
        data_len;

      // External
      if ( type === 0 ) {

        data_len = this.readU32();
        var url = this.readUTFBytes( data_len );
        console.log( url );

        asset = this.loadTexture( url );

      } else {
        // embed texture not supported
      }
      // Ignore for now
      this.parseProperties( null );

      this.parseUserAttributes();
      return asset;

    },

    loadTexture: function ( url ) {

      var tex = new THREE.Texture();

      var loader = new THREE.ImageLoader( this.manager );

      loader.load( this._baseDir + url, function ( image ) {

        tex.image = image;
        tex.needsUpdate = true;

      } );

      return tex;

    },

    parseSkeleton: function ( len ) {

      // Array<Bone>
      var name = this.readUTF(),
        num_joints = this.readU16(),
        skeleton = [],
        joints_parsed = 0;

      this.parseProperties( null );

      while ( joints_parsed < num_joints ) {

        var joint, ibp;

        // Ignore joint id
        this.readU16();

        joint = new THREE.Bone();
        joint.parent = this.readU16() - 1; // 0=null in AWD
        joint.name = this.readUTF();

        ibp = this.parseMatrix4();
        joint.skinMatrix = ibp;

        // Ignore joint props/attributes for now
        this.parseProperties( null );
        this.parseUserAttributes();

        skeleton.push( joint );
        joints_parsed ++;

      }

      // Discard attributes for now
      this.parseUserAttributes();


      return skeleton;

    },

    parseSkeletonPose: function ( blockID ) {

      var name = this.readUTF();

      var num_joints = this.readU16();
      this.parseProperties( null );

      // debug( 'parse Skeleton Pose. joints : ' + num_joints);

      var pose = [];

      var joints_parsed = 0;

      while ( joints_parsed < num_joints ) {

        var joint_pose;

        var has_transform; //:uint;
        var mtx_data;

        has_transform = this.readU8();

        if ( has_transform === 1 ) {

          mtx_data = this.parseMatrix4();

        } else {

          mtx_data = new THREE.Matrix4();

        }
        pose[ joints_parsed ] = mtx_data;
        joints_parsed ++;

      }

      // Skip attributes for now
      this.parseUserAttributes();

      return pose;

    },

    parseSkeletonAnimation: function ( blockID ) {

      var frame_dur;
      var pose_addr;
      var pose;

      var name = this.readUTF();

      var clip = [];

      var num_frames = this.readU16();
      this.parseProperties( null );

      var frames_parsed = 0;
      var returnedArray;

      // debug( 'parse Skeleton Animation. frames : ' + num_frames);

      while ( frames_parsed < num_frames ) {

        pose_addr = this.readU32();
        frame_dur = this.readU16();

        pose = this._blocks[ pose_addr ].data;
        // debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );
        clip.push( {
          pose: pose,
          duration: frame_dur
        } );

        frames_parsed ++;

      }

      if ( clip.length === 0 ) {

        // debug("Could not this SkeletonClipNode, because no Frames where set.");
        return;

      }
      // Ignore attributes for now
      this.parseUserAttributes();
      return clip;

    },

    parseVertexAnimationSet: function ( len ) {

      var poseBlockAdress,
        name = this.readUTF(),
        num_frames = this.readU16(),
        props = this.parseProperties( { 1: UINT16 } ),
        frames_parsed = 0,
        skeletonFrames = [];

      while ( frames_parsed < num_frames ) {

        poseBlockAdress = this.readU32();
        skeletonFrames.push( this._blocks[ poseBlockAdress ].data );
        frames_parsed ++;

      }

      this.parseUserAttributes();


      return skeletonFrames;

    },

    parseAnimatorSet: function ( len ) {

      var targetMesh;

      var animSetBlockAdress; //:int

      var targetAnimationSet; //:AnimationSetBase;
      var outputString = ""; //:String = "";
      var name = this.readUTF();
      var type = this.readU16();

      var props = this.parseProperties( { 1: BADDR } );

      animSetBlockAdress = this.readU32();
      var targetMeshLength = this.readU16();

      var meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;

      for ( var i = 0; i < targetMeshLength; i ++ )
        meshAdresses.push( this.readU32() );

      var activeState = this.readU16();
      var autoplay = Boolean( this.readU8() );
      this.parseUserAttributes();
      this.parseUserAttributes();

      var returnedArray;
      var targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;

      for ( i = 0; i < meshAdresses.length; i ++ ) {

        //      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);
        //      if (returnedArray[0])
        targetMeshes.push( this._blocks[ meshAdresses[ i ] ].data );

      }

      targetAnimationSet = this._blocks[ animSetBlockAdress ].data;
      var thisAnimator;

      if ( type == 1 ) {


        thisAnimator = {
          animationSet: targetAnimationSet,
          skeleton: this._blocks[ props.get( 1, 0 ) ].data
        };

      } else if ( type == 2 ) {
        // debug( "vertex Anim???");
      }


      for ( i = 0; i < targetMeshes.length; i ++ ) {

        targetMeshes[ i ].animator = thisAnimator;

      }
      // debug("Parsed a Animator: Name = " + name);

      return thisAnimator;

    },

    parseMeshData: function ( len ) {

      var name = this.readUTF(),
        num_subs = this.readU16(),
        geom,
        subs_parsed = 0,
        buffer,
        skinW, skinI,
        geometries = [];

      // Ignore for now
      this.parseProperties( { 1: this._geoNrType, 2: this._geoNrType } );

      // Loop through sub meshes
      while ( subs_parsed < num_subs ) {

        var sm_len, sm_end, attrib;

        geom = new THREE.BufferGeometry();
        geom.name = name;
        geometries.push( geom );


        sm_len = this.readU32();
        sm_end = this._ptr + sm_len;


        // Ignore for now
        this.parseProperties( { 1: this._geoNrType, 2: this._geoNrType } );

        // Loop through data streams
        while ( this._ptr < sm_end ) {

          var idx = 0,
            str_type = this.readU8(),
            str_ftype = this.readU8(),
            str_len = this.readU32(),
            str_end = str_len + this._ptr;

          if ( str_type === 1 ) {

            // VERTICES

            buffer = new Float32Array( ( str_len / 12 ) * 3 );
            attrib = new THREE.BufferAttribute( buffer, 3 );

            geom.addAttribute( 'position', attrib );
            idx = 0;

            while ( this._ptr < str_end ) {

              buffer[ idx ] = - this.readF32();
              buffer[ idx + 1 ] = this.readF32();
              buffer[ idx + 2 ] = this.readF32();
              idx += 3;

            }

          } else if ( str_type === 2 ) {

            // INDICES

            buffer = new Uint16Array( str_len / 2 );
            attrib = new THREE.BufferAttribute( buffer, 1 );
            geom.setIndex( attrib );

            idx = 0;

            while ( this._ptr < str_end ) {

              buffer[ idx + 1 ] = this.readU16();
              buffer[ idx ] = this.readU16();
              buffer[ idx + 2 ] = this.readU16();
              idx += 3;

            }

          } else if ( str_type === 3 ) {

            // UVS

            buffer = new Float32Array( ( str_len / 8 ) * 2 );
            attrib = new THREE.BufferAttribute( buffer, 2 );

            geom.addAttribute( 'uv', attrib );
            idx = 0;

            while ( this._ptr < str_end ) {

              buffer[ idx ] = this.readF32();
              buffer[ idx + 1 ] = 1.0 - this.readF32();
              idx += 2;

            }

          } else if ( str_type === 4 ) {

            // NORMALS

            buffer = new Float32Array( ( str_len / 12 ) * 3 );
            attrib = new THREE.BufferAttribute( buffer, 3 );
            geom.addAttribute( 'normal', attrib );
            idx = 0;

            while ( this._ptr < str_end ) {

              buffer[ idx ] = - this.readF32();
              buffer[ idx + 1 ] = this.readF32();
              buffer[ idx + 2 ] = this.readF32();
              idx += 3;

            }

          } else {

            this._ptr = str_end;

          }

        }

        this.parseUserAttributes();

        geom.computeBoundingSphere();
        subs_parsed ++;

      }

      //geom.computeFaceNormals();

      this.parseUserAttributes();
      //finalizeAsset(geom, name);

      return geometries;

    },

    parseMeshPoseAnimation: function ( len, poseOnly ) {

      var num_frames = 1,
        num_submeshes,
        frames_parsed,
        subMeshParsed,
        frame_dur,
        x, y, z,

        str_len,
        str_end,
        geom,
        subGeom,
        idx = 0,
        clip = {},
        indices,
        verts,
        num_Streams,
        streamsParsed,
        streamtypes = [],

        props,
        thisGeo,
        name = this.readUTF(),
        geoAdress = this.readU32();

      var mesh = this.getBlock( geoAdress );

      if ( mesh === null ) {

        console.log( "parseMeshPoseAnimation target mesh not found at:", geoAdress );
        return;

      }

      geom = mesh.geometry;
      geom.morphTargets = [];

      if ( ! poseOnly )
        num_frames = this.readU16();

      num_submeshes = this.readU16();
      num_Streams = this.readU16();

      // debug("VA num_frames : ", num_frames );
      // debug("VA num_submeshes : ", num_submeshes );
      // debug("VA numstreams : ", num_Streams );

      streamsParsed = 0;
      while ( streamsParsed < num_Streams ) {

        streamtypes.push( this.readU16() );
        streamsParsed ++;

      }
      props = this.parseProperties( { 1: BOOL, 2: BOOL } );

      clip.looping = props.get( 1, true );
      clip.stitchFinalFrame = props.get( 2, false );

      frames_parsed = 0;

      while ( frames_parsed < num_frames ) {

        frame_dur = this.readU16();
        subMeshParsed = 0;

        while ( subMeshParsed < num_submeshes ) {

          streamsParsed = 0;
          str_len = this.readU32();
          str_end = this._ptr + str_len;

          while ( streamsParsed < num_Streams ) {

            if ( streamtypes[ streamsParsed ] === 1 ) {

              //geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );
              var buffer = new Float32Array( str_len / 4 );
              geom.morphTargets.push( {
                array: buffer
              } );

              //buffer = geom.attributes['morphTarget'+frames_parsed].array
              idx = 0;

              while ( this._ptr < str_end ) {

                buffer[ idx ] = this.readF32();
                buffer[ idx + 1 ] = this.readF32();
                buffer[ idx + 2 ] = this.readF32();
                idx += 3;

              }


              subMeshParsed ++;

            } else
              this._ptr = str_end;
            streamsParsed ++;

          }

        }


        frames_parsed ++;

      }

      this.parseUserAttributes();

      return null;

    },

    getBlock: function ( id ) {

      return this._blocks[ id ].data;

    },

    parseMatrix4: function () {

      var mtx = new THREE.Matrix4();
      var e = mtx.elements;

      e[ 0 ] = this.readF32();
      e[ 1 ] = this.readF32();
      e[ 2 ] = this.readF32();
      e[ 3 ] = 0.0;
      //e[3] = 0.0;

      e[ 4 ] = this.readF32();
      e[ 5 ] = this.readF32();
      e[ 6 ] = this.readF32();
      //e[7] = this.readF32();
      e[ 7 ] = 0.0;

      e[ 8 ] = this.readF32();
      e[ 9 ] = this.readF32();
      e[ 10 ] = this.readF32();
      //e[11] = this.readF32();
      e[ 11 ] = 0.0;

      e[ 12 ] = - this.readF32();
      e[ 13 ] = this.readF32();
      e[ 14 ] = this.readF32();
      //e[15] = this.readF32();
      e[ 15 ] = 1.0;
      return mtx;

    },

    parseProperties: function ( expected ) {

      var list_len = this.readU32();
      var list_end = this._ptr + list_len;

      var props = new AWDProperties();

      if ( expected ) {

        while ( this._ptr < list_end ) {

          var key = this.readU16();
          var len = this.readU32();
          var type;

          if ( expected.hasOwnProperty( key ) ) {

            type = expected[ key ];
            props.set( key, this.parseAttrValue( type, len ) );

          } else {

            this._ptr += len;

          }

        }

      }

      return props;

    },

    parseUserAttributes: function () {

      // skip for now
      this._ptr = this.readU32() + this._ptr;
      return null;

    },

    parseAttrValue: function ( type, len ) {

      var elem_len;
      var read_func;

      switch ( type ) {

        case AWD_FIELD_INT8:
          elem_len = 1;
          read_func = this.readI8;
          break;

        case AWD_FIELD_INT16:
          elem_len = 2;
          read_func = this.readI16;
          break;

        case AWD_FIELD_INT32:
          elem_len = 4;
          read_func = this.readI32;
          break;

        case AWD_FIELD_BOOL:
        case AWD_FIELD_UINT8:
          elem_len = 1;
          read_func = this.readU8;
          break;

        case AWD_FIELD_UINT16:
          elem_len = 2;
          read_func = this.readU16;
          break;

        case AWD_FIELD_UINT32:
        case AWD_FIELD_BADDR:
          elem_len = 4;
          read_func = this.readU32;
          break;

        case AWD_FIELD_FLOAT32:
          elem_len = 4;
          read_func = this.readF32;
          break;

        case AWD_FIELD_FLOAT64:
          elem_len = 8;
          read_func = this.readF64;
          break;

        case AWD_FIELD_VECTOR2x1:
        case AWD_FIELD_VECTOR3x1:
        case AWD_FIELD_VECTOR4x1:
        case AWD_FIELD_MTX3x2:
        case AWD_FIELD_MTX3x3:
        case AWD_FIELD_MTX4x3:
        case AWD_FIELD_MTX4x4:
          elem_len = 8;
          read_func = this.readF64;
          break;

      }

      if ( elem_len < len ) {

        var list;
        var num_read;
        var num_elems;

        list = [];
        num_read = 0;
        num_elems = len / elem_len;

        while ( num_read < num_elems ) {

          list.push( read_func.call( this ) );
          num_read ++;

        }

        return list;

      } else {

        return read_func.call( this );

      }

    },

    readU8: function () {

      return this._data.getUint8( this._ptr ++ );

    },
    readI8: function () {

      return this._data.getInt8( this._ptr ++ );

    },
    readU16: function () {

      var a = this._data.getUint16( this._ptr, littleEndian );
      this._ptr += 2;
      return a;

    },
    readI16: function () {

      var a = this._data.getInt16( this._ptr, littleEndian );
      this._ptr += 2;
      return a;

    },
    readU32: function () {

      var a = this._data.getUint32( this._ptr, littleEndian );
      this._ptr += 4;
      return a;

    },
    readI32: function () {

      var a = this._data.getInt32( this._ptr, littleEndian );
      this._ptr += 4;
      return a;

    },
    readF32: function () {

      var a = this._data.getFloat32( this._ptr, littleEndian );
      this._ptr += 4;
      return a;

    },
    readF64: function () {

      var a = this._data.getFloat64( this._ptr, littleEndian );
      this._ptr += 8;
      return a;

    },

    /**
   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
   * @param {Array.<number>} bytes UTF-8 byte array.
   * @return {string} 16-bit Unicode string.
   */
    readUTF: function () {

      var len = this.readU16();
      return this.readUTFBytes( len );

    },

    /**
     * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
     * @param {Array.<number>} bytes UTF-8 byte array.
     * @return {string} 16-bit Unicode string.
     */
    readUTFBytes: function ( len ) {

      // TODO(user): Use native implementations if/when available
      var out = [], c = 0;

      while ( out.length < len ) {

        var c1 = this._data.getUint8( this._ptr ++, littleEndian );
        if ( c1 < 128 ) {

          out[ c ++ ] = String.fromCharCode( c1 );

        } else if ( c1 > 191 && c1 < 224 ) {

          var c2 = this._data.getUint8( this._ptr ++, littleEndian );
          out[ c ++ ] = String.fromCharCode( ( c1 & 31 ) << 6 | c2 & 63 );

        } else {

          var c2 = this._data.getUint8( this._ptr ++, littleEndian );
          var c3 = this._data.getUint8( this._ptr ++, littleEndian );
          out[ c ++ ] = String.fromCharCode( ( c1 & 15 ) << 12 | ( c2 & 63 ) << 6 | c3 & 63 );

        }

      }
      return out.join( '' );

    }

  };

} )();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.BabylonLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BabylonLoader.prototype = {

  constructor: THREE.BabylonLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  parse: function ( json ) {

    function parseMaterials( json ) {

      var materials = {};

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        var data = json.materials[ i ];

        var material = new THREE.MeshPhongMaterial();
        material.name = data.name;
        material.color.fromArray( data.diffuse );
        material.emissive.fromArray( data.emissive );
        material.specular.fromArray( data.specular );
        material.shininess = data.specularPower;
        material.opacity = data.alpha;

        materials[ data.id ] = material;

      }

      if ( json.multiMaterials ) {

        for ( var i = 0, l = json.multiMaterials.length; i < l; i ++ ) {

          var data = json.multiMaterials[ i ];

          console.warn( 'THREE.BabylonLoader: Multi materials not yet supported.' );

          materials[ data.id ] = new THREE.MeshPhongMaterial();

        }

      }

      return materials;

    }

    function parseGeometry( json ) {

      var geometry = new THREE.BufferGeometry();

      var indices = json.indices;
      var positions = json.positions;
      var normals = json.normals;
      var uvs = json.uvs;

      // indices

      geometry.setIndex( indices );

      // positions

      for ( var j = 2, jl = positions.length; j < jl; j += 3 ) {

        positions[ j ] = - positions[ j ];

      }

      geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

      // normals

      if ( normals ) {

        for ( var j = 2, jl = normals.length; j < jl; j += 3 ) {

          normals[ j ] = - normals[ j ];

        }

        geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );

      }

      // uvs

      if ( uvs ) {

        geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );

      }

      // offsets

      var subMeshes = json.subMeshes;

      if ( subMeshes ) {

        for ( var j = 0, jl = subMeshes.length; j < jl; j ++ ) {

          var subMesh = subMeshes[ j ];

          geometry.addGroup( subMesh.indexStart, subMesh.indexCount );

        }

      }

      return geometry;

    }

    function parseObjects( json, materials ) {

      var objects = {};
      var scene = new THREE.Scene();

      var cameras = json.cameras;

      for ( var i = 0, l = cameras.length; i < l; i ++ ) {

        var data = cameras[ i ];

        var camera = new THREE.PerspectiveCamera( ( data.fov / Math.PI ) * 180, 1.33, data.minZ, data.maxZ );

        camera.name = data.name;
        camera.position.fromArray( data.position );
        if ( data.rotation ) camera.rotation.fromArray( data.rotation );

        objects[ data.id ] = camera;

      }

      var lights = json.lights;

      for ( var i = 0, l = lights.length; i < l; i ++ ) {

        var data = lights[ i ];

        var light;

        switch ( data.type ) {

          case 0:
            light = new THREE.PointLight();
            break;

          case 1:
            light = new THREE.DirectionalLight();
            break;

          case 2:
            light = new THREE.SpotLight();
            break;

          case 3:
            light = new THREE.HemisphereLight();
            break;

        }

        light.name = data.name;
        if ( data.position ) light.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] );
        light.color.fromArray( data.diffuse );
        if ( data.groundColor ) light.groundColor.fromArray( data.groundColor );
        if ( data.intensity ) light.intensity = data.intensity;

        objects[ data.id ] = light;

        scene.add( light );

      }

      var meshes = json.meshes;

      for ( var i = 0, l = meshes.length; i < l; i ++ ) {

        var data = meshes[ i ];

        var object;

        if ( data.indices ) {

          var geometry = parseGeometry( data );

          object = new THREE.Mesh( geometry, materials[ data.materialId ] );

        } else {

          object = new THREE.Group();

        }

        object.name = data.name;
        object.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] );
        object.rotation.fromArray( data.rotation );
        if ( data.rotationQuaternion ) object.quaternion.fromArray( data.rotationQuaternion );
        object.scale.fromArray( data.scaling );
        // object.visible = data.isVisible;

        if ( data.parentId ) {

          objects[ data.parentId ].add( object );

        } else {

          scene.add( object );

        }

        objects[ data.id ] = object;

      }

      return scene;

    }

    var materials = parseMaterials( json );
    var scene = parseObjects( json, materials );

    return scene;

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.ColladaLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ColladaLoader.prototype = {

  constructor: THREE.ColladaLoader,

  crossOrigin: 'Anonymous',

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var path = THREE.Loader.prototype.extractUrlBase( url );

    var loader = new THREE.FileLoader( scope.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text, path ) );

    }, onProgress, onError );

  },

  options: {

    set convertUpAxis( value ) {

      console.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );

    }

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( text, path ) {

    function getElementsByTagName( xml, name ) {

      // Non recursive xml.getElementsByTagName() ...

      var array = [];
      var childNodes = xml.childNodes;

      for ( var i = 0, l = childNodes.length; i < l; i ++ ) {

        var child = childNodes[ i ];

        if ( child.nodeName === name ) {

          array.push( child );

        }

      }

      return array;

    }

    function parseStrings( text ) {

      if ( text.length === 0 ) return [];

      var parts = text.trim().split( /\s+/ );
      var array = new Array( parts.length );

      for ( var i = 0, l = parts.length; i < l; i ++ ) {

        array[ i ] = parts[ i ];

      }

      return array;

    }

    function parseFloats( text ) {

      if ( text.length === 0 ) return [];

      var parts = text.trim().split( /\s+/ );
      var array = new Array( parts.length );

      for ( var i = 0, l = parts.length; i < l; i ++ ) {

        array[ i ] = parseFloat( parts[ i ] );

      }

      return array;

    }

    function parseInts( text ) {

      if ( text.length === 0 ) return [];

      var parts = text.trim().split( /\s+/ );
      var array = new Array( parts.length );

      for ( var i = 0, l = parts.length; i < l; i ++ ) {

        array[ i ] = parseInt( parts[ i ] );

      }

      return array;

    }

    function parseId( text ) {

      return text.substring( 1 );

    }

    function isEmpty( object ) {

      return Object.keys( object ).length === 0;

    }

    // asset

    function parseAsset( xml ) {

      return {
        unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),
        upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )
      };

    }

    function parseAssetUnit( xml ) {

      return xml !== undefined ? parseFloat( xml.getAttribute( 'meter' ) ) : 1;

    }

    function parseAssetUpAxis( xml ) {

      return xml !== undefined ? xml.textContent : 'Y_UP';

    }

    // library

    function parseLibrary( xml, libraryName, nodeName, parser ) {

      var library = getElementsByTagName( xml, libraryName )[ 0 ];

      if ( library !== undefined ) {

        var elements = getElementsByTagName( library, nodeName );

        for ( var i = 0; i < elements.length; i ++ ) {

          parser( elements[ i ] );

        }

      }

    }

    function buildLibrary( data, builder ) {

      for ( var name in data ) {

        var object = data[ name ];
        object.build = builder( data[ name ] );

      }

    }

    // get

    function getBuild( data, builder ) {

      if ( data.build !== undefined ) return data.build;

      data.build = builder( data );

      return data.build;

    }

    // animation

    function parseAnimation( xml ) {

      var data = {
        sources: {},
        samplers: {},
        channels: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        var id;

        switch ( child.nodeName ) {

          case 'source':
            id = child.getAttribute( 'id' );
            data.sources[ id ] = parseSource( child );
            break;

          case 'sampler':
            id = child.getAttribute( 'id' );
            data.samplers[ id ] = parseAnimationSampler( child );
            break;

          case 'channel':
            id = child.getAttribute( 'target' );
            data.channels[ id ] = parseAnimationChannel( child );
            break;

          default:
            console.log( child );

        }

      }

      library.animations[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseAnimationSampler( xml ) {

      var data = {
        inputs: {},
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'input':
            var id = parseId( child.getAttribute( 'source' ) );
            var semantic = child.getAttribute( 'semantic' );
            data.inputs[ semantic ] = id;
            break;

        }

      }

      return data;

    }

    function parseAnimationChannel( xml ) {

      var data = {};

      var target = xml.getAttribute( 'target' );

      // parsing SID Addressing Syntax

      var parts = target.split( '/' );

      var id = parts.shift();
      var sid = parts.shift();

      // check selection syntax

      var arraySyntax = ( sid.indexOf( '(' ) !== - 1 );
      var memberSyntax = ( sid.indexOf( '.' ) !== - 1 );

      if ( memberSyntax ) {

        //  member selection access

        parts = sid.split( '.' );
        sid = parts.shift();
        data.member = parts.shift();

      } else if ( arraySyntax ) {

        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.

        var indices = sid.split( '(' );
        sid = indices.shift();

        for ( var i = 0; i < indices.length; i ++ ) {

          indices[ i ] = parseInt( indices[ i ].replace( /\)/, '' ) );

        }

        data.indices = indices;

      }

      data.id = id;
      data.sid = sid;

      data.arraySyntax = arraySyntax;
      data.memberSyntax = memberSyntax;

      data.sampler = parseId( xml.getAttribute( 'source' ) );

      return data;

    }

    function buildAnimation( data ) {

      var tracks = [];

      var channels = data.channels;
      var samplers = data.samplers;
      var sources = data.sources;

      for ( var target in channels ) {

        if ( channels.hasOwnProperty( target ) ) {

          var channel = channels[ target ];
          var sampler = samplers[ channel.sampler ];

          var inputId = sampler.inputs.INPUT;
          var outputId = sampler.inputs.OUTPUT;

          var inputSource = sources[ inputId ];
          var outputSource = sources[ outputId ];

          var animation = buildAnimationChannel( channel, inputSource, outputSource );

          createKeyframeTracks( animation, tracks );

        }

      }

      return tracks;

    }

    function getAnimation( id ) {

      return getBuild( library.animations[ id ], buildAnimation );

    }

    function buildAnimationChannel( channel, inputSource, outputSource ) {

      var node = library.nodes[ channel.id ];
      var object3D = getNode( node.id );

      var transform = node.transforms[ channel.sid ];
      var defaultMatrix = node.matrix.clone().transpose();

      var time, stride;
      var i, il, j, jl;

      var data = {};

      // the collada spec allows the animation of data in various ways.
      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic

      switch ( transform ) {

        case 'matrix':

          for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {

            time = inputSource.array[ i ];
            stride = i * outputSource.stride;

            if ( data[ time ] === undefined ) data[ time ] = {};

            if ( channel.arraySyntax === true ) {

              var value = outputSource.array[ stride ];
              var index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];

              data[ time ][ index ] = value;

            } else {

              for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {

                data[ time ][ j ] = outputSource.array[ stride + j ];

              }

            }

          }

          break;

        case 'translate':
          console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
          break;

        case 'rotate':
          console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
          break;

        case 'scale':
          console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
          break;

      }

      var keyframes = prepareAnimationData( data, defaultMatrix );

      var animation = {
        name: object3D.uuid,
        keyframes: keyframes
      };

      return animation;

    }

    function prepareAnimationData( data, defaultMatrix ) {

      var keyframes = [];

      // transfer data into a sortable array

      for ( var time in data ) {

        keyframes.push( { time: parseFloat( time ), value: data[ time ] } );

      }

      // ensure keyframes are sorted by time

      keyframes.sort( ascending );

      // now we clean up all animation data, so we can use them for keyframe tracks

      for ( var i = 0; i < 16; i ++ ) {

        transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );

      }

      return keyframes;

      // array sort function

      function ascending( a, b ) {

        return a.time - b.time;

      }

    }

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    function createKeyframeTracks( animation, tracks ) {

      var keyframes = animation.keyframes;
      var name = animation.name;

      var times = [];
      var positionData = [];
      var quaternionData = [];
      var scaleData = [];

      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {

        var keyframe = keyframes[ i ];

        var time = keyframe.time;
        var value = keyframe.value;

        matrix.fromArray( value ).transpose();
        matrix.decompose( position, quaternion, scale );

        times.push( time );
        positionData.push( position.x, position.y, position.z );
        quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );
        scaleData.push( scale.x, scale.y, scale.z );

      }

      if ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );
      if ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );
      if ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );

      return tracks;

    }

    function transformAnimationData( keyframes, property, defaultValue ) {

      var keyframe;

      var empty = true;
      var i, l;

      // check, if values of a property are missing in our keyframes

      for ( i = 0, l = keyframes.length; i < l; i ++ ) {

        keyframe = keyframes[ i ];

        if ( keyframe.value[ property ] === undefined ) {

          keyframe.value[ property ] = null; // mark as missing

        } else {

          empty = false;

        }

      }

      if ( empty === true ) {

        // no values at all, so we set a default value

        for ( i = 0, l = keyframes.length; i < l; i ++ ) {

          keyframe = keyframes[ i ];

          keyframe.value[ property ] = defaultValue;

        }

      } else {

        // filling gaps

        createMissingKeyframes( keyframes, property );

      }

    }

    function createMissingKeyframes( keyframes, property ) {

      var prev, next;

      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {

        var keyframe = keyframes[ i ];

        if ( keyframe.value[ property ] === null ) {

          prev = getPrev( keyframes, i, property );
          next = getNext( keyframes, i, property );

          if ( prev === null ) {

            keyframe.value[ property ] = next.value[ property ];
            continue;

          }

          if ( next === null ) {

            keyframe.value[ property ] = prev.value[ property ];
            continue;

          }

          interpolate( keyframe, prev, next, property );

        }

      }

    }

    function getPrev( keyframes, i, property ) {

      while ( i >= 0 ) {

        var keyframe = keyframes[ i ];

        if ( keyframe.value[ property ] !== null ) return keyframe;

        i --;

      }

      return null;

    }

    function getNext( keyframes, i, property ) {

      while ( i < keyframes.length ) {

        var keyframe = keyframes[ i ];

        if ( keyframe.value[ property ] !== null ) return keyframe;

        i ++;

      }

      return null;

    }

    function interpolate( key, prev, next, property ) {

      if ( ( next.time - prev.time ) === 0 ) {

        key.value[ property ] = prev.value[ property ];
        return;

      }

      key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];

    }

    // animation clips

    function parseAnimationClip( xml ) {

      var data = {
        name: xml.getAttribute( 'id' ) || 'default',
        start: parseFloat( xml.getAttribute( 'start' ) || 0 ),
        end: parseFloat( xml.getAttribute( 'end' ) || 0 ),
        animations: []
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'instance_animation':
            data.animations.push( parseId( child.getAttribute( 'url' ) ) );
            break;

        }

      }

      library.clips[ xml.getAttribute( 'id' ) ] = data;

    }

    function buildAnimationClip( data ) {

      var tracks = [];

      var name = data.name;
      var duration = ( data.end - data.start ) || - 1;
      var animations = data.animations;

      for ( var i = 0, il = animations.length; i < il; i ++ ) {

        var animationTracks = getAnimation( animations[ i ] );

        for ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {

          tracks.push( animationTracks[ j ] );

        }

      }

      return new THREE.AnimationClip( name, duration, tracks );

    }

    function getAnimationClip( id ) {

      return getBuild( library.clips[ id ], buildAnimationClip );

    }

    // controller

    function parseController( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'skin':
            // there is exactly one skin per controller
            data.id = parseId( child.getAttribute( 'source' ) );
            data.skin = parseSkin( child );
            break;

          case 'morph':
            data.id = parseId( child.getAttribute( 'source' ) );
            console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );
            break;

        }

      }

      library.controllers[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseSkin( xml ) {

      var data = {
        sources: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'bind_shape_matrix':
            data.bindShapeMatrix = parseFloats( child.textContent );
            break;

          case 'source':
            var id = child.getAttribute( 'id' );
            data.sources[ id ] = parseSource( child );
            break;

          case 'joints':
            data.joints = parseJoints( child );
            break;

          case 'vertex_weights':
            data.vertexWeights = parseVertexWeights( child );
            break;

        }

      }

      return data;

    }

    function parseJoints( xml ) {

      var data = {
        inputs: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'input':
            var semantic = child.getAttribute( 'semantic' );
            var id = parseId( child.getAttribute( 'source' ) );
            data.inputs[ semantic ] = id;
            break;

        }

      }

      return data;

    }

    function parseVertexWeights( xml ) {

      var data = {
        inputs: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'input':
            var semantic = child.getAttribute( 'semantic' );
            var id = parseId( child.getAttribute( 'source' ) );
            var offset = parseInt( child.getAttribute( 'offset' ) );
            data.inputs[ semantic ] = { id: id, offset: offset };
            break;

          case 'vcount':
            data.vcount = parseInts( child.textContent );
            break;

          case 'v':
            data.v = parseInts( child.textContent );
            break;

        }

      }

      return data;

    }

    function buildController( data ) {

      var build = {
        id: data.id
      };

      var geometry = library.geometries[ build.id ];

      if ( data.skin !== undefined ) {

        build.skin = buildSkin( data.skin );

        // we enhance the 'sources' property of the corresponding geometry with our skin data

        geometry.sources.skinIndices = build.skin.indices;
        geometry.sources.skinWeights = build.skin.weights;

      }

      return build;

    }

    function buildSkin( data ) {

      var BONE_LIMIT = 4;

      var build = {
        joints: [], // this must be an array to preserve the joint order
        indices: {
          array: [],
          stride: BONE_LIMIT
        },
        weights: {
          array: [],
          stride: BONE_LIMIT
        }
      };

      var sources = data.sources;
      var vertexWeights = data.vertexWeights;

      var vcount = vertexWeights.vcount;
      var v = vertexWeights.v;
      var jointOffset = vertexWeights.inputs.JOINT.offset;
      var weightOffset = vertexWeights.inputs.WEIGHT.offset;

      var jointSource = data.sources[ data.joints.inputs.JOINT ];
      var inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];

      var weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;
      var stride = 0;

      var i, j, l;

      // procces skin data for each vertex

      for ( i = 0, l = vcount.length; i < l; i ++ ) {

        var jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex
        var vertexSkinData = [];

        for ( j = 0; j < jointCount; j ++ ) {

          var skinIndex = v[ stride + jointOffset ];
          var weightId = v[ stride + weightOffset ];
          var skinWeight = weights[ weightId ];

          vertexSkinData.push( { index: skinIndex, weight: skinWeight } );

          stride += 2;

        }

        // we sort the joints in descending order based on the weights.
        // this ensures, we only procced the most important joints of the vertex

        vertexSkinData.sort( descending );

        // now we provide for each vertex a set of four index and weight values.
        // the order of the skin data matches the order of vertices

        for ( j = 0; j < BONE_LIMIT; j ++ ) {

          var d = vertexSkinData[ j ];

          if ( d !== undefined ) {

            build.indices.array.push( d.index );
            build.weights.array.push( d.weight );

          } else {

            build.indices.array.push( 0 );
            build.weights.array.push( 0 );

          }

        }

      }

      // setup bind matrix

      build.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();

      // process bones and inverse bind matrix data

      for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {

        var name = jointSource.array[ i ];
        var boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();

        build.joints.push( { name: name, boneInverse: boneInverse } );

      }

      return build;

      // array sort function

      function descending( a, b ) {

        return b.weight - a.weight;

      }

    }

    function getController( id ) {

      return getBuild( library.controllers[ id ], buildController );

    }

    // image

    function parseImage( xml ) {

      var data = {
        init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent
      };

      library.images[ xml.getAttribute( 'id' ) ] = data;

    }

    function buildImage( data ) {

      if ( data.build !== undefined ) return data.build;

      return data.init_from;

    }

    function getImage( id ) {

      return getBuild( library.images[ id ], buildImage );

    }

    // effect

    function parseEffect( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'profile_COMMON':
            data.profile = parseEffectProfileCOMMON( child );
            break;

        }

      }

      library.effects[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseEffectProfileCOMMON( xml ) {

      var data = {
        surfaces: {},
        samplers: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'newparam':
            parseEffectNewparam( child, data );
            break;

          case 'technique':
            data.technique = parseEffectTechnique( child );
            break;

        }

      }

      return data;

    }

    function parseEffectNewparam( xml, data ) {

      var sid = xml.getAttribute( 'sid' );

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'surface':
            data.surfaces[ sid ] = parseEffectSurface( child );
            break;

          case 'sampler2D':
            data.samplers[ sid ] = parseEffectSampler( child );
            break;

        }

      }

    }

    function parseEffectSurface( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'init_from':
            data.init_from = child.textContent;
            break;

        }

      }

      return data;

    }

    function parseEffectSampler( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'source':
            data.source = child.textContent;
            break;

        }

      }

      return data;

    }

    function parseEffectTechnique( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'constant':
          case 'lambert':
          case 'blinn':
          case 'phong':
            data.type = child.nodeName;
            data.parameters = parseEffectParameters( child );
            break;

        }

      }

      return data;

    }

    function parseEffectParameters( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'emission':
          case 'diffuse':
          case 'specular':
          case 'shininess':
          case 'transparent':
          case 'transparency':
            data[ child.nodeName ] = parseEffectParameter( child );
            break;

        }

      }

      return data;

    }

    function parseEffectParameter( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'color':
            data[ child.nodeName ] = parseFloats( child.textContent );
            break;

          case 'float':
            data[ child.nodeName ] = parseFloat( child.textContent );
            break;

          case 'texture':
            data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };
            break;

        }

      }

      return data;

    }

    function parseEffectParameterTexture( xml ) {

      var data = {
        technique: {}
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'extra':
            parseEffectParameterTextureExtra( child, data );
            break;

        }

      }

      return data;

    }

    function parseEffectParameterTextureExtra( xml, data ) {

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'technique':
            parseEffectParameterTextureExtraTechnique( child, data );
            break;

        }

      }

    }

    function parseEffectParameterTextureExtraTechnique( xml, data ) {

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'repeatU':
          case 'repeatV':
          case 'offsetU':
          case 'offsetV':
            data.technique[ child.nodeName ] = parseFloat( child.textContent );
            break;

          case 'wrapU':
          case 'wrapV':

            // some files have values for wrapU/wrapV which become NaN via parseInt

            if ( child.textContent.toUpperCase() === 'TRUE' ) {

              data.technique[ child.nodeName ] = 1;

            } else if ( child.textContent.toUpperCase() === 'FALSE' ) {

              data.technique[ child.nodeName ] = 0;

            } else {

              data.technique[ child.nodeName ] = parseInt( child.textContent );

            }

            break;

        }

      }

    }

    function buildEffect( data ) {

      return data;

    }

    function getEffect( id ) {

      return getBuild( library.effects[ id ], buildEffect );

    }

    // material

    function parseMaterial( xml ) {

      var data = {
        name: xml.getAttribute( 'name' )
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'instance_effect':
            data.url = parseId( child.getAttribute( 'url' ) );
            break;

        }

      }

      library.materials[ xml.getAttribute( 'id' ) ] = data;

    }

    function buildMaterial( data ) {

      var effect = getEffect( data.url );
      var technique = effect.profile.technique;

      var material;

      switch ( technique.type ) {

        case 'phong':
        case 'blinn':
          material = new THREE.MeshPhongMaterial();
          break;

        case 'lambert':
          material = new THREE.MeshLambertMaterial();
          break;

        default:
          material = new THREE.MeshBasicMaterial();
          break;

      }

      material.name = data.name;

      function getTexture( textureObject ) {

        var sampler = effect.profile.samplers[ textureObject.id ];

        if ( sampler !== undefined ) {

          var surface = effect.profile.surfaces[ sampler.source ];

          var texture = textureLoader.load( getImage( surface.init_from ) );

          var extra = textureObject.extra;

          if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {

            var technique = extra.technique;

            texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
            texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

            texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );
            texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );

          } else {

            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;

          }

          return texture;

        }

        console.error( 'THREE.ColladaLoader: Undefined sampler', textureObject.id );

        return null;

      }

      var parameters = technique.parameters;

      for ( var key in parameters ) {

        var parameter = parameters[ key ];

        switch ( key ) {

          case 'diffuse':
            if ( parameter.color ) material.color.fromArray( parameter.color );
            if ( parameter.texture ) material.map = getTexture( parameter.texture );
            break;
          case 'specular':
            if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );
            if ( parameter.texture ) material.specularMap = getTexture( parameter.texture );
            break;
          case 'shininess':
            if ( parameter.float && material.shininess )
              material.shininess = parameter.float;
            break;
          case 'emission':
            if ( parameter.color && material.emissive )
              material.emissive.fromArray( parameter.color );
            break;
          case 'transparent':
            // if ( parameter.texture ) material.alphaMap = getTexture( parameter.texture );
            material.transparent = true;
            break;
          case 'transparency':
            if ( parameter.float !== undefined ) material.opacity = parameter.float;
            material.transparent = true;
            break;

        }

      }

      return material;

    }

    function getMaterial( id ) {

      return getBuild( library.materials[ id ], buildMaterial );

    }

    // camera

    function parseCamera( xml ) {

      var data = {
        name: xml.getAttribute( 'name' )
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'optics':
            data.optics = parseCameraOptics( child );
            break;

        }

      }

      library.cameras[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseCameraOptics( xml ) {

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        switch ( child.nodeName ) {

          case 'technique_common':
            return parseCameraTechnique( child );

        }

      }

      return {};

    }

    function parseCameraTechnique( xml ) {

      var data = {};

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        switch ( child.nodeName ) {

          case 'perspective':
          case 'orthographic':

            data.technique = child.nodeName;
            data.parameters = parseCameraParameters( child );

            break;

        }

      }

      return data;

    }

    function parseCameraParameters( xml ) {

      var data = {};

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        switch ( child.nodeName ) {

          case 'xfov':
          case 'yfov':
          case 'xmag':
          case 'ymag':
          case 'znear':
          case 'zfar':
          case 'aspect_ratio':
            data[ child.nodeName ] = parseFloat( child.textContent );
            break;

        }

      }

      return data;

    }

    function buildCamera( data ) {

      var camera;

      switch ( data.optics.technique ) {

        case 'perspective':
          camera = new THREE.PerspectiveCamera(
            data.optics.parameters.yfov,
            data.optics.parameters.aspect_ratio,
            data.optics.parameters.znear,
            data.optics.parameters.zfar
          );
          break;

        case 'orthographic':
          var ymag = data.optics.parameters.ymag;
          var xmag = data.optics.parameters.xmag;
          var aspectRatio = data.optics.parameters.aspect_ratio;

          xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;
          ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;

          xmag *= 0.5;
          ymag *= 0.5;

          camera = new THREE.OrthographicCamera(
            - xmag, xmag, ymag, - ymag, // left, right, top, bottom
            data.optics.parameters.znear,
            data.optics.parameters.zfar
          );
          break;

        default:
          camera = new THREE.PerspectiveCamera();
          break;

      }

      camera.name = data.name;

      return camera;

    }

    function getCamera( id ) {

      return getBuild( library.cameras[ id ], buildCamera );

    }

    // light

    function parseLight( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'technique_common':
            data = parseLightTechnique( child );
            break;

        }

      }

      library.lights[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseLightTechnique( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'directional':
          case 'point':
          case 'spot':
          case 'ambient':

            data.technique = child.nodeName;
            data.parameters = parseLightParameters( child );

        }

      }

      return data;

    }

    function parseLightParameters( xml ) {

      var data = {};

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'color':
            var array = parseFloats( child.textContent );
            data.color = new THREE.Color().fromArray( array );
            break;

          case 'falloff_angle':
            data.falloffAngle = parseFloat( child.textContent );
            break;

          case 'quadratic_attenuation':
            var f = parseFloat( child.textContent );
            data.distance = f ? Math.sqrt( 1 / f ) : 0;
            break;

        }

      }

      return data;

    }

    function buildLight( data ) {

      var light;

      switch ( data.technique ) {

        case 'directional':
          light = new THREE.DirectionalLight();
          break;

        case 'point':
          light = new THREE.PointLight();
          break;

        case 'spot':
          light = new THREE.SpotLight();
          break;

        case 'ambient':
          light = new THREE.AmbientLight();
          break;

      }

      if ( data.parameters.color ) light.color.copy( data.parameters.color );
      if ( data.parameters.distance ) light.distance = data.parameters.distance;

      return light;

    }

    function getLight( id ) {

      return getBuild( library.lights[ id ], buildLight );

    }

    // geometry

    function parseGeometry( xml ) {

      var data = {
        name: xml.getAttribute( 'name' ),
        sources: {},
        vertices: {},
        primitives: []
      };

      var mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];

      for ( var i = 0; i < mesh.childNodes.length; i ++ ) {

        var child = mesh.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        var id = child.getAttribute( 'id' );

        switch ( child.nodeName ) {

          case 'source':
            data.sources[ id ] = parseSource( child );
            break;

          case 'vertices':
            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
            data.vertices = parseGeometryVertices( child );
            break;

          case 'polygons':
            console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );
            break;

          case 'lines':
          case 'linestrips':
          case 'polylist':
          case 'triangles':
            data.primitives.push( parseGeometryPrimitive( child ) );
            break;

          default:
            console.log( child );

        }

      }

      library.geometries[ xml.getAttribute( 'id' ) ] = data;

    }

    function parseSource( xml ) {

      var data = {
        array: [],
        stride: 3
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'float_array':
            data.array = parseFloats( child.textContent );
            break;

          case 'Name_array':
            data.array = parseStrings( child.textContent );
            break;

          case 'technique_common':
            var accessor = getElementsByTagName( child, 'accessor' )[ 0 ];

            if ( accessor !== undefined ) {

              data.stride = parseInt( accessor.getAttribute( 'stride' ) );

            }
            break;

        }

      }

      return data;

    }

    function parseGeometryVertices( xml ) {

      var data = {};

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );

      }

      return data;

    }

    function parseGeometryPrimitive( xml ) {

      var primitive = {
        type: xml.nodeName,
        material: xml.getAttribute( 'material' ),
        count: parseInt( xml.getAttribute( 'count' ) ),
        inputs: {},
        stride: 0
      };

      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'input':
            var id = parseId( child.getAttribute( 'source' ) );
            var semantic = child.getAttribute( 'semantic' );
            var offset = parseInt( child.getAttribute( 'offset' ) );
            primitive.inputs[ semantic ] = { id: id, offset: offset };
            primitive.stride = Math.max( primitive.stride, offset + 1 );
            break;

          case 'vcount':
            primitive.vcount = parseInts( child.textContent );
            break;

          case 'p':
            primitive.p = parseInts( child.textContent );
            break;

        }

      }

      return primitive;

    }

    function groupPrimitives( primitives ) {

      var build = {};

      for ( var i = 0; i < primitives.length; i ++ ) {

        var primitive = primitives[ i ];

        if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];

        build[ primitive.type ].push( primitive );

      }

      return build;

    }

    function buildGeometry( data ) {

      var build = {};

      var sources = data.sources;
      var vertices = data.vertices;
      var primitives = data.primitives;

      if ( primitives.length === 0 ) return {};

      // our goal is to create one buffer geoemtry for a single type of primitives
      // first, we group all primitives by their type

      var groupedPrimitives = groupPrimitives( primitives );

      for ( var type in groupedPrimitives ) {

        // second, we create for each type of primitives (polylist,triangles or lines) a buffer geometry

        build[ type ] = buildGeometryType( groupedPrimitives[ type ], sources, vertices );

      }

      return build;

    }

    function buildGeometryType( primitives, sources, vertices ) {

      var build = {};

      var position = { array: [], stride: 0 };
      var normal = { array: [], stride: 0 };
      var uv = { array: [], stride: 0 };
      var color = { array: [], stride: 0 };

      var skinIndex = { array: [], stride: 4 };
      var skinWeight = { array: [], stride: 4 };

      var geometry = new THREE.BufferGeometry();

      var materialKeys = [];

      var start = 0, count = 0;

      for ( var p = 0; p < primitives.length; p ++ ) {

        var primitive = primitives[ p ];
        var inputs = primitive.inputs;
        var triangleCount = 1;

        if ( primitive.vcount && primitive.vcount[ 0 ] === 4 ) {

          triangleCount = 2; // one quad -> two triangles

        }

        // groups

        if ( primitive.type === 'lines' || primitive.type === 'linestrips' ) {

          count = primitive.count * 2;

        } else {

          count = primitive.count * 3 * triangleCount;

        }

        geometry.addGroup( start, count, p );
        start += count;

        // material

        if ( primitive.material ) {

          materialKeys.push( primitive.material );

        }

        // geometry data

        for ( var name in inputs ) {

          var input = inputs[ name ];

          switch ( name ) {

            case 'VERTEX':
              for ( var key in vertices ) {

                var id = vertices[ key ];

                switch ( key ) {

                  case 'POSITION':
                    buildGeometryData( primitive, sources[ id ], input.offset, position.array );
                    position.stride = sources[ id ].stride;

                    if ( sources.skinWeights && sources.skinIndices ) {

                      buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );
                      buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );

                    }
                    break;

                  case 'NORMAL':
                    buildGeometryData( primitive, sources[ id ], input.offset, normal.array );
                    normal.stride = sources[ id ].stride;
                    break;

                  case 'COLOR':
                    buildGeometryData( primitive, sources[ id ], input.offset, color.array );
                    color.stride = sources[ id ].stride;
                    break;

                  case 'TEXCOORD':
                    buildGeometryData( primitive, sources[ id ], input.offset, uv.array );
                    uv.stride = sources[ id ].stride;
                    break;

                  default:
                    console.warn( 'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key );

                }

              }
              break;

            case 'NORMAL':
              buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );
              normal.stride = sources[ input.id ].stride;
              break;

            case 'COLOR':
              buildGeometryData( primitive, sources[ input.id ], input.offset, color.array );
              color.stride = sources[ input.id ].stride;
              break;

            case 'TEXCOORD':
              buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );
              uv.stride = sources[ input.id ].stride;
              break;

          }

        }

      }

      // build geometry

      if ( position.array.length > 0 ) geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );
      if ( normal.array.length > 0 ) geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );
      if ( color.array.length > 0 ) geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );
      if ( uv.array.length > 0 ) geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );

      if ( skinIndex.array.length > 0 ) geometry.addAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );
      if ( skinWeight.array.length > 0 ) geometry.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );

      build.data = geometry;
      build.type = primitives[ 0 ].type;
      build.materialKeys = materialKeys;

      return build;

    }

    function buildGeometryData( primitive, source, offset, array ) {

      var indices = primitive.p;
      var stride = primitive.stride;
      var vcount = primitive.vcount;

      function pushVector( i ) {

        var index = indices[ i + offset ] * sourceStride;
        var length = index + sourceStride;

        for ( ; index < length; index ++ ) {

          array.push( sourceArray[ index ] );

        }

      }

      var maxcount = 0;

      var sourceArray = source.array;
      var sourceStride = source.stride;

      if ( primitive.vcount !== undefined ) {

        var index = 0;

        for ( var i = 0, l = vcount.length; i < l; i ++ ) {

          var count = vcount[ i ];

          if ( count === 4 ) {

            var a = index + stride * 0;
            var b = index + stride * 1;
            var c = index + stride * 2;
            var d = index + stride * 3;

            pushVector( a ); pushVector( b ); pushVector( d );
            pushVector( b ); pushVector( c ); pushVector( d );

          } else if ( count === 3 ) {

            var a = index + stride * 0;
            var b = index + stride * 1;
            var c = index + stride * 2;

            pushVector( a ); pushVector( b ); pushVector( c );

          } else {

            maxcount = Math.max( maxcount, count );

          }

          index += stride * count;

        }

        if ( maxcount > 0 ) {

          console.log( 'THREE.ColladaLoader: Geometry has faces with more than 4 vertices.' );

        }

      } else {

        for ( var i = 0, l = indices.length; i < l; i += stride ) {

          pushVector( i );

        }

      }

    }

    function getGeometry( id ) {

      return getBuild( library.geometries[ id ], buildGeometry );

    }

    // kinematics

    function parseKinematicsModel( xml ) {

      var data = {
        name: xml.getAttribute( 'name' ) || '',
        joints: {},
        links: []
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'technique_common':
            parseKinematicsTechniqueCommon( child, data );
            break;

        }

      }

      library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;

    }

    function buildKinematicsModel( data ) {

      if ( data.build !== undefined ) return data.build;

      return data;

    }

    function getKinematicsModel( id ) {

      return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );

    }

    function parseKinematicsTechniqueCommon( xml, data ) {

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'joint':
            data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );
            break;

          case 'link':
            data.links.push( parseKinematicsLink( child ) );
            break;

        }

      }

    }

    function parseKinematicsJoint( xml ) {

      var data;

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'prismatic':
          case 'revolute':
            data = parseKinematicsJointParameter( child );
            break;

        }

      }

      return data;

    }

    function parseKinematicsJointParameter( xml, data ) {

      var data = {
        sid: xml.getAttribute( 'sid' ),
        name: xml.getAttribute( 'name' ) || '',
        axis: new THREE.Vector3(),
        limits: {
          min: 0,
          max: 0
        },
        type: xml.nodeName,
        static: false,
        zeroPosition: 0,
        middlePosition: 0
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'axis':
            var array = parseFloats( child.textContent );
            data.axis.fromArray( array );
            break;
          case 'limits':
            var max = child.getElementsByTagName( 'max' )[ 0 ];
            var min = child.getElementsByTagName( 'min' )[ 0 ];

            data.limits.max = parseFloat( max.textContent );
            data.limits.min = parseFloat( min.textContent );
            break;

        }

      }

      // if min is equal to or greater than max, consider the joint static

      if ( data.limits.min >= data.limits.max ) {

        data.static = true;

      }

      // calculate middle position

      data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;

      return data;

    }

    function parseKinematicsLink( xml ) {

      var data = {
        sid: xml.getAttribute( 'sid' ),
        name: xml.getAttribute( 'name' ) || '',
        attachments: [],
        transforms: []
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'attachment_full':
            data.attachments.push( parseKinematicsAttachment( child ) );
            break;

          case 'matrix':
          case 'translate':
          case 'rotate':
            data.transforms.push( parseKinematicsTransform( child ) );
            break;

        }

      }

      return data;

    }

    function parseKinematicsAttachment( xml ) {

      var data = {
        joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),
        transforms: [],
        links: []
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'link':
            data.links.push( parseKinematicsLink( child ) );
            break;

          case 'matrix':
          case 'translate':
          case 'rotate':
            data.transforms.push( parseKinematicsTransform( child ) );
            break;

        }

      }

      return data;

    }

    function parseKinematicsTransform( xml ) {

      var data = {
        type: xml.nodeName
      };

      var array = parseFloats( xml.textContent );

      switch ( data.type ) {

        case 'matrix':
          data.obj = new THREE.Matrix4();
          data.obj.fromArray( array ).transpose();
          break;

        case 'translate':
          data.obj = new THREE.Vector3();
          data.obj.fromArray( array );
          break;

        case 'rotate':
          data.obj = new THREE.Vector3();
          data.obj.fromArray( array );
          data.angle = THREE.Math.degToRad( array[ 3 ] );
          break;

      }

      return data;

    }

    function parseKinematicsScene( xml ) {

      var data = {
        bindJointAxis: []
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'bind_joint_axis':
            data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );
            break;

        }

      }

      library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;

    }

    function parseKinematicsBindJointAxis( xml ) {

      var data = {
        target: xml.getAttribute( 'target' ).split( '/' ).pop()
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'axis':
            var param = child.getElementsByTagName( 'param' )[ 0 ];
            data.axis = param.textContent;
            var tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];
            data.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );
            break;

        }

      }

      return data;

    }

    function buildKinematicsScene( data ) {

      if ( data.build !== undefined ) return data.build;

      return data;

    }

    function getKinematicsScene( id ) {

      return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );

    }

    function setupKinematics() {

      var kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];
      var kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];
      var visualSceneId = Object.keys( library.visualScenes )[ 0 ];

      if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;

      var kinematicsModel = getKinematicsModel( kinematicsModelId );
      var kinematicsScene = getKinematicsScene( kinematicsSceneId );
      var visualScene = getVisualScene( visualSceneId );

      var bindJointAxis = kinematicsScene.bindJointAxis;
      var jointMap = {};

      for ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {

        var axis = bindJointAxis[ i ];

        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'

        var targetElement = collada.querySelector( '[sid="' + axis.target + '"]' );

        if ( targetElement ) {

          // get the parent of the transfrom element

          var parentVisualElement = targetElement.parentElement;

          // connect the joint of the kinematics model with the element in the visual scene

          connect( axis.jointIndex, parentVisualElement );

        }

      }

      function connect( jointIndex, visualElement ) {

        var visualElementName = visualElement.getAttribute( 'name' );
        var joint = kinematicsModel.joints[ jointIndex ];

        visualScene.traverse( function ( object ) {

          if ( object.name === visualElementName ) {

            jointMap[ jointIndex ] = {
              object: object,
              transforms: buildTransformList( visualElement ),
              joint: joint,
              position: joint.zeroPosition
            };

          }

        } );

      }

      var m0 = new THREE.Matrix4();

      kinematics = {

        joints: kinematicsModel && kinematicsModel.joints,

        getJointValue: function ( jointIndex ) {

          var jointData = jointMap[ jointIndex ];

          if ( jointData ) {

            return jointData.position;

          } else {

            console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\'t exist.' );

          }

        },

        setJointValue: function ( jointIndex, value ) {

          var jointData = jointMap[ jointIndex ];

          if ( jointData ) {

            var joint = jointData.joint;

            if ( value > joint.limits.max || value < joint.limits.min ) {

              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );

            } else if ( joint.static ) {

              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );

            } else {

              var object = jointData.object;
              var axis = joint.axis;
              var transforms = jointData.transforms;

              matrix.identity();

              // each update, we have to apply all transforms in the correct order

              for ( var i = 0; i < transforms.length; i ++ ) {

                var transform = transforms[ i ];

                // if there is a connection of the transform node with a joint, apply the joint value

                if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {

                  switch ( joint.type ) {

                    case 'revolute':
                      matrix.multiply( m0.makeRotationAxis( axis, THREE.Math.degToRad( value ) ) );
                      break;

                    case 'prismatic':
                      matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );
                      break;

                    default:
                      console.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );
                      break;

                  }

                } else {

                  switch ( transform.type ) {

                    case 'matrix':
                      matrix.multiply( transform.obj );
                      break;

                    case 'translate':
                      matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );
                      break;

                    case 'scale':
                      matrix.scale( transform.obj );
                      break;

                    case 'rotate':
                      matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );
                      break;

                  }

                }

              }

              object.matrix.copy( matrix );
              object.matrix.decompose( object.position, object.quaternion, object.scale );

              jointMap[ jointIndex ].position = value;

            }

          } else {

            console.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );

          }

        }

      };

    }

    function buildTransformList( node ) {

      var transforms = [];

      var xml = collada.querySelector( '[id="' + node.id + '"]' );

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'matrix':
            var array = parseFloats( child.textContent );
            var matrix = new THREE.Matrix4().fromArray( array ).transpose();
            transforms.push( {
              sid: child.getAttribute( 'sid' ),
              type: child.nodeName,
              obj: matrix
            } );
            break;

          case 'translate':
          case 'scale':
            var array = parseFloats( child.textContent );
            var vector = new THREE.Vector3().fromArray( array );
            transforms.push( {
              sid: child.getAttribute( 'sid' ),
              type: child.nodeName,
              obj: vector
            } );
            break;

          case 'rotate':
            var array = parseFloats( child.textContent );
            var vector = new THREE.Vector3().fromArray( array );
            var angle = THREE.Math.degToRad( array[ 3 ] );
            transforms.push( {
              sid: child.getAttribute( 'sid' ),
              type: child.nodeName,
              obj: vector,
              angle: angle
            } );
            break;

        }

      }

      return transforms;

    }

    // nodes

    var matrix = new THREE.Matrix4();
    var vector = new THREE.Vector3();

    function parseNode( xml ) {

      var data = {
        name: xml.getAttribute( 'name' ),
        type: xml.getAttribute( 'type' ),
        id: xml.getAttribute( 'id' ),
        sid: xml.getAttribute( 'sid' ),
        matrix: new THREE.Matrix4(),
        nodes: [],
        instanceCameras: [],
        instanceControllers: [],
        instanceLights: [],
        instanceGeometries: [],
        instanceNodes: [],
        transforms: {}
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        if ( child.nodeType !== 1 ) continue;

        switch ( child.nodeName ) {

          case 'node':

            if ( child.hasAttribute( 'id' ) ) {

              data.nodes.push( child.getAttribute( 'id' ) );
              parseNode( child );

            }

            break;

          case 'instance_camera':
            data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );
            break;

          case 'instance_controller':
            data.instanceControllers.push( parseNodeInstance( child ) );
            break;

          case 'instance_light':
            data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );
            break;

          case 'instance_geometry':
            data.instanceGeometries.push( parseNodeInstance( child ) );
            break;

          case 'instance_node':
            data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );
            break;

          case 'matrix':
            var array = parseFloats( child.textContent );
            data.matrix.multiply( matrix.fromArray( array ).transpose() );
            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
            break;

          case 'translate':
            var array = parseFloats( child.textContent );
            vector.fromArray( array );
            data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );
            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
            break;

          case 'rotate':
            var array = parseFloats( child.textContent );
            var angle = THREE.Math.degToRad( array[ 3 ] );
            data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );
            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
            break;

          case 'scale':
            var array = parseFloats( child.textContent );
            data.matrix.scale( vector.fromArray( array ) );
            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
            break;

          case 'extra':
            break;

          default:
            console.log( child );

        }

      }

      if ( xml.hasAttribute( 'id' ) ) {

        library.nodes[ xml.getAttribute( 'id' ) ] = data;

      }

      return data;

    }

    function parseNodeInstance( xml ) {

      var data = {
        id: parseId( xml.getAttribute( 'url' ) ),
        materials: {},
        skeletons: []
      };

      for ( var i = 0; i < xml.childNodes.length; i ++ ) {

        var child = xml.childNodes[ i ];

        switch ( child.nodeName ) {

          case 'bind_material':
            var instances = child.getElementsByTagName( 'instance_material' );

            for ( var j = 0; j < instances.length; j ++ ) {

              var instance = instances[ j ];
              var symbol = instance.getAttribute( 'symbol' );
              var target = instance.getAttribute( 'target' );

              data.materials[ symbol ] = parseId( target );

            }

            break;

          case 'skeleton':
            data.skeletons.push( parseId( child.textContent ) );
            break;

          default:
            break;

        }

      }

      return data;

    }

    function buildSkeleton( skeletons, joints ) {

      var boneData = [];
      var sortedBoneData = [];

      var i, j, data;

      // a skeleton can have multiple root bones. collada expresses this
      // situtation with multiple "skeleton" tags per controller instance

      for ( i = 0; i < skeletons.length; i ++ ) {

        var skeleton = skeletons[ i ];
        var root = getNode( skeleton );

        // setup bone data for a single bone hierarchy

        buildBoneHierarchy( root, joints, boneData );

      }

      // sort bone data (the order is defined in the corresponding controller)

      for ( i = 0; i < joints.length; i ++ ) {

        for ( j = 0; j < boneData.length; j ++ ) {

          data = boneData[ j ];

          if ( data.bone.name === joints[ i ].name ) {

            sortedBoneData[ i ] = data;
            data.processed = true;
            break;

          }

        }

      }

      // add unprocessed bone data at the end of the list

      for ( i = 0; i < boneData.length; i ++ ) {

        data = boneData[ i ];

        if ( data.processed === false ) {

          sortedBoneData.push( data );
          data.processed = true;

        }

      }

      // setup arrays for skeleton creation

      var bones = [];
      var boneInverses = [];

      for ( i = 0; i < sortedBoneData.length; i ++ ) {

        data = sortedBoneData[ i ];

        bones.push( data.bone );
        boneInverses.push( data.boneInverse );

      }

      return new THREE.Skeleton( bones, boneInverses );

    }

    function buildBoneHierarchy( root, joints, boneData ) {

      // setup bone data from visual scene

      root.traverse( function ( object ) {

        if ( object.isBone === true ) {

          var boneInverse;

          // retrieve the boneInverse from the controller data

          for ( var i = 0; i < joints.length; i ++ ) {

            var joint = joints[ i ];

            if ( joint.name === object.name ) {

              boneInverse = joint.boneInverse;
              break;

            }

          }

          if ( boneInverse === undefined ) {

            // Unfortunately, there can be joints in the visual scene that are not part of the
            // corresponding controller. In this case, we have to create a dummy boneInverse matrix
            // for the respective bone. This bone won't affect any vertices, because there are no skin indices
            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to
            // ensure a correct animation of the model.

             boneInverse = new THREE.Matrix4();

          }

          boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );

        }

      } );

    }

    function buildNode( data ) {

      var objects = [];

      var matrix = data.matrix;
      var nodes = data.nodes;
      var type = data.type;
      var instanceCameras = data.instanceCameras;
      var instanceControllers = data.instanceControllers;
      var instanceLights = data.instanceLights;
      var instanceGeometries = data.instanceGeometries;
      var instanceNodes = data.instanceNodes;

      // nodes

      for ( var i = 0, l = nodes.length; i < l; i ++ ) {

        objects.push( getNode( nodes[ i ] ) );

      }

      // instance cameras

      for ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {

        objects.push( getCamera( instanceCameras[ i ] ).clone() );

      }

      // instance controllers

      for ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {

        var instance = instanceControllers[ i ];
        var controller = getController( instance.id );
        var geometries = getGeometry( controller.id );
        var newObjects = buildObjects( geometries, instance.materials );

        var skeletons = instance.skeletons;
        var joints = controller.skin.joints;

        var skeleton = buildSkeleton( skeletons, joints );

        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {

          var object = newObjects[ j ];

          if ( object.isSkinnedMesh ) {

            object.bind( skeleton, controller.skin.bindMatrix );
            object.normalizeSkinWeights();

          }

          objects.push( object );

        }

      }

      // instance lights

      for ( var i = 0, l = instanceLights.length; i < l; i ++ ) {

        objects.push( getLight( instanceLights[ i ] ).clone() );

      }

      // instance geometries

      for ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {

        var instance = instanceGeometries[ i ];

        // a single geometry instance in collada can lead to multiple object3Ds.
        // this is the case when primitives are combined like triangles and lines

        var geometries = getGeometry( instance.id );
        var newObjects = buildObjects( geometries, instance.materials );

        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {

          objects.push( newObjects[ j ] );

        }

      }

      // instance nodes

      for ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {

        objects.push( getNode( instanceNodes[ i ] ).clone() );

      }

      var object;

      if ( nodes.length === 0 && objects.length === 1 ) {

        object = objects[ 0 ];

      } else {

        object = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();

        for ( var i = 0; i < objects.length; i ++ ) {

          object.add( objects[ i ] );

        }

      }

      object.name = ( type === 'JOINT' ) ? data.sid : data.name;
      object.matrix.copy( matrix );
      object.matrix.decompose( object.position, object.quaternion, object.scale );

      return object;

    }

    function resolveMaterialBinding( keys, instanceMaterials ) {

      var materials = [];

      for ( var i = 0, l = keys.length; i < l; i ++ ) {

        var id = instanceMaterials[ keys[ i ] ];
        materials.push( getMaterial( id ) );

      }

      return materials;

    }

    function buildObjects( geometries, instanceMaterials ) {

      var objects = [];

      for ( var type in geometries ) {

        var geometry = geometries[ type ];

        var materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );

        // handle case if no materials are defined

        if ( materials.length === 0 ) {

          if ( type === 'lines' || type === 'linestrips' ) {

            materials.push( new THREE.LineBasicMaterial() );

          } else {

            materials.push( new THREE.MeshPhongMaterial() );

          }

        }

        // regard skinning

        var skinning = ( geometry.data.attributes.skinIndex !== undefined );

        if ( skinning ) {

          for ( var i = 0, l = materials.length; i < l; i ++ ) {

            materials[ i ].skinning = true;

          }

        }

        // choose between a single or multi materials (material array)

        var material = ( materials.length === 1 ) ? materials[ 0 ] : materials;

        // now create a specific 3D object

        var object;

        switch ( type ) {

          case 'lines':
            object = new THREE.LineSegments( geometry.data, material );
            break;

          case 'linestrips':
            object = new THREE.Line( geometry.data, material );
            break;

          case 'triangles':
          case 'polylist':
            if ( skinning ) {

              object = new THREE.SkinnedMesh( geometry.data, material );

            } else {

              object = new THREE.Mesh( geometry.data, material );

            }
            break;

        }

        objects.push( object );

      }

      return objects;

    }

    function getNode( id ) {

      return getBuild( library.nodes[ id ], buildNode );

    }

    // visual scenes

    function parseVisualScene( xml ) {

      var data = {
        name: xml.getAttribute( 'name' ),
        children: []
      };

      var elements = getElementsByTagName( xml, 'node' );

      for ( var i = 0; i < elements.length; i ++ ) {

        data.children.push( parseNode( elements[ i ] ) );

      }

      library.visualScenes[ xml.getAttribute( 'id' ) ] = data;

    }

    function buildVisualScene( data ) {

      var group = new THREE.Group();
      group.name = data.name;

      var children = data.children;

      for ( var i = 0; i < children.length; i ++ ) {

        var child = children[ i ];

        if ( child.id === null ) {

          group.add( buildNode( child ) );

        } else {

          // if there is an ID, let's try to get the finished build (e.g. joints are already build)

          group.add( getNode( child.id ) );

        }

      }

      return group;

    }

    function getVisualScene( id ) {

      return getBuild( library.visualScenes[ id ], buildVisualScene );

    }

    // scenes

    function parseScene( xml ) {

      var instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];
      return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );

    }

    function setupAnimations() {

      var clips = library.clips;

      if ( isEmpty( clips ) === true ) {

        if ( isEmpty( library.animations ) === false ) {

          // if there are animations but no clips, we create a default clip for playback

          var tracks = [];

          for ( var id in library.animations ) {

            var animationTracks = getAnimation( id );

            for ( var i = 0, l = animationTracks.length; i < l; i ++ ) {

              tracks.push( animationTracks[ i ] );

            }

          }

          animations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );

        }

      } else {

        for ( var id in clips ) {

          animations.push( getAnimationClip( id ) );

        }

      }

    }

    console.time( 'THREE.ColladaLoader' );

    if ( text.length === 0 ) {

      return { scene: new THREE.Scene() };

    }

    console.time( 'THREE.ColladaLoader: DOMParser' );

    var xml = new DOMParser().parseFromString( text, 'application/xml' );

    console.timeEnd( 'THREE.ColladaLoader: DOMParser' );

    var collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];

    // metadata

    var version = collada.getAttribute( 'version' );
    console.log( 'THREE.ColladaLoader: File version', version );

    var asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );
    var textureLoader = new THREE.TextureLoader( this.manager );
    textureLoader.setPath( path ).setCrossOrigin( this.crossOrigin );

    //

    var animations = [];
    var kinematics = {};

    //

    var library = {
      animations: {},
      clips: {},
      controllers: {},
      images: {},
      effects: {},
      materials: {},
      cameras: {},
      lights: {},
      geometries: {},
      nodes: {},
      visualScenes: {},
      kinematicsModels: {},
      kinematicsScenes: {}
    };

    console.time( 'THREE.ColladaLoader: Parse' );

    parseLibrary( collada, 'library_animations', 'animation', parseAnimation );
    parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );
    parseLibrary( collada, 'library_controllers', 'controller', parseController );
    parseLibrary( collada, 'library_images', 'image', parseImage );
    parseLibrary( collada, 'library_effects', 'effect', parseEffect );
    parseLibrary( collada, 'library_materials', 'material', parseMaterial );
    parseLibrary( collada, 'library_cameras', 'camera', parseCamera );
    parseLibrary( collada, 'library_lights', 'light', parseLight );
    parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );
    parseLibrary( collada, 'library_nodes', 'node', parseNode );
    parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );
    parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );
    parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );

    console.timeEnd( 'THREE.ColladaLoader: Parse' );

    console.time( 'THREE.ColladaLoader: Build' );

    buildLibrary( library.animations, buildAnimation );
    buildLibrary( library.clips, buildAnimationClip );
    buildLibrary( library.controllers, buildController );
    buildLibrary( library.images, buildImage );
    buildLibrary( library.effects, buildEffect );
    buildLibrary( library.materials, buildMaterial );
    buildLibrary( library.cameras, buildCamera );
    buildLibrary( library.lights, buildLight );
    buildLibrary( library.geometries, buildGeometry );
    buildLibrary( library.visualScenes, buildVisualScene );

    console.timeEnd( 'THREE.ColladaLoader: Build' );

    setupAnimations();
    setupKinematics();

    var scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );

    if ( asset.upAxis === 'Z_UP' ) {

      scene.rotation.x = - Math.PI / 2;

    }

    scene.scale.multiplyScalar( asset.unit );

    console.timeEnd( 'THREE.ColladaLoader' );

    return {
      animations: animations,
      kinematics: kinematics,
      library: library,
      scene: scene
    };

  }

};

/**
 * @author Kyle-Larson https://github.com/Kyle-Larson
 * @author Takahiro https://github.com/takahirox
 *
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or to be any version in Binary format.
 *
 * Supports:
 *  Mesh Generation (Positional Data)
 *  Normal Data (Per Vertex Drawing Instance)
 *  UV Data (Per Vertex Drawing Instance)
 *  Skinning
 *  Animation
 *  - Separated Animations based on stacks.
 *  - Skeletal & Non-Skeletal Animations
 *  NURBS (Open, Closed and Periodic forms)
 *
 * Needs Support:
 *  Indexed Buffers
 *  PreRotation support.
 */

( function () {

  /**
   * Generates a loader for loading FBX files from URL and parsing into
   * a THREE.Group.
   * @param {THREE.LoadingManager} manager - Loading Manager for loader to use.
   */
  THREE.FBXLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  };

  Object.assign( THREE.FBXLoader.prototype, {

    /**
     * Loads an ASCII/Binary FBX file from URL and parses into a THREE.Group.
     * THREE.Group will have an animations property of AnimationClips
     * of the different animations exported with the FBX.
     * @param {string} url - URL of the FBX file.
     * @param {function(THREE.Group):void} onLoad - Callback for when FBX file is loaded and parsed.
     * @param {function(ProgressEvent):void} onProgress - Callback fired periodically when file is being retrieved from server.
     * @param {function(Event):void} onError - Callback fired when error occurs (Currently only with retrieving file, not with parsing errors).
     */
    load: function ( url, onLoad, onProgress, onError ) {

      var self = this;

      var resourceDirectory = THREE.Loader.prototype.extractUrlBase( url );

      var loader = new THREE.FileLoader( this.manager );
      loader.setResponseType( 'arraybuffer' );
      loader.load( url, function ( buffer ) {

        try {

          var scene = self.parse( buffer, resourceDirectory );

          onLoad( scene );

        } catch ( error ) {

          window.setTimeout( function () {

            if ( onError ) onError( error );

            self.manager.itemError( url );

          }, 0 );

        }

      }, onProgress, onError );

    },

    /**
     * Parses an ASCII/Binary FBX file and returns a THREE.Group.
     * THREE.Group will have an animations property of AnimationClips
     * of the different animations within the FBX file.
     * @param {ArrayBuffer} FBXBuffer - Contents of FBX file to parse.
     * @param {string} resourceDirectory - Directory to load external assets (e.g. textures ) from.
     * @returns {THREE.Group}
     */
    parse: function ( FBXBuffer, resourceDirectory ) {

      var FBXTree;

      if ( isFbxFormatBinary( FBXBuffer ) ) {

        FBXTree = new BinaryParser().parse( FBXBuffer );

      } else {

        var FBXText = convertArrayBufferToString( FBXBuffer );

        if ( ! isFbxFormatASCII( FBXText ) ) {

          throw new Error( 'THREE.FBXLoader: Unknown format.' );

        }

        if ( getFbxVersion( FBXText ) < 7000 ) {

          throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );

        }

        FBXTree = new TextParser().parse( FBXText );

      }

      // console.log( FBXTree );

      var connections = parseConnections( FBXTree );
      var images = parseImages( FBXTree );
      var textures = parseTextures( FBXTree, new THREE.TextureLoader( this.manager ).setPath( resourceDirectory ), images, connections );
      var materials = parseMaterials( FBXTree, textures, connections );
      var deformers = parseDeformers( FBXTree, connections );
      var geometryMap = parseGeometries( FBXTree, connections, deformers );
      var sceneGraph = parseScene( FBXTree, connections, deformers, geometryMap, materials );

      return sceneGraph;

    }

  } );

  /**
   * Parses map of relationships between objects.
   * @param {{Connections: { properties: { connections: [number, number, string][]}}}} FBXTree
   * @returns {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}
   */
  function parseConnections( FBXTree ) {

    /**
     * @type {Map<number, { parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}
     */
    var connectionMap = new Map();

    if ( 'Connections' in FBXTree ) {

      /**
       * @type {[number, number, string][]}
       */
      var connectionArray = FBXTree.Connections.properties.connections;
      for ( var connectionArrayIndex = 0, connectionArrayLength = connectionArray.length; connectionArrayIndex < connectionArrayLength; ++ connectionArrayIndex ) {

        var connection = connectionArray[ connectionArrayIndex ];

        if ( ! connectionMap.has( connection[ 0 ] ) ) {

          connectionMap.set( connection[ 0 ], {
            parents: [],
            children: []
          } );

        }

        var parentRelationship = { ID: connection[ 1 ], relationship: connection[ 2 ] };
        connectionMap.get( connection[ 0 ] ).parents.push( parentRelationship );

        if ( ! connectionMap.has( connection[ 1 ] ) ) {

          connectionMap.set( connection[ 1 ], {
            parents: [],
            children: []
          } );

        }

        var childRelationship = { ID: connection[ 0 ], relationship: connection[ 2 ] };
        connectionMap.get( connection[ 1 ] ).children.push( childRelationship );

      }

    }

    return connectionMap;

  }

  /**
   * Parses map of images referenced in FBXTree.
   * @param {{Objects: {subNodes: {Texture: Object.<string, FBXTextureNode>}}}} FBXTree
   * @returns {Map<number, string(image blob/data URL)>}
   */
  function parseImages( FBXTree ) {

    /**
     * @type {Map<number, string(image blob/data URL)>}
     */
    var imageMap = new Map();

    if ( 'Video' in FBXTree.Objects.subNodes ) {

      var videoNodes = FBXTree.Objects.subNodes.Video;

      for ( var nodeID in videoNodes ) {

        var videoNode = videoNodes[ nodeID ];

        // raw image data is in videoNode.properties.Content
        if ( 'Content' in videoNode.properties ) {

          var image = parseImage( videoNodes[ nodeID ] );
          imageMap.set( parseInt( nodeID ), image );

        }

      }

    }

    return imageMap;

  }

  /**
   * @param {videoNode} videoNode - Node to get texture image information from.
   * @returns {string} - image blob/data URL
   */
  function parseImage( videoNode ) {

    var content = videoNode.properties.Content;
    var fileName = videoNode.properties.RelativeFilename || videoNode.properties.Filename;
    var extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

    var type;

    switch ( extension ) {

      case 'bmp':

        type = 'image/bmp';
        break;

      case 'jpg':

        type = 'image/jpeg';
        break;

      case 'png':

        type = 'image/png';
        break;

      case 'tif':

        type = 'image/tiff';
        break;

      default:

        console.warn( 'FBXLoader: No support image type ' + extension );
        return;

    }

    if ( typeof content === 'string' ) {

      return 'data:' + type + ';base64,' + content;

    } else {

      var array = new Uint8Array( content );
      return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );

    }

  }

  /**
   * Parses map of textures referenced in FBXTree.
   * @param {{Objects: {subNodes: {Texture: Object.<string, FBXTextureNode>}}}} FBXTree
   * @param {THREE.TextureLoader} loader
   * @param {Map<number, string(image blob/data URL)>} imageMap
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @returns {Map<number, THREE.Texture>}
   */
  function parseTextures( FBXTree, loader, imageMap, connections ) {

    /**
     * @type {Map<number, THREE.Texture>}
     */
    var textureMap = new Map();

    if ( 'Texture' in FBXTree.Objects.subNodes ) {

      var textureNodes = FBXTree.Objects.subNodes.Texture;
      for ( var nodeID in textureNodes ) {

        var texture = parseTexture( textureNodes[ nodeID ], loader, imageMap, connections );
        textureMap.set( parseInt( nodeID ), texture );

      }

    }

    return textureMap;

  }

  /**
   * @param {textureNode} textureNode - Node to get texture information from.
   * @param {THREE.TextureLoader} loader
   * @param {Map<number, string(image blob/data URL)>} imageMap
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @returns {THREE.Texture}
   */
  function parseTexture( textureNode, loader, imageMap, connections ) {

    var FBX_ID = textureNode.id;

    var name = textureNode.name;

    var fileName;

    var filePath = textureNode.properties.FileName;
    var relativeFilePath = textureNode.properties.RelativeFilename;

    var children = connections.get( FBX_ID ).children;

    if ( children !== undefined && children.length > 0 && imageMap.has( children[ 0 ].ID ) ) {

      fileName = imageMap.get( children[ 0 ].ID );

    } else if ( relativeFilePath !== undefined && relativeFilePath[ 0 ] !== '/' &&
        relativeFilePath.match( /^[a-zA-Z]:/ ) === null ) {

      // use textureNode.properties.RelativeFilename
      // if it exists and it doesn't seem an absolute path

      fileName = relativeFilePath;

    } else {

      var split = filePath.split( /[\\\/]/ );

      if ( split.length > 0 ) {

        fileName = split[ split.length - 1 ];

      } else {

        fileName = filePath;

      }

    }

    var currentPath = loader.path;

    if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

      loader.setPath( undefined );

    }

    /**
     * @type {THREE.Texture}
     */
    var texture = loader.load( fileName );
    texture.name = name;
    texture.FBX_ID = FBX_ID;

    var wrapModeU = textureNode.properties.WrapModeU;
    var wrapModeV = textureNode.properties.WrapModeV;

    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
    // 0: repeat(default), 1: clamp

    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

    loader.setPath( currentPath );

    return texture;

  }

  /**
   * Parses map of Material information.
   * @param {{Objects: {subNodes: {Material: Object.<number, FBXMaterialNode>}}}} FBXTree
   * @param {Map<number, THREE.Texture>} textureMap
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @returns {Map<number, THREE.Material>}
   */
  function parseMaterials( FBXTree, textureMap, connections ) {

    var materialMap = new Map();

    if ( 'Material' in FBXTree.Objects.subNodes ) {

      var materialNodes = FBXTree.Objects.subNodes.Material;
      for ( var nodeID in materialNodes ) {

        var material = parseMaterial( materialNodes[ nodeID ], textureMap, connections );
        if ( material !== null ) materialMap.set( parseInt( nodeID ), material );

      }

    }

    return materialMap;

  }

  /**
   * Takes information from Material node and returns a generated THREE.Material
   * @param {FBXMaterialNode} materialNode
   * @param {Map<number, THREE.Texture>} textureMap
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @returns {THREE.Material}
   */
  function parseMaterial( materialNode, textureMap, connections ) {

    var FBX_ID = materialNode.id;
    var name = materialNode.attrName;
    var type = materialNode.properties.ShadingModel;

    //Case where FBXs wrap shading model in property object.
    if ( typeof type === 'object' ) {

      type = type.value;

    }

    // Seems like FBX can include unused materials which don't have any connections.
    // Ignores them so far.
    if ( ! connections.has( FBX_ID ) ) return null;

    var children = connections.get( FBX_ID ).children;

    var parameters = parseParameters( materialNode.properties, textureMap, children );

    var material;

    switch ( type.toLowerCase() ) {

      case 'phong':
        material = new THREE.MeshPhongMaterial();
        break;
      case 'lambert':
        material = new THREE.MeshLambertMaterial();
        break;
      default:
        console.warn( 'THREE.FBXLoader: No implementation given for material type %s in FBXLoader.js. Defaulting to standard material.', type );
        material = new THREE.MeshStandardMaterial( { color: 0x3300ff } );
        break;

    }

    material.setValues( parameters );
    material.name = name;

    return material;

  }

  /**
   * @typedef {{Diffuse: FBXVector3, Specular: FBXVector3, Shininess: FBXValue, Emissive: FBXVector3, EmissiveFactor: FBXValue, Opacity: FBXValue}} FBXMaterialProperties
   */
  /**
   * @typedef {{color: THREE.Color=, specular: THREE.Color=, shininess: number=, emissive: THREE.Color=, emissiveIntensity: number=, opacity: number=, transparent: boolean=, map: THREE.Texture=}} THREEMaterialParameterPack
   */
  /**
   * @param {FBXMaterialProperties} properties
   * @param {Map<number, THREE.Texture>} textureMap
   * @param {{ID: number, relationship: string}[]} childrenRelationships
   * @returns {THREEMaterialParameterPack}
   */
  function parseParameters( properties, textureMap, childrenRelationships ) {

    var parameters = {};

    if ( properties.Diffuse ) {

      parameters.color = parseColor( properties.Diffuse );

    }
    if ( properties.Specular ) {

      parameters.specular = parseColor( properties.Specular );

    }
    if ( properties.Shininess ) {

      parameters.shininess = properties.Shininess.value;

    }
    if ( properties.Emissive ) {

      parameters.emissive = parseColor( properties.Emissive );

    }
    if ( properties.EmissiveFactor ) {

      parameters.emissiveIntensity = properties.EmissiveFactor.value;

    }
    if ( properties.Opacity ) {

      parameters.opacity = properties.Opacity.value;

    }
    if ( parameters.opacity < 1.0 ) {

      parameters.transparent = true;

    }

    for ( var childrenRelationshipsIndex = 0, childrenRelationshipsLength = childrenRelationships.length; childrenRelationshipsIndex < childrenRelationshipsLength; ++ childrenRelationshipsIndex ) {

      var relationship = childrenRelationships[ childrenRelationshipsIndex ];

      var type = relationship.relationship;

      switch ( type ) {

        case 'DiffuseColor':
        case ' "DiffuseColor':
          parameters.map = textureMap.get( relationship.ID );
          break;

        case 'Bump':
        case ' "Bump':
          parameters.bumpMap = textureMap.get( relationship.ID );
          break;

        case 'NormalMap':
        case ' "NormalMap':
          parameters.normalMap = textureMap.get( relationship.ID );
          break;

        case 'AmbientColor':
        case 'EmissiveColor':
        case ' "AmbientColor':
        case ' "EmissiveColor':
        default:
          console.warn( 'THREE.FBXLoader: Unknown texture application of type %s, skipping texture.', type );
          break;

      }

    }

    return parameters;

  }

  /**
   * Generates map of Skeleton-like objects for use later when generating and binding skeletons.
   * @param {{Objects: {subNodes: {Deformer: Object.<number, FBXSubDeformerNode>}}}} FBXTree
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @returns {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>}
   */
  function parseDeformers( FBXTree, connections ) {

    var deformers = {};

    if ( 'Deformer' in FBXTree.Objects.subNodes ) {

      var DeformerNodes = FBXTree.Objects.subNodes.Deformer;

      for ( var nodeID in DeformerNodes ) {

        var deformerNode = DeformerNodes[ nodeID ];

        if ( deformerNode.attrType === 'Skin' ) {

          var conns = connections.get( parseInt( nodeID ) );
          var skeleton = parseSkeleton( conns, DeformerNodes );
          skeleton.FBX_ID = parseInt( nodeID );

          deformers[ nodeID ] = skeleton;

        }

      }

    }

    return deformers;

  }

  /**
   * Generates a "Skeleton Representation" of FBX nodes based on an FBX Skin Deformer's connections and an object containing SubDeformer nodes.
   * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} connections
   * @param {Object.<number, FBXSubDeformerNode>} DeformerNodes
   * @returns {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}}
   */
  function parseSkeleton( connections, DeformerNodes ) {

    var subDeformers = {};
    var children = connections.children;

    for ( var i = 0, l = children.length; i < l; ++ i ) {

      var child = children[ i ];

      var subDeformerNode = DeformerNodes[ child.ID ];

      var subDeformer = {
        FBX_ID: child.ID,
        index: i,
        indices: [],
        weights: [],
        transform: parseMatrixArray( subDeformerNode.subNodes.Transform.properties.a ),
        transformLink: parseMatrixArray( subDeformerNode.subNodes.TransformLink.properties.a ),
        linkMode: subDeformerNode.properties.Mode
      };

      if ( 'Indexes' in subDeformerNode.subNodes ) {

        subDeformer.indices = parseIntArray( subDeformerNode.subNodes.Indexes.properties.a );
        subDeformer.weights = parseFloatArray( subDeformerNode.subNodes.Weights.properties.a );

      }

      subDeformers[ child.ID ] = subDeformer;

    }

    return {
      map: subDeformers,
      bones: []
    };

  }

  /**
   * Generates Buffer geometries from geometry information in FBXTree, and generates map of THREE.BufferGeometries
   * @param {{Objects: {subNodes: {Geometry: Object.<number, FBXGeometryNode}}}} FBXTree
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformers
   * @returns {Map<number, THREE.BufferGeometry>}
   */
  function parseGeometries( FBXTree, connections, deformers ) {

    var geometryMap = new Map();

    if ( 'Geometry' in FBXTree.Objects.subNodes ) {

      var geometryNodes = FBXTree.Objects.subNodes.Geometry;

      for ( var nodeID in geometryNodes ) {

        var relationships = connections.get( parseInt( nodeID ) );
        var geo = parseGeometry( geometryNodes[ nodeID ], relationships, deformers );
        geometryMap.set( parseInt( nodeID ), geo );

      }

    }

    return geometryMap;

  }

  /**
   * Generates BufferGeometry from FBXGeometryNode.
   * @param {FBXGeometryNode} geometryNode
   * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships
   * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformers
   * @returns {THREE.BufferGeometry}
   */
  function parseGeometry( geometryNode, relationships, deformers ) {

    switch ( geometryNode.attrType ) {

      case 'Mesh':
        return parseMeshGeometry( geometryNode, relationships, deformers );
        break;

      case 'NurbsCurve':
        return parseNurbsGeometry( geometryNode );
        break;

    }

  }

  /**
   * Specialty function for parsing Mesh based Geometry Nodes.
   * @param {FBXGeometryNode} geometryNode
   * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships - Object representing relationships between specific geometry node and other nodes.
   * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformers - Map object of deformers and subDeformers by ID.
   * @returns {THREE.BufferGeometry}
   */
  function parseMeshGeometry( geometryNode, relationships, deformers ) {

    for ( var i = 0; i < relationships.children.length; ++ i ) {

      var deformer = deformers[ relationships.children[ i ].ID ];
      if ( deformer !== undefined ) break;

    }

    return genGeometry( geometryNode, deformer );

  }

  /**
   * @param {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}} deformer - Skeleton representation for geometry instance.
   * @returns {THREE.BufferGeometry}
   */
  function genGeometry( geometryNode, deformer ) {

    var geometry = new Geometry();

    var subNodes = geometryNode.subNodes;

    // First, each index is going to be its own vertex.

    var vertexBuffer = parseFloatArray( subNodes.Vertices.properties.a );
    var indexBuffer = parseIntArray( subNodes.PolygonVertexIndex.properties.a );

    if ( subNodes.LayerElementNormal ) {

      var normalInfo = getNormals( subNodes.LayerElementNormal[ 0 ] );

    }

    if ( subNodes.LayerElementUV ) {

      var uvInfo = getUVs( subNodes.LayerElementUV[ 0 ] );

    }

    if ( subNodes.LayerElementColor ) {

      var colorInfo = getColors( subNodes.LayerElementColor[ 0 ] );

    }

    if ( subNodes.LayerElementMaterial ) {

      var materialInfo = getMaterials( subNodes.LayerElementMaterial[ 0 ] );

    }

    var weightTable = {};

    if ( deformer ) {

      var subDeformers = deformer.map;

      for ( var key in subDeformers ) {

        var subDeformer = subDeformers[ key ];
        var indices = subDeformer.indices;

        for ( var j = 0; j < indices.length; j ++ ) {

          var index = indices[ j ];
          var weight = subDeformer.weights[ j ];

          if ( weightTable[ index ] === undefined ) weightTable[ index ] = [];

          weightTable[ index ].push( {
            id: subDeformer.index,
            weight: weight
          } );

        }

      }

    }

    var faceVertexBuffer = [];
    var polygonIndex = 0;
    var displayedWeightsWarning = false;

    for ( var polygonVertexIndex = 0; polygonVertexIndex < indexBuffer.length; polygonVertexIndex ++ ) {

      var vertexIndex = indexBuffer[ polygonVertexIndex ];

      var endOfFace = false;

      if ( vertexIndex < 0 ) {

        vertexIndex = vertexIndex ^ - 1;
        indexBuffer[ polygonVertexIndex ] = vertexIndex;
        endOfFace = true;

      }

      var vertex = new Vertex();
      var weightIndices = [];
      var weights = [];

      vertex.position.fromArray( vertexBuffer, vertexIndex * 3 );

      if ( deformer ) {

        if ( weightTable[ vertexIndex ] !== undefined ) {

          var array = weightTable[ vertexIndex ];

          for ( var j = 0, jl = array.length; j < jl; j ++ ) {

            weights.push( array[ j ].weight );
            weightIndices.push( array[ j ].id );

          }

        }

        if ( weights.length > 4 ) {

          if ( ! displayedWeightsWarning ) {

            console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
            displayedWeightsWarning = true;

          }

          var WIndex = [ 0, 0, 0, 0 ];
          var Weight = [ 0, 0, 0, 0 ];

          weights.forEach( function ( weight, weightIndex ) {

            var currentWeight = weight;
            var currentIndex = weightIndices[ weightIndex ];

            Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

              if ( currentWeight > comparedWeight ) {

                comparedWeightArray[ comparedWeightIndex ] = currentWeight;
                currentWeight = comparedWeight;

                var tmp = WIndex[ comparedWeightIndex ];
                WIndex[ comparedWeightIndex ] = currentIndex;
                currentIndex = tmp;

              }

            } );

          } );

          weightIndices = WIndex;
          weights = Weight;

        }

        for ( var i = weights.length; i < 4; ++ i ) {

          weights[ i ] = 0;
          weightIndices[ i ] = 0;

        }

        vertex.skinWeights.fromArray( weights );
        vertex.skinIndices.fromArray( weightIndices );

      }

      if ( normalInfo ) {

        vertex.normal.fromArray( getData( polygonVertexIndex, polygonIndex, vertexIndex, normalInfo ) );

      }

      if ( uvInfo ) {

        vertex.uv.fromArray( getData( polygonVertexIndex, polygonIndex, vertexIndex, uvInfo ) );

      }

      if ( colorInfo ) {

        vertex.color.fromArray( getData( polygonVertexIndex, polygonIndex, vertexIndex, colorInfo ) );

      }

      faceVertexBuffer.push( vertex );

      if ( endOfFace ) {

        var face = new Face();
        face.genTrianglesFromVertices( faceVertexBuffer );

        if ( materialInfo !== undefined ) {

          var materials = getData( polygonVertexIndex, polygonIndex, vertexIndex, materialInfo );
          face.materialIndex = materials[ 0 ];

        } else {

          // Seems like some models don't have materialInfo(subNodes.LayerElementMaterial).
          // Set 0 in such a case.
          face.materialIndex = 0;

        }

        geometry.faces.push( face );
        faceVertexBuffer = [];
        polygonIndex ++;

        endOfFace = false;

      }

    }

    /**
     * @type {{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}
     */
    var bufferInfo = geometry.flattenToBuffers();

    var geo = new THREE.BufferGeometry();
    geo.name = geometryNode.name;
    geo.addAttribute( 'position', new THREE.Float32BufferAttribute( bufferInfo.vertexBuffer, 3 ) );

    if ( bufferInfo.normalBuffer.length > 0 ) {

      geo.addAttribute( 'normal', new THREE.Float32BufferAttribute( bufferInfo.normalBuffer, 3 ) );

    }
    if ( bufferInfo.uvBuffer.length > 0 ) {

      geo.addAttribute( 'uv', new THREE.Float32BufferAttribute( bufferInfo.uvBuffer, 2 ) );

    }
    if ( subNodes.LayerElementColor ) {

      geo.addAttribute( 'color', new THREE.Float32BufferAttribute( bufferInfo.colorBuffer, 3 ) );

    }

    if ( deformer ) {

      geo.addAttribute( 'skinIndex', new THREE.Float32BufferAttribute( bufferInfo.skinIndexBuffer, 4 ) );

      geo.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( bufferInfo.skinWeightBuffer, 4 ) );

      geo.FBX_Deformer = deformer;

    }

    // Convert the material indices of each vertex into rendering groups on the geometry.

    var materialIndexBuffer = bufferInfo.materialIndexBuffer;
    var prevMaterialIndex = materialIndexBuffer[ 0 ];
    var startIndex = 0;

    for ( var i = 0; i < materialIndexBuffer.length; ++ i ) {

      if ( materialIndexBuffer[ i ] !== prevMaterialIndex ) {

        geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

        prevMaterialIndex = materialIndexBuffer[ i ];
        startIndex = i;

      }

    }

    return geo;

  }

  /**
   * Parses normal information for geometry.
   * @param {FBXGeometryNode} geometryNode
   * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
   */
  function getNormals( NormalNode ) {

    var mappingType = NormalNode.properties.MappingInformationType;
    var referenceType = NormalNode.properties.ReferenceInformationType;
    var buffer = parseFloatArray( NormalNode.subNodes.Normals.properties.a );
    var indexBuffer = [];
    if ( referenceType === 'IndexToDirect' ) {

      if ( 'NormalIndex' in NormalNode.subNodes ) {

        indexBuffer = parseIntArray( NormalNode.subNodes.NormalIndex.properties.a );

      } else if ( 'NormalsIndex' in NormalNode.subNodes ) {

        indexBuffer = parseIntArray( NormalNode.subNodes.NormalsIndex.properties.a );

      }

    }

    return {
      dataSize: 3,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };

  }

  /**
   * Parses UV information for geometry.
   * @param {FBXGeometryNode} geometryNode
   * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
   */
  function getUVs( UVNode ) {

    var mappingType = UVNode.properties.MappingInformationType;
    var referenceType = UVNode.properties.ReferenceInformationType;
    var buffer = parseFloatArray( UVNode.subNodes.UV.properties.a );
    var indexBuffer = [];
    if ( referenceType === 'IndexToDirect' ) {

      indexBuffer = parseIntArray( UVNode.subNodes.UVIndex.properties.a );

    }

    return {
      dataSize: 2,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };

  }

  /**
   * Parses Vertex Color information for geometry.
   * @param {FBXGeometryNode} geometryNode
   * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
   */
  function getColors( ColorNode ) {

    var mappingType = ColorNode.properties.MappingInformationType;
    var referenceType = ColorNode.properties.ReferenceInformationType;
    var buffer = parseFloatArray( ColorNode.subNodes.Colors.properties.a );
    var indexBuffer = [];
    if ( referenceType === 'IndexToDirect' ) {

      indexBuffer = parseFloatArray( ColorNode.subNodes.ColorIndex.properties.a );

    }

    return {
      dataSize: 4,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };

  }

  /**
   * Parses material application information for geometry.
   * @param {FBXGeometryNode}
   * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
   */
  function getMaterials( MaterialNode ) {

    var mappingType = MaterialNode.properties.MappingInformationType;
    var referenceType = MaterialNode.properties.ReferenceInformationType;

    if ( mappingType === 'NoMappingInformation' ) {

      return {
        dataSize: 1,
        buffer: [ 0 ],
        indices: [ 0 ],
        mappingType: 'AllSame',
        referenceType: referenceType
      };

    }

    var materialIndexBuffer = parseIntArray( MaterialNode.subNodes.Materials.properties.a );

    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
    // we expect.  So we create an intermediate buffer that points to the index in the buffer,
    // for conforming with the other functions we've written for other data.
    var materialIndices = [];

    for ( var materialIndexBufferIndex = 0, materialIndexBufferLength = materialIndexBuffer.length; materialIndexBufferIndex < materialIndexBufferLength; ++ materialIndexBufferIndex ) {

      materialIndices.push( materialIndexBufferIndex );

    }

    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType: mappingType,
      referenceType: referenceType
    };

  }

  /**
   * Function uses the infoObject and given indices to return value array of object.
   * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
   * @param {number} polygonIndex - Index of polygon in geometry.
   * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
   * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
   * @returns {number[]}
   */

  var dataArray = [];

  var GetData = {

    ByPolygonVertex: {

      /**
       * Function uses the infoObject and given indices to return value array of object.
       * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
       * @param {number} polygonIndex - Index of polygon in geometry.
       * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
       * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
       * @returns {number[]}
       */
      Direct: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var from = ( polygonVertexIndex * infoObject.dataSize );
        var to = ( polygonVertexIndex * infoObject.dataSize ) + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      },

      /**
       * Function uses the infoObject and given indices to return value array of object.
       * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
       * @param {number} polygonIndex - Index of polygon in geometry.
       * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
       * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
       * @returns {number[]}
       */
      IndexToDirect: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var index = infoObject.indices[ polygonVertexIndex ];
        var from = ( index * infoObject.dataSize );
        var to = ( index * infoObject.dataSize ) + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      }

    },

    ByPolygon: {

      /**
       * Function uses the infoObject and given indices to return value array of object.
       * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
       * @param {number} polygonIndex - Index of polygon in geometry.
       * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
       * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
       * @returns {number[]}
       */
      Direct: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var from = polygonIndex * infoObject.dataSize;
        var to = polygonIndex * infoObject.dataSize + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      },

      /**
       * Function uses the infoObject and given indices to return value array of object.
       * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
       * @param {number} polygonIndex - Index of polygon in geometry.
       * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
       * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
       * @returns {number[]}
       */
      IndexToDirect: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var index = infoObject.indices[ polygonIndex ];
        var from = index * infoObject.dataSize;
        var to = index * infoObject.dataSize + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      }

    },

    ByVertice: {

      Direct: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var from = ( vertexIndex * infoObject.dataSize );
        var to = ( vertexIndex * infoObject.dataSize ) + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      }

    },

    AllSame: {

      /**
       * Function uses the infoObject and given indices to return value array of object.
       * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
       * @param {number} polygonIndex - Index of polygon in geometry.
       * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
       * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
       * @returns {number[]}
       */
      IndexToDirect: function ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

        var from = infoObject.indices[ 0 ] * infoObject.dataSize;
        var to = infoObject.indices[ 0 ] * infoObject.dataSize + infoObject.dataSize;

        // return infoObject.buffer.slice( from, to );
        return slice( dataArray, infoObject.buffer, from, to );

      }

    }

  };

  function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

    return GetData[ infoObject.mappingType ][ infoObject.referenceType ]( polygonVertexIndex, polygonIndex, vertexIndex, infoObject );

  }

  /**
   * Specialty function for parsing NurbsCurve based Geometry Nodes.
   * @param {FBXGeometryNode} geometryNode
   * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships
   * @returns {THREE.BufferGeometry}
   */
  function parseNurbsGeometry( geometryNode ) {

    if ( THREE.NURBSCurve === undefined ) {

      console.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );
      return new THREE.BufferGeometry();

    }

    var order = parseInt( geometryNode.properties.Order );

    if ( isNaN( order ) ) {

      console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geometryNode.properties.Order, geometryNode.id );
      return new THREE.BufferGeometry();

    }

    var degree = order - 1;

    var knots = parseFloatArray( geometryNode.subNodes.KnotVector.properties.a );
    var controlPoints = [];
    var pointsValues = parseFloatArray( geometryNode.subNodes.Points.properties.a );

    for ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {

      controlPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );

    }

    var startKnot, endKnot;

    if ( geometryNode.properties.Form === 'Closed' ) {

      controlPoints.push( controlPoints[ 0 ] );

    } else if ( geometryNode.properties.Form === 'Periodic' ) {

      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;

      for ( var i = 0; i < degree; ++ i ) {

        controlPoints.push( controlPoints[ i ] );

      }

    }

    var curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
    var vertices = curve.getPoints( controlPoints.length * 7 );

    var positions = new Float32Array( vertices.length * 3 );

    for ( var i = 0, l = vertices.length; i < l; ++ i ) {

      vertices[ i ].toArray( positions, i * 3 );

    }

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    return geometry;

  }

  /**
   * Finally generates Scene graph and Scene graph Objects.
   * @param {{Objects: {subNodes: {Model: Object.<number, FBXModelNode>}}}} FBXTree
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformers
   * @param {Map<number, THREE.BufferGeometry>} geometryMap
   * @param {Map<number, THREE.Material>} materialMap
   * @returns {THREE.Group}
   */
  function parseScene( FBXTree, connections, deformers, geometryMap, materialMap ) {

    var sceneGraph = new THREE.Group();

    var ModelNode = FBXTree.Objects.subNodes.Model;

    /**
     * @type {Array.<THREE.Object3D>}
     */
    var modelArray = [];

    /**
     * @type {Map.<number, THREE.Object3D>}
     */
    var modelMap = new Map();

    for ( var nodeID in ModelNode ) {

      var id = parseInt( nodeID );
      var node = ModelNode[ nodeID ];
      var conns = connections.get( id );
      var model = null;

      for ( var i = 0; i < conns.parents.length; ++ i ) {

        for ( var FBX_ID in deformers ) {

          var deformer = deformers[ FBX_ID ];
          var subDeformers = deformer.map;
          var subDeformer = subDeformers[ conns.parents[ i ].ID ];

          if ( subDeformer ) {

            var model2 = model;
            model = new THREE.Bone();
            deformer.bones[ subDeformer.index ] = model;

            // seems like we need this not to make non-connected bone, maybe?
            // TODO: confirm
            if ( model2 !== null ) model.add( model2 );

          }

        }

      }

      if ( ! model ) {

        switch ( node.attrType ) {

          case 'Camera':
            /* ***********
            * Supported camera types:
            * PerspectiveCamera
            * OrthographicCamera
            ************** */
            var cameraAttribute;

            for ( var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++ childrenIndex ) {

              var childID = conns.children[ childrenIndex ].ID;

              var attr = FBXTree.Objects.subNodes.NodeAttribute[ childID ];

              if ( attr !== undefined && attr.properties !== undefined ) {

                cameraAttribute = attr.properties;

              }

            }

            if ( cameraAttribute === undefined ) {

              model = new THREE.Object3D();

            } else {

              var type = 0;
              if ( cameraAttribute.CameraProjectionType !== undefined && ( cameraAttribute.CameraProjectionType.value === '1' || cameraAttribute.CameraProjectionType.value === 1 ) ) {

                type = 1;

              }

              var nearClippingPlane = 1;
              if ( cameraAttribute.NearPlane !== undefined ) {

                nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

              }

              var farClippingPlane = 1000;
              if ( cameraAttribute.FarPlane !== undefined ) {

                farClippingPlane = cameraAttribute.FarPlane.value / 1000;

              }


              var width = window.innerWidth;
              var height = window.innerHeight;

              if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

                width = parseFloat( cameraAttribute.AspectWidth.value );
                height = parseFloat( cameraAttribute.AspectHeight.value );

              }

              var aspect = width / height;

              var fov = 45;
              if ( cameraAttribute.FieldOfView !== undefined ) {

                fov = parseFloat( cameraAttribute.FieldOfView.value );

              }

              switch ( type ) {

                case '0': // Perspective
                case 0:
                  model = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
                  break;

                case '1': // Orthographic
                case 1:
                  model = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );
                  break;

                default:
                  console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );
                  model = new THREE.Object3D();
                  break;

              }

            }

            break;

          case 'Light':
            /* ***********
            * Supported light types:
            * DirectionalLight
            * PointLight
            * SpotLight
            ************** */

            var lightAttribute;

            for ( var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++ childrenIndex ) {

              var childID = conns.children[ childrenIndex ].ID;

              var attr = FBXTree.Objects.subNodes.NodeAttribute[ childID ];

              if ( attr !== undefined && attr.properties !== undefined ) {

                lightAttribute = attr.properties;

              }

            }

            if ( lightAttribute === undefined ) {

              model = new THREE.Object3D();

            } else {

              var type;

              // LightType can be undefined for Point lights
              if ( lightAttribute.LightType === undefined ) {

                type = 0;

              } else {

                type = lightAttribute.LightType.value;

              }

              var color = 0xffffff;

              if ( lightAttribute.Color !== undefined ) {

                var temp = lightAttribute.Color.value.split( ',' );

                var r = parseFloat( temp[ 0 ] );
                var g = parseFloat( temp[ 1 ] );
                var b = parseFloat( temp[ 1 ] );

                color = new THREE.Color( r, g, b );

              }

              var intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

              // light disabled
              if ( lightAttribute.CastLightOnObject !== undefined && ( lightAttribute.CastLightOnObject.value === '0' || lightAttribute.CastLightOnObject.value === 0 ) ) {

                intensity = 0;

              }

              var distance = 0;
              if ( lightAttribute.FarAttenuationEnd !== undefined ) {

                if ( lightAttribute.EnableFarAttenuation !== undefined && ( lightAttribute.EnableFarAttenuation.value === '0' || lightAttribute.EnableFarAttenuation.value === 0 ) ) {

                  distance = 0;

                } else {

                  distance = lightAttribute.FarAttenuationEnd.value / 1000;

                }

              }

              // TODO
              // could be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
              var decay = 1;

              switch ( type ) {

                case '0': // Point
                case 0:
                  model = new THREE.PointLight( color, intensity, distance, decay );
                  break;

                case '1': // Directional
                case 1:
                  model = new THREE.DirectionalLight( color, intensity );
                  break;

                case '2': // Spot
                case 2:
                  var angle = Math.PI / 3;

                  if ( lightAttribute.InnerAngle !== undefined ) {

                    angle = THREE.Math.degToRad( lightAttribute.InnerAngle.value );

                  }

                  var penumbra = 0;
                  if ( lightAttribute.OuterAngle !== undefined ) {

                    // TODO: this is not correct - FBX calculates outer and inner angle in degrees
                    // with OuterAngle > InnerAngle && OuterAngle <= Math.PI
                    // while three.js uses a penumbra between (0, 1) to attenuate the inner angle
                    penumbra = THREE.Math.degToRad( lightAttribute.OuterAngle.value );
                    penumbra = Math.max( penumbra, 1 );

                  }

                  model = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );
                  break;

                default:
                  console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );
                  model = new THREE.PointLight( color, intensity );
                  break;

              }

              if ( lightAttribute.CastShadows !== undefined && ( lightAttribute.CastShadows.value === '1' || lightAttribute.CastShadows.value === 1 ) ) {

                model.castShadow = true;

              }

            }

            break;

          case 'Mesh':
            /**
             * @type {?THREE.BufferGeometry}
             */
            var geometry = null;

            /**
             * @type {THREE.MultiMaterial|THREE.Material}
             */
            var material = null;

            /**
             * @type {Array.<THREE.Material>}
             */
            var materials = [];

            for ( var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++ childrenIndex ) {

              var child = conns.children[ childrenIndex ];

              if ( geometryMap.has( child.ID ) ) {

                geometry = geometryMap.get( child.ID );

              }

              if ( materialMap.has( child.ID ) ) {

                materials.push( materialMap.get( child.ID ) );

              }

            }
            if ( materials.length > 1 ) {

              material = materials;

            } else if ( materials.length > 0 ) {

              material = materials[ 0 ];

            } else {

              material = new THREE.MeshStandardMaterial( { color: 0x3300ff } );
              materials.push( material );

            }
            if ( 'color' in geometry.attributes ) {

              for ( var materialIndex = 0, numMaterials = materials.length; materialIndex < numMaterials; ++ materialIndex ) {

                materials[ materialIndex ].vertexColors = THREE.VertexColors;

              }

            }
            if ( geometry.FBX_Deformer ) {

              for ( var materialsIndex = 0, materialsLength = materials.length; materialsIndex < materialsLength; ++ materialsIndex ) {

                materials[ materialsIndex ].skinning = true;

              }
              model = new THREE.SkinnedMesh( geometry, material );

            } else {

              model = new THREE.Mesh( geometry, material );

            }
            break;

          case 'NurbsCurve':
            var geometry = null;

            for ( var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++ childrenIndex ) {

              var child = conns.children[ childrenIndex ];

              if ( geometryMap.has( child.ID ) ) {

                geometry = geometryMap.get( child.ID );

              }

            }

            // FBX does not list materials for Nurbs lines, so we'll just put our own in here.
            material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 5 } );
            model = new THREE.Line( geometry, material );
            break;

          default:
            model = new THREE.Object3D();
            break;

        }

      }

      model.name = node.attrName.replace( /:/, '' ).replace( /_/, '' ).replace( /-/, '' );
      model.FBX_ID = id;

      modelArray.push( model );
      modelMap.set( id, model );

    }

    for ( var modelArrayIndex = 0, modelArrayLength = modelArray.length; modelArrayIndex < modelArrayLength; ++ modelArrayIndex ) {

      var model = modelArray[ modelArrayIndex ];

      var node = ModelNode[ model.FBX_ID ];

      if ( 'Lcl_Translation' in node.properties ) {

        model.position.fromArray( parseFloatArray( node.properties.Lcl_Translation.value ) );

      }

      if ( 'Lcl_Rotation' in node.properties ) {

        var rotation = parseFloatArray( node.properties.Lcl_Rotation.value ).map( degreeToRadian );
        rotation.push( 'ZYX' );
        model.rotation.fromArray( rotation );

      }

      if ( 'Lcl_Scaling' in node.properties ) {

        model.scale.fromArray( parseFloatArray( node.properties.Lcl_Scaling.value ) );

      }

      if ( 'PreRotation' in node.properties ) {

        var preRotations = new THREE.Euler().setFromVector3( parseVector3( node.properties.PreRotation ).multiplyScalar( DEG2RAD ), 'ZYX' );
        preRotations = new THREE.Quaternion().setFromEuler( preRotations );
        var currentRotation = new THREE.Quaternion().setFromEuler( model.rotation );
        preRotations.multiply( currentRotation );
        model.rotation.setFromQuaternion( preRotations, 'ZYX' );

      }

      if ( 'LookAtProperty' in node.properties ) {

        var conns = connections.get( model.FBX_ID );

        for ( var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++ childrenIndex ) {

          var child = conns.children[ childrenIndex ];

          if ( child.relationship === 'LookAtProperty' || child.relationship === ' "LookAtProperty' ) {

            var lookAtTarget = FBXTree.Objects.subNodes.Model[ child.ID ];

            if ( 'Lcl_Translation' in lookAtTarget.properties ) {

              var pos = lookAtTarget.properties.Lcl_Translation.value.split( ',' ).map( function ( val ) {

                return parseFloat( val );

              } );

              // DirectionalLight, SpotLight
              if ( model.target !== undefined ) {

                model.target.position.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );
                sceneGraph.add( model.target );


              } else { // Cameras and other Object3Ds

                model.lookAt( new THREE.Vector3( pos[ 0 ], pos[ 1 ], pos[ 2 ] ) );

              }

            }

          }

        }

      }

      var conns = connections.get( model.FBX_ID );
      for ( var parentIndex = 0; parentIndex < conns.parents.length; parentIndex ++ ) {

        var pIndex = findIndex( modelArray, function ( mod ) {

          return mod.FBX_ID === conns.parents[ parentIndex ].ID;

        } );
        if ( pIndex > - 1 ) {

          modelArray[ pIndex ].add( model );
          break;

        }

      }
      if ( model.parent === null ) {

        sceneGraph.add( model );

      }

    }


    // Now with the bones created, we can update the skeletons and bind them to the skinned meshes.
    sceneGraph.updateMatrixWorld( true );

    // Put skeleton into bind pose.
    var BindPoseNode = FBXTree.Objects.subNodes.Pose;
    for ( var nodeID in BindPoseNode ) {

      if ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {

        BindPoseNode = BindPoseNode[ nodeID ];
        break;

      }

    }
    if ( BindPoseNode ) {

      var PoseNode = BindPoseNode.subNodes.PoseNode;
      var worldMatrices = new Map();

      for ( var PoseNodeIndex = 0, PoseNodeLength = PoseNode.length; PoseNodeIndex < PoseNodeLength; ++ PoseNodeIndex ) {

        var node = PoseNode[ PoseNodeIndex ];

        var rawMatWrd = parseMatrixArray( node.subNodes.Matrix.properties.a );

        worldMatrices.set( parseInt( node.id ), rawMatWrd );

      }

    }

    for ( var FBX_ID in deformers ) {

      var deformer = deformers[ FBX_ID ];
      var subDeformers = deformer.map;

      for ( var key in subDeformers ) {

        var subDeformer = subDeformers[ key ];
        var subDeformerIndex = subDeformer.index;

        /**
         * @type {THREE.Bone}
         */
        var bone = deformer.bones[ subDeformerIndex ];
        if ( ! worldMatrices.has( bone.FBX_ID ) ) {

          break;

        }
        var mat = worldMatrices.get( bone.FBX_ID );
        bone.matrixWorld.copy( mat );

      }

      // Now that skeleton is in bind pose, bind to model.
      deformer.skeleton = new THREE.Skeleton( deformer.bones );

      var conns = connections.get( deformer.FBX_ID );
      var parents = conns.parents;

      for ( var parentsIndex = 0, parentsLength = parents.length; parentsIndex < parentsLength; ++ parentsIndex ) {

        var parent = parents[ parentsIndex ];

        if ( geometryMap.has( parent.ID ) ) {

          var geoID = parent.ID;
          var geoConns = connections.get( geoID );

          for ( var i = 0; i < geoConns.parents.length; ++ i ) {

            if ( modelMap.has( geoConns.parents[ i ].ID ) ) {

              var model = modelMap.get( geoConns.parents[ i ].ID );
              //ASSERT model typeof SkinnedMesh
              model.bind( deformer.skeleton, model.matrixWorld );
              break;

            }

          }

        }

      }

    }

    //Skeleton is now bound, return objects to starting
    //world positions.
    sceneGraph.updateMatrixWorld( true );

    // Silly hack with the animation parsing.  We're gonna pretend the scene graph has a skeleton
    // to attach animations to, since FBXs treat animations as animations for the entire scene,
    // not just for individual objects.
    sceneGraph.skeleton = {
      bones: modelArray
    };

    var animations = parseAnimations( FBXTree, connections, sceneGraph );

    addAnimations( sceneGraph, animations );


    // Parse ambient color - if it's not set to black (default), create an ambient light
    var ambientColor = FBXTree.GlobalSettings.properties.AmbientColor.value;
    var r = ambientColor[ 0 ];
    var g = ambientColor[ 1 ];
    var b = ambientColor[ 2 ];

    if ( r !== 0 || g !== 0 || b !== 0 ) {

      var color = new THREE.Color( r, g, b );
      sceneGraph.add( new THREE.AmbientLight( color, 1 ) );

    }

    return sceneGraph;

  }

  /**
   * Parses animation information from FBXTree and generates an AnimationInfoObject.
   * @param {{Objects: {subNodes: {AnimationCurveNode: any, AnimationCurve: any, AnimationLayer: any, AnimationStack: any}}}} FBXTree
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   */
  function parseAnimations( FBXTree, connections, sceneGraph ) {

    var rawNodes = FBXTree.Objects.subNodes.AnimationCurveNode;
    var rawCurves = FBXTree.Objects.subNodes.AnimationCurve;
    var rawLayers = FBXTree.Objects.subNodes.AnimationLayer;
    var rawStacks = FBXTree.Objects.subNodes.AnimationStack;

    /**
     * @type {{
         curves: Map<number, {
         T: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        },
         R: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        },
         S: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        }
       }>,
       layers: Map<number, {
        T: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        },
        R: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        },
        S: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        }
        }[]>,
       stacks: Map<number, {
         name: string,
         layers: {
          T: {
            id: number;
            attr: string;
            internalID: number;
            attrX: boolean;
            attrY: boolean;
            attrZ: boolean;
            containerBoneID: number;
            containerID: number;
            curves: {
              x: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              y: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              z: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
            };
          };
          R: {
            id: number;
            attr: string;
            internalID: number;
            attrX: boolean;
            attrY: boolean;
            attrZ: boolean;
            containerBoneID: number;
            containerID: number;
            curves: {
              x: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              y: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              z: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
            };
          };
          S: {
            id: number;
            attr: string;
            internalID: number;
            attrX: boolean;
            attrY: boolean;
            attrZ: boolean;
            containerBoneID: number;
            containerID: number;
            curves: {
              x: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              y: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
              z: {
                version: any;
                id: number;
                internalID: number;
                times: number[];
                values: number[];
                attrFlag: number[];
                attrData: number[];
              };
            };
          };
        }[][],
       length: number,
       frames: number }>,
       length: number,
       fps: number,
       frames: number
     }}
     */
    var returnObject = {
      curves: new Map(),
      layers: {},
      stacks: {},
      length: 0,
      fps: 30,
      frames: 0
    };

    /**
     * @type {Array.<{
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
      }>}
     */
    var animationCurveNodes = [];
    for ( var nodeID in rawNodes ) {

      if ( nodeID.match( /\d+/ ) ) {

        var animationNode = parseAnimationNode( FBXTree, rawNodes[ nodeID ], connections, sceneGraph );
        animationCurveNodes.push( animationNode );

      }

    }

    /**
     * @type {Map.<number, {
        id: number,
        attr: string,
        internalID: number,
        attrX: boolean,
        attrY: boolean,
        attrZ: boolean,
        containerBoneID: number,
        containerID: number,
        curves: {
          x: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
          },
          y: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
          },
          z: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
          }
        }
      }>}
     */
    var tmpMap = new Map();
    for ( var animationCurveNodeIndex = 0; animationCurveNodeIndex < animationCurveNodes.length; ++ animationCurveNodeIndex ) {

      if ( animationCurveNodes[ animationCurveNodeIndex ] === null ) {

        continue;

      }
      tmpMap.set( animationCurveNodes[ animationCurveNodeIndex ].id, animationCurveNodes[ animationCurveNodeIndex ] );

    }


    /**
     * @type {{
        version: any,
        id: number,
        internalID: number,
        times: number[],
        values: number[],
        attrFlag: number[],
        attrData: number[],
      }[]}
     */
    var animationCurves = [];
    for ( nodeID in rawCurves ) {

      if ( nodeID.match( /\d+/ ) ) {

        var animationCurve = parseAnimationCurve( rawCurves[ nodeID ] );

        // seems like this check would be necessary?
        if ( ! connections.has( animationCurve.id ) ) continue;

        animationCurves.push( animationCurve );

        var firstParentConn = connections.get( animationCurve.id ).parents[ 0 ];
        var firstParentID = firstParentConn.ID;
        var firstParentRelationship = firstParentConn.relationship;
        var axis = '';

        if ( firstParentRelationship.match( /X/ ) ) {

          axis = 'x';

        } else if ( firstParentRelationship.match( /Y/ ) ) {

          axis = 'y';

        } else if ( firstParentRelationship.match( /Z/ ) ) {

          axis = 'z';

        } else {

          continue;

        }

        tmpMap.get( firstParentID ).curves[ axis ] = animationCurve;

      }

    }

    tmpMap.forEach( function ( curveNode ) {

      var id = curveNode.containerBoneID;
      if ( ! returnObject.curves.has( id ) ) {

        returnObject.curves.set( id, { T: null, R: null, S: null } );

      }
      returnObject.curves.get( id )[ curveNode.attr ] = curveNode;
      if ( curveNode.attr === 'R' ) {

        var curves = curveNode.curves;

        // Seems like some FBX files have AnimationCurveNode
        // which doesn't have any connected AnimationCurve.
        // Setting animation parameter for them here.

        if ( curves.x === null ) {

          curves.x = {
            version: null,
            times: [ 0.0 ],
            values: [ 0.0 ]
          };

        }

        if ( curves.y === null ) {

          curves.y = {
            version: null,
            times: [ 0.0 ],
            values: [ 0.0 ]
          };

        }

        if ( curves.z === null ) {

          curves.z = {
            version: null,
            times: [ 0.0 ],
            values: [ 0.0 ]
          };

        }

        curves.x.values = curves.x.values.map( degreeToRadian );
        curves.y.values = curves.y.values.map( degreeToRadian );
        curves.z.values = curves.z.values.map( degreeToRadian );

        if ( curveNode.preRotations !== null ) {

          var preRotations = new THREE.Euler().setFromVector3( curveNode.preRotations, 'ZYX' );
          preRotations = new THREE.Quaternion().setFromEuler( preRotations );
          var frameRotation = new THREE.Euler();
          var frameRotationQuaternion = new THREE.Quaternion();
          for ( var frame = 0; frame < curves.x.times.length; ++ frame ) {

            frameRotation.set( curves.x.values[ frame ], curves.y.values[ frame ], curves.z.values[ frame ], 'ZYX' );
            frameRotationQuaternion.setFromEuler( frameRotation ).premultiply( preRotations );
            frameRotation.setFromQuaternion( frameRotationQuaternion, 'ZYX' );
            curves.x.values[ frame ] = frameRotation.x;
            curves.y.values[ frame ] = frameRotation.y;
            curves.z.values[ frame ] = frameRotation.z;

          }

        }

      }

    } );

    for ( var nodeID in rawLayers ) {

      /**
       * @type {{
        T: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        },
        R: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        },
        S: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          },
        }
        }[]}
       */
      var layer = [];
      var children = connections.get( parseInt( nodeID ) ).children;

      for ( var childIndex = 0; childIndex < children.length; childIndex ++ ) {

        // Skip lockInfluenceWeights
        if ( tmpMap.has( children[ childIndex ].ID ) ) {

          var curveNode = tmpMap.get( children[ childIndex ].ID );
          var boneID = curveNode.containerBoneID;
          if ( layer[ boneID ] === undefined ) {

            layer[ boneID ] = {
              T: null,
              R: null,
              S: null
            };

          }

          layer[ boneID ][ curveNode.attr ] = curveNode;

        }

      }

      returnObject.layers[ nodeID ] = layer;

    }

    for ( var nodeID in rawStacks ) {

      var layers = [];
      var children = connections.get( parseInt( nodeID ) ).children;
      var timestamps = { max: 0, min: Number.MAX_VALUE };

      for ( var childIndex = 0; childIndex < children.length; ++ childIndex ) {

        var currentLayer = returnObject.layers[ children[ childIndex ].ID ];

        if ( currentLayer !== undefined ) {

          layers.push( currentLayer );

          for ( var currentLayerIndex = 0, currentLayerLength = currentLayer.length; currentLayerIndex < currentLayerLength; ++ currentLayerIndex ) {

            var layer = currentLayer[ currentLayerIndex ];

            if ( layer ) {

              getCurveNodeMaxMinTimeStamps( layer, timestamps );

            }

          }

        }

      }

      // Do we have an animation clip with actual length?
      if ( timestamps.max > timestamps.min ) {

        returnObject.stacks[ nodeID ] = {
          name: rawStacks[ nodeID ].attrName,
          layers: layers,
          length: timestamps.max - timestamps.min,
          frames: ( timestamps.max - timestamps.min ) * 30
        };

      }

    }

    return returnObject;

  }

  /**
   * @param {Object} FBXTree
   * @param {{id: number, attrName: string, properties: Object<string, any>}} animationCurveNode
   * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
   * @param {{skeleton: {bones: {FBX_ID: number}[]}}} sceneGraph
   */
  function parseAnimationNode( FBXTree, animationCurveNode, connections, sceneGraph ) {

    var rawModels = FBXTree.Objects.subNodes.Model;

    var returnObject = {
      /**
       * @type {number}
       */
      id: animationCurveNode.id,

      /**
       * @type {string}
       */
      attr: animationCurveNode.attrName,

      /**
       * @type {number}
       */
      internalID: animationCurveNode.id,

      /**
       * @type {boolean}
       */
      attrX: false,

      /**
       * @type {boolean}
       */
      attrY: false,

      /**
       * @type {boolean}
       */
      attrZ: false,

      /**
       * @type {number}
       */
      containerBoneID: - 1,

      /**
       * @type {number}
       */
      containerID: - 1,

      curves: {
        x: null,
        y: null,
        z: null
      },

      /**
       * @type {number[]}
       */
      preRotations: null
    };

    if ( returnObject.attr.match( /S|R|T/ ) ) {

      for ( var attributeKey in animationCurveNode.properties ) {

        if ( attributeKey.match( /X/ ) ) {

          returnObject.attrX = true;

        }
        if ( attributeKey.match( /Y/ ) ) {

          returnObject.attrY = true;

        }
        if ( attributeKey.match( /Z/ ) ) {

          returnObject.attrZ = true;

        }

      }

    } else {

      return null;

    }

    var conns = connections.get( returnObject.id );
    var containerIndices = conns.parents;

    for ( var containerIndicesIndex = containerIndices.length - 1; containerIndicesIndex >= 0; -- containerIndicesIndex ) {

      var boneID = findIndex( sceneGraph.skeleton.bones, function ( bone ) {

        return bone.FBX_ID === containerIndices[ containerIndicesIndex ].ID;

      } );
      if ( boneID > - 1 ) {

        returnObject.containerBoneID = boneID;
        returnObject.containerID = containerIndices[ containerIndicesIndex ].ID;
        var model = rawModels[ returnObject.containerID.toString() ];
        if ( 'PreRotation' in model.properties ) {

          returnObject.preRotations = parseVector3( model.properties.PreRotation ).multiplyScalar( Math.PI / 180 );

        }
        break;

      }

    }

    return returnObject;

  }

  /**
   * @param {{id: number, subNodes: {KeyTime: {properties: {a: string}}, KeyValueFloat: {properties: {a: string}}, KeyAttrFlags: {properties: {a: string}}, KeyAttrDataFloat: {properties: {a: string}}}}} animationCurve
   */
  function parseAnimationCurve( animationCurve ) {

    return {
      version: null,
      id: animationCurve.id,
      internalID: animationCurve.id,
      times: parseFloatArray( animationCurve.subNodes.KeyTime.properties.a ).map( convertFBXTimeToSeconds ),
      values: parseFloatArray( animationCurve.subNodes.KeyValueFloat.properties.a ),

      attrFlag: parseIntArray( animationCurve.subNodes.KeyAttrFlags.properties.a ),
      attrData: parseFloatArray( animationCurve.subNodes.KeyAttrDataFloat.properties.a )
    };

  }

  /**
   * Sets the maxTimeStamp and minTimeStamp variables if it has timeStamps that are either larger or smaller
   * than the max or min respectively.
   * @param {{
        T: {
            id: number,
            attr: string,
            internalID: number,
            attrX: boolean,
            attrY: boolean,
            attrZ: boolean,
            containerBoneID: number,
            containerID: number,
            curves: {
                x: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                y: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                z: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
            },
        },
        R: {
            id: number,
            attr: string,
            internalID: number,
            attrX: boolean,
            attrY: boolean,
            attrZ: boolean,
            containerBoneID: number,
            containerID: number,
            curves: {
                x: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                y: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                z: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
            },
        },
        S: {
            id: number,
            attr: string,
            internalID: number,
            attrX: boolean,
            attrY: boolean,
            attrZ: boolean,
            containerBoneID: number,
            containerID: number,
            curves: {
                x: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                y: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
                z: {
                    version: any,
                    id: number,
                    internalID: number,
                    times: number[],
                    values: number[],
                    attrFlag: number[],
                    attrData: number[],
                },
            },
        },
    }} layer
   */
  function getCurveNodeMaxMinTimeStamps( layer, timestamps ) {

    if ( layer.R ) {

      getCurveMaxMinTimeStamp( layer.R.curves, timestamps );

    }
    if ( layer.S ) {

      getCurveMaxMinTimeStamp( layer.S.curves, timestamps );

    }
    if ( layer.T ) {

      getCurveMaxMinTimeStamp( layer.T.curves, timestamps );

    }

  }

  /**
   * Sets the maxTimeStamp and minTimeStamp if one of the curve's time stamps
   * exceeds the maximum or minimum.
   * @param {{
        x: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
        },
        y: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
        },
        z: {
            version: any,
            id: number,
            internalID: number,
            times: number[],
            values: number[],
            attrFlag: number[],
            attrData: number[],
        }
    }} curve
   */
  function getCurveMaxMinTimeStamp( curve, timestamps ) {

    if ( curve.x ) {

      getCurveAxisMaxMinTimeStamps( curve.x, timestamps );

    }
    if ( curve.y ) {

      getCurveAxisMaxMinTimeStamps( curve.y, timestamps );

    }
    if ( curve.z ) {

      getCurveAxisMaxMinTimeStamps( curve.z, timestamps );

    }

  }

  /**
   * Sets the maxTimeStamp and minTimeStamp if one of its timestamps exceeds the maximum or minimum.
   * @param {{times: number[]}} axis
   */
  function getCurveAxisMaxMinTimeStamps( axis, timestamps ) {

    timestamps.max = axis.times[ axis.times.length - 1 ] > timestamps.max ? axis.times[ axis.times.length - 1 ] : timestamps.max;
    timestamps.min = axis.times[ 0 ] < timestamps.min ? axis.times[ 0 ] : timestamps.min;

  }

  /**
   * @param {{
    curves: Map<number, {
      T: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
      R: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
      S: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
    }>;
    layers: Map<number, {
      T: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
      R: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
      S: {
        id: number;
        attr: string;
        internalID: number;
        attrX: boolean;
        attrY: boolean;
        attrZ: boolean;
        containerBoneID: number;
        containerID: number;
        curves: {
          x: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          y: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
          z: {
            version: any;
            id: number;
            internalID: number;
            times: number[];
            values: number[];
            attrFlag: number[];
            attrData: number[];
          };
        };
      };
    }[]>;
    stacks: Map<number, {
      name: string;
      layers: {
        T: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        };
        R: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        };
        S: {
          id: number;
          attr: string;
          internalID: number;
          attrX: boolean;
          attrY: boolean;
          attrZ: boolean;
          containerBoneID: number;
          containerID: number;
          curves: {
            x: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            y: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
            z: {
              version: any;
              id: number;
              internalID: number;
              times: number[];
              values: number[];
              attrFlag: number[];
              attrData: number[];
            };
          };
        };
      }[][];
      length: number;
      frames: number;
    }>;
    length: number;
    fps: number;
    frames: number;
  }} animations,
   * @param {{skeleton: { bones: THREE.Bone[]}}} group
   */
  function addAnimations( group, animations ) {

    if ( group.animations === undefined ) {

      group.animations = [];

    }

    var stacks = animations.stacks;

    for ( var key in stacks ) {

      var stack = stacks[ key ];

      /**
       * @type {{
       * name: string,
       * fps: number,
       * length: number,
       * hierarchy: Array.<{
       *  parent: number,
       *  name: string,
       *  keys: Array.<{
       *    time: number,
       *    pos: Array.<number>,
       *    rot: Array.<number>,
       *    scl: Array.<number>
       *  }>
       * }>
       * }}
       */
      var animationData = {
        name: stack.name,
        fps: 30,
        length: stack.length,
        hierarchy: []
      };

      var bones = group.skeleton.bones;

      for ( var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++ bonesIndex ) {

        var bone = bones[ bonesIndex ];

        var name = bone.name.replace( /.*:/, '' );
        var parentIndex = findIndex( bones, function ( parentBone ) {

          return bone.parent === parentBone;

        } );
        animationData.hierarchy.push( { parent: parentIndex, name: name, keys: [] } );

      }

      for ( var frame = 0; frame <= stack.frames; frame ++ ) {

        for ( var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++ bonesIndex ) {

          var bone = bones[ bonesIndex ];
          var boneIndex = bonesIndex;

          var animationNode = stack.layers[ 0 ][ boneIndex ];

          for ( var hierarchyIndex = 0, hierarchyLength = animationData.hierarchy.length; hierarchyIndex < hierarchyLength; ++ hierarchyIndex ) {

            var node = animationData.hierarchy[ hierarchyIndex ];

            if ( node.name === bone.name ) {

              node.keys.push( generateKey( animations, animationNode, bone, frame ) );

            }

          }

        }

      }

      group.animations.push( THREE.AnimationClip.parseAnimation( animationData, bones ) );

    }

  }

  var euler = new THREE.Euler();
  var quaternion = new THREE.Quaternion();

  /**
   * @param {THREE.Bone} bone
   */
  function generateKey( animations, animationNode, bone, frame ) {

    var key = {
      time: frame / animations.fps,
      pos: bone.position.toArray(),
      rot: bone.quaternion.toArray(),
      scl: bone.scale.toArray()
    };

    if ( animationNode === undefined ) return key;

    try {

      if ( hasCurve( animationNode, 'T' ) && hasKeyOnFrame( animationNode.T, frame ) ) {

        key.pos = [ animationNode.T.curves.x.values[ frame ], animationNode.T.curves.y.values[ frame ], animationNode.T.curves.z.values[ frame ] ];

      }

      if ( hasCurve( animationNode, 'R' ) && hasKeyOnFrame( animationNode.R, frame ) ) {

        var rotationX = animationNode.R.curves.x.values[ frame ];
        var rotationY = animationNode.R.curves.y.values[ frame ];
        var rotationZ = animationNode.R.curves.z.values[ frame ];

        quaternion.setFromEuler( euler.set( rotationX, rotationY, rotationZ, 'ZYX' ) );
        key.rot = quaternion.toArray();

      }

      if ( hasCurve( animationNode, 'S' ) && hasKeyOnFrame( animationNode.S, frame ) ) {

        key.scl = [ animationNode.S.curves.x.values[ frame ], animationNode.S.curves.y.values[ frame ], animationNode.S.curves.z.values[ frame ] ];

      }

    } catch ( error ) {

      // Curve is not fully plotted.
      console.log( 'THREE.FBXLoader: ', bone );
      console.log( 'THREE.FBXLoader: ', error );

    }

    return key;

  }

  var AXES = [ 'x', 'y', 'z' ];

  function hasCurve( animationNode, attribute ) {

    if ( animationNode === undefined ) {

      return false;

    }

    var attributeNode = animationNode[ attribute ];

    if ( ! attributeNode ) {

      return false;

    }

    return AXES.every( function ( key ) {

      return attributeNode.curves[ key ] !== null;

    } );

  }

  function hasKeyOnFrame( attributeNode, frame ) {

    return AXES.every( function ( key ) {

      return isKeyExistOnFrame( attributeNode.curves[ key ], frame );

    } );

  }

  function isKeyExistOnFrame( curve, frame ) {

    return curve.values[ frame ] !== undefined;

  }

  /**
   * An instance of a Vertex with data for drawing vertices to the screen.
   * @constructor
   */
  function Vertex() {

    /**
     * Position of the vertex.
     * @type {THREE.Vector3}
     */
    this.position = new THREE.Vector3();

    /**
     * Normal of the vertex
     * @type {THREE.Vector3}
     */
    this.normal = new THREE.Vector3();

    /**
     * UV coordinates of the vertex.
     * @type {THREE.Vector2}
     */
    this.uv = new THREE.Vector2();

    /**
     * Color of the vertex
     * @type {THREE.Vector3}
     */
    this.color = new THREE.Vector3();

    /**
     * Indices of the bones vertex is influenced by.
     * @type {THREE.Vector4}
     */
    this.skinIndices = new THREE.Vector4( 0, 0, 0, 0 );

    /**
     * Weights that each bone influences the vertex.
     * @type {THREE.Vector4}
     */
    this.skinWeights = new THREE.Vector4( 0, 0, 0, 0 );

  }

  Object.assign( Vertex.prototype, {

    copy: function ( target ) {

      var returnVar = target || new Vertex();

      returnVar.position.copy( this.position );
      returnVar.normal.copy( this.normal );
      returnVar.uv.copy( this.uv );
      returnVar.skinIndices.copy( this.skinIndices );
      returnVar.skinWeights.copy( this.skinWeights );

      return returnVar;

    },

    flattenToBuffers: function ( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer ) {

      this.position.toArray( vertexBuffer, vertexBuffer.length );
      this.normal.toArray( normalBuffer, normalBuffer.length );
      this.uv.toArray( uvBuffer, uvBuffer.length );
      this.color.toArray( colorBuffer, colorBuffer.length );
      this.skinIndices.toArray( skinIndexBuffer, skinIndexBuffer.length );
      this.skinWeights.toArray( skinWeightBuffer, skinWeightBuffer.length );

    }

  } );

  /**
   * @constructor
   */
  function Triangle() {

    /**
     * @type {{position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}
     */
    this.vertices = [];

  }

  Object.assign( Triangle.prototype, {

    copy: function ( target ) {

      var returnVar = target || new Triangle();

      for ( var i = 0; i < this.vertices.length; ++ i ) {

         this.vertices[ i ].copy( returnVar.vertices[ i ] );

      }

      return returnVar;

    },

    flattenToBuffers: function ( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer ) {

      var vertices = this.vertices;

      for ( var i = 0, l = vertices.length; i < l; ++ i ) {

        vertices[ i ].flattenToBuffers( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer );

      }

    }

  } );

  /**
   * @constructor
   */
  function Face() {

    /**
     * @type {{vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[]}
     */
    this.triangles = [];
    this.materialIndex = 0;

  }

  Object.assign( Face.prototype, {

    copy: function ( target ) {

      var returnVar = target || new Face();

      for ( var i = 0; i < this.triangles.length; ++ i ) {

        this.triangles[ i ].copy( returnVar.triangles[ i ] );

      }

      returnVar.materialIndex = this.materialIndex;

      return returnVar;

    },

    genTrianglesFromVertices: function ( vertexArray ) {

      for ( var i = 2; i < vertexArray.length; ++ i ) {

        var triangle = new Triangle();
        triangle.vertices[ 0 ] = vertexArray[ 0 ];
        triangle.vertices[ 1 ] = vertexArray[ i - 1 ];
        triangle.vertices[ 2 ] = vertexArray[ i ];
        this.triangles.push( triangle );

      }

    },

    flattenToBuffers: function ( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer, materialIndexBuffer ) {

      var triangles = this.triangles;
      var materialIndex = this.materialIndex;

      for ( var i = 0, l = triangles.length; i < l; ++ i ) {

        triangles[ i ].flattenToBuffers( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer );
        append( materialIndexBuffer, [ materialIndex, materialIndex, materialIndex ] );

      }

    }

  } );

  /**
   * @constructor
   */
  function Geometry() {

    /**
     * @type {{triangles: {vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[], materialIndex: number}[]}
     */
    this.faces = [];

    /**
     * @type {{}|THREE.Skeleton}
     */
    this.skeleton = null;

  }

  Object.assign( Geometry.prototype, {

    /**
     * @returns {{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}
     */
    flattenToBuffers: function () {

      var vertexBuffer = [];
      var normalBuffer = [];
      var uvBuffer = [];
      var colorBuffer = [];
      var skinIndexBuffer = [];
      var skinWeightBuffer = [];

      var materialIndexBuffer = [];

      var faces = this.faces;

      for ( var i = 0, l = faces.length; i < l; ++ i ) {

        faces[ i ].flattenToBuffers( vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer, materialIndexBuffer );

      }

      return {
        vertexBuffer: vertexBuffer,
        normalBuffer: normalBuffer,
        uvBuffer: uvBuffer,
        colorBuffer: colorBuffer,
        skinIndexBuffer: skinIndexBuffer,
        skinWeightBuffer: skinWeightBuffer,
        materialIndexBuffer: materialIndexBuffer
      };

    }

  } );

  function TextParser() {}

  Object.assign( TextParser.prototype, {

    getPrevNode: function () {

      return this.nodeStack[ this.currentIndent - 2 ];

    },

    getCurrentNode: function () {

      return this.nodeStack[ this.currentIndent - 1 ];

    },

    getCurrentProp: function () {

      return this.currentProp;

    },

    pushStack: function ( node ) {

      this.nodeStack.push( node );
      this.currentIndent += 1;

    },

    popStack: function () {

      this.nodeStack.pop();
      this.currentIndent -= 1;

    },

    setCurrentProp: function ( val, name ) {

      this.currentProp = val;
      this.currentPropName = name;

    },

    // ----------parse ---------------------------------------------------
    parse: function ( text ) {

      this.currentIndent = 0;
      this.allNodes = new FBXTree();
      this.nodeStack = [];
      this.currentProp = [];
      this.currentPropName = '';

      var split = text.split( '\n' );

      for ( var lineNum = 0, lineLength = split.length; lineNum < lineLength; lineNum ++ ) {

        var l = split[ lineNum ];

        // skip comment line
        if ( l.match( /^[\s\t]*;/ ) ) {

          continue;

        }

        // skip empty line
        if ( l.match( /^[\s\t]*$/ ) ) {

          continue;

        }

        // beginning of node
        var beginningOfNodeExp = new RegExp( '^\\t{' + this.currentIndent + '}(\\w+):(.*){', '' );
        var match = l.match( beginningOfNodeExp );

        if ( match ) {

          var nodeName = match[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );
          var nodeAttrs = match[ 2 ].split( ',' );

          for ( var i = 0, l = nodeAttrs.length; i < l; i ++ ) {

            nodeAttrs[ i ] = nodeAttrs[ i ].trim().replace( /^"/, '' ).replace( /"$/, '' );

          }

          this.parseNodeBegin( l, nodeName, nodeAttrs || null );
          continue;

        }

        // node's property
        var propExp = new RegExp( '^\\t{' + ( this.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
        var match = l.match( propExp );

        if ( match ) {

          var propName = match[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
          var propValue = match[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

          // for special case: base64 image data follows "Content: ," line
          //  Content: ,
          //   "iVB..."
          if ( propName === 'Content' && propValue === ',' ) {

            propValue = split[ ++ lineNum ].replace( /"/g, '' ).trim();

          }

          this.parseNodeProperty( l, propName, propValue );
          continue;

        }

        // end of node
        var endOfNodeExp = new RegExp( '^\\t{' + ( this.currentIndent - 1 ) + '}}' );

        if ( l.match( endOfNodeExp ) ) {

          this.nodeEnd();
          continue;

        }

        // for special case,
        //
        //    Vertices: *8670 {
        //      a: 0.0356229953467846,13.9599733352661,-0.399196773.....(snip)
        // -0.0612030513584614,13.960485458374,-0.409748703241348,-0.10.....
        // 0.12490539252758,13.7450733184814,-0.454119384288788,0.09272.....
        // 0.0836158767342567,13.5432004928589,-0.435397416353226,0.028.....
        //
        // these case the lines must contiue with previous line
        if ( l.match( /^[^\s\t}]/ ) ) {

          this.parseNodePropertyContinued( l );

        }

      }

      return this.allNodes;

    },

    parseNodeBegin: function ( line, nodeName, nodeAttrs ) {

      // var nodeName = match[1];
      var node = { 'name': nodeName, properties: {}, 'subNodes': {} };
      var attrs = this.parseNodeAttr( nodeAttrs );
      var currentNode = this.getCurrentNode();

      // a top node
      if ( this.currentIndent === 0 ) {

        this.allNodes.add( nodeName, node );

      } else {

        // a subnode

        // already exists subnode, then append it
        if ( nodeName in currentNode.subNodes ) {

          var tmp = currentNode.subNodes[ nodeName ];

          // console.log( "duped entry found\nkey: " + nodeName + "\nvalue: " + propValue );
          if ( this.isFlattenNode( currentNode.subNodes[ nodeName ] ) ) {


            if ( attrs.id === '' ) {

              currentNode.subNodes[ nodeName ] = [];
              currentNode.subNodes[ nodeName ].push( tmp );

            } else {

              currentNode.subNodes[ nodeName ] = {};
              currentNode.subNodes[ nodeName ][ tmp.id ] = tmp;

            }

          }

          if ( attrs.id === '' ) {

            currentNode.subNodes[ nodeName ].push( node );

          } else {

            currentNode.subNodes[ nodeName ][ attrs.id ] = node;

          }

        } else if ( typeof attrs.id === 'number' || attrs.id.match( /^\d+$/ ) ) {

          currentNode.subNodes[ nodeName ] = {};
          currentNode.subNodes[ nodeName ][ attrs.id ] = node;

        } else {

          currentNode.subNodes[ nodeName ] = node;

        }

      }

      // for this     
      // NodeAttribute: 1001463072, "NodeAttribute::", "LimbNode" {
      if ( nodeAttrs ) {

        node.id = attrs.id;
        node.attrName = attrs.name;
        node.attrType = attrs.type;

      }

      this.pushStack( node );

    },

    parseNodeAttr: function ( attrs ) {

      var id = attrs[ 0 ];

      if ( attrs[ 0 ] !== '' ) {

        id = parseInt( attrs[ 0 ] );

        if ( isNaN( id ) ) {

          // PolygonVertexIndex: *16380 {
          id = attrs[ 0 ];

        }

      }

      var name = '', type = '';

      if ( attrs.length > 1 ) {

        name = attrs[ 1 ].replace( /^(\w+)::/, '' );
        type = attrs[ 2 ];

      }

      return { id: id, name: name, type: type };

    },

    parseNodeProperty: function ( line, propName, propValue ) {

      var currentNode = this.getCurrentNode();
      var parentName = currentNode.name;

      // special case parent node's is like "Properties70"
      // these children nodes must treat with careful
      if ( parentName !== undefined ) {

        var propMatch = parentName.match( /Properties(\d)+/ );
        if ( propMatch ) {

          this.parseNodeSpecialProperty( line, propName, propValue );
          return;

        }

      }

      // special case Connections
      if ( propName === 'C' ) {

        var connProps = propValue.split( ',' ).slice( 1 );
        var from = parseInt( connProps[ 0 ] );
        var to = parseInt( connProps[ 1 ] );

        var rest = propValue.split( ',' ).slice( 3 );

        propName = 'connections';
        propValue = [ from, to ];
        append( propValue, rest );

        if ( currentNode.properties[ propName ] === undefined ) {

          currentNode.properties[ propName ] = [];

        }

      }

      // special case Connections
      if ( propName === 'Node' ) {

        var id = parseInt( propValue );
        currentNode.properties.id = id;
        currentNode.id = id;

      }

      // already exists in properties, then append this
      if ( propName in currentNode.properties ) {

        // console.log( "duped entry found\nkey: " + propName + "\nvalue: " + propValue );
        if ( Array.isArray( currentNode.properties[ propName ] ) ) {

          currentNode.properties[ propName ].push( propValue );

        } else {

          currentNode.properties[ propName ] += propValue;

        }

      } else {

        // console.log( propName + ":  " + propValue );
        if ( Array.isArray( currentNode.properties[ propName ] ) ) {

          currentNode.properties[ propName ].push( propValue );

        } else {

          currentNode.properties[ propName ] = propValue;

        }

      }

      this.setCurrentProp( currentNode.properties, propName );

    },

    // TODO:
    parseNodePropertyContinued: function ( line ) {

      this.currentProp[ this.currentPropName ] += line;

    },

    parseNodeSpecialProperty: function ( line, propName, propValue ) {

      // split this
      // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
      // into array like below
      // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
      var props = propValue.split( '",' );

      for ( var i = 0, l = props.length; i < l; i ++ ) {

        props[ i ] = props[ i ].trim().replace( /^\"/, '' ).replace( /\s/, '_' );

      }

      var innerPropName = props[ 0 ];
      var innerPropType1 = props[ 1 ];
      var innerPropType2 = props[ 2 ];
      var innerPropFlag = props[ 3 ];
      var innerPropValue = props[ 4 ];

      /*
      if ( innerPropValue === undefined ) {
        innerPropValue = props[3];
      }
      */

      // cast value in its type
      switch ( innerPropType1 ) {

        case 'int':
          innerPropValue = parseInt( innerPropValue );
          break;

        case 'double':
          innerPropValue = parseFloat( innerPropValue );
          break;

        case 'ColorRGB':
        case 'Vector3D':
          innerPropValue = parseFloatArray( innerPropValue );
          break;

      }

      // CAUTION: these props must append to parent's parent
      this.getPrevNode().properties[ innerPropName ] = {

        'type': innerPropType1,
        'type2': innerPropType2,
        'flag': innerPropFlag,
        'value': innerPropValue

      };

      this.setCurrentProp( this.getPrevNode().properties, innerPropName );

    },

    nodeEnd: function () {

      this.popStack();

    },

    /* ---------------------------------------------------------------- */
    /*    util                            */
    isFlattenNode: function ( node ) {

      return ( 'subNodes' in node && 'properties' in node ) ? true : false;

    }

  } );

  // Binary format specification:
  //   https://code.blender.org/2013/08/fbx-binary-file-format-specification/
  //   https://wiki.rogiken.org/specifications/file-format/fbx/ (more detail but Japanese)
  function BinaryParser() {}

  Object.assign( BinaryParser.prototype, {

    /**
     * Parses binary data and builds FBXTree as much compatible as possible with the one built by TextParser.
     * @param {ArrayBuffer} buffer
     * @returns {THREE.FBXTree}
     */
    parse: function ( buffer ) {

      var reader = new BinaryReader( buffer );
      reader.skip( 23 ); // skip magic 23 bytes

      var version = reader.getUint32();

      console.log( 'THREE.FBXLoader: FBX binary version: ' + version );

      var allNodes = new FBXTree();

      while ( ! this.endOfContent( reader ) ) {

        var node = this.parseNode( reader, version );
        if ( node !== null ) allNodes.add( node.name, node );

      }

      return allNodes;

    },

    /**
     * Checks if reader has reached the end of content.
     * @param {BinaryReader} reader
     * @returns {boolean}
     */
    endOfContent: function ( reader ) {

      // footer size: 160bytes + 16-byte alignment padding
      // - 16bytes: magic
      // - padding til 16-byte alignment (at least 1byte?)
      //   (seems like some exporters embed fixed 15 or 16bytes?)
      // - 4bytes: magic
      // - 4bytes: version
      // - 120bytes: zero
      // - 16bytes: magic
      if ( reader.size() % 16 === 0 ) {

        return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();

      } else {

        return reader.getOffset() + 160 + 16 >= reader.size();

      }

    },

    /**
     * Parses Node as much compatible as possible with the one parsed by TextParser
     * TODO: could be optimized more?
     * @param {BinaryReader} reader
     * @param {number} version
     * @returns {Object} - Returns an Object as node, or null if NULL-record.
     */
    parseNode: function ( reader, version ) {

      // The first three data sizes depends on version.
      var endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
      var numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
      var propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
      var nameLen = reader.getUint8();
      var name = reader.getString( nameLen );

      // Regards this node as NULL-record if endOffset is zero
      if ( endOffset === 0 ) return null;

      var propertyList = [];

      for ( var i = 0; i < numProperties; i ++ ) {

        propertyList.push( this.parseProperty( reader ) );

      }

      // Regards the first three elements in propertyList as id, attrName, and attrType
      var id = propertyList.length > 0 ? propertyList[ 0 ] : '';
      var attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
      var attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

      var subNodes = {};
      var properties = {};

      var isSingleProperty = false;

      // if this node represents just a single property
      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
      if ( numProperties === 1 && reader.getOffset() === endOffset ) {

        isSingleProperty = true;

      }

      while ( endOffset > reader.getOffset() ) {

        var node = this.parseNode( reader, version );

        if ( node === null ) continue;

        // special case: child node is single property
        if ( node.singleProperty === true ) {

          var value = node.propertyList[ 0 ];

          if ( Array.isArray( value ) ) {

            // node represents
            //  Vertices: *3 {
            //    a: 0.01, 0.02, 0.03
            //  }
            // of text format here.

            node.properties[ node.name ] = node.propertyList[ 0 ];
            subNodes[ node.name ] = node;

            // Later phase expects single property array is in node.properties.a as String.
            // TODO: optimize
            node.properties.a = value.toString();

          } else {

            // node represents
            //  Version: 100
            // of text format here.

            properties[ node.name ] = value;

          }

          continue;

        }

        // special case: connections
        if ( name === 'Connections' && node.name === 'C' ) {

          var array = [];

          // node.propertyList would be like
          // ["OO", 111264976, 144038752, "d|x"] (?, from, to, additional values)
          for ( var i = 1, il = node.propertyList.length; i < il; i ++ ) {

            array[ i - 1 ] = node.propertyList[ i ];

          }

          if ( properties.connections === undefined ) {

            properties.connections = [];

          }

          properties.connections.push( array );

          continue;

        }

        // special case: child node is Properties\d+
        if ( node.name.match( /^Properties\d+$/ ) ) {

          // move child node's properties to this node.

          var keys = Object.keys( node.properties );

          for ( var i = 0, il = keys.length; i < il; i ++ ) {

            var key = keys[ i ];
            properties[ key ] = node.properties[ key ];

          }

          continue;

        }

        // special case: properties
        if ( name.match( /^Properties\d+$/ ) && node.name === 'P' ) {

          var innerPropName = node.propertyList[ 0 ];
          var innerPropType1 = node.propertyList[ 1 ];
          var innerPropType2 = node.propertyList[ 2 ];
          var innerPropFlag = node.propertyList[ 3 ];
          var innerPropValue;

          if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
          if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

          if ( innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' ||
             innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

            innerPropValue = [
              node.propertyList[ 4 ],
              node.propertyList[ 5 ],
              node.propertyList[ 6 ]
            ];

          } else {

            innerPropValue = node.propertyList[ 4 ];

          }

          if ( innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

            innerPropValue = innerPropValue.toString();

          }

          // this will be copied to parent. see above.
          properties[ innerPropName ] = {

            'type': innerPropType1,
            'type2': innerPropType2,
            'flag': innerPropFlag,
            'value': innerPropValue

          };

          continue;

        }

        // standard case
        // follows TextParser's manner.
        if ( subNodes[ node.name ] === undefined ) {

          if ( typeof node.id === 'number' ) {

            subNodes[ node.name ] = {};
            subNodes[ node.name ][ node.id ] = node;

          } else {

            subNodes[ node.name ] = node;

          }

        } else {

          if ( node.id === '' ) {

            if ( ! Array.isArray( subNodes[ node.name ] ) ) {

              subNodes[ node.name ] = [ subNodes[ node.name ] ];

            }

            subNodes[ node.name ].push( node );

          } else {

            if ( subNodes[ node.name ][ node.id ] === undefined ) {

              subNodes[ node.name ][ node.id ] = node;

            } else {

              // conflict id. irregular?

              if ( ! Array.isArray( subNodes[ node.name ][ node.id ] ) ) {

                subNodes[ node.name ][ node.id ] = [ subNodes[ node.name ][ node.id ] ];

              }

              subNodes[ node.name ][ node.id ].push( node );

            }

          }

        }

      }

      return {

        singleProperty: isSingleProperty,
        id: id,
        attrName: attrName,
        attrType: attrType,
        name: name,
        properties: properties,
        propertyList: propertyList, // raw property list, would be used by parent
        subNodes: subNodes

      };

    },

    parseProperty: function ( reader ) {

      var type = reader.getChar();

      switch ( type ) {

        case 'F':
          return reader.getFloat32();

        case 'D':
          return reader.getFloat64();

        case 'L':
          return reader.getInt64();

        case 'I':
          return reader.getInt32();

        case 'Y':
          return reader.getInt16();

        case 'C':
          return reader.getBoolean();

        case 'f':
        case 'd':
        case 'l':
        case 'i':
        case 'b':

          var arrayLength = reader.getUint32();
          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
          var compressedLength = reader.getUint32();

          if ( encoding === 0 ) {

            switch ( type ) {

              case 'f':
                return reader.getFloat32Array( arrayLength );

              case 'd':
                return reader.getFloat64Array( arrayLength );

              case 'l':
                return reader.getInt64Array( arrayLength );

              case 'i':
                return reader.getInt32Array( arrayLength );

              case 'b':
                return reader.getBooleanArray( arrayLength );

            }

          }

          if ( window.Zlib === undefined ) {

            throw new Error( 'THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );

          }

          var inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef
          var reader2 = new BinaryReader( inflate.decompress().buffer );

          switch ( type ) {

            case 'f':
              return reader2.getFloat32Array( arrayLength );

            case 'd':
              return reader2.getFloat64Array( arrayLength );

            case 'l':
              return reader2.getInt64Array( arrayLength );

            case 'i':
              return reader2.getInt32Array( arrayLength );

            case 'b':
              return reader2.getBooleanArray( arrayLength );

          }

        case 'S':
          var length = reader.getUint32();
          return reader.getString( length );

        case 'R':
          var length = reader.getUint32();
          return reader.getArrayBuffer( length );

        default:
          throw new Error( 'THREE.FBXLoader: Unknown property type ' + type );

      }

    }

  } );


  function BinaryReader( buffer, littleEndian ) {

    this.dv = new DataView( buffer );
    this.offset = 0;
    this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;

  }

  Object.assign( BinaryReader.prototype, {

    getOffset: function () {

      return this.offset;

    },

    size: function () {

      return this.dv.buffer.byteLength;

    },

    skip: function ( length ) {

      this.offset += length;

    },

    // seems like true/false representation depends on exporter.
    //   true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
    // then sees LSB.
    getBoolean: function () {

      return ( this.getUint8() & 1 ) === 1;

    },

    getBooleanArray: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getBoolean() );

      }

      return a;

    },

    getInt8: function () {

      var value = this.dv.getInt8( this.offset );
      this.offset += 1;
      return value;

    },

    getInt8Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getInt8() );

      }

      return a;

    },

    getUint8: function () {

      var value = this.dv.getUint8( this.offset );
      this.offset += 1;
      return value;

    },

    getUint8Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getUint8() );

      }

      return a;

    },

    getInt16: function () {

      var value = this.dv.getInt16( this.offset, this.littleEndian );
      this.offset += 2;
      return value;

    },

    getInt16Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getInt16() );

      }

      return a;

    },

    getUint16: function () {

      var value = this.dv.getUint16( this.offset, this.littleEndian );
      this.offset += 2;
      return value;

    },

    getUint16Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getUint16() );

      }

      return a;

    },

    getInt32: function () {

      var value = this.dv.getInt32( this.offset, this.littleEndian );
      this.offset += 4;
      return value;

    },

    getInt32Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getInt32() );

      }

      return a;

    },

    getUint32: function () {

      var value = this.dv.getUint32( this.offset, this.littleEndian );
      this.offset += 4;
      return value;

    },

    getUint32Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getUint32() );

      }

      return a;

    },

    // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.
    // 1 << 32 will return 1 so using multiply operation instead here.
    // There'd be a possibility that this method returns wrong value if the value
    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
    // TODO: safely handle 64-bit integer
    getInt64: function () {

      var low, high;

      if ( this.littleEndian ) {

        low = this.getUint32();
        high = this.getUint32();

      } else {

        high = this.getUint32();
        low = this.getUint32();

      }

      // calculate negative value
      if ( high & 0x80000000 ) {

        high = ~ high & 0xFFFFFFFF;
        low = ~ low & 0xFFFFFFFF;

        if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;

        low = ( low + 1 ) & 0xFFFFFFFF;

        return - ( high * 0x100000000 + low );

      }

      return high * 0x100000000 + low;

    },

    getInt64Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getInt64() );

      }

      return a;

    },

    // Note: see getInt64() comment
    getUint64: function () {

      var low, high;

      if ( this.littleEndian ) {

        low = this.getUint32();
        high = this.getUint32();

      } else {

        high = this.getUint32();
        low = this.getUint32();

      }

      return high * 0x100000000 + low;

    },

    getUint64Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getUint64() );

      }

      return a;

    },

    getFloat32: function () {

      var value = this.dv.getFloat32( this.offset, this.littleEndian );
      this.offset += 4;
      return value;

    },

    getFloat32Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getFloat32() );

      }

      return a;

    },

    getFloat64: function () {

      var value = this.dv.getFloat64( this.offset, this.littleEndian );
      this.offset += 8;
      return value;

    },

    getFloat64Array: function ( size ) {

      var a = [];

      for ( var i = 0; i < size; i ++ ) {

        a.push( this.getFloat64() );

      }

      return a;

    },

    getArrayBuffer: function ( size ) {

      var value = this.dv.buffer.slice( this.offset, this.offset + size );
      this.offset += size;
      return value;

    },

    getChar: function () {

      return String.fromCharCode( this.getUint8() );

    },

    getString: function ( size ) {

      var s = '';

      while ( size > 0 ) {

        var value = this.getUint8();
        size --;

        if ( value === 0 ) break;

        s += String.fromCharCode( value );

      }

      // Manage UTF8 encoding
      s = decodeURIComponent( escape( s ) );

      this.skip( size );

      return s;

    }

  } );


  function FBXTree() {}

  Object.assign( FBXTree.prototype, {

    add: function ( key, val ) {

      this[ key ] = val;

    },

    searchConnectionParent: function ( id ) {

      if ( this.__cache_search_connection_parent === undefined ) {

        this.__cache_search_connection_parent = [];

      }

      if ( this.__cache_search_connection_parent[ id ] !== undefined ) {

        return this.__cache_search_connection_parent[ id ];

      } else {

        this.__cache_search_connection_parent[ id ] = [];

      }

      var conns = this.Connections.properties.connections;

      var results = [];
      for ( var i = 0; i < conns.length; ++ i ) {

        if ( conns[ i ][ 0 ] == id ) {

          // 0 means scene root
          var res = conns[ i ][ 1 ] === 0 ? - 1 : conns[ i ][ 1 ];
          results.push( res );

        }

      }

      if ( results.length > 0 ) {

        append( this.__cache_search_connection_parent[ id ], results );
        return results;

      } else {

        this.__cache_search_connection_parent[ id ] = [ - 1 ];
        return [ - 1 ];

      }

    },

    searchConnectionChildren: function ( id ) {

      if ( this.__cache_search_connection_children === undefined ) {

        this.__cache_search_connection_children = [];

      }

      if ( this.__cache_search_connection_children[ id ] !== undefined ) {

        return this.__cache_search_connection_children[ id ];

      } else {

        this.__cache_search_connection_children[ id ] = [];

      }

      var conns = this.Connections.properties.connections;

      var res = [];
      for ( var i = 0; i < conns.length; ++ i ) {

        if ( conns[ i ][ 1 ] == id ) {

          // 0 means scene root
          res.push( conns[ i ][ 0 ] === 0 ? - 1 : conns[ i ][ 0 ] );
          // there may more than one kid, then search to the end

        }

      }

      if ( res.length > 0 ) {

        append( this.__cache_search_connection_children[ id ], res );
        return res;

      } else {

        this.__cache_search_connection_children[ id ] = [ ];
        return [ ];

      }

    },

    searchConnectionType: function ( id, to ) {

      var key = id + ',' + to; // TODO: to hash
      if ( this.__cache_search_connection_type === undefined ) {

        this.__cache_search_connection_type = {};

      }

      if ( this.__cache_search_connection_type[ key ] !== undefined ) {

        return this.__cache_search_connection_type[ key ];

      } else {

        this.__cache_search_connection_type[ key ] = '';

      }

      var conns = this.Connections.properties.connections;

      for ( var i = 0; i < conns.length; ++ i ) {

        if ( conns[ i ][ 0 ] == id && conns[ i ][ 1 ] == to ) {

          // 0 means scene root
          this.__cache_search_connection_type[ key ] = conns[ i ][ 2 ];
          return conns[ i ][ 2 ];

        }

      }

      this.__cache_search_connection_type[ id ] = null;
      return null;

    }

  } );


  /**
   * @param {ArrayBuffer} buffer
   * @returns {boolean}
   */
  function isFbxFormatBinary( buffer ) {

    var CORRECT = 'Kaydara FBX Binary  \0';

    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );

  }

  /**
   * @returns {boolean}
   */
  function isFbxFormatASCII( text ) {

    var CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

    var cursor = 0;

    function read( offset ) {

      var result = text[ offset - 1 ];
      text = text.slice( cursor + offset );
      cursor ++;
      return result;

    }

    for ( var i = 0; i < CORRECT.length; ++ i ) {

      var num = read( 1 );
      if ( num === CORRECT[ i ] ) {

        return false;

      }

    }

    return true;

  }

  /**
   * @returns {number}
   */
  function getFbxVersion( text ) {

    var versionRegExp = /FBXVersion: (\d+)/;
    var match = text.match( versionRegExp );
    if ( match ) {

      var version = parseInt( match[ 1 ] );
      return version;

    }
    throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );

  }

  /**
   * Converts FBX ticks into real time seconds.
   * @param {number} time - FBX tick timestamp to convert.
   * @returns {number} - FBX tick in real world time.
   */
  function convertFBXTimeToSeconds( time ) {

    // Constant is FBX ticks per second.
    return time / 46186158000;

  }

  /**
   * Parses comma separated list of float numbers and returns them in an array.
   * @example
   * // Returns [ 5.6, 9.4, 2.5, 1.4 ]
   * parseFloatArray( "5.6,9.4,2.5,1.4" )
   * @returns {number[]}
   */
  function parseFloatArray( string ) {

    var array = string.split( ',' );

    for ( var i = 0, l = array.length; i < l; i ++ ) {

      array[ i ] = parseFloat( array[ i ] );

    }

    return array;

  }

  /**
   * Parses comma separated list of int numbers and returns them in an array.
   * @example
   * // Returns [ 5, 8, 2, 3 ]
   * parseFloatArray( "5,8,2,3" )
   * @returns {number[]}
   */
  function parseIntArray( string ) {

    var array = string.split( ',' );

    for ( var i = 0, l = array.length; i < l; i ++ ) {

      array[ i ] = parseInt( array[ i ] );

    }

    return array;

  }

  /**
   * Parses Vector3 property from FBXTree.  Property is given as .value.x, .value.y, etc.
   * @param {FBXVector3} property - Property to parse as Vector3.
   * @returns {THREE.Vector3}
   */
  function parseVector3( property ) {

    return new THREE.Vector3().fromArray( property.value );

  }

  /**
   * Parses Color property from FBXTree.  Property is given as .value.x, .value.y, etc.
   * @param {FBXVector3} property - Property to parse as Color.
   * @returns {THREE.Color}
   */
  function parseColor( property ) {

    return new THREE.Color().fromArray( property.value );

  }

  function parseMatrixArray( floatString ) {

    return new THREE.Matrix4().fromArray( parseFloatArray( floatString ) );

  }

  /**
   * Converts ArrayBuffer to String.
   * @param {ArrayBuffer} buffer
   * @param {number} from
   * @param {number} to
   * @returns {String}
   */
  function convertArrayBufferToString( buffer, from, to ) {

    if ( from === undefined ) from = 0;
    if ( to === undefined ) to = buffer.byteLength;

    var array = new Uint8Array( buffer, from, to );

    if ( window.TextDecoder !== undefined ) {

      return new TextDecoder().decode( array );

    }

    var s = '';

    for ( var i = 0, il = array.length; i < il; i ++ ) {

      s += String.fromCharCode( array[ i ] );

    }

    return s;

  }

  /**
   * Converts number from degrees into radians.
   * @param {number} value
   * @returns {number}
   */
  function degreeToRadian( value ) {

    return value * DEG2RAD;

  }

  var DEG2RAD = Math.PI / 180;

  //

  function findIndex( array, func ) {

    for ( var i = 0, l = array.length; i < l; i ++ ) {

      if ( func( array[ i ] ) ) return i;

    }

    return - 1;

  }

  function append( a, b ) {

    for ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {

      a[ j ] = b[ i ];

    }

  }

  function slice( a, b, from, to ) {

    for ( var i = from, j = 0; i < to; i ++, j ++ ) {

      a[ j ] = b[ i ];

    }

    return a;

  }

} )();

/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */

THREE.GLTFLoader = ( function () {

  function GLTFLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  }

  GLTFLoader.prototype = {

    constructor: GLTFLoader,

    crossOrigin: 'Anonymous',

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var path = this.path && ( typeof this.path === 'string' ) ? this.path : THREE.Loader.prototype.extractUrlBase( url );

      var loader = new THREE.FileLoader( scope.manager );

      loader.setResponseType( 'arraybuffer' );

      loader.load( url, function ( data ) {

        try {

          scope.parse( data, path, onLoad, onError );

        } catch ( e ) {

          if ( onError !== undefined ) {

            // For SyntaxError or TypeError, return a generic failure message.
            onError( e.constructor === Error ? e : new Error( 'THREE.GLTFLoader: Unable to parse model.' ) );

          }

        }

      }, onProgress, onError );

    },

    setCrossOrigin: function ( value ) {

      this.crossOrigin = value;

    },

    setPath: function ( value ) {

      this.path = value;

    },

    parse: function ( data, path, onLoad, onError ) {

      var content;
      var extensions = {};

      var magic = convertUint8ArrayToString( new Uint8Array( data, 0, 4 ) );

      if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

        extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );
        content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

      } else {

        content = convertUint8ArrayToString( new Uint8Array( data ) );

      }

      var json = JSON.parse( content );

      if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

        onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
        return;

      }

      if ( json.extensionsUsed ) {

        if ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_LIGHTS ) >= 0 ) {

          extensions[ EXTENSIONS.KHR_LIGHTS ] = new GLTFLightsExtension( json );

        }

        if ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_COMMON ) >= 0 ) {

          extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] = new GLTFMaterialsCommonExtension( json );

        }

        if ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ) >= 0 ) {

          extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] = new GLTFMaterialsPbrSpecularGlossinessExtension();

        }

      }

      console.time( 'GLTFLoader' );

      var parser = new GLTFParser( json, extensions, {

        path: path || this.path,
        crossOrigin: this.crossOrigin

      } );

      parser.parse( function ( scene, scenes, cameras, animations ) {

        console.timeEnd( 'GLTFLoader' );

        var glTF = {
          scene: scene,
          scenes: scenes,
          cameras: cameras,
          animations: animations
        };

        onLoad( glTF );

      }, onError );

    }

  };

  /* GLTFREGISTRY */

  function GLTFRegistry() {

    var objects = {};

    return  {

      get: function ( key ) {

        return objects[ key ];

      },

      add: function ( key, object ) {

        objects[ key ] = object;

      },

      remove: function ( key ) {

        delete objects[ key ];

      },

      removeAll: function () {

        objects = {};

      }

    };

  }

  /*********************************/
  /********** EXTENSIONS ***********/
  /*********************************/

  var EXTENSIONS = {
    KHR_BINARY_GLTF: 'KHR_binary_glTF',
    KHR_LIGHTS: 'KHR_lights',
    KHR_MATERIALS_COMMON: 'KHR_materials_common',
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness'
  };

  /**
   * Lights Extension
   *
   * Specification: PENDING
   */
  function GLTFLightsExtension( json ) {

    this.name = EXTENSIONS.KHR_LIGHTS;

    this.lights = {};

    var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS ] ) || {};
    var lights = extension.lights || {};

    for ( var lightId in lights ) {

      var light = lights[ lightId ];
      var lightNode;

      var color = new THREE.Color().fromArray( light.color );

      switch ( light.type ) {

        case 'directional':
          lightNode = new THREE.DirectionalLight( color );
          lightNode.position.set( 0, 0, 1 );
          break;

        case 'point':
          lightNode = new THREE.PointLight( color );
          break;

        case 'spot':
          lightNode = new THREE.SpotLight( color );
          lightNode.position.set( 0, 0, 1 );
          break;

        case 'ambient':
          lightNode = new THREE.AmbientLight( color );
          break;

      }

      if ( lightNode ) {

        if ( light.constantAttenuation !== undefined ) {

          lightNode.intensity = light.constantAttenuation;

        }

        if ( light.linearAttenuation !== undefined ) {

          lightNode.distance = 1 / light.linearAttenuation;

        }

        if ( light.quadraticAttenuation !== undefined ) {

          lightNode.decay = light.quadraticAttenuation;

        }

        if ( light.fallOffAngle !== undefined ) {

          lightNode.angle = light.fallOffAngle;

        }

        if ( light.fallOffExponent !== undefined ) {

          console.warn( 'THREE.GLTFLoader:: light.fallOffExponent not currently supported.' );

        }

        lightNode.name = light.name || ( 'light_' + lightId );
        this.lights[ lightId ] = lightNode;

      }

    }

  }

  /**
   * Common Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/Khronos/KHR_materials_common
   */
  function GLTFMaterialsCommonExtension( json ) {

    this.name = EXTENSIONS.KHR_MATERIALS_COMMON;

  }

  GLTFMaterialsCommonExtension.prototype.getMaterialType = function ( material ) {

    var khrMaterial = material.extensions[ this.name ];

    switch ( khrMaterial.type ) {

      case 'commonBlinn' :
      case 'commonPhong' :
        return THREE.MeshPhongMaterial;

      case 'commonLambert' :
        return THREE.MeshLambertMaterial;

      case 'commonConstant' :
      default :
        return THREE.MeshBasicMaterial;

    }

  };

  GLTFMaterialsCommonExtension.prototype.extendParams = function ( materialParams, material, parser ) {

    var khrMaterial = material.extensions[ this.name ];

    var pending = [];

    var keys = [];

    // TODO: Currently ignored: 'ambientFactor', 'ambientTexture'
    switch ( khrMaterial.type ) {

      case 'commonBlinn' :
      case 'commonPhong' :
        keys.push( 'diffuseFactor', 'diffuseTexture', 'specularFactor', 'specularTexture', 'shininessFactor' );
        break;

      case 'commonLambert' :
        keys.push( 'diffuseFactor', 'diffuseTexture' );
        break;

      case 'commonConstant' :
      default :
        break;

    }

    var materialValues = {};

    keys.forEach( function ( v ) {

      if ( khrMaterial[ v ] !== undefined ) materialValues[ v ] = khrMaterial[ v ];

    } );

    if ( materialValues.diffuseFactor !== undefined ) {

      materialParams.color = new THREE.Color().fromArray( materialValues.diffuseFactor );
      materialParams.opacity = materialValues.diffuseFactor[ 3 ];

    }

    if ( materialValues.diffuseTexture !== undefined ) {

      pending.push( parser.assignTexture( materialParams, 'map', materialValues.diffuseTexture.index ) );

    }

    if ( materialValues.specularFactor !== undefined ) {

      materialParams.specular = new THREE.Color().fromArray( materialValues.specularFactor );

    }

    if ( materialValues.specularTexture !== undefined ) {

      pending.push( parser.assignTexture( materialParams, 'specularMap', materialValues.specularTexture.index ) );

    }

    if ( materialValues.shininessFactor !== undefined ) {

      materialParams.shininess = materialValues.shininessFactor;

    }

    return Promise.all( pending );

  };

  /* BINARY EXTENSION */

  var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';
  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

  function GLTFBinaryExtension( data ) {

    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;

    var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

    this.header = {
      magic: convertUint8ArrayToString( new Uint8Array( data.slice( 0, 4 ) ) ),
      version: headerView.getUint32( 4, true ),
      length: headerView.getUint32( 8, true )
    };

    if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

      throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

    } else if ( this.header.version < 2.0 ) {

      throw new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use GLTFLoader instead.' );

    }

    var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
    var chunkIndex = 0;

    while ( chunkIndex < chunkView.byteLength ) {

      var chunkLength = chunkView.getUint32( chunkIndex, true );
      chunkIndex += 4;

      var chunkType = chunkView.getUint32( chunkIndex, true );
      chunkIndex += 4;

      if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

        var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
        this.content = convertUint8ArrayToString( contentArray );

      } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice( byteOffset, byteOffset + chunkLength );

      }

      // Clients must ignore chunks with unknown types.

      chunkIndex += chunkLength;

    }

    if ( this.content === null ) {

      throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

    }

  }

  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
   */
  function GLTFMaterialsPbrSpecularGlossinessExtension() {

    return {

      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

      getMaterialType: function () {

        return THREE.ShaderMaterial;

      },

      extendParams: function ( params, material, parser ) {

        var pbrSpecularGlossiness = material.extensions[ this.name ];

        var shader = THREE.ShaderLib[ 'standard' ];

        var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

        var specularMapParsFragmentChunk = [
          '#ifdef USE_SPECULARMAP',
          ' uniform sampler2D specularMap;',
          '#endif'
        ].join( '\n' );

        var glossinessMapParsFragmentChunk = [
          '#ifdef USE_GLOSSINESSMAP',
          ' uniform sampler2D glossinessMap;',
          '#endif'
        ].join( '\n' );

        var specularMapFragmentChunk = [
          'vec3 specularFactor = specular;',
          '#ifdef USE_SPECULARMAP',
          ' vec4 texelSpecular = texture2D( specularMap, vUv );',
          ' // reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
          ' specularFactor *= texelSpecular.rgb;',
          '#endif'
        ].join( '\n' );

        var glossinessMapFragmentChunk = [
          'float glossinessFactor = glossiness;',
          '#ifdef USE_GLOSSINESSMAP',
          ' vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
          ' // reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
          ' glossinessFactor *= texelGlossiness.a;',
          '#endif'
        ].join( '\n' );

        var lightPhysicalFragmentChunk = [
          'PhysicalMaterial material;',
          'material.diffuseColor = diffuseColor.rgb;',
          'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',
          'material.specularColor = specularFactor.rgb;',
        ].join( '\n' );

        var fragmentShader = shader.fragmentShader
          .replace( '#include <specularmap_fragment>', '' )
          .replace( 'uniform float roughness;', 'uniform vec3 specular;' )
          .replace( 'uniform float metalness;', 'uniform float glossiness;' )
          .replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
          .replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
          .replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
          .replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
          .replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

        delete uniforms.roughness;
        delete uniforms.metalness;
        delete uniforms.roughnessMap;
        delete uniforms.metalnessMap;

        uniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) };
        uniforms.glossiness = { value: 0.5 };
        uniforms.specularMap = { value: null };
        uniforms.glossinessMap = { value: null };

        params.vertexShader = shader.vertexShader;
        params.fragmentShader = fragmentShader;
        params.uniforms = uniforms;
        params.defines = { 'STANDARD': '' };

        params.color = new THREE.Color( 1.0, 1.0, 1.0 );
        params.opacity = 1.0;

        var pending = [];

        if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

          var array = pbrSpecularGlossiness.diffuseFactor;

          params.color.fromArray( array );
          params.opacity = array[ 3 ];

        }

        if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

          pending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture.index ) );

        }

        params.emissive = new THREE.Color( 0.0, 0.0, 0.0 );
        params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
        params.specular = new THREE.Color( 1.0, 1.0, 1.0 );

        if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

          params.specular.fromArray( pbrSpecularGlossiness.specularFactor );

        }

        if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

          var specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;
          pending.push( parser.assignTexture( params, 'glossinessMap', specGlossIndex ) );
          pending.push( parser.assignTexture( params, 'specularMap', specGlossIndex ) );

        }

        return Promise.all( pending );

      },

      createMaterial: function ( params ) {

        // setup material properties based on MeshStandardMaterial for Specular-Glossiness

        var material = new THREE.ShaderMaterial( {
          defines: params.defines,
          vertexShader: params.vertexShader,
          fragmentShader: params.fragmentShader,
          uniforms: params.uniforms,
          fog: true,
          lights: true,
          opacity: params.opacity,
          transparent: params.transparent
        } );

        material.isGLTFSpecularGlossinessMaterial = true;

        material.color = params.color;

        material.map = params.map === undefined ? null : params.map;

        material.lightMap = null;
        material.lightMapIntensity = 1.0;

        material.aoMap = params.aoMap === undefined ? null : params.aoMap;
        material.aoMapIntensity = 1.0;

        material.emissive = params.emissive;
        material.emissiveIntensity = 1.0;
        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;

        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
        material.bumpScale = 1;

        material.normalMap = params.normalMap === undefined ? null : params.normalMap;
        if ( params.normalScale ) material.normalScale = params.normalScale;

        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;

        material.specularMap = params.specularMap === undefined ? null : params.specularMap;
        material.specular = params.specular;

        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
        material.glossiness = params.glossiness;

        material.alphaMap = null;

        material.envMap = params.envMap === undefined ? null : params.envMap;
        material.envMapIntensity = 1.0;

        material.refractionRatio = 0.98;

        material.extensions.derivatives = true;

        return material;

      },

      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
      refreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {

        var uniforms = material.uniforms;
        var defines = material.defines;

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value.copy( material.color );
        uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;

        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

          uvScaleMap = material.map;

        } else if ( material.specularMap ) {

          uvScaleMap = material.specularMap;

        } else if ( material.displacementMap ) {

          uvScaleMap = material.displacementMap;

        } else if ( material.normalMap ) {

          uvScaleMap = material.normalMap;

        } else if ( material.bumpMap ) {

          uvScaleMap = material.bumpMap;

        } else if ( material.glossinessMap ) {

          uvScaleMap = material.glossinessMap;

        } else if ( material.alphaMap ) {

          uvScaleMap = material.alphaMap;

        } else if ( material.emissiveMap ) {

          uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

          // backwards compatibility
          if ( uvScaleMap.isWebGLRenderTarget ) {

            uvScaleMap = uvScaleMap.texture;

          }

          if ( uvScaleMap.matrixAutoUpdate === true ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;
            var rotation = uvScaleMap.rotation;
            var center = uvScaleMap.center;

            uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

          }

          uniforms.uvTransform.value.copy( uvScaleMap.matrix );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.envMapIntensity.value = material.envMapIntensity;
        uniforms.flipEnvMap.value = ( material.envMap && material.envMap.isCubeTexture ) ? - 1 : 1;

        uniforms.refractionRatio.value = material.refractionRatio;

        uniforms.specular.value.copy( material.specular );
        uniforms.glossiness.value = material.glossiness;

        uniforms.glossinessMap.value = material.glossinessMap;

        uniforms.emissiveMap.value = material.emissiveMap;
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.normalMap.value = material.normalMap;

        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

        if ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {

          defines.USE_GLOSSINESSMAP = '';
          // set USE_ROUGHNESSMAP to enable vUv
          defines.USE_ROUGHNESSMAP = '';

        }

        if ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {

          delete defines.USE_GLOSSINESSMAP;
          delete defines.USE_ROUGHNESSMAP;

        }

      }

    };

  }

  /*********************************/
  /********** INTERNALS ************/
  /*********************************/

  /* CONSTANTS */

  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };

  var WEBGL_TYPE = {
    5126: Number,
    //35674: THREE.Matrix2,
    35675: THREE.Matrix3,
    35676: THREE.Matrix4,
    35664: THREE.Vector2,
    35665: THREE.Vector3,
    35666: THREE.Vector4,
    35678: THREE.Texture
  };

  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };

  var WEBGL_FILTERS = {
    9728: THREE.NearestFilter,
    9729: THREE.LinearFilter,
    9984: THREE.NearestMipMapNearestFilter,
    9985: THREE.LinearMipMapNearestFilter,
    9986: THREE.NearestMipMapLinearFilter,
    9987: THREE.LinearMipMapLinearFilter
  };

  var WEBGL_WRAPPINGS = {
    33071: THREE.ClampToEdgeWrapping,
    33648: THREE.MirroredRepeatWrapping,
    10497: THREE.RepeatWrapping
  };

  var WEBGL_TEXTURE_FORMATS = {
    6406: THREE.AlphaFormat,
    6407: THREE.RGBFormat,
    6408: THREE.RGBAFormat,
    6409: THREE.LuminanceFormat,
    6410: THREE.LuminanceAlphaFormat
  };

  var WEBGL_TEXTURE_DATATYPES = {
    5121: THREE.UnsignedByteType,
    32819: THREE.UnsignedShort4444Type,
    32820: THREE.UnsignedShort5551Type,
    33635: THREE.UnsignedShort565Type
  };

  var WEBGL_SIDES = {
    1028: THREE.BackSide, // Culling front
    1029: THREE.FrontSide // Culling back
    //1032: THREE.NoSide   // Culling front and back, what to do?
  };

  var WEBGL_DEPTH_FUNCS = {
    512: THREE.NeverDepth,
    513: THREE.LessDepth,
    514: THREE.EqualDepth,
    515: THREE.LessEqualDepth,
    516: THREE.GreaterEqualDepth,
    517: THREE.NotEqualDepth,
    518: THREE.GreaterEqualDepth,
    519: THREE.AlwaysDepth
  };

  var WEBGL_BLEND_EQUATIONS = {
    32774: THREE.AddEquation,
    32778: THREE.SubtractEquation,
    32779: THREE.ReverseSubtractEquation
  };

  var WEBGL_BLEND_FUNCS = {
    0: THREE.ZeroFactor,
    1: THREE.OneFactor,
    768: THREE.SrcColorFactor,
    769: THREE.OneMinusSrcColorFactor,
    770: THREE.SrcAlphaFactor,
    771: THREE.OneMinusSrcAlphaFactor,
    772: THREE.DstAlphaFactor,
    773: THREE.OneMinusDstAlphaFactor,
    774: THREE.DstColorFactor,
    775: THREE.OneMinusDstColorFactor,
    776: THREE.SrcAlphaSaturateFactor
    // The followings are not supported by Three.js yet
    //32769: CONSTANT_COLOR,
    //32770: ONE_MINUS_CONSTANT_COLOR,
    //32771: CONSTANT_ALPHA,
    //32772: ONE_MINUS_CONSTANT_COLOR
  };

  var WEBGL_TYPE_SIZES = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16
  };

  var PATH_PROPERTIES = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  };

  var INTERPOLATION = {
    CATMULLROMSPLINE: THREE.InterpolateSmooth,
    CUBICSPLINE: THREE.InterpolateSmooth,
    LINEAR: THREE.InterpolateLinear,
    STEP: THREE.InterpolateDiscrete
  };

  var STATES_ENABLES = {
    2884: 'CULL_FACE',
    2929: 'DEPTH_TEST',
    3042: 'BLEND',
    3089: 'SCISSOR_TEST',
    32823: 'POLYGON_OFFSET_FILL',
    32926: 'SAMPLE_ALPHA_TO_COVERAGE'
  };

  var ALPHA_MODES = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND'
  };

  /* UTILITY FUNCTIONS */

  function _each( object, callback, thisObj ) {

    if ( ! object ) {

      return Promise.resolve();

    }

    var results;
    var fns = [];

    if ( Object.prototype.toString.call( object ) === '[object Array]' ) {

      results = [];

      var length = object.length;

      for ( var idx = 0; idx < length; idx ++ ) {

        var value = callback.call( thisObj || this, object[ idx ], idx );

        if ( value ) {

          fns.push( value );

          if ( value instanceof Promise ) {

            value.then( function ( key, value ) {

              results[ key ] = value;

            }.bind( this, idx ) );

          } else {

            results[ idx ] = value;

          }

        }

      }

    } else {

      results = {};

      for ( var key in object ) {

        if ( object.hasOwnProperty( key ) ) {

          var value = callback.call( thisObj || this, object[ key ], key );

          if ( value ) {

            fns.push( value );

            if ( value instanceof Promise ) {

              value.then( function ( key, value ) {

                results[ key ] = value;

              }.bind( this, key ) );

            } else {

              results[ key ] = value;

            }

          }

        }

      }

    }

    return Promise.all( fns ).then( function () {

      return results;

    } );

  }

  function resolveURL( url, path ) {

    // Invalid URL
    if ( typeof url !== 'string' || url === '' )
      return '';

    // Absolute URL http://,https://,//
    if ( /^(https?:)?\/\//i.test( url ) ) {

      return url;

    }

    // Data URI
    if ( /^data:.*,.*$/i.test( url ) ) {

      return url;

    }

    // Blob URL
    if ( /^blob:.*$/i.test( url ) ) {

      return url;

    }

    // Relative URL
    return ( path || '' ) + url;

  }

  function convertUint8ArrayToString( array ) {

    if ( window.TextDecoder !== undefined ) {

      return new TextDecoder().decode( array );

    }

    // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.

    var s = '';

    for ( var i = 0, il = array.length; i < il; i ++ ) {

      s += String.fromCharCode( array[ i ] );

    }

    return s;

  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */
  function createDefaultMaterial() {

    return new THREE.MeshStandardMaterial( {
      color: 0xFFFFFF,
      emissive: 0x000000,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: THREE.FrontSide
    } );

  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   * @param {THREE.Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   * @param {GLTF.Primitive} primitiveDef
   * @param {Object} dependencies
   */
  function addMorphTargets( mesh, meshDef, primitiveDef, dependencies ) {

    var geometry = mesh.geometry;
    var material = mesh.material;

    var targets = primitiveDef.targets;
    var morphAttributes = geometry.morphAttributes;

    morphAttributes.position = [];
    morphAttributes.normal = [];

    material.morphTargets = true;

    for ( var i = 0, il = targets.length; i < il; i ++ ) {

      var target = targets[ i ];
      var attributeName = 'morphTarget' + i;

      var positionAttribute, normalAttribute;

      if ( target.POSITION !== undefined ) {

        // Three.js morph formula is
        //   position
        //     + weight0 * ( morphTarget0 - position )
        //     + weight1 * ( morphTarget1 - position )
        //     ...
        // while the glTF one is
        //   position
        //     + weight0 * morphTarget0
        //     + weight1 * morphTarget1
        //     ...
        // then adding position to morphTarget.
        // So morphTarget value will depend on mesh's position, then cloning attribute
        // for the case if attribute is shared among two or more meshes.

        positionAttribute = dependencies.accessors[ target.POSITION ].clone();
        var position = geometry.attributes.position;

        for ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {

          positionAttribute.setXYZ(
            j,
            positionAttribute.getX( j ) + position.getX( j ),
            positionAttribute.getY( j ) + position.getY( j ),
            positionAttribute.getZ( j ) + position.getZ( j )
          );

        }

      } else {

        // Copying the original position not to affect the final position.
        // See the formula above.
        positionAttribute = geometry.attributes.position.clone();

      }

      if ( target.NORMAL !== undefined ) {

        material.morphNormals = true;

        // see target.POSITION's comment

        normalAttribute = dependencies.accessors[ target.NORMAL ].clone();
        var normal = geometry.attributes.normal;

        for ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) {

          normalAttribute.setXYZ(
            j,
            normalAttribute.getX( j ) + normal.getX( j ),
            normalAttribute.getY( j ) + normal.getY( j ),
            normalAttribute.getZ( j ) + normal.getZ( j )
          );

        }

      } else {

        normalAttribute = geometry.attributes.normal.clone();

      }

      if ( target.TANGENT !== undefined ) {

        // TODO: implement

      }

      positionAttribute.name = attributeName;
      normalAttribute.name = attributeName;

      morphAttributes.position.push( positionAttribute );
      morphAttributes.normal.push( normalAttribute );

    }

    mesh.updateMorphTargets();

    if ( meshDef.weights !== undefined ) {

      for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

        mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

      }

    }

  }

  /* GLTF PARSER */

  function GLTFParser( json, extensions, options ) {

    this.json = json || {};
    this.extensions = extensions || {};
    this.options = options || {};

    // loader object cache
    this.cache = new GLTFRegistry();

  }

  GLTFParser.prototype._withDependencies = function ( dependencies ) {

    var _dependencies = {};

    for ( var i = 0; i < dependencies.length; i ++ ) {

      var dependency = dependencies[ i ];
      var fnName = 'load' + dependency.charAt( 0 ).toUpperCase() + dependency.slice( 1 );

      var cached = this.cache.get( dependency );

      if ( cached !== undefined ) {

        _dependencies[ dependency ] = cached;

      } else if ( this[ fnName ] ) {

        var fn = this[ fnName ]();
        this.cache.add( dependency, fn );

        _dependencies[ dependency ] = fn;

      }

    }

    return _each( _dependencies, function ( dependency ) {

      return dependency;

    } );

  };

  GLTFParser.prototype.parse = function ( onLoad, onError ) {

    var json = this.json;

    // Clear the loader cache
    this.cache.removeAll();

    // Fire the callback on complete
    this._withDependencies( [

      'scenes',
      'cameras',
      'animations'

    ] ).then( function ( dependencies ) {

      var scenes = [];

      for ( var i = 0; i < dependencies.scenes.length; i ++ ) {

        scenes.push( dependencies.scenes[ i ] );

      }

      var scene = json.scene !== undefined ? dependencies.scenes[ json.scene ] : scenes[ 0 ];

      var cameras = [];

      dependencies.cameras = dependencies.cameras || [];

      for ( var i = 0; i < dependencies.cameras.length; i ++ ) {

        var camera = dependencies.cameras[ i ];
        cameras.push( camera );

      }

      var animations = [];

      dependencies.animations = dependencies.animations || [];

      for ( var i = 0; i < dependencies.animations.length; i ++ ) {

        animations.push( dependencies.animations[ i ] );

      }

      onLoad( scene, scenes, cameras, animations );

    } ).catch( onError );

  };

  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object>}
   */
  GLTFParser.prototype.getDependency = function ( type, index ) {

    var cacheKey = type + ':' + index;
    var dependency = this.cache.get( cacheKey );

    if ( ! dependency ) {

      var fnName = 'load' + type.charAt( 0 ).toUpperCase() + type.slice( 1 );
      dependency = this[ fnName ]( index );
      this.cache.add( cacheKey, dependency );

    }

    return dependency;

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

    var bufferDef = this.json.buffers[ bufferIndex ];

    if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

      throw new Error( 'THREE.GLTFLoader: %s buffer type is not supported.', bufferDef.type );

    }

    // If present, GLB container is required to be the first buffer.
    if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

      return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

    }

    var options = this.options;

    return new Promise( function ( resolve ) {

      var loader = new THREE.FileLoader();
      loader.setResponseType( 'arraybuffer' );
      loader.load( resolveURL( bufferDef.uri, options.path ), resolve );

    } );

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

    var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

    return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice( byteOffset, byteOffset + byteLength );

    } );

  };

  GLTFParser.prototype.loadAccessors = function () {

    var parser = this;
    var json = this.json;

    return _each( json.accessors, function ( accessor ) {

      return parser.getDependency( 'bufferView', accessor.bufferView ).then( function ( bufferView ) {

        var itemSize = WEBGL_TYPE_SIZES[ accessor.type ];
        var TypedArray = WEBGL_COMPONENT_TYPES[ accessor.componentType ];

        // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteStride = json.bufferViews[ accessor.bufferView ].byteStride;
        var array;

        // The buffer is not interleaved if the stride is the item size in bytes.
        if ( byteStride && byteStride !== itemBytes ) {

          // Use the full buffer if it's interleaved.
          array = new TypedArray( bufferView );

          // Integer parameters to IB/IBA are in array elements, not bytes.
          var ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );

          return new THREE.InterleavedBufferAttribute( ib, itemSize, accessor.byteOffset / elementBytes );

        } else {

          array = new TypedArray( bufferView, accessor.byteOffset, accessor.count * itemSize );

          return new THREE.BufferAttribute( array, itemSize );

        }

      } );

    } );

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */
  GLTFParser.prototype.loadTexture = function ( textureIndex ) {

    var parser = this;
    var json = this.json;
    var options = this.options;

    var URL = window.URL || window.webkitURL;

    var textureDef = json.textures[ textureIndex ];
    var source = json.images[ textureDef.source ];
    var sourceURI = source.uri;
    var isObjectURL = false;

    if ( source.bufferView !== undefined ) {

      // Load binary image data from bufferView, if provided.

      sourceURI = parser.getDependency( 'bufferView', source.bufferView )
        .then( function ( bufferView ) {

          isObjectURL = true;
          var blob = new Blob( [ bufferView ], { type: source.mimeType } );
          sourceURI = URL.createObjectURL( blob );
          return sourceURI;

        } );

    }

    return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

      // Load Texture resource.

      var textureLoader = THREE.Loader.Handlers.get( sourceURI ) || new THREE.TextureLoader();
      textureLoader.setCrossOrigin( options.crossOrigin );

      return new Promise( function ( resolve, reject ) {

        textureLoader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );

      } );

    } ).then( function ( texture ) {

      // Clean up resources and configure Texture.

      if ( isObjectURL === true ) {

        URL.revokeObjectURL( sourceURI );

      }

      texture.flipY = false;

      if ( textureDef.name !== undefined ) texture.name = textureDef.name;

      texture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[ textureDef.format ] : THREE.RGBAFormat;

      if ( textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[ textureDef.internalFormat ] ) {

        console.warn( 'THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' +
                      'internalFormat will be forced to be the same value as format.' );

      }

      texture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ textureDef.type ] : THREE.UnsignedByteType;

      var samplers = json.samplers || {};
      var sampler = samplers[ textureDef.sampler ] || {};

      texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;
      texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;

      return texture;

    } );

  };

  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} textureName
   * @param {number} textureIndex
   * @return {Promise}
   */
  GLTFParser.prototype.assignTexture = function ( materialParams, textureName, textureIndex ) {

    return this.getDependency( 'texture', textureIndex ).then( function ( texture ) {

      materialParams[ textureName ] = texture;

    } );

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @return {Promise<Array<THREE.Material>>}
   */
  GLTFParser.prototype.loadMaterials = function () {

    var parser = this;
    var json = this.json;
    var extensions = this.extensions;

    return _each( json.materials, function ( material ) {

      var materialType;
      var materialParams = {};
      var materialExtensions = material.extensions || {};

      var pending = [];

      if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) {

        var khcExtension = extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ];
        materialType = khcExtension.getMaterialType( material );
        pending.push( khcExtension.extendParams( materialParams, material, parser ) );

      } else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

        var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
        materialType = sgExtension.getMaterialType( material );
        pending.push( sgExtension.extendParams( materialParams, material, parser ) );

      } else if ( material.pbrMetallicRoughness !== undefined ) {

        // Specification:
        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

        materialType = THREE.MeshStandardMaterial;

        var metallicRoughness = material.pbrMetallicRoughness;

        materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
        materialParams.opacity = 1.0;

        if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

          var array = metallicRoughness.baseColorFactor;

          materialParams.color.fromArray( array );
          materialParams.opacity = array[ 3 ];

        }

        if ( metallicRoughness.baseColorTexture !== undefined ) {

          pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );

        }

        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

        if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

          var textureIndex = metallicRoughness.metallicRoughnessTexture.index;
          pending.push( parser.assignTexture( materialParams, 'metalnessMap', textureIndex ) );
          pending.push( parser.assignTexture( materialParams, 'roughnessMap', textureIndex ) );

        }

      } else {

        materialType = THREE.MeshPhongMaterial;

      }

      if ( material.doubleSided === true ) {

        materialParams.side = THREE.DoubleSide;

      }

      var alphaMode = material.alphaMode || ALPHA_MODES.OPAQUE;

      if ( alphaMode !== ALPHA_MODES.OPAQUE ) {

        materialParams.transparent = true;

        if ( alphaMode === ALPHA_MODES.MASK ) {

          materialParams.alphaTest = material.alphaCutoff || 0.5;

        }

      } else {

        materialParams.transparent = false;

      }

      if ( material.normalTexture !== undefined ) {

        pending.push( parser.assignTexture( materialParams, 'normalMap', material.normalTexture.index ) );

        materialParams.normalScale = new THREE.Vector2( 1, 1 );

        if ( material.normalTexture.scale !== undefined ) {

          materialParams.normalScale.set( material.normalTexture.scale, material.normalTexture.scale );

        }

      }

      if ( material.occlusionTexture !== undefined ) {

        pending.push( parser.assignTexture( materialParams, 'aoMap', material.occlusionTexture.index ) );

        if ( material.occlusionTexture.strength !== undefined ) {

          materialParams.aoMapIntensity = material.occlusionTexture.strength;

        }

      }

      if ( material.emissiveFactor !== undefined ) {

        if ( materialType === THREE.MeshBasicMaterial ) {

          materialParams.color = new THREE.Color().fromArray( material.emissiveFactor );

        } else {

          materialParams.emissive = new THREE.Color().fromArray( material.emissiveFactor );

        }

      }

      if ( material.emissiveTexture !== undefined ) {

        if ( materialType === THREE.MeshBasicMaterial ) {

          pending.push( parser.assignTexture( materialParams, 'map', material.emissiveTexture.index ) );

        } else {

          pending.push( parser.assignTexture( materialParams, 'emissiveMap', material.emissiveTexture.index ) );

        }

      }

      return Promise.all( pending ).then( function () {

        var _material;

        if ( materialType === THREE.ShaderMaterial ) {

          _material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

        } else {

          _material = new materialType( materialParams );

        }

        if ( material.name !== undefined ) _material.name = material.name;

        // Normal map textures use OpenGL conventions:
        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture
        if ( _material.normalScale ) {

          _material.normalScale.x = - _material.normalScale.x;

        }

        // emissiveTexture and baseColorTexture use sRGB encoding.
        if ( _material.map ) _material.map.encoding = THREE.sRGBEncoding;
        if ( _material.emissiveMap ) _material.emissiveMap.encoding = THREE.sRGBEncoding;

        if ( material.extras ) _material.userData = material.extras;

        return _material;

      } );

    } );

  };

  GLTFParser.prototype.loadGeometries = function ( primitives ) {

    return this._withDependencies( [

      'accessors',

    ] ).then( function ( dependencies ) {

      return _each( primitives, function ( primitive ) {

        var geometry = new THREE.BufferGeometry();

        var attributes = primitive.attributes;

        for ( var attributeId in attributes ) {

          var attributeEntry = attributes[ attributeId ];

          if ( attributeEntry === undefined ) return;

          var bufferAttribute = dependencies.accessors[ attributeEntry ];

          switch ( attributeId ) {

            case 'POSITION':

              geometry.addAttribute( 'position', bufferAttribute );
              break;

            case 'NORMAL':

              geometry.addAttribute( 'normal', bufferAttribute );
              break;

            case 'TEXCOORD_0':
            case 'TEXCOORD0':
            case 'TEXCOORD':

              geometry.addAttribute( 'uv', bufferAttribute );
              break;

            case 'TEXCOORD_1':

              geometry.addAttribute( 'uv2', bufferAttribute );
              break;

            case 'COLOR_0':
            case 'COLOR0':
            case 'COLOR':

              geometry.addAttribute( 'color', bufferAttribute );
              break;

            case 'WEIGHTS_0':
            case 'WEIGHT': // WEIGHT semantic deprecated.

              geometry.addAttribute( 'skinWeight', bufferAttribute );
              break;

            case 'JOINTS_0':
            case 'JOINT': // JOINT semantic deprecated.

              geometry.addAttribute( 'skinIndex', bufferAttribute );
              break;

          }

        }

        if ( primitive.indices !== undefined ) {

          geometry.setIndex( dependencies.accessors[ primitive.indices ] );

        }

        return geometry;

      } );

    } );

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   */
  GLTFParser.prototype.loadMeshes = function () {

    var scope = this;
    var json = this.json;

    return this._withDependencies( [

      'accessors',
      'materials'

    ] ).then( function ( dependencies ) {

      return _each( json.meshes, function ( meshDef, meshIndex ) {

        var group = new THREE.Group();

        var primitives = meshDef.primitives || [];

        return scope.loadGeometries( primitives ).then( function ( geometries ) {

          for ( var i = 0; i < primitives.length; i ++ ) {

            var primitive = primitives[ i ];
            var geometry = geometries[ i ];

            var material = primitive.material === undefined
              ? createDefaultMaterial()
              : dependencies.materials[ primitive.material ];

            if ( material.aoMap
                && geometry.attributes.uv2 === undefined
                && geometry.attributes.uv !== undefined ) {

              console.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' );
              geometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );

            }

            var useVertexColors = geometry.attributes.color !== undefined;
            var useFlatShading = geometry.attributes.normal === undefined;

            if ( useVertexColors || useFlatShading ) {

              material = material.clone();

            }

            if ( useVertexColors ) {

              material.vertexColors = THREE.VertexColors;
              material.needsUpdate = true;

            }

            if ( useFlatShading ) {

              material.flatShading = true;

            }

            var mesh;

            if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined ) {

              mesh = new THREE.Mesh( geometry, material );

            } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

              mesh = new THREE.Mesh( geometry, material );
              mesh.drawMode = THREE.TriangleStripDrawMode;

            } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

              mesh = new THREE.Mesh( geometry, material );
              mesh.drawMode = THREE.TriangleFanDrawMode;

            } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

              mesh = new THREE.LineSegments( geometry, material );

            } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

              mesh = new THREE.Line( geometry, material );

            } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

              mesh = new THREE.LineLoop( geometry, material );

            } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

              mesh = new THREE.Points( geometry, material );

            } else {

              throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ', primitive.mode );

            }

            mesh.name = meshDef.name || ( 'mesh_' + meshIndex );
            mesh.name += i > 0 ? ( '_' + i ) : '';

            if ( primitive.targets !== undefined ) {

              addMorphTargets( mesh, meshDef, primitive, dependencies );

            }

            if ( primitive.extras ) mesh.userData = primitive.extras;

            group.add( mesh );

          }

          return group;

        } );

      } );

    } );

  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   */
  GLTFParser.prototype.loadCameras = function () {

    var json = this.json;

    return _each( json.cameras, function ( camera ) {

      var _camera;

      var params = camera[ camera.type ];

      if ( ! params ) {

        console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
        return;

      }

      if ( camera.type === 'perspective' ) {

        var aspectRatio = params.aspectRatio || 1;
        var xfov = params.yfov * aspectRatio;

        _camera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( xfov ), aspectRatio, params.znear || 1, params.zfar || 2e6 );

      } else if ( camera.type === 'orthographic' ) {

        _camera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );

      }

      if ( camera.name !== undefined ) _camera.name = camera.name;
      if ( camera.extras ) _camera.userData = camera.extras;

      return _camera;

    } );

  };

  GLTFParser.prototype.loadSkins = function () {

    var json = this.json;

    return this._withDependencies( [

      'accessors'

    ] ).then( function ( dependencies ) {

      return _each( json.skins, function ( skin ) {

        var _skin = {
          joints: skin.joints,
          inverseBindMatrices: dependencies.accessors[ skin.inverseBindMatrices ]
        };

        return _skin;

      } );

    } );

  };

  GLTFParser.prototype.loadAnimations = function () {

    var json = this.json;

    return this._withDependencies( [

      'accessors',
      'nodes'

    ] ).then( function ( dependencies ) {

      return _each( json.animations, function ( animation, animationId ) {

        var tracks = [];

        for ( var i = 0; i < animation.channels.length; i ++ ) {

          var channel = animation.channels[ i ];
          var sampler = animation.samplers[ channel.sampler ];

          if ( sampler ) {

            var target = channel.target;
            var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
            var input = animation.parameters !== undefined ? animation.parameters[ sampler.input ] : sampler.input;
            var output = animation.parameters !== undefined ? animation.parameters[ sampler.output ] : sampler.output;

            var inputAccessor = dependencies.accessors[ input ];
            var outputAccessor = dependencies.accessors[ output ];

            var node = dependencies.nodes[ name ];

            if ( node ) {

              node.updateMatrix();
              node.matrixAutoUpdate = true;

              var TypedKeyframeTrack;

              switch ( PATH_PROPERTIES[ target.path ] ) {

                case PATH_PROPERTIES.weights:

                  TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                  break;

                case PATH_PROPERTIES.rotation:

                  TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                  break;

                case PATH_PROPERTIES.position:
                case PATH_PROPERTIES.scale:
                default:

                  TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                  break;

              }

              var targetName = node.name ? node.name : node.uuid;

              if ( sampler.interpolation === 'CATMULLROMSPLINE' ) {

                console.warn( 'THREE.GLTFLoader: CATMULLROMSPLINE interpolation is not supported. Using CUBICSPLINE instead.' );

              }

              var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;

              var targetNames = [];

              if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

                // node should be THREE.Group here but
                // PATH_PROPERTIES.weights(morphTargetInfluences) should be
                // the property of a mesh object under node.
                // So finding targets here.

                node.traverse( function ( object ) {

                  if ( object.isMesh === true && object.material.morphTargets === true ) {

                    targetNames.push( object.name ? object.name : object.uuid );

                  }

                } );

              } else {

                targetNames.push( targetName );

              }

              // KeyframeTrack.optimize() will modify given 'times' and 'values'
              // buffers before creating a truncated copy to keep. Because buffers may
              // be reused by other tracks, make copies here.
              for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

                tracks.push( new TypedKeyframeTrack(
                  targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
                  THREE.AnimationUtils.arraySlice( inputAccessor.array, 0 ),
                  THREE.AnimationUtils.arraySlice( outputAccessor.array, 0 ),
                  interpolation
                ) );

              }

            }

          }

        }

        var name = animation.name !== undefined ? animation.name : 'animation_' + animationId;

        return new THREE.AnimationClip( name, undefined, tracks );

      } );

    } );

  };

  GLTFParser.prototype.loadNodes = function () {

    var json = this.json;
    var extensions = this.extensions;
    var scope = this;

    var nodes = json.nodes || [];
    var skins = json.skins || [];

    // Nothing in the node definition indicates whether it is a Bone or an
    // Object3D. Use the skins' joint references to mark bones.
    skins.forEach( function ( skin ) {

      skin.joints.forEach( function ( id ) {

        nodes[ id ].isBone = true;

      } );

    } );

    return scope._withDependencies( [

      'meshes',
      'skins',
      'cameras'

    ] ).then( function ( dependencies ) {

      return _each( json.nodes, function ( nodeDef ) {

        if ( nodeDef.isBone === true ) {

          return new THREE.Bone();

        } else if ( nodeDef.mesh !== undefined ) {

          return dependencies.meshes[ nodeDef.mesh ].clone();

        } else if ( nodeDef.camera !== undefined ) {

          return dependencies.cameras[ nodeDef.camera ];

        } else if ( nodeDef.extensions
                 && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ]
                 && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light !== undefined ) {

          var lights = extensions[ EXTENSIONS.KHR_LIGHTS ].lights;
          return lights[ nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light ];

        } else {

          return new THREE.Object3D();

        }

      } ).then( function ( __nodes ) {

        return _each( __nodes, function ( node, nodeIndex ) {

          var nodeDef = json.nodes[ nodeIndex ];

          if ( nodeDef.name !== undefined ) {

            node.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );

          }

          if ( nodeDef.extras ) node.userData = nodeDef.extras;

          if ( nodeDef.matrix !== undefined ) {

            var matrix = new THREE.Matrix4();
            matrix.fromArray( nodeDef.matrix );
            node.applyMatrix( matrix );

          } else {

            if ( nodeDef.translation !== undefined ) {

              node.position.fromArray( nodeDef.translation );

            }

            if ( nodeDef.rotation !== undefined ) {

              node.quaternion.fromArray( nodeDef.rotation );

            }

            if ( nodeDef.scale !== undefined ) {

              node.scale.fromArray( nodeDef.scale );

            }

          }

          if ( nodeDef.skin !== undefined ) {

            var skinnedMeshes = [];

            for ( var i = 0; i < node.children.length; i ++ ) {

              var skinEntry = dependencies.skins[ nodeDef.skin ];

              // Replace Mesh with SkinnedMesh.
              var geometry = node.children[ i ].geometry;
              var material = node.children[ i ].material;
              material.skinning = true;

              var child = new THREE.SkinnedMesh( geometry, material );
              child.morphTargetInfluences = node.children[ i ].morphTargetInfluences;
              child.userData = node.children[ i ].userData;
              child.name = node.children[ i ].name;

              var bones = [];
              var boneInverses = [];

              for ( var j = 0, l = skinEntry.joints.length; j < l; j ++ ) {

                var jointId = skinEntry.joints[ j ];
                var jointNode = __nodes[ jointId ];

                if ( jointNode ) {

                  bones.push( jointNode );

                  var m = skinEntry.inverseBindMatrices.array;
                  var mat = new THREE.Matrix4().fromArray( m, j * 16 );
                  boneInverses.push( mat );

                } else {

                  console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', jointId );

                }

              }

              child.bind( new THREE.Skeleton( bones, boneInverses ), child.matrixWorld );

              skinnedMeshes.push( child );

            }

            node.remove.apply( node, node.children );
            node.add.apply( node, skinnedMeshes );

          }

          return node;

        } );

      } );

    } );

  };

  GLTFParser.prototype.loadScenes = function () {

    var json = this.json;
    var extensions = this.extensions;

    // scene node hierachy builder

    function buildNodeHierachy( nodeId, parentObject, allNodes ) {

      var _node = allNodes[ nodeId ];
      parentObject.add( _node );

      var node = json.nodes[ nodeId ];

      if ( node.children ) {

        var children = node.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

          var child = children[ i ];
          buildNodeHierachy( child, _node, allNodes );

        }

      }

    }

    return this._withDependencies( [

      'nodes'

    ] ).then( function ( dependencies ) {

      return _each( json.scenes, function ( scene ) {

        var _scene = new THREE.Scene();
        if ( scene.name !== undefined ) _scene.name = scene.name;

        if ( scene.extras ) _scene.userData = scene.extras;

        var nodes = scene.nodes || [];

        for ( var i = 0, l = nodes.length; i < l; i ++ ) {

          var nodeId = nodes[ i ];
          buildNodeHierachy( nodeId, _scene, dependencies.nodes );

        }

        _scene.traverse( function ( child ) {

          // for Specular-Glossiness.
          if ( child.material && child.material.isGLTFSpecularGlossinessMaterial ) {

            child.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;

          }

        } );

        // Ambient lighting, if present, is always attached to the scene root.
        if ( scene.extensions
               && scene.extensions[ EXTENSIONS.KHR_LIGHTS ]
               && scene.extensions[ EXTENSIONS.KHR_LIGHTS ].light !== undefined ) {

          var lights = extensions[ EXTENSIONS.KHR_LIGHTS ].lights;
          _scene.add( lights[ scene.extensions[ EXTENSIONS.KHR_LIGHTS ].light ] );

        }

        return _scene;

      } );

    } );

  };

  return GLTFLoader;

} )();

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.KMZLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.KMZLoader.prototype = {

  constructor: THREE.KMZLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  parse: function ( data ) {

    var zip = new JSZip( data ); // eslint-disable-line no-undef

    // console.log( zip );

    // var xml = new DOMParser().parseFromString( zip.file( 'doc.kml' ).asText(), 'application/xml' );

    function loadImage( image ) {

      var path = decodeURI( image.init_from );

      // Hack to support relative paths
      path = path.replace( '../', '' );

      var regex = new RegExp( path + '$' );
      var files = zip.file( regex );

      // console.log( image, files );

      if ( files.length ) {

        var file = files[ 0 ];
        var blob = new Blob( [ file.asArrayBuffer() ], { type: 'application/octet-binary' } );
        image.build.src = URL.createObjectURL( blob );

      }

    }

    // load collada

    var files = zip.file( /dae$/i );

    if ( files.length ) {

      var file = files[ 0 ];

      var collada = new THREE.ColladaLoader().parse( file.asText() );

      // fix images

      var images = collada.library.images;

      for ( var name in images ) {

        loadImage( images[ name ] );

      }

      return collada;

    }

    console.error( 'KMZLoader: Couldn\'t find .dae file.' );

    return {
      scene: new THREE.Group()
    };

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MD2Loader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MD2Loader.prototype = {

  constructor: THREE.MD2Loader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( buffer ) {

      onLoad( scope.parse( buffer ) );

    }, onProgress, onError );

  },

  parse: ( function () {

    var normals = [
      [ -0.525731,  0.000000,  0.850651 ], [ -0.442863,  0.238856,  0.864188 ],
      [ -0.295242,  0.000000,  0.955423 ], [ -0.309017,  0.500000,  0.809017 ],
      [ -0.162460,  0.262866,  0.951056 ], [  0.000000,  0.000000,  1.000000 ],
      [  0.000000,  0.850651,  0.525731 ], [ -0.147621,  0.716567,  0.681718 ],
      [  0.147621,  0.716567,  0.681718 ], [  0.000000,  0.525731,  0.850651 ],
      [  0.309017,  0.500000,  0.809017 ], [  0.525731,  0.000000,  0.850651 ],
      [  0.295242,  0.000000,  0.955423 ], [  0.442863,  0.238856,  0.864188 ],
      [  0.162460,  0.262866,  0.951056 ], [ -0.681718,  0.147621,  0.716567 ],
      [ -0.809017,  0.309017,  0.500000 ], [ -0.587785,  0.425325,  0.688191 ],
      [ -0.850651,  0.525731,  0.000000 ], [ -0.864188,  0.442863,  0.238856 ],
      [ -0.716567,  0.681718,  0.147621 ], [ -0.688191,  0.587785,  0.425325 ],
      [ -0.500000,  0.809017,  0.309017 ], [ -0.238856,  0.864188,  0.442863 ],
      [ -0.425325,  0.688191,  0.587785 ], [ -0.716567,  0.681718, -0.147621 ],
      [ -0.500000,  0.809017, -0.309017 ], [ -0.525731,  0.850651,  0.000000 ],
      [  0.000000,  0.850651, -0.525731 ], [ -0.238856,  0.864188, -0.442863 ],
      [  0.000000,  0.955423, -0.295242 ], [ -0.262866,  0.951056, -0.162460 ],
      [  0.000000,  1.000000,  0.000000 ], [  0.000000,  0.955423,  0.295242 ],
      [ -0.262866,  0.951056,  0.162460 ], [  0.238856,  0.864188,  0.442863 ],
      [  0.262866,  0.951056,  0.162460 ], [  0.500000,  0.809017,  0.309017 ],
      [  0.238856,  0.864188, -0.442863 ], [  0.262866,  0.951056, -0.162460 ],
      [  0.500000,  0.809017, -0.309017 ], [  0.850651,  0.525731,  0.000000 ],
      [  0.716567,  0.681718,  0.147621 ], [  0.716567,  0.681718, -0.147621 ],
      [  0.525731,  0.850651,  0.000000 ], [  0.425325,  0.688191,  0.587785 ],
      [  0.864188,  0.442863,  0.238856 ], [  0.688191,  0.587785,  0.425325 ],
      [  0.809017,  0.309017,  0.500000 ], [  0.681718,  0.147621,  0.716567 ],
      [  0.587785,  0.425325,  0.688191 ], [  0.955423,  0.295242,  0.000000 ],
      [  1.000000,  0.000000,  0.000000 ], [  0.951056,  0.162460,  0.262866 ],
      [  0.850651, -0.525731,  0.000000 ], [  0.955423, -0.295242,  0.000000 ],
      [  0.864188, -0.442863,  0.238856 ], [  0.951056, -0.162460,  0.262866 ],
      [  0.809017, -0.309017,  0.500000 ], [  0.681718, -0.147621,  0.716567 ],
      [  0.850651,  0.000000,  0.525731 ], [  0.864188,  0.442863, -0.238856 ],
      [  0.809017,  0.309017, -0.500000 ], [  0.951056,  0.162460, -0.262866 ],
      [  0.525731,  0.000000, -0.850651 ], [  0.681718,  0.147621, -0.716567 ],
      [  0.681718, -0.147621, -0.716567 ], [  0.850651,  0.000000, -0.525731 ],
      [  0.809017, -0.309017, -0.500000 ], [  0.864188, -0.442863, -0.238856 ],
      [  0.951056, -0.162460, -0.262866 ], [  0.147621,  0.716567, -0.681718 ],
      [  0.309017,  0.500000, -0.809017 ], [  0.425325,  0.688191, -0.587785 ],
      [  0.442863,  0.238856, -0.864188 ], [  0.587785,  0.425325, -0.688191 ],
      [  0.688191,  0.587785, -0.425325 ], [ -0.147621,  0.716567, -0.681718 ],
      [ -0.309017,  0.500000, -0.809017 ], [  0.000000,  0.525731, -0.850651 ],
      [ -0.525731,  0.000000, -0.850651 ], [ -0.442863,  0.238856, -0.864188 ],
      [ -0.295242,  0.000000, -0.955423 ], [ -0.162460,  0.262866, -0.951056 ],
      [  0.000000,  0.000000, -1.000000 ], [  0.295242,  0.000000, -0.955423 ],
      [  0.162460,  0.262866, -0.951056 ], [ -0.442863, -0.238856, -0.864188 ],
      [ -0.309017, -0.500000, -0.809017 ], [ -0.162460, -0.262866, -0.951056 ],
      [  0.000000, -0.850651, -0.525731 ], [ -0.147621, -0.716567, -0.681718 ],
      [  0.147621, -0.716567, -0.681718 ], [  0.000000, -0.525731, -0.850651 ],
      [  0.309017, -0.500000, -0.809017 ], [  0.442863, -0.238856, -0.864188 ],
      [  0.162460, -0.262866, -0.951056 ], [  0.238856, -0.864188, -0.442863 ],
      [  0.500000, -0.809017, -0.309017 ], [  0.425325, -0.688191, -0.587785 ],
      [  0.716567, -0.681718, -0.147621 ], [  0.688191, -0.587785, -0.425325 ],
      [  0.587785, -0.425325, -0.688191 ], [  0.000000, -0.955423, -0.295242 ],
      [  0.000000, -1.000000,  0.000000 ], [  0.262866, -0.951056, -0.162460 ],
      [  0.000000, -0.850651,  0.525731 ], [  0.000000, -0.955423,  0.295242 ],
      [  0.238856, -0.864188,  0.442863 ], [  0.262866, -0.951056,  0.162460 ],
      [  0.500000, -0.809017,  0.309017 ], [  0.716567, -0.681718,  0.147621 ],
      [  0.525731, -0.850651,  0.000000 ], [ -0.238856, -0.864188, -0.442863 ],
      [ -0.500000, -0.809017, -0.309017 ], [ -0.262866, -0.951056, -0.162460 ],
      [ -0.850651, -0.525731,  0.000000 ], [ -0.716567, -0.681718, -0.147621 ],
      [ -0.716567, -0.681718,  0.147621 ], [ -0.525731, -0.850651,  0.000000 ],
      [ -0.500000, -0.809017,  0.309017 ], [ -0.238856, -0.864188,  0.442863 ],
      [ -0.262866, -0.951056,  0.162460 ], [ -0.864188, -0.442863,  0.238856 ],
      [ -0.809017, -0.309017,  0.500000 ], [ -0.688191, -0.587785,  0.425325 ],
      [ -0.681718, -0.147621,  0.716567 ], [ -0.442863, -0.238856,  0.864188 ],
      [ -0.587785, -0.425325,  0.688191 ], [ -0.309017, -0.500000,  0.809017 ],
      [ -0.147621, -0.716567,  0.681718 ], [ -0.425325, -0.688191,  0.587785 ],
      [ -0.162460, -0.262866,  0.951056 ], [  0.442863, -0.238856,  0.864188 ],
      [  0.162460, -0.262866,  0.951056 ], [  0.309017, -0.500000,  0.809017 ],
      [  0.147621, -0.716567,  0.681718 ], [  0.000000, -0.525731,  0.850651 ],
      [  0.425325, -0.688191,  0.587785 ], [  0.587785, -0.425325,  0.688191 ],
      [  0.688191, -0.587785,  0.425325 ], [ -0.955423,  0.295242,  0.000000 ],
      [ -0.951056,  0.162460,  0.262866 ], [ -1.000000,  0.000000,  0.000000 ],
      [ -0.850651,  0.000000,  0.525731 ], [ -0.955423, -0.295242,  0.000000 ],
      [ -0.951056, -0.162460,  0.262866 ], [ -0.864188,  0.442863, -0.238856 ],
      [ -0.951056,  0.162460, -0.262866 ], [ -0.809017,  0.309017, -0.500000 ],
      [ -0.864188, -0.442863, -0.238856 ], [ -0.951056, -0.162460, -0.262866 ],
      [ -0.809017, -0.309017, -0.500000 ], [ -0.681718,  0.147621, -0.716567 ],
      [ -0.681718, -0.147621, -0.716567 ], [ -0.850651,  0.000000, -0.525731 ],
      [ -0.688191,  0.587785, -0.425325 ], [ -0.587785,  0.425325, -0.688191 ],
      [ -0.425325,  0.688191, -0.587785 ], [ -0.425325, -0.688191, -0.587785 ],
      [ -0.587785, -0.425325, -0.688191 ], [ -0.688191, -0.587785, -0.425325 ]
    ];

    return function ( buffer ) {

      console.time( 'MD2Loader' );

      var data = new DataView( buffer );

      // http://tfc.duke.free.fr/coding/md2-specs-en.html

      var header = {};
      var headerNames = [
        'ident', 'version',
        'skinwidth', 'skinheight',
        'framesize',
        'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames',
        'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'
      ];

      for ( var i = 0; i < headerNames.length; i ++ ) {

        header[ headerNames[ i ] ] = data.getInt32( i * 4, true );

      }

      if ( header.ident !== 844121161 || header.version !== 8 ) {

        console.error( 'Not a valid MD2 file' );
        return;

      }

      if ( header.offset_end !== data.byteLength ) {

        console.error( 'Corrupted MD2 file' );
        return;

      }

      //

      var geometry = new THREE.Geometry();

      // uvs

      var uvs = [];
      var offset = header.offset_st;

      for ( var i = 0, l = header.num_st; i < l; i ++ ) {

        var u = data.getInt16( offset + 0, true );
        var v = data.getInt16( offset + 2, true );

        uvs.push( new THREE.Vector2( u / header.skinwidth, 1 - ( v / header.skinheight ) ) );

        offset += 4;

      }

      // triangles

      var offset = header.offset_tris;

      for ( var i = 0, l = header.num_tris; i < l; i ++ ) {

        var a = data.getUint16( offset + 0, true );
        var b = data.getUint16( offset + 2, true );
        var c = data.getUint16( offset + 4, true );

        geometry.faces.push( new THREE.Face3( a, b, c ) );

        geometry.faceVertexUvs[ 0 ].push( [
          uvs[ data.getUint16( offset + 6, true ) ],
          uvs[ data.getUint16( offset + 8, true ) ],
          uvs[ data.getUint16( offset + 10, true ) ]
        ] );

        offset += 12;

      }

      // frames

      var translation = new THREE.Vector3();
      var scale = new THREE.Vector3();
      var string = [];

      var offset = header.offset_frames;

      for ( var i = 0, l = header.num_frames; i < l; i ++ ) {

        scale.set(
          data.getFloat32( offset + 0, true ),
          data.getFloat32( offset + 4, true ),
          data.getFloat32( offset + 8, true )
        );

        translation.set(
          data.getFloat32( offset + 12, true ),
          data.getFloat32( offset + 16, true ),
          data.getFloat32( offset + 20, true )
        );

        offset += 24;

        for ( var j = 0; j < 16; j ++ ) {

          var character = data.getUint8( offset + j, true );
          if ( character === 0 ) break;

          string[ j ] = character;

        }

        var frame = {
          name: String.fromCharCode.apply( null, string ),
          vertices: [],
          normals: []
        };

        offset += 16;

        for ( var j = 0; j < header.num_vertices; j ++ ) {

          var x = data.getUint8( offset ++, true );
          var y = data.getUint8( offset ++, true );
          var z = data.getUint8( offset ++, true );
          var n = normals[ data.getUint8( offset ++, true ) ];

          var vertex = new THREE.Vector3(
            x * scale.x + translation.x,
            z * scale.z + translation.z,
            y * scale.y + translation.y
          );

          var normal = new THREE.Vector3( n[ 0 ], n[ 2 ], n[ 1 ] );

          frame.vertices.push( vertex );
          frame.normals.push( normal );

        }

        geometry.morphTargets.push( frame );

      }

      // Static

      geometry.vertices = geometry.morphTargets[ 0 ].vertices;

      var morphTarget = geometry.morphTargets[ 0 ];

      for ( var j = 0, jl = geometry.faces.length; j < jl; j ++ ) {

        var face = geometry.faces[ j ];

        face.vertexNormals = [
          morphTarget.normals[ face.a ],
          morphTarget.normals[ face.b ],
          morphTarget.normals[ face.c ]
        ];

      }


      // Convert to geometry.morphNormals

      for ( var i = 0, l = geometry.morphTargets.length; i < l; i ++ ) {

        var morphTarget = geometry.morphTargets[ i ];
        var vertexNormals = [];

        for ( var j = 0, jl = geometry.faces.length; j < jl; j ++ ) {

          var face = geometry.faces[ j ];

          vertexNormals.push( {
            a: morphTarget.normals[ face.a ],
            b: morphTarget.normals[ face.b ],
            c: morphTarget.normals[ face.c ]
          } );

        }

        geometry.morphNormals.push( { vertexNormals: vertexNormals } );

      }

      geometry.animations = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );

      console.timeEnd( 'MD2Loader' );

      return geometry;

    };

  } )()

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJLoader = ( function () {

  // o object_name | g group_name
  var object_pattern           = /^[og]\s*(.+)?/;
  // mtllib file_reference
  var material_library_pattern = /^mtllib /;
  // usemtl material_name
  var material_use_pattern     = /^usemtl /;

  function ParserState() {

    var state = {
      objects  : [],
      object   : {},

      vertices : [],
      normals  : [],
      uvs      : [],

      materialLibraries : [],

      startObject: function ( name, fromDeclaration ) {

        // If the current object (initial from reset) is not from a g/o declaration in the parsed
        // file. We need to use it for the first parsed g/o to keep things in sync.
        if ( this.object && this.object.fromDeclaration === false ) {

          this.object.name = name;
          this.object.fromDeclaration = ( fromDeclaration !== false );
          return;

        }

        var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

        if ( this.object && typeof this.object._finalize === 'function' ) {

          this.object._finalize( true );

        }

        this.object = {
          name : name || '',
          fromDeclaration : ( fromDeclaration !== false ),

          geometry : {
            vertices : [],
            normals  : [],
            uvs      : []
          },
          materials : [],
          smooth : true,

          startMaterial: function ( name, libraries ) {

            var previous = this._finalize( false );

            // New usemtl declaration overwrites an inherited material, except if faces were declared
            // after the material, then it must be preserved for proper MultiMaterial continuation.
            if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

              this.materials.splice( previous.index, 1 );

            }

            var material = {
              index      : this.materials.length,
              name       : name || '',
              mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
              smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
              groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
              groupEnd   : -1,
              groupCount : -1,
              inherited  : false,

              clone: function ( index ) {
                var cloned = {
                  index      : ( typeof index === 'number' ? index : this.index ),
                  name       : this.name,
                  mtllib     : this.mtllib,
                  smooth     : this.smooth,
                  groupStart : 0,
                  groupEnd   : -1,
                  groupCount : -1,
                  inherited  : false
                };
                cloned.clone = this.clone.bind(cloned);
                return cloned;
              }
            };

            this.materials.push( material );

            return material;

          },

          currentMaterial: function () {

            if ( this.materials.length > 0 ) {
              return this.materials[ this.materials.length - 1 ];
            }

            return undefined;

          },

          _finalize: function ( end ) {

            var lastMultiMaterial = this.currentMaterial();
            if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
              lastMultiMaterial.inherited = false;

            }

            // Ignore objects tail materials if no face declarations followed them before a new o/g started.
            if ( end && this.materials.length > 1 ) {

              for ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {
                if ( this.materials[ mi ].groupCount <= 0 ) {
                  this.materials.splice( mi, 1 );
                }
              }

            }

            // Guarantee at least one empty material, this makes the creation later more straight forward.
            if ( end && this.materials.length === 0 ) {

              this.materials.push({
                name   : '',
                smooth : this.smooth
              });

            }

            return lastMultiMaterial;

          }
        };

        // Inherit previous objects material.
        // Spec tells us that a declared material must be set to all objects until a new material is declared.
        // If a usemtl declaration is encountered while this new object is being parsed, it will
        // overwrite the inherited material. Exception being that there was already face declarations
        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

        if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

          var declared = previousMaterial.clone( 0 );
          declared.inherited = true;
          this.object.materials.push( declared );

        }

        this.objects.push( this.object );

      },

      finalize: function () {

        if ( this.object && typeof this.object._finalize === 'function' ) {

          this.object._finalize( true );

        }

      },

      parseVertexIndex: function ( value, len ) {

        var index = parseInt( value, 10 );
        return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

      },

      parseNormalIndex: function ( value, len ) {

        var index = parseInt( value, 10 );
        return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

      },

      parseUVIndex: function ( value, len ) {

        var index = parseInt( value, 10 );
        return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

      },

      addVertex: function ( a, b, c ) {

        var src = this.vertices;
        var dst = this.object.geometry.vertices;

        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
        dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
        dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

      },

      addVertexLine: function ( a ) {

        var src = this.vertices;
        var dst = this.object.geometry.vertices;

        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

      },

      addNormal: function ( a, b, c ) {

        var src = this.normals;
        var dst = this.object.geometry.normals;

        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
        dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
        dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

      },

      addUV: function ( a, b, c ) {

        var src = this.uvs;
        var dst = this.object.geometry.uvs;

        dst.push( src[ a + 0 ], src[ a + 1 ] );
        dst.push( src[ b + 0 ], src[ b + 1 ] );
        dst.push( src[ c + 0 ], src[ c + 1 ] );

      },

      addUVLine: function ( a ) {

        var src = this.uvs;
        var dst = this.object.geometry.uvs;

        dst.push( src[ a + 0 ], src[ a + 1 ] );

      },

      addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

        var vLen = this.vertices.length;

        var ia = this.parseVertexIndex( a, vLen );
        var ib = this.parseVertexIndex( b, vLen );
        var ic = this.parseVertexIndex( c, vLen );

        this.addVertex( ia, ib, ic );

        if ( ua !== undefined ) {

          var uvLen = this.uvs.length;

          ia = this.parseUVIndex( ua, uvLen );
          ib = this.parseUVIndex( ub, uvLen );
          ic = this.parseUVIndex( uc, uvLen );

          this.addUV( ia, ib, ic );

        }

        if ( na !== undefined ) {

          // Normals are many times the same. If so, skip function call and parseInt.
          var nLen = this.normals.length;
          ia = this.parseNormalIndex( na, nLen );

          ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
          ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

          this.addNormal( ia, ib, ic );

        }

      },

      addLineGeometry: function ( vertices, uvs ) {

        this.object.geometry.type = 'Line';

        var vLen = this.vertices.length;
        var uvLen = this.uvs.length;

        for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

          this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

        }

        for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

          this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

        }

      }

    };

    state.startObject( '', false );

    return state;

  }

  //

  function OBJLoader( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.materials = null;

  };

  OBJLoader.prototype = {

    constructor: OBJLoader,

    load: function ( url, onLoad, onProgress, onError ) {

      var scope = this;

      var loader = new THREE.FileLoader( scope.manager );
      loader.setPath( this.path );
      loader.load( url, function ( text ) {

        onLoad( scope.parse( text ) );

      }, onProgress, onError );

    },

    setPath: function ( value ) {

      this.path = value;

    },

    setMaterials: function ( materials ) {

      this.materials = materials;

      return this;

    },

    parse: function ( text ) {

      console.time( 'OBJLoader' );

      var state = new ParserState();

      if ( text.indexOf( '\r\n' ) !== - 1 ) {

        // This is faster than String.split with regex that splits on both
        text = text.replace( /\r\n/g, '\n' );

      }

      if ( text.indexOf( '\\\n' ) !== - 1) {

        // join lines separated by a line continuation character (\)
        text = text.replace( /\\\n/g, '' );

      }

      var lines = text.split( '\n' );
      var line = '', lineFirstChar = '';
      var lineLength = 0;
      var result = [];

      // Faster to just trim left side of the line. Use if available.
      var trimLeft = ( typeof ''.trimLeft === 'function' );

      for ( var i = 0, l = lines.length; i < l; i ++ ) {

        line = lines[ i ];

        line = trimLeft ? line.trimLeft() : line.trim();

        lineLength = line.length;

        if ( lineLength === 0 ) continue;

        lineFirstChar = line.charAt( 0 );

        // @todo invoke passed in handler if any
        if ( lineFirstChar === '#' ) continue;

        if ( lineFirstChar === 'v' ) {

          var data = line.split( /\s+/ );

          switch ( data[ 0 ] ) {

            case 'v':
              state.vertices.push(
                parseFloat( data[ 1 ] ),
                parseFloat( data[ 2 ] ),
                parseFloat( data[ 3 ] )
              );
              break;
            case 'vn':
              state.normals.push(
                parseFloat( data[ 1 ] ),
                parseFloat( data[ 2 ] ),
                parseFloat( data[ 3 ] )
              );
              break;
            case 'vt':
              state.uvs.push(
                parseFloat( data[ 1 ] ),
                parseFloat( data[ 2 ] )
              );
              break;
          }

        } else if ( lineFirstChar === 'f' ) {

          var lineData = line.substr( 1 ).trim();
          var vertexData = lineData.split( /\s+/ );
          var faceVertices = [];

          // Parse the face vertex data into an easy to work with format

          for ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {

            var vertex = vertexData[ j ];

            if ( vertex.length > 0 ) {

              var vertexParts = vertex.split( '/' );
              faceVertices.push( vertexParts );

            }

          }

          // Draw an edge between the first vertex and all subsequent vertices to form an n-gon

          var v1 = faceVertices[ 0 ];

          for ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

            var v2 = faceVertices[ j ];
            var v3 = faceVertices[ j + 1 ];

            state.addFace(
              v1[ 0 ], v2[ 0 ], v3[ 0 ],
              v1[ 1 ], v2[ 1 ], v3[ 1 ],
              v1[ 2 ], v2[ 2 ], v3[ 2 ]
            );

          }

        } else if ( lineFirstChar === 'l' ) {

          var lineParts = line.substring( 1 ).trim().split( " " );
          var lineVertices = [], lineUVs = [];

          if ( line.indexOf( "/" ) === - 1 ) {

            lineVertices = lineParts;

          } else {

            for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

              var parts = lineParts[ li ].split( "/" );

              if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
              if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

            }

          }
          state.addLineGeometry( lineVertices, lineUVs );

        } else if ( ( result = object_pattern.exec( line ) ) !== null ) {

          // o object_name
          // or
          // g group_name

          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
          // var name = result[ 0 ].substr( 1 ).trim();
          var name = ( " " + result[ 0 ].substr( 1 ).trim() ).substr( 1 );

          state.startObject( name );

        } else if ( material_use_pattern.test( line ) ) {

          // material

          state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

        } else if ( material_library_pattern.test( line ) ) {

          // mtl file

          state.materialLibraries.push( line.substring( 7 ).trim() );

        } else if ( lineFirstChar === 's' ) {

          result = line.split( ' ' );

          // smooth shading

          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
          // but does not define a usemtl for each face set.
          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
          // This requires some care to not create extra material on each smooth value for "normal" obj files.
          // where explicit usemtl defines geometry groups.
          // Example asset: examples/models/obj/cerberus/Cerberus.obj

          /*
           * http://paulbourke.net/dataformats/obj/
           * or
           * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
           *
           * From chapter "Grouping" Syntax explanation "s group_number":
           * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
           * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
           * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
           * than 0."
           */
          if ( result.length > 1 ) {

            var value = result[ 1 ].trim().toLowerCase();
            state.object.smooth = ( value !== '0' && value !== 'off' );

          } else {

            // ZBrush can produce "s" lines #11707
            state.object.smooth = true;

          }
          var material = state.object.currentMaterial();
          if ( material ) material.smooth = state.object.smooth;

        } else {

          // Handle null terminated files without exception
          if ( line === '\0' ) continue;

          throw new Error( "Unexpected line: '" + line  + "'" );

        }

      }

      state.finalize();

      var container = new THREE.Group();
      container.materialLibraries = [].concat( state.materialLibraries );

      for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

        var object = state.objects[ i ];
        var geometry = object.geometry;
        var materials = object.materials;
        var isLine = ( geometry.type === 'Line' );

        // Skip o/g line declarations that did not follow with any faces
        if ( geometry.vertices.length === 0 ) continue;

        var buffergeometry = new THREE.BufferGeometry();

        buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

        if ( geometry.normals.length > 0 ) {

          buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );

        } else {

          buffergeometry.computeVertexNormals();

        }

        if ( geometry.uvs.length > 0 ) {

          buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );

        }

        // Create materials

        var createdMaterials = [];

        for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

          var sourceMaterial = materials[ mi ];
          var material = undefined;

          if ( this.materials !== null ) {

            material = this.materials.create( sourceMaterial.name );

            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
            if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {

              var materialLine = new THREE.LineBasicMaterial();
              materialLine.copy( material );
              material = materialLine;

            }

          }

          if ( ! material ) {

            material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );
            material.name = sourceMaterial.name;

          }

          material.flatShading = sourceMaterial.smooth ? false : true;

          createdMaterials.push(material);

        }

        // Create mesh

        var mesh;

        if ( createdMaterials.length > 1 ) {

          for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

            var sourceMaterial = materials[ mi ];
            buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

          }

          mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials ) : new THREE.LineSegments( buffergeometry, createdMaterials ) );

        } else {

          mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );
        }

        mesh.name = object.name;

        container.add( mesh );

      }

      console.timeEnd( 'OBJLoader' );

      return container;

    }

  };

  return OBJLoader;

} )();

/**
  * @author Kai Salmen / https://kaisalmen.de
  * Development repository: https://github.com/kaisalmen/WWOBJLoader
  */

'use strict';

if ( THREE.OBJLoader2 === undefined ) { THREE.OBJLoader2 = {} }

/**
 * Use this class to load OBJ data from files or to parse OBJ data from an arraybuffer
 * @class
 *
 * @param {THREE.DefaultLoadingManager} [manager] The loadingManager for the loader to use. Default is {@link THREE.DefaultLoadingManager}
 */
THREE.OBJLoader2 = (function () {

  var OBJLOADER2_VERSION = '2.0.0';
  var Commons = THREE.LoaderSupport.Commons;
  var Validator = THREE.LoaderSupport.Validator;
  var ConsoleLogger = THREE.LoaderSupport.ConsoleLogger;

  OBJLoader2.prototype = Object.create( THREE.LoaderSupport.Commons.prototype );
  OBJLoader2.prototype.constructor = OBJLoader2;

  function OBJLoader2( logger, manager ) {
    THREE.LoaderSupport.Commons.call( this, logger, manager );
    this.logger.logInfo( 'Using THREE.OBJLoader2 version: ' + OBJLOADER2_VERSION );

    this.materialPerSmoothingGroup = false;
    this.fileLoader = Validator.verifyInput( this.fileLoader, new THREE.FileLoader( this.manager ) );

    this.workerSupport = null;
    this.terminateWorkerOnLoad = true;
  };

  /**
   * Tells whether a material shall be created per smoothing group.
   * @memberOf THREE.OBJLoader2
   *
   * @param {boolean} materialPerSmoothingGroup=false
   */
  OBJLoader2.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {
    this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;
  };

  /**
   * Use this convenient method to load an OBJ file at the given URL. Per default the fileLoader uses an arraybuffer.
   * @memberOf THREE.OBJLoader2
   *
   * @param {string} url URL of the file to load
   * @param {callback} onLoad Called after loading was successfully completed
   * @param {callback} onProgress Called to report progress of loading. The argument will be the XMLHttpRequest instance, which contains {integer total} and {integer loaded} bytes.
   * @param {callback} onError Called after an error occurred during loading
   * @param {callback} onMeshAlter Called after a new mesh raw data becomes available to allow alteration
   * @param {boolean} useAsync If true uses async loading with worker, if false loads data synchronously
   */
  OBJLoader2.prototype.load = function ( url, onLoad, onProgress, onError, onMeshAlter, useAsync ) {
    var scope = this;
    if ( ! Validator.isValid( onProgress ) ) {
      var numericalValueRef = 0;
      var numericalValue = 0;
      onProgress = function ( event ) {
        if ( ! event.lengthComputable ) return;

        numericalValue = event.loaded / event.total;
        if ( numericalValue > numericalValueRef ) {

          numericalValueRef = numericalValue;
          var output = 'Download of "' + url + '": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';
          scope.onProgress( 'progressLoad', output, numericalValue );

        }
      };
    }

    if ( ! Validator.isValid( onError ) ) {
      onError = function ( event ) {
        var output = 'Error occurred while downloading "' + url + '"';
        scope.logger.logError( output + ': ' + event );
        scope.onProgress( 'error', output, -1 );
      };
    }

    this.fileLoader.setPath( this.path );
    this.fileLoader.setResponseType( 'arraybuffer' );
    this.fileLoader.load( url, function ( content ) {
      if ( useAsync ) {

        scope.parseAsync( content, onLoad );

      } else {

        scope._setCallbacks( null, onMeshAlter, null );
        onLoad(
          {
            detail: {
              loaderRootNode: scope.parse( content ),
              modelName: scope.modelName,
              instanceNo: scope.instanceNo
            }
          }
        );

      }

    }, onProgress, onError );

  };

  /**
   * Run the loader according the provided instructions.
   * @memberOf THREE.OBJLoader2
   *
   * @param {THREE.LoaderSupport.PrepData} prepData All parameters and resources required for execution
   * @param {THREE.LoaderSupport.WorkerSupport} [workerSupportExternal] Use pre-existing WorkerSupport
   */
  OBJLoader2.prototype.run = function ( prepData, workerSupportExternal ) {
    this._applyPrepData( prepData );
    var available = this._checkFiles( prepData.resources );
    if ( Validator.isValid( workerSupportExternal ) ) {

      this.terminateWorkerOnLoad = false;
      this.workerSupport = workerSupportExternal;
      this.logger = workerSupportExternal.logger;

    } else {

      this.terminateWorkerOnLoad = true;

    }
    var scope = this;
    var onMaterialsLoaded = function ( materials ) {
      scope.builder.setMaterials( materials );

      if ( Validator.isValid( available.obj.content ) ) {

        if ( prepData.useAsync ) {

          scope.parseAsync( available.obj.content, scope.callbacks.onLoad );

        } else {

          scope.parse( available.obj.content );

        }
      } else {

        scope.setPath( available.obj.path );
        scope.load( available.obj.name, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync );

      }
    };

    this._loadMtl( available.mtl, onMaterialsLoaded, prepData.crossOrigin );
  };

  OBJLoader2.prototype._applyPrepData = function ( prepData ) {
    THREE.LoaderSupport.Commons.prototype._applyPrepData.call( this, prepData );

    if ( Validator.isValid( prepData ) ) {

      this.setMaterialPerSmoothingGroup( prepData.materialPerSmoothingGroup );

    }
  };

  /**
   * Parses OBJ data synchronously from arraybuffer or string.
   * @memberOf THREE.OBJLoader2
   *
   * @param {arraybuffer|string} content OBJ data as Uint8Array or String
   */
  OBJLoader2.prototype.parse = function ( content ) {
    this.logger.logTimeStart( 'OBJLoader2 parse: ' + this.modelName );

    var parser = new Parser( this.logger );
    parser.setMaterialPerSmoothingGroup( this.materialPerSmoothingGroup );
    parser.setUseIndices( this.useIndices );
    parser.setDisregardNormals( this.disregardNormals );
    parser.setMaterialNames( this.builder.materialNames );

    var scope = this;
    var onMeshLoaded = function ( payload ) {
      var meshes = scope.builder.buildMeshes( payload );
      var mesh;
      for ( var i in meshes ) {
        mesh = meshes[ i ];
        scope.loaderRootNode.add( mesh );
      }
    };
    parser.setCallbackBuilder( onMeshLoaded );
    var onProgressScoped = function ( text, numericalValue ) {
      scope.onProgress( 'progressParse', text, numericalValue );
    };
    parser.setCallbackProgress( onProgressScoped );

    if ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {

      this.logger.logInfo( 'Parsing arrayBuffer...' );
      parser.parse( content );

    } else if ( typeof( content ) === 'string' || content instanceof String ) {

      this.logger.logInfo( 'Parsing text...' );
      parser.parseText( content );

    } else {

      throw 'Provided content was neither of type String nor Uint8Array! Aborting...';

    }
    this.logger.logTimeEnd( 'OBJLoader2 parse: ' + this.modelName );

    return this.loaderRootNode;
  };

  /**
   * Parses OBJ content asynchronously from arraybuffer.
   * @memberOf THREE.OBJLoader2
   *
   * @param {arraybuffer} content OBJ data as Uint8Array
   * @param {callback} onLoad Called after worker successfully completed loading
   */
  OBJLoader2.prototype.parseAsync = function ( content, onLoad ) {
    this.logger.logTimeStart( 'OBJLoader2 parseAsync: ' + this.modelName );

    var scope = this;
    var scopedOnLoad = function () {
      onLoad(
        {
          detail: {
            loaderRootNode: scope.loaderRootNode,
            modelName: scope.modelName,
            instanceNo: scope.instanceNo
          }
        }
      );
      if ( scope.terminateWorkerOnLoad ) scope.workerSupport.terminateWorker();
      scope.logger.logTimeEnd( 'OBJLoader2 parseAsync: ' + scope.modelName );
    };
    var scopedOnMeshLoaded = function ( payload ) {
      var meshes = scope.builder.buildMeshes( payload );
      var mesh;
      for ( var i in meshes ) {
        mesh = meshes[ i ];
        scope.loaderRootNode.add( mesh );
      }
    };

    this.workerSupport = Validator.verifyInput( this.workerSupport, new THREE.LoaderSupport.WorkerSupport( this.logger ) );
    var buildCode = function ( funcBuildObject, funcBuildSingelton ) {
      var workerCode = '';
      workerCode += '/**\n';
      workerCode += '  * This code was constructed by OBJLoader2 buildWorkerCode.\n';
      workerCode += '  */\n\n';
      workerCode += funcBuildSingelton( 'Commons', 'Commons', Commons );
      workerCode += funcBuildObject( 'Consts', Consts );
      workerCode += funcBuildObject( 'Validator', Validator );
      workerCode += funcBuildSingelton( 'ConsoleLogger', 'ConsoleLogger', ConsoleLogger );
      workerCode += funcBuildSingelton( 'Parser', 'Parser', Parser );
      workerCode += funcBuildSingelton( 'RawMesh', 'RawMesh', RawMesh );
      workerCode += funcBuildSingelton( 'RawMeshSubGroup', 'RawMeshSubGroup', RawMeshSubGroup );

      return workerCode;
    };
    this.workerSupport.validate( buildCode, false );
    this.workerSupport.setCallbacks( scopedOnMeshLoaded, scopedOnLoad );
    this.workerSupport.run(
      {
        cmd: 'run',
        params: {
          materialPerSmoothingGroup: this.materialPerSmoothingGroup,
          useIndices: this.useIndices,
          disregardNormals: this.disregardNormals
        },
        logger: {
          debug: this.logger.debug,
          enabled: this.logger.enabled
        },
        materials: {
          materialNames: this.builder.materialNames
        },
        buffers: {
          input: content
        }
      },
      [ content.buffer ]
    );
  };

  /**
   * Constants used by THREE.OBJLoader2
   */
  var Consts = {
    CODE_LF: 10,
    CODE_CR: 13,
    CODE_SPACE: 32,
    CODE_SLASH: 47,
    STRING_LF: '\n',
    STRING_CR: '\r',
    STRING_SPACE: ' ',
    STRING_SLASH: '/',
    LINE_F: 'f',
    LINE_G: 'g',
    LINE_L: 'l',
    LINE_O: 'o',
    LINE_S: 's',
    LINE_V: 'v',
    LINE_VT: 'vt',
    LINE_VN: 'vn',
    LINE_MTLLIB: 'mtllib',
    LINE_USEMTL: 'usemtl'
  };

  /**
   * Parse OBJ data either from ArrayBuffer or string
   * @class
   */
  var Parser = (function () {

    function Parser( logger ) {
      this.callbackProgress = null;
      this.callbackBuilder = null;

      this.materialNames = [];
      this.rawMesh = null;
      this.materialPerSmoothingGroup = false;
      this.useIndices = false;
      this.disregardNormals = false;

      this.inputObjectCount = 1;
      this.outputObjectCount = 1;
      this.counts = {
        vertices: 0,
        faces: 0,
        doubleIndicesCount: 0
      };
      this.logger = logger;
      this.totalBytes = 0;
    };

    Parser.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {
      this.materialPerSmoothingGroup = materialPerSmoothingGroup;
    };

    Parser.prototype.setUseIndices = function ( useIndices ) {
      this.useIndices = useIndices;
    };

    Parser.prototype.setDisregardNormals = function ( disregardNormals ) {
      this.disregardNormals = disregardNormals;
    };

    Parser.prototype.setMaterialNames = function ( materialNames ) {
      this.materialNames = Validator.verifyInput( materialNames, this.materialNames );
      this.materialNames = Validator.verifyInput( this.materialNames, [] );
    };

    Parser.prototype.setCallbackBuilder = function ( callbackBuilder ) {
      this.callbackBuilder = callbackBuilder;
      if ( ! Validator.isValid( this.callbackBuilder ) ) throw 'Unable to run as no "builder" callback is set.';
    };

    Parser.prototype.setCallbackProgress = function ( callbackProgress ) {
      this.callbackProgress = callbackProgress;
    };

    Parser.prototype.configure = function () {
      this.rawMesh = new RawMesh( this.materialPerSmoothingGroup, this.useIndices, this.disregardNormals );

      if ( this.logger.isEnabled() ) {

        var matNames = ( this.materialNames.length > 0 ) ? '\n\tmaterialNames:\n\t\t- ' + this.materialNames.join( '\n\t\t- ' ) : '\n\tmaterialNames: None';
        var printedConfig = 'OBJLoader2.Parser configuration:'
            + matNames
            + '\n\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup
            + '\n\tuseIndices: ' + this.useIndices
            + '\n\tdisregardNormals: ' + this.disregardNormals
            + '\n\tcallbackBuilderName: ' + this.callbackBuilder.name
            + '\n\tcallbackProgressName: ' + this.callbackProgress.name;
        this.logger.logInfo( printedConfig );
      }
    };

    /**
     * Parse the provided arraybuffer
     * @memberOf Parser
     *
     * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array
     */
    Parser.prototype.parse = function ( arrayBuffer ) {
      this.logger.logTimeStart( 'OBJLoader2.Parser.parse' );
      this.configure();

      var arrayBufferView = new Uint8Array( arrayBuffer );
      var length = arrayBufferView.byteLength;
      this.totalBytes = length;
      var buffer = new Array( 128 );
      var bufferPointer = 0;
      var slashesCount = 0;
      var reachedFaces = false;
      var code;
      var word = '';
      var i = 0;
      for ( ; i < length; i ++ ) {

        code = arrayBufferView[ i ];
        switch ( code ) {
          case Consts.CODE_SPACE:
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            break;

          case Consts.CODE_SLASH:
            slashesCount ++;
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            break;

          case Consts.CODE_LF:
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            reachedFaces = this.processLine( buffer, bufferPointer, slashesCount, reachedFaces, i );
            bufferPointer = 0;
            slashesCount = 0;
            break;

          case Consts.CODE_CR:
            break;

          default:
            word += String.fromCharCode( code );
            break;
        }
      }
      this.finalize( i );
      this.logger.logTimeEnd( 'OBJLoader2.Parser.parse' );
    };

    /**
     * Parse the provided text
     * @memberOf Parser
     *
     * @param {string} text OBJ data as string
     */
    Parser.prototype.parseText = function ( text ) {
      this.logger.logTimeStart( 'OBJLoader2.Parser.parseText' );
      this.configure();

      var length = text.length;
      this.totalBytes = length;
      var buffer = new Array( 128 );
      var bufferPointer = 0;
      var slashesCount = 0;
      var reachedFaces = false;
      var char;
      var word = '';
      var i = 0;
      for ( ; i < length; i ++ ) {

        char = text[ i ];
        switch ( char ) {
          case Consts.STRING_SPACE:
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            break;

          case Consts.STRING_SLASH:
            slashesCount ++;
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            break;

          case Consts.STRING_LF:
            if ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;
            word = '';
            reachedFaces = this.processLine( buffer, bufferPointer, slashesCount, reachedFaces, i );
            bufferPointer = 0;
            slashesCount = 0;
            break;

          case Consts.STRING_CR:
            break;

          default:
            word += char;
        }
      }
      this.finalize( i );
      this.logger.logTimeEnd( 'OBJLoader2.Parser.parseText' );
    };

    Parser.prototype.processLine = function ( buffer, bufferPointer, slashesCount, reachedFaces, currentByte ) {
      if ( bufferPointer < 1 ) return reachedFaces;

      var bufferLength = bufferPointer - 1;
      var concatBuffer;
      switch ( buffer[ 0 ] ) {
        case Consts.LINE_V:

          // object complete instance required if reached faces already (= reached next block of v)
          if ( reachedFaces ) {

            if ( this.rawMesh.colors.length > 0 && this.rawMesh.colors.length !== this.rawMesh.vertices.length ) {

              throw 'Vertex Colors were detected, but vertex count and color count do not match!';

            }
            this.processCompletedObject( null, this.rawMesh.groupName, currentByte );
            reachedFaces = false;

          }
          if ( bufferLength === 3 ) {

            this.rawMesh.pushVertex( buffer )

          } else {

            this.rawMesh.pushVertexAndVertextColors( buffer );

          }
          break;

        case Consts.LINE_VT:
          this.rawMesh.pushUv( buffer );
          break;

        case Consts.LINE_VN:
          this.rawMesh.pushNormal( buffer );
          break;

        case Consts.LINE_F:
          reachedFaces = true;
          this.rawMesh.processFaces( buffer, bufferPointer, slashesCount );
          break;

        case Consts.LINE_L:
          if ( bufferLength === slashesCount * 2 ) {

            this.rawMesh.buildLineVvt( buffer );

          } else {

            this.rawMesh.buildLineV( buffer );

          }
          break;

        case Consts.LINE_S:
          this.rawMesh.pushSmoothingGroup( buffer[ 1 ] );
          this.flushStringBuffer( buffer, bufferPointer );
          break;

        case Consts.LINE_G:
          concatBuffer = bufferLength > 1 ? buffer.slice( 1, bufferPointer ).join( ' ' ) : buffer[ 1 ];
          this.processCompletedGroup( concatBuffer, currentByte );
          this.flushStringBuffer( buffer, bufferPointer );
          break;

        case Consts.LINE_O:
          concatBuffer = bufferLength > 1 ? buffer.slice( 1, bufferPointer ).join( ' ' ) : buffer[ 1 ];
          if ( this.rawMesh.vertices.length > 0 ) {

            this.processCompletedObject( concatBuffer, null, currentByte );
            reachedFaces = false;

          } else {

            this.rawMesh.pushObject( concatBuffer );

          }
          this.flushStringBuffer( buffer, bufferPointer );
          break;

        case Consts.LINE_MTLLIB:
          concatBuffer = bufferLength > 1 ? buffer.slice( 1, bufferPointer ).join( ' ' ) : buffer[ 1 ];
          this.rawMesh.pushMtllib( concatBuffer );
          this.flushStringBuffer( buffer, bufferPointer );
          break;

        case Consts.LINE_USEMTL:
          concatBuffer = bufferLength > 1 ? buffer.slice( 1, bufferPointer ).join( ' ' ) : buffer[ 1 ];
          this.rawMesh.pushUsemtl( concatBuffer );
          this.flushStringBuffer( buffer, bufferPointer );
          break;

        default:
          break;
      }
      return reachedFaces;
    };

    Parser.prototype.flushStringBuffer = function ( buffer, bufferLength ) {
      for ( var i = 0; i < bufferLength; i ++ ) {
        buffer[ i ] = '';
      }
    };

    Parser.prototype.createRawMeshReport = function ( rawMesh , inputObjectCount ) {
      var report = rawMesh.createReport( inputObjectCount );
      return 'Input Object number: ' + inputObjectCount +
        '\n\tObject name: ' + report.objectName +
        '\n\tGroup name: ' + report.groupName +
        '\n\tMtllib name: ' + report.mtllibName +
        '\n\tVertex count: ' + report.vertexCount +
        '\n\tNormal count: ' + report.normalCount +
        '\n\tUV count: ' + report.uvCount +
        '\n\tSmoothingGroup count: ' + report.smoothingGroupCount +
        '\n\tMaterial count: ' + report.mtlCount +
        '\n\tReal RawMeshSubGroup count: ' + report.subGroups;
    };

    Parser.prototype.processCompletedObject = function ( objectName, groupName, currentByte ) {
      var result = this.rawMesh.finalize();
      if ( Validator.isValid( result ) ) {

        this.inputObjectCount++;
        if ( this.logger.isDebug() ) this.logger.logDebug( this.createRawMeshReport( this.rawMesh, this.inputObjectCount ) );
        this.buildMesh( result, currentByte );
        var progressBytesPercent = currentByte / this.totalBytes;
        this.callbackProgress( 'Completed object: ' + objectName + ' Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%', progressBytesPercent );

      }
      this.rawMesh = this.rawMesh.newInstanceFromObject( objectName, groupName );
    };

    Parser.prototype.processCompletedGroup = function ( groupName, currentByte ) {
      var result = this.rawMesh.finalize();
      if ( Validator.isValid( result ) ) {

        this.inputObjectCount++;
        if ( this.logger.isDebug() ) this.logger.logDebug( this.createRawMeshReport( this.rawMesh, this.inputObjectCount ) );
        this.buildMesh( result, currentByte );
        var progressBytesPercent = currentByte / this.totalBytes;
        this.callbackProgress( 'Completed group: ' + groupName + ' Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%', progressBytesPercent );
        this.rawMesh = this.rawMesh.newInstanceFromGroup( groupName );

      } else {

        // if a group was set that did not lead to object creation in finalize, then the group name has to be updated
        this.rawMesh.pushGroup( groupName );

      }
    };

    Parser.prototype.finalize = function ( currentByte ) {
      this.logger.logInfo( 'Global output object count: ' + this.outputObjectCount );
      var result = Validator.isValid( this.rawMesh ) ? this.rawMesh.finalize() : null;
      if ( Validator.isValid( result ) ) {

        this.inputObjectCount++;
        if ( this.logger.isDebug() ) this.logger.logDebug( this.createRawMeshReport( this.rawMesh, this.inputObjectCount ) );
        this.buildMesh( result, currentByte );

        if ( this.logger.isEnabled() ) {

          var parserFinalReport = 'Overall counts: ' +
            '\n\tVertices: ' + this.counts.vertices +
            '\n\tFaces: ' + this.counts.faces +
            '\n\tMultiple definitions: ' + this.counts.doubleIndicesCount;
          this.logger.logInfo( parserFinalReport );

        }
        var progressBytesPercent = currentByte / this.totalBytes;
        this.callbackProgress( 'Completed Parsing: 100.00%', progressBytesPercent );

      }
    };

    /**
     * RawObjectDescriptions are transformed to too intermediate format that is forwarded to the Builder.
     * It is ensured that rawObjectDescriptions only contain objects with vertices (no need to check).
     *
     * @param result
     */
    Parser.prototype.buildMesh = function ( result, currentByte ) {
      var rawObjectDescriptions = result.subGroups;

      var vertexFA = new Float32Array( result.absoluteVertexCount );
      this.counts.vertices += result.absoluteVertexCount / 3;
      this.counts.faces += result.faceCount;
      this.counts.doubleIndicesCount += result.doubleIndicesCount;
      var indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;
      var colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;
      var normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;
      var uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;

      var rawObjectDescription;
      var materialDescription;
      var materialDescriptions = [];

      var createMultiMaterial = ( rawObjectDescriptions.length > 1 );
      var materialIndex = 0;
      var materialIndexMapping = [];
      var selectedMaterialIndex;
      var materialGroup;
      var materialGroups = [];

      var vertexFAOffset = 0;
      var indexUAOffset = 0;
      var colorFAOffset = 0;
      var normalFAOffset = 0;
      var uvFAOffset = 0;
      var materialGroupOffset = 0;
      var materialGroupLength = 0;

      for ( var oodIndex in rawObjectDescriptions ) {
        if ( ! rawObjectDescriptions.hasOwnProperty( oodIndex ) ) continue;
        rawObjectDescription = rawObjectDescriptions[ oodIndex ];

        materialDescription = {
          name: rawObjectDescription.materialName,
          flat: false,
          default: false
        };
        if ( this.materialNames[ materialDescription.name ] === null ) {

          materialDescription.default = true;
          this.logger.logWarn( 'object_group "' + rawObjectDescription.objectName + '_' +
            rawObjectDescription.groupName +
            '" was defined without material! Assigning "defaultMaterial".' );

        }
        // Attach '_flat' to materialName in case flat shading is needed due to smoothingGroup 0
        if ( rawObjectDescription.smoothingGroup === 0 ) materialDescription.flat = true;

        if ( createMultiMaterial ) {

          // re-use material if already used before. Reduces materials array size and eliminates duplicates

          selectedMaterialIndex = materialIndexMapping[ materialDescription.name ];
          if ( ! selectedMaterialIndex ) {

            selectedMaterialIndex = materialIndex;
            materialIndexMapping[ materialDescription.name ] = materialIndex;
            materialDescriptions.push( materialDescription );
            materialIndex++;

          }
          materialGroupLength = this.useIndices ? rawObjectDescription.indices.length : rawObjectDescription.vertices.length / 3;
          materialGroup = {
            start: materialGroupOffset,
            count: materialGroupLength,
            index: selectedMaterialIndex
          };
          materialGroups.push( materialGroup );
          materialGroupOffset += materialGroupLength;

        } else {

          materialDescriptions.push( materialDescription );

        }

        vertexFA.set( rawObjectDescription.vertices, vertexFAOffset );
        vertexFAOffset += rawObjectDescription.vertices.length;

        if ( indexUA ) {

          indexUA.set( rawObjectDescription.indices, indexUAOffset );
          indexUAOffset += rawObjectDescription.indices.length;

        }

        if ( colorFA ) {

          colorFA.set( rawObjectDescription.colors, colorFAOffset );
          colorFAOffset += rawObjectDescription.colors.length;

        }

        if ( normalFA ) {

          normalFA.set( rawObjectDescription.normals, normalFAOffset );
          normalFAOffset += rawObjectDescription.normals.length;

        }
        if ( uvFA ) {

          uvFA.set( rawObjectDescription.uvs, uvFAOffset );
          uvFAOffset += rawObjectDescription.uvs.length;

        }

        if ( this.logger.isDebug() ) {
          var materialIndexLine = Validator.isValid( selectedMaterialIndex ) ? '\n\t\tmaterialIndex: ' + selectedMaterialIndex : '';
          var createdReport = 'Output Object no.: ' + this.outputObjectCount +
            '\n\t\tobjectName: ' + rawObjectDescription.objectName +
            '\n\t\tgroupName: ' + rawObjectDescription.groupName +
            '\n\t\tmaterialName: ' + rawObjectDescription.materialName +
            materialIndexLine +
            '\n\t\tsmoothingGroup: ' + rawObjectDescription.smoothingGroup +
            '\n\t\t#vertices: ' + rawObjectDescription.vertices.length / 3 +
            '\n\t\t#indices: ' + rawObjectDescription.indices.length +
            '\n\t\t#colors: ' + rawObjectDescription.colors.length / 3 +
            '\n\t\t#uvs: ' + rawObjectDescription.uvs.length / 2 +
            '\n\t\t#normals: ' + rawObjectDescription.normals.length / 3;
          this.logger.logDebug( createdReport );
        }


      }

      this.outputObjectCount++;
      this.callbackBuilder(
        {
          cmd: 'meshData',
          progress: {
            numericalValue: currentByte / this.totalBytes
          },
          params: {
            meshName: result.name
          },
          materials: {
            multiMaterial: createMultiMaterial,
            materialDescriptions: materialDescriptions,
            materialGroups: materialGroups
          },
          buffers: {
            vertices: vertexFA,
            indices: indexUA,
            colors: colorFA,
            normals: normalFA,
            uvs: uvFA
          }
        },
        [ vertexFA.buffer ],
        Validator.isValid( indexUA ) ? [ indexUA.buffer ] : null,
        Validator.isValid( colorFA ) ? [ colorFA.buffer ] : null,
        Validator.isValid( normalFA ) ? [ normalFA.buffer ] : null,
        Validator.isValid( uvFA ) ? [ uvFA.buffer ] : null
      );
    };

    return Parser;
  })();

  /**
   * {@link RawMesh} is only used by {@link Parser}.
   * The user of OBJLoader2 does not need to care about this class.
   * It is defined publicly for inclusion in web worker based OBJ loader ({@link THREE.OBJLoader2.WWOBJLoader2})
   */
  var RawMesh = (function () {

    function RawMesh( materialPerSmoothingGroup, useIndices, disregardNormals, objectName, groupName, activeMtlName ) {
      this.globalVertexOffset = 1;
      this.globalUvOffset = 1;
      this.globalNormalOffset = 1;

      this.vertices = [];
      this.colors = [];
      this.normals = [];
      this.uvs = [];

      // faces are stored according combined index of group, material and smoothingGroup (0 or not)
      this.activeMtlName = Validator.verifyInput( activeMtlName, '' );
      this.objectName = Validator.verifyInput( objectName, '' );
      this.groupName = Validator.verifyInput( groupName, '' );
      this.mtllibName = '';
      this.smoothingGroup = {
        splitMaterials: materialPerSmoothingGroup === true,
        normalized: -1,
        real: -1
      };
      this.useIndices = useIndices === true;
      this.disregardNormals = disregardNormals === true;

      this.mtlCount = 0;
      this.smoothingGroupCount = 0;

      this.subGroups = [];
      this.subGroupInUse = null;
      // this default index is required as it is possible to define faces without 'g' or 'usemtl'
      this.pushSmoothingGroup( 1 );

      this.doubleIndicesCount = 0;
      this.faceCount = 0;
    }

    RawMesh.prototype.newInstanceFromObject = function ( objectName, groupName ) {
      var newRawObject = new RawMesh( this.smoothingGroup.splitMaterials, this.useIndices, this.disregardNormals, objectName, groupName, this.activeMtlName );

      // move indices forward
      newRawObject.globalVertexOffset = this.globalVertexOffset + this.vertices.length / 3;
      newRawObject.globalUvOffset = this.globalUvOffset + this.uvs.length / 2;
      newRawObject.globalNormalOffset = this.globalNormalOffset + this.normals.length / 3;

      return newRawObject;
    };

    RawMesh.prototype.newInstanceFromGroup = function ( groupName ) {
      var newRawObject = new RawMesh( this.smoothingGroup.splitMaterials, this.useIndices, this.disregardNormals, this.objectName, groupName, this.activeMtlName );

      // keep current buffers and indices forward
      newRawObject.vertices = this.vertices;
      newRawObject.colors = this.colors;
      newRawObject.uvs = this.uvs;
      newRawObject.normals = this.normals;
      newRawObject.globalVertexOffset = this.globalVertexOffset;
      newRawObject.globalUvOffset = this.globalUvOffset;
      newRawObject.globalNormalOffset = this.globalNormalOffset;

      return newRawObject;
    };

    RawMesh.prototype.pushVertex = function ( buffer ) {
      this.vertices.push( parseFloat( buffer[ 1 ] ) );
      this.vertices.push( parseFloat( buffer[ 2 ] ) );
      this.vertices.push( parseFloat( buffer[ 3 ] ) );
    };

    RawMesh.prototype.pushVertexAndVertextColors = function ( buffer ) {
      this.vertices.push( parseFloat( buffer[ 1 ] ) );
      this.vertices.push( parseFloat( buffer[ 2 ] ) );
      this.vertices.push( parseFloat( buffer[ 3 ] ) );
      this.colors.push( parseFloat( buffer[ 4 ] ) );
      this.colors.push( parseFloat( buffer[ 5 ] ) );
      this.colors.push( parseFloat( buffer[ 6 ] ) );
    };

    RawMesh.prototype.pushUv = function ( buffer ) {
      this.uvs.push( parseFloat( buffer[ 1 ] ) );
      this.uvs.push( parseFloat( buffer[ 2 ] ) );
    };

    RawMesh.prototype.pushNormal = function ( buffer ) {
      this.normals.push( parseFloat( buffer[ 1 ] ) );
      this.normals.push( parseFloat( buffer[ 2 ] ) );
      this.normals.push( parseFloat( buffer[ 3 ] ) );
    };

    RawMesh.prototype.pushObject = function ( objectName ) {
      this.objectName = Validator.verifyInput( objectName, '' );
    };

    RawMesh.prototype.pushMtllib = function ( mtllibName ) {
      this.mtllibName = Validator.verifyInput( mtllibName, '' );
    };

    RawMesh.prototype.pushGroup = function ( groupName ) {
      this.groupName = Validator.verifyInput( groupName, '' );
    };

    RawMesh.prototype.pushUsemtl = function ( mtlName ) {
      if ( this.activeMtlName === mtlName || ! Validator.isValid( mtlName ) ) return;
      this.activeMtlName = mtlName;
      this.mtlCount++;

      this.verifyIndex();
    };

    RawMesh.prototype.pushSmoothingGroup = function ( smoothingGroup ) {
      var smoothingGroupInt = parseInt( smoothingGroup );
      if ( isNaN( smoothingGroupInt ) ) {
        smoothingGroupInt = smoothingGroup === "off" ? 0 : 1;
      }

      var smoothCheck = this.smoothingGroup.normalized;
      this.smoothingGroup.normalized = this.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;
      this.smoothingGroup.real = smoothingGroupInt;

      if ( smoothCheck !== smoothingGroupInt ) {

        this.smoothingGroupCount++;
        this.verifyIndex();

      }
    };

    RawMesh.prototype.verifyIndex = function () {
      var index = this.activeMtlName + '|' + this.smoothingGroup.normalized;
      this.subGroupInUse = this.subGroups[ index ];
      if ( ! Validator.isValid( this.subGroupInUse ) ) {

        this.subGroupInUse = new RawMeshSubGroup( this.objectName, this.groupName, this.activeMtlName, this.smoothingGroup.normalized );
        this.subGroups[ index ] = this.subGroupInUse;

      }
    };

    RawMesh.prototype.processFaces = function ( buffer, bufferPointer, slashesCount ) {
      var bufferLength = bufferPointer - 1;
      var i, length;

      // "f vertex ..."
      if ( slashesCount === 0 ) {

        for ( i = 2, length = bufferLength - 1; i < length; i ++ ) {

          this.buildFace( buffer[ 1 ] );
          this.buildFace( buffer[ i ] );
          this.buildFace( buffer[ i + 1 ] );

        }

        // "f vertex/uv ..."
      } else if  ( bufferLength === slashesCount * 2 ) {

        for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {

          this.buildFace( buffer[ 1 ], buffer[ 2 ] );
          this.buildFace( buffer[ i ], buffer[ i + 1 ] );
          this.buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );

        }

        // "f vertex/uv/normal ..."
      } else if  ( bufferLength * 2 === slashesCount * 3 ) {

        for ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {

          this.buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );
          this.buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );
          this.buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );

        }

        // "f vertex//normal ..."
      } else {

        for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {

          this.buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );
          this.buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );
          this.buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );

        }

      }
    };

    RawMesh.prototype.buildFace = function ( faceIndexV, faceIndexU, faceIndexN ) {
      var sgiu = this.subGroupInUse;
      if ( this.disregardNormals ) faceIndexN = undefined;
      var scope = this;
      var updateRawObjectDescriptionInUse = function () {

        var indexPointerV = ( parseInt( faceIndexV ) - scope.globalVertexOffset ) * 3;
        var indexPointerC = scope.colors.length > 0 ? indexPointerV : null;

        var vertices = sgiu.vertices;
        vertices.push( scope.vertices[ indexPointerV++ ] );
        vertices.push( scope.vertices[ indexPointerV++ ] );
        vertices.push( scope.vertices[ indexPointerV ] );

        if ( indexPointerC !== null ) {

          var colors = sgiu.colors;
          colors.push( scope.colors[ indexPointerC++ ] );
          colors.push( scope.colors[ indexPointerC++ ] );
          colors.push( scope.colors[ indexPointerC ] );

        }

        if ( faceIndexU ) {

          var indexPointerU = ( parseInt( faceIndexU ) - scope.globalUvOffset ) * 2;
          var uvs = sgiu.uvs;
          uvs.push( scope.uvs[ indexPointerU++ ] );
          uvs.push( scope.uvs[ indexPointerU ] );

        }
        if ( faceIndexN ) {

          var indexPointerN = ( parseInt( faceIndexN ) - scope.globalNormalOffset ) * 3;
          var normals = sgiu.normals;
          normals.push( scope.normals[ indexPointerN++ ] );
          normals.push( scope.normals[ indexPointerN++ ] );
          normals.push( scope.normals[ indexPointerN ] );

        }
      };

      if ( this.useIndices ) {

        var mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );
        var indicesPointer = sgiu.indexMappings[ mappingName ];
        if ( Validator.isValid( indicesPointer ) ) {

          this.doubleIndicesCount++;

        } else {

          indicesPointer = sgiu.vertices.length / 3;
          updateRawObjectDescriptionInUse();
          sgiu.indexMappings[ mappingName ] = indicesPointer;
          sgiu.indexMappingsCount++;

        }
        sgiu.indices.push( indicesPointer );

      } else {

        updateRawObjectDescriptionInUse();

      }
      this.faceCount++;
    };

    /*
     * Support for lines with or without texture. First element in indexArray is the line identification
     * 0: "f vertex/uv    vertex/uv     ..."
     * 1: "f vertex     vertex      ..."
     */
    RawMesh.prototype.buildLineVvt = function ( lineArray ) {
      for ( var i = 1, length = lineArray.length; i < length; i ++ ) {

        this.vertices.push( parseInt( lineArray[ i ] ) );
        this.uvs.push( parseInt( lineArray[ i ] ) );

      }
    };

    RawMesh.prototype.buildLineV = function ( lineArray ) {
      for ( var i = 1, length = lineArray.length; i < length; i++ ) {

        this.vertices.push( parseInt( lineArray[ i ] ) );

      }
    };

    /**
     * Clear any empty rawObjectDescription and calculate absolute vertex, normal and uv counts
     */
    RawMesh.prototype.finalize = function () {
      var rawObjectDescriptionsTemp = [];
      var rawObjectDescription;
      var absoluteVertexCount = 0;
      var absoluteIndexMappingsCount = 0;
      var absoluteIndexCount = 0;
      var absoluteColorCount = 0;
      var absoluteNormalCount = 0;
      var absoluteUvCount = 0;
      var indices;
      for ( var name in this.subGroups ) {

        rawObjectDescription = this.subGroups[ name ];
        if ( rawObjectDescription.vertices.length > 0 ) {

          indices = rawObjectDescription.indices;
          if ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {

            for ( var i in indices ) indices[ i ] = indices[ i ] + absoluteIndexMappingsCount;

          }
          rawObjectDescriptionsTemp.push( rawObjectDescription );
          absoluteVertexCount += rawObjectDescription.vertices.length;
          absoluteIndexMappingsCount += rawObjectDescription.indexMappingsCount;
          absoluteIndexCount += rawObjectDescription.indices.length;
          absoluteColorCount += rawObjectDescription.colors.length;
          absoluteUvCount += rawObjectDescription.uvs.length;
          absoluteNormalCount += rawObjectDescription.normals.length;

        }
      }

      // do not continue if no result
      var result = null;
      if ( rawObjectDescriptionsTemp.length > 0 ) {

        result = {
          name: this.groupName !== '' ? this.groupName : this.objectName,
          subGroups: rawObjectDescriptionsTemp,
          absoluteVertexCount: absoluteVertexCount,
          absoluteIndexCount: absoluteIndexCount,
          absoluteColorCount: absoluteColorCount,
          absoluteNormalCount: absoluteNormalCount,
          absoluteUvCount: absoluteUvCount,
          faceCount: this.faceCount,
          doubleIndicesCount: this.doubleIndicesCount
        };

      }
      return result;
    };

    RawMesh.prototype.createReport = function () {
      var report = {
        objectName: this.objectName,
        groupName: this.groupName,
        mtllibName: this.mtllibName,
        vertexCount: this.vertices.length / 3,
        normalCount: this.normals.length / 3,
        uvCount: this.uvs.length / 2,
        smoothingGroupCount: this.smoothingGroupCount,
        mtlCount: this.mtlCount,
        subGroups: this.subGroups.length
      };

      return report;
    };

    return RawMesh;
  })();

  /**
   * Descriptive information and data (vertices, normals, uvs) to passed on to mesh building function.
   * @class
   *
   * @param {string} objectName Name of the mesh
   * @param {string} groupName Name of the group
   * @param {string} materialName Name of the material
   * @param {number} smoothingGroup Normalized smoothingGroup (0: flat shading, 1: smooth shading)
   */
  var RawMeshSubGroup = (function () {

    function RawMeshSubGroup( objectName, groupName, materialName, smoothingGroup ) {
      this.objectName = objectName;
      this.groupName = groupName;
      this.materialName = materialName;
      this.smoothingGroup = smoothingGroup;
      this.vertices = [];
      this.indexMappingsCount = 0;
      this.indexMappings = [];
      this.indices = [];
      this.colors = [];
      this.uvs = [];
      this.normals = [];
    }

    return RawMeshSubGroup;
  })();

  OBJLoader2.prototype._checkFiles = function ( resources ) {
    var resource;
    var result = {
      mtl: null,
      obj: null
    };
    for ( var index in resources ) {

      resource = resources[ index ];
      if ( ! Validator.isValid( resource.name ) ) continue;
      if ( Validator.isValid( resource.content ) ) {

        if ( resource.extension === 'OBJ' ) {

          // fast-fail on bad type
          if ( ! ( resource.content instanceof Uint8Array ) ) throw 'Provided content is not of type arraybuffer! Aborting...';
          result.obj = resource;

        } else if ( resource.extension === 'MTL' && Validator.isValid( resource.name ) ) {

          if ( ! ( typeof( resource.content ) === 'string' || resource.content instanceof String ) ) throw 'Provided  content is not of type String! Aborting...';
          result.mtl = resource;

        } else if ( resource.extension === "ZIP" ) {
          // ignore

        } else {

          throw 'Unidentified resource "' + resource.name + '": ' + resource.url;

        }

      } else {

        // fast-fail on bad type
        if ( ! ( typeof( resource.name ) === 'string' || resource.name instanceof String ) ) throw 'Provided file is not properly defined! Aborting...';
        if ( resource.extension === 'OBJ' ) {

          result.obj = resource;

        } else if ( resource.extension === 'MTL' ) {

          result.mtl = resource;

        } else if ( resource.extension === "ZIP" ) {
          // ignore

        } else {

          throw 'Unidentified resource "' + resource.name + '": ' + resource.url;

        }
      }
    }

    return result;
  };

  /**
   * Utility method for loading an mtl file according resource description.
   * @memberOf THREE.OBJLoader2
   *
   * @param {string} url URL to the file
   * @param {string} name The name of the object
   * @param {Object} content The file content as arraybuffer or text
   * @param {function} callbackOnLoad
   * @param {string} [crossOrigin] CORS value
   */
  OBJLoader2.prototype.loadMtl = function ( url, name, content, callbackOnLoad, crossOrigin ) {
    var resource = new THREE.LoaderSupport.ResourceDescriptor( url, 'MTL' );
    resource.setContent( content );
    this._loadMtl( resource, callbackOnLoad, crossOrigin );
  };

  /**
   * Utility method for loading an mtl file according resource description.
   * @memberOf THREE.OBJLoader2
   *
   * @param {THREE.LoaderSupport.ResourceDescriptor} resource
   * @param {function} callbackOnLoad
   * @param {string} [crossOrigin] CORS value
   */
  OBJLoader2.prototype._loadMtl = function ( resource, callbackOnLoad, crossOrigin ) {
    if ( Validator.isValid( resource ) ) this.logger.logTimeStart( 'Loading MTL: ' + resource.name );

    var materials = [];
    var scope = this;
    var processMaterials = function ( materialCreator ) {
      var materialCreatorMaterials = [];
      if ( Validator.isValid( materialCreator ) ) {

        materialCreator.preload();
        materialCreatorMaterials = materialCreator.materials;
        for ( var materialName in materialCreatorMaterials ) {

          if ( materialCreatorMaterials.hasOwnProperty( materialName ) ) {

            materials[ materialName ] = materialCreatorMaterials[ materialName ];

          }
        }
      }

      if ( Validator.isValid( resource ) ) scope.logger.logTimeEnd( 'Loading MTL: ' + resource.name );
      callbackOnLoad( materials );
    };

    var mtlLoader = new THREE.MTLLoader();
    crossOrigin = Validator.verifyInput( crossOrigin, 'anonymous' );
    mtlLoader.setCrossOrigin( crossOrigin );

    // fast-fail
    if ( ! Validator.isValid( resource ) || ( ! Validator.isValid( resource.content ) && ! Validator.isValid( resource.url ) ) ) {

      processMaterials();

    } else {

      mtlLoader.setPath( resource.path );
      if ( Validator.isValid( resource.content ) ) {

        processMaterials( Validator.isValid( resource.content ) ? mtlLoader.parse( resource.content ) : null );

      } else if ( Validator.isValid( resource.url ) ) {

        var onError = function ( event ) {
          var output = 'Error occurred while downloading "' + resource.url + '"';
          this.logger.logError( output + ': ' + event );
          throw output;
        };

        mtlLoader.load( resource.name, processMaterials, undefined, onError );

      }
    }
  };

  return OBJLoader2;
})();

/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

THREE.MTLLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MTLLoader.prototype = {

  constructor: THREE.MTLLoader,

  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setTexturePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setPath and/or setTexturePath explicitly prior to load.
   */
  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( this.manager );
    loader.setPath( this.path );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  /**
   * Set base path for resolving references.
   * If set this path will be prepended to each loaded and found reference.
   *
   * @see setTexturePath
   * @param {String} path
   *
   * @example
   *     mtlLoader.setPath( 'assets/obj/' );
   *     mtlLoader.load( 'my.mtl', ... );
   */
  setPath: function ( path ) {

    this.path = path;

  },

  /**
   * Set base path for resolving texture references.
   * If set this path will be prepended found texture reference.
   * If not set and setPath is, it will be used as texture base path.
   *
   * @see setPath
   * @param {String} path
   *
   * @example
   *     mtlLoader.setPath( 'assets/obj/' );
   *     mtlLoader.setTexturePath( 'assets/textures/' );
   *     mtlLoader.load( 'my.mtl', ... );
   */
  setTexturePath: function ( path ) {

    this.texturePath = path;

  },

  setBaseUrl: function ( path ) {

    console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );

    this.setTexturePath( path );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setMaterialOptions: function ( value ) {

    this.materialOptions = value;

  },

  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {THREE.MTLLoader.MaterialCreator}
   *
   * @see setPath setTexturePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setPath and/or setTexturePath explicitly prior to parse.
   */
  parse: function ( text ) {

    var lines = text.split( '\n' );
    var info = {};
    var delimiter_pattern = /\s+/;
    var materialsInfo = {};

    for ( var i = 0; i < lines.length; i ++ ) {

      var line = lines[ i ];
      line = line.trim();

      if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

        // Blank line or comment ignore
        continue;

      }

      var pos = line.indexOf( ' ' );

      var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
      key = key.toLowerCase();

      var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
      value = value.trim();

      if ( key === 'newmtl' ) {

        // New material

        info = { name: value };
        materialsInfo[ value ] = info;

      } else if ( info ) {

        if ( key === 'ka' || key === 'kd' || key === 'ks' ) {

          var ss = value.split( delimiter_pattern, 3 );
          info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

        } else {

          info[ key ] = value;

        }

      }

    }

    var materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );
    materialCreator.setCrossOrigin( this.crossOrigin );
    materialCreator.setManager( this.manager );
    materialCreator.setMaterials( materialsInfo );
    return materialCreator;

  }

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {

  this.baseUrl = baseUrl || '';
  this.options = options;
  this.materialsInfo = {};
  this.materials = {};
  this.materialsArray = [];
  this.nameLookup = {};

  this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
  this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

  constructor: THREE.MTLLoader.MaterialCreator,

  crossOrigin: 'Anonymous',

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setManager: function ( value ) {

    this.manager = value;

  },

  setMaterials: function ( materialsInfo ) {

    this.materialsInfo = this.convert( materialsInfo );
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};

  },

  convert: function ( materialsInfo ) {

    if ( ! this.options ) return materialsInfo;

    var converted = {};

    for ( var mn in materialsInfo ) {

      // Convert materials info into normalized form based on options

      var mat = materialsInfo[ mn ];

      var covmat = {};

      converted[ mn ] = covmat;

      for ( var prop in mat ) {

        var save = true;
        var value = mat[ prop ];
        var lprop = prop.toLowerCase();

        switch ( lprop ) {

          case 'kd':
          case 'ka':
          case 'ks':

            // Diffuse color (color under white light) using RGB values

            if ( this.options && this.options.normalizeRGB ) {

              value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

            }

            if ( this.options && this.options.ignoreZeroRGBs ) {

              if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

                // ignore

                save = false;

              }

            }

            break;

          default:

            break;

        }

        if ( save ) {

          covmat[ lprop ] = value;

        }

      }

    }

    return converted;

  },

  preload: function () {

    for ( var mn in this.materialsInfo ) {

      this.create( mn );

    }

  },

  getIndex: function ( materialName ) {

    return this.nameLookup[ materialName ];

  },

  getAsArray: function () {

    var index = 0;

    for ( var mn in this.materialsInfo ) {

      this.materialsArray[ index ] = this.create( mn );
      this.nameLookup[ mn ] = index;
      index ++;

    }

    return this.materialsArray;

  },

  create: function ( materialName ) {

    if ( this.materials[ materialName ] === undefined ) {

      this.createMaterial_( materialName );

    }

    return this.materials[ materialName ];

  },

  createMaterial_: function ( materialName ) {

    // Create material

    var scope = this;
    var mat = this.materialsInfo[ materialName ];
    var params = {

      name: materialName,
      side: this.side

    };

    function resolveURL( baseUrl, url ) {

      if ( typeof url !== 'string' || url === '' )
        return '';

      // Absolute URL
      if ( /^https?:\/\//i.test( url ) ) return url;

      return baseUrl + url;

    }

    function setMapForType( mapType, value ) {

      if ( params[ mapType ] ) return; // Keep the first encountered texture

      var texParams = scope.getTextureParams( value, params );
      var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

      map.repeat.copy( texParams.scale );
      map.offset.copy( texParams.offset );

      map.wrapS = scope.wrap;
      map.wrapT = scope.wrap;

      params[ mapType ] = map;

    }

    for ( var prop in mat ) {

      var value = mat[ prop ];
      var n;

      if ( value === '' ) continue;

      switch ( prop.toLowerCase() ) {

        // Ns is material specular exponent

        case 'kd':

          // Diffuse color (color under white light) using RGB values

          params.color = new THREE.Color().fromArray( value );

          break;

        case 'ks':

          // Specular color (color when light is reflected from shiny surface) using RGB values
          params.specular = new THREE.Color().fromArray( value );

          break;

        case 'map_kd':

          // Diffuse texture map

          setMapForType( "map", value );

          break;

        case 'map_ks':

          // Specular map

          setMapForType( "specularMap", value );

          break;

        case 'norm':

          setMapForType( "normalMap", value );

          break;

        case 'map_bump':
        case 'bump':

          // Bump texture map

          setMapForType( "bumpMap", value );

          break;

        case 'ns':

          // The specular exponent (defines the focus of the specular highlight)
          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

          params.shininess = parseFloat( value );

          break;

        case 'd':
          n = parseFloat( value );

          if ( n < 1 ) {

            params.opacity = n;
            params.transparent = true;

          }

          break;

        case 'tr':
          n = parseFloat( value );

          if ( n > 0 ) {

            params.opacity = 1 - n;
            params.transparent = true;

          }

          break;

        default:
          break;

      }

    }

    this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
    return this.materials[ materialName ];

  },

  getTextureParams: function ( value, matParams ) {

    var texParams = {

      scale: new THREE.Vector2( 1, 1 ),
      offset: new THREE.Vector2( 0, 0 )

     };

    var items = value.split( /\s+/ );
    var pos;

    pos = items.indexOf( '-bm' );

    if ( pos >= 0 ) {

      matParams.bumpScale = parseFloat( items[ pos + 1 ] );
      items.splice( pos, 2 );

    }

    pos = items.indexOf( '-s' );

    if ( pos >= 0 ) {

      texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
      items.splice( pos, 4 ); // we expect 3 parameters here!

    }

    pos = items.indexOf( '-o' );

    if ( pos >= 0 ) {

      texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
      items.splice( pos, 4 ); // we expect 3 parameters here!

    }

    texParams.url = items.join( ' ' ).trim();
    return texParams;

  },

  loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

    var texture;
    var loader = THREE.Loader.Handlers.get( url );
    var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

    if ( loader === null ) {

      loader = new THREE.TextureLoader( manager );

    }

    if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
    texture = loader.load( url, onLoad, onProgress, onError );

    if ( mapping !== undefined ) texture.mapping = mapping;

    return texture;

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.PlayCanvasLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.PlayCanvasLoader.prototype = {

  constructor: THREE.PlayCanvasLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  parse: function ( json ) {

    function parseVertices( data ) {

      var attributes = {};

      // create a buffer attribute for each array that contains vertex information

      for ( var name in data ) {

        var array = data[ name ];

        var type = array.type;
        var size = array.components;

        var attribute;

        switch ( type ) {

          case 'float32':
            attribute = new THREE.Float32BufferAttribute( array.data, size );
            break;

          case 'uint8':
            attribute = new THREE.Uint8BufferAttribute( array.data, size );
            break;

          case 'uint16':
            attribute = new THREE.Uint16BufferAttribute( array.data, size );
            break;

          default:
            console.log( 'THREE.PlayCanvasLoader: Array type "%s" not yet supported.', type );

        }

        attributes[ name ] = attribute;

      }

      data._attributes = attributes;

    }

    function parseMeshes( data ) {

      // create buffer geometry

      var geometry = new THREE.BufferGeometry();

      geometry.setIndex( data.indices );

      var attributes = model.vertices[ data.vertices ]._attributes;

      for ( var name in attributes ) {

        var attribute = attributes[ name ];

        if ( name === 'texCoord0' ) name = 'uv';

        geometry.addAttribute( name, attribute );

      }

      data._geometry = geometry;

    }

    function parseMeshInstances( data ) {

      var node = model.nodes[ data.node ];
      var mesh = model.meshes[ data.mesh ];

      if ( node._geometries === undefined ) {

        node._geometries = [];

      }

      node._geometries.push( mesh._geometry );

    }

    function parseNodes( data ) {

      var object = new THREE.Group();

      var geometries = data._geometries;

      if ( geometries !== undefined ) {

        var material = new THREE.MeshPhongMaterial();

        for ( var i = 0, l = geometries.length; i < l; i ++ ) {

          var geometry = geometries[ i ];

          object.add( new THREE.Mesh( geometry, material ) );

        }

      }

      for ( var i = 0, l = data.rotation.length; i < l; i ++ ) {

        data.rotation[ i ] *= Math.PI / 180;

      }

      //

      object.name = data.name;

      object.position.fromArray( data.position );
      object.rotation.fromArray( data.rotation );
      object.scale.fromArray( data.scale );

      data._object = object;

    }

    //

    var model = json.model;

    for ( var i = 0, l = model.vertices.length; i < l; i ++ ) {

      parseVertices( model.vertices[ i ] );

    }

    for ( var i = 0, l = model.meshes.length; i < l; i ++ ) {

      parseMeshes( model.meshes[ i ] );

    }

    for ( var i = 0, l = model.meshInstances.length; i < l; i ++ ) {

      parseMeshInstances( model.meshInstances[ i ] );

    }

    for ( var i = 0, l = model.nodes.length; i < l; i ++ ) {

      parseNodes( model.nodes[ i ] );

    }

    // setup scene hierarchy

    for ( var i = 0, l = model.parents.length; i < l; i ++ ) {

      var parent = model.parents[ i ];

      if ( parent === - 1 ) continue;

      model.nodes[ parent ]._object.add( model.nodes[ i ]._object );


    }

    return model.nodes[ 0 ]._object;

  }

};

/**
 * @author Wei Meng / http://about.me/menway
 *
 * Description: A THREE loader for PLY ASCII files (known as the Polygon
 * File Format or the Stanford Triangle Format).
 *
 * Limitations: ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new THREE.PLYLoader();
 *  loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {
 *
 *    scene.add( new THREE.Mesh( geometry ) );
 *
 *  } );
 *
 * If the PLY file uses non standard property names, they can be mapped while
 * loading. For example, the following maps the properties
 * diffuse_(red|green|blue) in the file to standard color names.
 *
 * loader.setPropertyNameMapping( {
 *  diffuse_red: 'red',
 *  diffuse_green: 'green',
 *  diffuse_blue: 'blue'
 * } );
 *
 */


THREE.PLYLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  this.propertyNameMapping = {};

};

THREE.PLYLoader.prototype = {

  constructor: THREE.PLYLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( this.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  setPropertyNameMapping: function ( mapping ) {

    this.propertyNameMapping = mapping;

  },

  parse: function ( data ) {

    function bin2str( buf ) {

      var array_buffer = new Uint8Array( buf );

      if ( window.TextDecoder !== undefined ) {

        return new TextDecoder().decode( array_buffer );

      }

      var str = '';

      for ( var i = 0, il = buf.byteLength; i < il; i ++ ) {

        str += String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian

      }

      return str;

    }

    function parseHeader( data ) {

      var patternHeader = /ply([\s\S]*)end_header\s/;
      var headerText = '';
      var headerLength = 0;
      var result = patternHeader.exec( data );

      if ( result !== null ) {

        headerText = result[ 1 ];
        headerLength = result[ 0 ].length;

      }

      var header = {
        comments: [],
        elements: [],
        headerLength: headerLength
      };

      var lines = headerText.split( '\n' );
      var currentElement;
      var lineType, lineValues;

      function make_ply_element_property( propertValues, propertyNameMapping ) {

        var property = { type: propertValues[ 0 ] };

        if ( property.type === 'list' ) {

          property.name = propertValues[ 3 ];
          property.countType = propertValues[ 1 ];
          property.itemType = propertValues[ 2 ];

        } else {

          property.name = propertValues[ 1 ];

        }

        if ( property.name in propertyNameMapping ) {

          property.name = propertyNameMapping[ property.name ];

        }

        return property;

      }

      for ( var i = 0; i < lines.length; i ++ ) {

        var line = lines[ i ];
        line = line.trim();

        if ( line === '' ) continue;

        lineValues = line.split( /\s+/ );
        lineType = lineValues.shift();
        line = lineValues.join( ' ' );

        switch ( lineType ) {

          case 'format':

            header.format = lineValues[ 0 ];
            header.version = lineValues[ 1 ];

            break;

          case 'comment':

            header.comments.push( line );

            break;

          case 'element':

            if ( currentElement !== undefined ) {

              header.elements.push( currentElement );

            }

            currentElement = {};
            currentElement.name = lineValues[ 0 ];
            currentElement.count = parseInt( lineValues[ 1 ] );
            currentElement.properties = [];

            break;

          case 'property':

            currentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );

            break;


          default:

            console.log( 'unhandled', lineType, lineValues );

        }

      }

      if ( currentElement !== undefined ) {

        header.elements.push( currentElement );

      }

      return header;

    }

    function parseASCIINumber( n, type ) {

      switch ( type ) {

        case 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':
        case 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':

          return parseInt( n );

        case 'float': case 'double': case 'float32': case 'float64':

          return parseFloat( n );

      }

    }

    function parseASCIIElement( properties, line ) {

      var values = line.split( /\s+/ );

      var element = {};

      for ( var i = 0; i < properties.length; i ++ ) {

        if ( properties[ i ].type === 'list' ) {

          var list = [];
          var n = parseASCIINumber( values.shift(), properties[ i ].countType );

          for ( var j = 0; j < n; j ++ ) {

            list.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );

          }

          element[ properties[ i ].name ] = list;

        } else {

          element[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );

        }

      }

      return element;

    }

    function parseASCII( data, header ) {

      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

      var buffer = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        colors: []
      };

      var result;

      var patternBody = /end_header\s([\s\S]*)$/;
      var body = '';
      if ( ( result = patternBody.exec( data ) ) !== null ) {

        body = result[ 1 ];

      }

      var lines = body.split( '\n' );
      var currentElement = 0;
      var currentElementCount = 0;

      for ( var i = 0; i < lines.length; i ++ ) {

        var line = lines[ i ];
        line = line.trim();
        if ( line === '' ) {

          continue;

        }

        if ( currentElementCount >= header.elements[ currentElement ].count ) {

          currentElement ++;
          currentElementCount = 0;

        }

        var element = parseASCIIElement( header.elements[ currentElement ].properties, line );

        handleElement( buffer, header.elements[ currentElement ].name, element );

        currentElementCount ++;

      }

      return postProcess( buffer );

    }

    function postProcess( buffer ) {

      var geometry = new THREE.BufferGeometry();

      // mandatory buffer data

      if ( buffer.indices.length > 0 ) {

        geometry.setIndex( buffer.indices );

      }

      geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( buffer.vertices, 3 ) );

      // optional buffer data

      if ( buffer.normals.length > 0 ) {

        geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( buffer.normals, 3 ) );

      }

      if ( buffer.uvs.length > 0 ) {

        geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.uvs, 2 ) );

      }

      if ( buffer.colors.length > 0 ) {

        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( buffer.colors, 3 ) );

      }

      geometry.computeBoundingSphere();

      return geometry;

    }

    function handleElement( buffer, elementName, element ) {

      if ( elementName === 'vertex' ) {

        buffer.vertices.push( element.x, element.y, element.z );

        if ( 'nx' in element && 'ny' in element && 'nz' in element ) {

          buffer.normals.push( element.nx, element.ny, element.nz );

        }

        if ( 's' in element && 't' in element ) {

          buffer.uvs.push( element.s, element.t );

        }

        if ( 'red' in element && 'green' in element && 'blue' in element ) {

          buffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );

        }

      } else if ( elementName === 'face' ) {

        var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338

        if ( vertex_indices.length === 3 ) {

          buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );

        } else if ( vertex_indices.length === 4 ) {

          buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );
          buffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );

        }

      }

    }

    function binaryRead( dataview, at, type, little_endian ) {

      switch ( type ) {

        // corespondences for non-specific length types here match rply:
        case 'int8':    case 'char':   return [ dataview.getInt8( at ), 1 ];
        case 'uint8':   case 'uchar':  return [ dataview.getUint8( at ), 1 ];
        case 'int16':   case 'short':  return [ dataview.getInt16( at, little_endian ), 2 ];
        case 'uint16':  case 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];
        case 'int32':   case 'int':    return [ dataview.getInt32( at, little_endian ), 4 ];
        case 'uint32':  case 'uint':   return [ dataview.getUint32( at, little_endian ), 4 ];
        case 'float32': case 'float':  return [ dataview.getFloat32( at, little_endian ), 4 ];
        case 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];

      }

    }

    function binaryReadElement( dataview, at, properties, little_endian ) {

      var element = {};
      var result, read = 0;

      for ( var i = 0; i < properties.length; i ++ ) {

        if ( properties[ i ].type === 'list' ) {

          var list = [];

          result = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );
          var n = result[ 0 ];
          read += result[ 1 ];

          for ( var j = 0; j < n; j ++ ) {

            result = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );
            list.push( result[ 0 ] );
            read += result[ 1 ];

          }

          element[ properties[ i ].name ] = list;

        } else {

          result = binaryRead( dataview, at + read, properties[ i ].type, little_endian );
          element[ properties[ i ].name ] = result[ 0 ];
          read += result[ 1 ];

        }

      }

      return [ element, read ];

    }

    function parseBinary( data, header ) {

      var buffer = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        colors: []
      };

      var little_endian = ( header.format === 'binary_little_endian' );
      var body = new DataView( data, header.headerLength );
      var result, loc = 0;

      for ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {

        for ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {

          result = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );
          loc += result[ 1 ];
          var element = result[ 0 ];

          handleElement( buffer, header.elements[ currentElement ].name, element );

        }

      }

      return postProcess( buffer );

    }

    //

    var geometry;
    var scope = this;

    if ( data instanceof ArrayBuffer ) {

      var text = bin2str( data );
      var header = parseHeader( text );

      geometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );

    } else {

      geometry = parseASCII( data, parseHeader( data ) );

    }

    return geometry;

  }

};

/**
 * @author aleeper / http://adamleeper.com/
 * @author mrdoob / http://mrdoob.com/
 * @author gero3 / https://github.com/gero3
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new THREE.STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
 *  } else { .... }
 *  var mesh = new THREE.Mesh( geometry, material );
 */


THREE.STLLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.STLLoader.prototype = {

  constructor: THREE.STLLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  parse: function ( data ) {

    function isBinary( data ) {

      var expect, face_size, n_faces, reader;
      reader = new DataView( data );
      face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
      n_faces = reader.getUint32( 80, true );
      expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

      if ( expect === reader.byteLength ) {

        return true;

      }

      // An ASCII STL data must begin with 'solid ' as the first six bytes.
      // However, ASCII STLs lacking the SPACE after the 'd' are known to be
      // plentiful.  So, check the first 5 bytes for 'solid'.

      // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

      var solid = [ 115, 111, 108, 105, 100 ];

      for ( var i = 0; i < 5; i ++ ) {

        // If solid[ i ] does not match the i-th byte, then it is not an
        // ASCII STL; hence, it is binary and return true.

        if ( solid[ i ] != reader.getUint8( i, false ) ) return true;

      }

      // First 5 bytes read "solid"; declare it to be an ASCII STL

      return false;

    }

    function parseBinary( data ) {

      var reader = new DataView( data );
      var faces = reader.getUint32( 80, true );

      var r, g, b, hasColors = false, colors;
      var defaultR, defaultG, defaultB, alpha;

      // process STL header
      // check for default color in header ("COLOR=rgba" sequence).

      for ( var index = 0; index < 80 - 10; index ++ ) {

        if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
          ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
          ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {

          hasColors = true;
          colors = [];

          defaultR = reader.getUint8( index + 6 ) / 255;
          defaultG = reader.getUint8( index + 7 ) / 255;
          defaultB = reader.getUint8( index + 8 ) / 255;
          alpha = reader.getUint8( index + 9 ) / 255;

        }

      }

      var dataOffset = 84;
      var faceLength = 12 * 4 + 2;

      var geometry = new THREE.BufferGeometry();

      var vertices = [];
      var normals = [];

      for ( var face = 0; face < faces; face ++ ) {

        var start = dataOffset + face * faceLength;
        var normalX = reader.getFloat32( start, true );
        var normalY = reader.getFloat32( start + 4, true );
        var normalZ = reader.getFloat32( start + 8, true );

        if ( hasColors ) {

          var packedColor = reader.getUint16( start + 48, true );

          if ( ( packedColor & 0x8000 ) === 0 ) {

            // facet has its own unique color

            r = ( packedColor & 0x1F ) / 31;
            g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
            b = ( ( packedColor >> 10 ) & 0x1F ) / 31;

          } else {

            r = defaultR;
            g = defaultG;
            b = defaultB;

          }

        }

        for ( var i = 1; i <= 3; i ++ ) {

          var vertexstart = start + i * 12;

          vertices.push( reader.getFloat32( vertexstart, true ) );
          vertices.push( reader.getFloat32( vertexstart + 4, true ) );
          vertices.push( reader.getFloat32( vertexstart + 8, true ) );

          normals.push( normalX, normalY, normalZ );

          if ( hasColors ) {

            colors.push( r, g, b );

          }

        }

      }

      geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );
      geometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );

      if ( hasColors ) {

        geometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( colors ), 3 ) );
        geometry.hasColors = true;
        geometry.alpha = alpha;

      }

      return geometry;

    }

    function parseASCII( data ) {

      var geometry = new THREE.BufferGeometry();
      var patternFace = /facet([\s\S]*?)endfacet/g;
      var faceCounter = 0;

      var patternFloat = /[\s]+([+-]?(?:\d+.\d+|\d+.|\d+|.\d+)(?:[eE][+-]?\d+)?)/.source;
      var patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );
      var patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );

      var vertices = [];
      var normals = [];

      var normal = new THREE.Vector3();

      var result;

      while ( ( result = patternFace.exec( data ) ) !== null ) {

        var vertexCountPerFace = 0;
        var normalCountPerFace = 0;

        var text = result[ 0 ];

        while ( ( result = patternNormal.exec( text ) ) !== null ) {

          normal.x = parseFloat( result[ 1 ] );
          normal.y = parseFloat( result[ 2 ] );
          normal.z = parseFloat( result[ 3 ] );
          normalCountPerFace ++;

        }

        while ( ( result = patternVertex.exec( text ) ) !== null ) {

          vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );
          normals.push( normal.x, normal.y, normal.z );
          vertexCountPerFace ++;

        }

        // every face have to own ONE valid normal

        if ( normalCountPerFace !== 1 ) {

          console.error( 'THREE.STLLoader: Something isn\'t right with the normal of face number ' + faceCounter );

        }

        // each face have to own THREE valid vertices

        if ( vertexCountPerFace !== 3 ) {

          console.error( 'THREE.STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter );

        }

        faceCounter ++;

      }

      geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
      geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );

      return geometry;

    }

    function ensureString( buffer ) {

      if ( typeof buffer !== 'string' ) {

        var array_buffer = new Uint8Array( buffer );

        if ( window.TextDecoder !== undefined ) {

          return new TextDecoder().decode( array_buffer );

        }

        var str = '';

        for ( var i = 0, il = buffer.byteLength; i < il; i ++ ) {

          str += String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian

        }

        return str;

      } else {

        return buffer;

      }

    }

    function ensureBinary( buffer ) {

      if ( typeof buffer === 'string' ) {

        var array_buffer = new Uint8Array( buffer.length );
        for ( var i = 0; i < buffer.length; i ++ ) {

          array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian

        }
        return array_buffer.buffer || array_buffer;

      } else {

        return buffer;

      }

    }

    // start

    var binData = ensureBinary( data );

    return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );

  }

};

/*
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */

THREE.TGALoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TGALoader.prototype = {

  constructor: THREE.TGALoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texture = new THREE.Texture();

    var loader = new THREE.FileLoader( this.manager );
    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( buffer ) {

      texture.image = scope.parse( buffer );
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

    return texture;

  },

  parse: function ( buffer ) {

    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

    function tgaCheckHeader( header ) {

      switch ( header.image_type ) {

        // check indexed type

        case TGA_TYPE_INDEXED:
        case TGA_TYPE_RLE_INDEXED:
          if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

            console.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );

          }
          break;

        // check colormap type

        case TGA_TYPE_RGB:
        case TGA_TYPE_GREY:
        case TGA_TYPE_RLE_RGB:
        case TGA_TYPE_RLE_GREY:
          if ( header.colormap_type ) {

            console.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );

          }
          break;

        // What the need of a file without data ?

        case TGA_TYPE_NO_DATA:
          console.error( 'THREE.TGALoader: No data.' );

        // Invalid type ?

        default:
          console.error( 'THREE.TGALoader: Invalid type "%s".', header.image_type );

      }

      // check image width and height

      if ( header.width <= 0 || header.height <= 0 ) {

        console.error( 'THREE.TGALoader: Invalid image size.' );

      }

      // check image pixel size

      if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&
        header.pixel_size !== 24 && header.pixel_size !== 32 ) {

        console.error( 'THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size );

      }

    }

    // parse tga image buffer

    function tgaParse( use_rle, use_pal, header, offset, data ) {

      var pixel_data,
        pixel_size,
        pixel_total,
        palettes;

      pixel_size = header.pixel_size >> 3;
      pixel_total = header.width * header.height * pixel_size;

       // read palettes

       if ( use_pal ) {

         palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

       }

       // read RLE

       if ( use_rle ) {

         pixel_data = new Uint8Array( pixel_total );

        var c, count, i;
        var shift = 0;
        var pixels = new Uint8Array( pixel_size );

        while ( shift < pixel_total ) {

          c = data[ offset ++ ];
          count = ( c & 0x7f ) + 1;

          // RLE pixels

          if ( c & 0x80 ) {

            // bind pixel tmp array

            for ( i = 0; i < pixel_size; ++ i ) {

              pixels[ i ] = data[ offset ++ ];

            }

            // copy pixel array

            for ( i = 0; i < count; ++ i ) {

              pixel_data.set( pixels, shift + i * pixel_size );

            }

            shift += pixel_size * count;

          } else {

            // raw pixels

            count *= pixel_size;
            for ( i = 0; i < count; ++ i ) {

              pixel_data[ shift + i ] = data[ offset ++ ];

            }
            shift += count;

          }

        }

       } else {

        // raw pixels

        pixel_data = data.subarray(
           offset, offset += ( use_pal ? header.width * header.height : pixel_total )
        );

       }

       return {
        pixel_data: pixel_data,
        palettes: palettes
       };

    }

    function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

      var colormap = palettes;
      var color, i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

          color = image[ i ];
          imageData[ ( x + width * y ) * 4 + 3 ] = 255;
          imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];
          imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];
          imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];

        }

      }

      return imageData;

    }

    function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

      var color, i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

          color = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?
          imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;
          imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;
          imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;
          imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;

        }

      }

      return imageData;

    }

    function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

      var i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

          imageData[ ( x + width * y ) * 4 + 3 ] = 255;
          imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
          imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
          imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];

        }

      }

      return imageData;

    }

    function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

      var i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

          imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
          imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
          imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];
          imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];

        }

      }

      return imageData;

    }

    function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

      var color, i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

          color = image[ i ];
          imageData[ ( x + width * y ) * 4 + 0 ] = color;
          imageData[ ( x + width * y ) * 4 + 1 ] = color;
          imageData[ ( x + width * y ) * 4 + 2 ] = color;
          imageData[ ( x + width * y ) * 4 + 3 ] = 255;

        }

      }

      return imageData;

    }

    function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

      var i = 0, x, y;
      var width = header.width;

      for ( y = y_start; y !== y_end; y += y_step ) {

        for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

          imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];
          imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];
          imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
          imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];

        }

      }

      return imageData;

    }

    function getTgaRGBA( data, width, height, image, palette ) {

      var x_start,
        y_start,
        x_step,
        y_step,
        x_end,
        y_end;

      switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {

        default:
        case TGA_ORIGIN_UL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;

        case TGA_ORIGIN_BL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = height - 1;
          y_step = - 1;
          y_end = - 1;
          break;

        case TGA_ORIGIN_UR:
          x_start = width - 1;
          x_step = - 1;
          x_end = - 1;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;

        case TGA_ORIGIN_BR:
          x_start = width - 1;
          x_step = - 1;
          x_end = - 1;
          y_start = height - 1;
          y_step = - 1;
          y_end = - 1;
          break;

      }

      if ( use_grey ) {

        switch ( header.pixel_size ) {

          case 8:
            tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
            break;

          case 16:
            tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
            break;

          default:
            console.error( 'THREE.TGALoader: Format not supported.' );
            break;

        }

      } else {

        switch ( header.pixel_size ) {

          case 8:
            tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
            break;

          case 16:
            tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
            break;

          case 24:
            tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
            break;

          case 32:
            tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
            break;

          default:
            console.error( 'THREE.TGALoader: Format not supported.' );
            break;

        }

      }

      // Load image data according to specific method
      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
      return data;

    }

    // TGA constants

    var TGA_TYPE_NO_DATA = 0,
      TGA_TYPE_INDEXED = 1,
      TGA_TYPE_RGB = 2,
      TGA_TYPE_GREY = 3,
      TGA_TYPE_RLE_INDEXED = 9,
      TGA_TYPE_RLE_RGB = 10,
      TGA_TYPE_RLE_GREY = 11,

      TGA_ORIGIN_MASK = 0x30,
      TGA_ORIGIN_SHIFT = 0x04,
      TGA_ORIGIN_BL = 0x00,
      TGA_ORIGIN_BR = 0x01,
      TGA_ORIGIN_UL = 0x02,
      TGA_ORIGIN_UR = 0x03;

    if ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );

    var content = new Uint8Array( buffer ),
      offset = 0,
      header = {
        id_length: content[ offset ++ ],
        colormap_type: content[ offset ++ ],
        image_type: content[ offset ++ ],
        colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,
        colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,
        colormap_size: content[ offset ++ ],
        origin: [
          content[ offset ++ ] | content[ offset ++ ] << 8,
          content[ offset ++ ] | content[ offset ++ ] << 8
        ],
        width: content[ offset ++ ] | content[ offset ++ ] << 8,
        height: content[ offset ++ ] | content[ offset ++ ] << 8,
        pixel_size: content[ offset ++ ],
        flags: content[ offset ++ ]
      };

      // check tga if it is valid format

    tgaCheckHeader( header );

    if ( header.id_length + offset > buffer.length ) {

      console.error( 'THREE.TGALoader: No data.' );

    }

    // skip the needn't data

    offset += header.id_length;

    // get targa information about RLE compression and palette

    var use_rle = false,
      use_pal = false,
      use_grey = false;

    switch ( header.image_type ) {

      case TGA_TYPE_RLE_INDEXED:
        use_rle = true;
        use_pal = true;
        break;

      case TGA_TYPE_INDEXED:
        use_pal = true;
        break;

      case TGA_TYPE_RLE_RGB:
        use_rle = true;
        break;

      case TGA_TYPE_RGB:
        break;

      case TGA_TYPE_RLE_GREY:
        use_rle = true;
        use_grey = true;
        break;

      case TGA_TYPE_GREY:
        use_grey = true;
        break;

    }

    //

    var canvas = document.createElement( 'canvas' );
    canvas.width = header.width;
    canvas.height = header.height;

    var context = canvas.getContext( '2d' );
    var imageData = context.createImageData( header.width, header.height );

    var result = tgaParse( use_rle, use_pal, header, offset, content );
    var rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );

    context.putImageData( imageData, 0, 0 );

    return canvas;

  }

};

/*
 * Autodesk 3DS threee.js file loader, based on lib3ds.
 *
 * Loads geometry with uv and materials basic properties with texture support.
 *
 * @author @tentone
 * @author @timknip
 * @class TDSLoader
 * @constructor
 */

'use strict';

THREE.TDSLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.debug = false;

  this.group = null;
  this.position = 0;

  this.materials = [];
  this.meshes = [];

  this.path = "";

};

THREE.TDSLoader.prototype = {

  constructor: THREE.TDSLoader,

  /**
   * Load 3ds file from url.
   *
   * @method load
   * @param {[type]} url URL for the file.
   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.
   * @param {Function} onProgress onProgress callback.
   * @param {Function} onError onError callback.
   */
  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( this.manager );

    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( data ) {

      onLoad( scope.parse( data ) );

    }, onProgress, onError );

  },

  /**
   * Parse arraybuffer data and load 3ds file.
   *
   * @method parse
   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
   * @param {String} path Path for external resources.
   * @return {Object3D} Group loaded from 3ds file.
   */
  parse: function ( arraybuffer ) {

    this.group = new THREE.Group();
    this.position = 0;
    this.materials = [];
    this.meshes = [];

    this.readFile( arraybuffer );

    for ( var i = 0; i < this.meshes.length; i ++ ) {

      this.group.add( this.meshes[ i ] );

    }

    return this.group;

  },

  /**
   * Decode file content to read 3ds data.
   *
   * @method readFile
   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
   */
  readFile: function ( arraybuffer ) {

    var data = new DataView( arraybuffer );
    var chunk = this.readChunk( data );

    if ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {

      var next = this.nextChunk( data, chunk );

      while ( next !== 0 ) {

        if ( next === M3D_VERSION ) {

          var version = this.readDWord( data );
          this.debugMessage( '3DS file version: ' + version );

        } else if ( next === MDATA ) {

          this.resetPosition( data );
          this.readMeshData( data );

        } else {

          this.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

    }

    this.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );

  },

  /**
   * Read mesh data chunk.
   *
   * @method readMeshData
   * @param {Dataview} data Dataview in use.
   */
  readMeshData: function ( data ) {

    var chunk = this.readChunk( data );
    var next = this.nextChunk( data, chunk );

    while ( next !== 0 ) {

      if ( next === MESH_VERSION ) {

        var version = + this.readDWord( data );
        this.debugMessage( 'Mesh Version: ' + version );

      } else if ( next === MASTER_SCALE ) {

        var scale = this.readFloat( data );
        this.debugMessage( 'Master scale: ' + scale );
        this.group.scale.set( scale, scale, scale );

      } else if ( next === NAMED_OBJECT ) {

        this.debugMessage( 'Named Object' );
        this.resetPosition( data );
        this.readNamedObject( data );

      } else if ( next === MAT_ENTRY ) {

        this.debugMessage( 'Material' );
        this.resetPosition( data );
        this.readMaterialEntry( data );

      } else {

        this.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );

      }

      next = this.nextChunk( data, chunk );

    }

  },

  /**
   * Read named object chunk.
   *
   * @method readNamedObject
   * @param {Dataview} data Dataview in use.
   */
  readNamedObject: function ( data ) {

    var chunk = this.readChunk( data );
    var name = this.readString( data, 64 );
    chunk.cur = this.position;

    var next = this.nextChunk( data, chunk );
    while ( next !== 0 ) {

      if ( next === N_TRI_OBJECT ) {

        this.resetPosition( data );
        var mesh = this.readMesh( data );
        mesh.name = name;
        this.meshes.push( mesh );

      } else {

        this.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );

      }

      next = this.nextChunk( data, chunk );

    }

    this.endChunk( chunk );

  },

  /**
   * Read material data chunk and add it to the material list.
   *
   * @method readMaterialEntry
   * @param {Dataview} data Dataview in use.
   */
  readMaterialEntry: function ( data ) {

    var chunk = this.readChunk( data );
    var next = this.nextChunk( data, chunk );
    var material = new THREE.MeshPhongMaterial();

    while ( next !== 0 ) {

      if ( next === MAT_NAME ) {

        material.name = this.readString( data, 64 );
        this.debugMessage( '   Name: ' + material.name );

      } else if ( next === MAT_WIRE ) {

        this.debugMessage( '   Wireframe' );
        material.wireframe = true;

      } else if ( next === MAT_WIRE_SIZE ) {

        var value = this.readByte( data );
        material.wireframeLinewidth = value;
        this.debugMessage( '   Wireframe Thickness: ' + value );

      } else if ( next === MAT_TWO_SIDE ) {

        material.side = THREE.DoubleSide;
        this.debugMessage( '   DoubleSided' );

      } else if ( next === MAT_ADDITIVE ) {

        this.debugMessage( '   Additive Blending' );
        material.blending = THREE.AdditiveBlending;

      } else if ( next === MAT_DIFFUSE ) {

        this.debugMessage( '   Diffuse Color' );
        material.color = this.readColor( data );

      } else if ( next === MAT_SPECULAR ) {

        this.debugMessage( '   Specular Color' );
        material.specular = this.readColor( data );

      } else if ( next === MAT_AMBIENT ) {

        this.debugMessage( '   Ambient color' );
        material.color = this.readColor( data );

      } else if ( next === MAT_SHININESS ) {

        var shininess = this.readWord( data );
        material.shininess = shininess;
        this.debugMessage( '   Shininess : ' + shininess );

      } else if ( next === MAT_TEXMAP ) {

        this.debugMessage( '   ColorMap' );
        this.resetPosition( data );
        material.map = this.readMap( data );

      } else if ( next === MAT_BUMPMAP ) {

        this.debugMessage( '   BumpMap' );
        this.resetPosition( data );
        material.bumpMap = this.readMap( data );

      } else if ( next === MAT_OPACMAP ) {

        this.debugMessage( '   OpacityMap' );
        this.resetPosition( data );
        material.alphaMap = this.readMap( data );

      } else if ( next === MAT_SPECMAP ) {

        this.debugMessage( '   SpecularMap' );
        this.resetPosition( data );
        material.specularMap = this.readMap( data );

      } else {

        this.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );

      }

      next = this.nextChunk( data, chunk );

    }

    this.endChunk( chunk );

    this.materials[ material.name ] = material;

  },

  /**
   * Read mesh data chunk.
   *
   * @method readMesh
   * @param {Dataview} data Dataview in use.
   */
  readMesh: function ( data ) {

    var chunk = this.readChunk( data );
    var next = this.nextChunk( data, chunk );

    var useBufferGeometry = false;
    var geometry = null;
    var uvs = [];

    if ( useBufferGeometry ) {

      geometry = new THREE.BufferGeometry();

    } else {

      geometry = new THREE.Geometry();

    }

    var material = new THREE.MeshPhongMaterial();
    var mesh = new THREE.Mesh( geometry, material );
    mesh.name = 'mesh';

    while ( next !== 0 ) {

      if ( next === POINT_ARRAY ) {

        var points = this.readWord( data );

        this.debugMessage( '   Vertex: ' + points );

        //BufferGeometry

        if ( useBufferGeometry )  {

          var vertices = [];
          for ( var i = 0; i < points; i ++ )   {

            vertices.push( this.readFloat( data ) );
            vertices.push( this.readFloat( data ) );
            vertices.push( this.readFloat( data ) );

          }

          geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );

        } else  { //Geometry

          for ( var i = 0; i < points; i ++ )   {

            geometry.vertices.push( new THREE.Vector3( this.readFloat( data ), this.readFloat( data ), this.readFloat( data ) ) );

          }

        }

      } else if ( next === FACE_ARRAY ) {

        this.resetPosition( data );
        this.readFaceArray( data, mesh );

      } else if ( next === TEX_VERTS ) {

        var texels = this.readWord( data );

        this.debugMessage( '   UV: ' + texels );

        //BufferGeometry

        if ( useBufferGeometry )  {

          var uvs = [];
          for ( var i = 0; i < texels; i ++ )   {

            uvs.push( this.readFloat( data ) );
            uvs.push( this.readFloat( data ) );

          }
          geometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );

        } else { //Geometry

          uvs = [];
          for ( var i = 0; i < texels; i ++ )   {

            uvs.push( new THREE.Vector2( this.readFloat( data ), this.readFloat( data ) ) );

          }

        }

      } else if ( next === MESH_MATRIX ) {

        this.debugMessage( '   Tranformation Matrix (TODO)' );

        var values = [];
        for ( var i = 0; i < 12; i ++ ) {

          values[ i ] = this.readFloat( data );

        }

        var matrix = new THREE.Matrix4();

        //X Line
        matrix.elements[ 0 ] = values[ 0 ];
        matrix.elements[ 1 ] = values[ 6 ];
        matrix.elements[ 2 ] = values[ 3 ];
        matrix.elements[ 3 ] = values[ 9 ];

        //Y Line
        matrix.elements[ 4 ] = values[ 2 ];
        matrix.elements[ 5 ] = values[ 8 ];
        matrix.elements[ 6 ] = values[ 5 ];
        matrix.elements[ 7 ] = values[ 11 ];

        //Z Line
        matrix.elements[ 8 ] = values[ 1 ];
        matrix.elements[ 9 ] = values[ 7 ];
        matrix.elements[ 10 ] = values[ 4 ];
        matrix.elements[ 11 ] = values[ 10 ];

        //W Line
        matrix.elements[ 12 ] = 0;
        matrix.elements[ 13 ] = 0;
        matrix.elements[ 14 ] = 0;
        matrix.elements[ 15 ] = 1;

        matrix.transpose();

        var inverse = new THREE.Matrix4();
        inverse.getInverse( matrix, true );
        geometry.applyMatrix( inverse );

        matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );

      } else {

        this.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );

      }

      next = this.nextChunk( data, chunk );

    }

    this.endChunk( chunk );

    if ( ! useBufferGeometry ) {

      //geometry.faceVertexUvs[0][faceIndex][vertexIndex]

      if ( uvs.length > 0 ) {

        var faceUV = [];

        for ( var i = 0; i < geometry.faces.length; i ++ ) {

          faceUV.push( [ uvs[ geometry.faces[ i ].a ], uvs[ geometry.faces[ i ].b ], uvs[ geometry.faces[ i ].c ] ] );

        }

        geometry.faceVertexUvs[ 0 ] = faceUV;

      }

      geometry.computeVertexNormals();

    }

    return mesh;

  },

  /**
   * Read face array data chunk.
   *
   * @method readFaceArray
   * @param {Dataview} data Dataview in use.
   * @param {Mesh} mesh Mesh to be filled with the data read.
   */
  readFaceArray: function ( data, mesh ) {

    var chunk = this.readChunk( data );
    var faces = this.readWord( data );

    this.debugMessage( '   Faces: ' + faces );

    for ( var i = 0; i < faces; ++ i ) {

      mesh.geometry.faces.push( new THREE.Face3( this.readWord( data ), this.readWord( data ), this.readWord( data ) ) );

      var visibility = this.readWord( data );

    }

    //The rest of the FACE_ARRAY chunk is subchunks

    while ( this.position < chunk.end ) {

      var chunk = this.readChunk( data );

      if ( chunk.id === MSH_MAT_GROUP ) {

        this.debugMessage( '      Material Group' );

        this.resetPosition( data );

        var group = this.readMaterialGroup( data );

        var material = this.materials[ group.name ];

        if ( material !== undefined ) {

          mesh.material = material;

          if ( material.name === '' )   {

            material.name = mesh.name;

          }

        }

      } else {

        this.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );

      }

      this.endChunk( chunk );

    }

    this.endChunk( chunk );

  },

  /**
   * Read texture map data chunk.
   *
   * @method readMap
   * @param {Dataview} data Dataview in use.
   * @return {Texture} Texture read from this data chunk.
   */
  readMap: function ( data ) {

    var chunk = this.readChunk( data );
    var next = this.nextChunk( data, chunk );
    var texture = {};

    var loader = new THREE.TextureLoader();
    loader.setPath( this.path );

    while ( next !== 0 ) {

      if ( next === MAT_MAPNAME ) {

        var name = this.readString( data, 128 );
        texture = loader.load( name );

        this.debugMessage( '      File: ' + this.path + name );

      } else if ( next === MAT_MAP_UOFFSET ) {

        texture.offset.x = this.readFloat( data );
        this.debugMessage( '      OffsetX: ' + texture.offset.x );

      } else if ( next === MAT_MAP_VOFFSET ) {

        texture.offset.y = this.readFloat( data );
        this.debugMessage( '      OffsetY: ' + texture.offset.y );

      } else if ( next === MAT_MAP_USCALE ) {

        texture.repeat.x = this.readFloat( data );
        this.debugMessage( '      RepeatX: ' + texture.repeat.x );

      } else if ( next === MAT_MAP_VSCALE ) {

        texture.repeat.y = this.readFloat( data );
        this.debugMessage( '      RepeatY: ' + texture.repeat.y );

      } else {

        this.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );

      }

      next = this.nextChunk( data, chunk );

    }

    this.endChunk( chunk );

    return texture;

  },

  /**
   * Read material group data chunk.
   *
   * @method readMaterialGroup
   * @param {Dataview} data Dataview in use.
   * @return {Object} Object with name and index of the object.
   */
  readMaterialGroup: function ( data ) {

    var chunk = this.readChunk( data );
    var name = this.readString( data, 64 );
    var numFaces = this.readWord( data );

    this.debugMessage( '         Name: ' + name );
    this.debugMessage( '         Faces: ' + numFaces );

    var index = [];
    for ( var i = 0; i < numFaces; ++ i ) {

      index.push( this.readWord( data ) );

    }

    return { name: name, index: index };

  },

  /**
   * Read a color value.
   *
   * @method readColor
   * @param {DataView} data Dataview.
   * @return {Color} Color value read..
   */
  readColor: function ( data ) {

    var chunk = this.readChunk( data );
    var color = new THREE.Color();

    if ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {

      var r = this.readByte( data );
      var g = this.readByte( data );
      var b = this.readByte( data );

      color.setRGB( r / 255, g / 255, b / 255 );

      this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

    } else if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {

      var r = this.readFloat( data );
      var g = this.readFloat( data );
      var b = this.readFloat( data );

      color.setRGB( r, g, b );

      this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

    } else {

      this.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );

    }

    this.endChunk( chunk );
    return color;

  },

  /**
   * Read next chunk of data.
   *
   * @method readChunk
   * @param {DataView} data Dataview.
   * @return {Object} Chunk of data read.
   */
  readChunk: function ( data ) {

    var chunk = {};

    chunk.cur = this.position;
    chunk.id = this.readWord( data );
    chunk.size = this.readDWord( data );
    chunk.end = chunk.cur + chunk.size;
    chunk.cur += 6;

    return chunk;

  },

  /**
   * Set position to the end of the current chunk of data.
   *
   * @method endChunk
   * @param {Object} chunk Data chunk.
   */
  endChunk: function ( chunk ) {

    this.position = chunk.end;

  },

  /**
   * Move to the next data chunk.
   *
   * @method nextChunk
   * @param {DataView} data Dataview.
   * @param {Object} chunk Data chunk.
   */
  nextChunk: function ( data, chunk ) {

    if ( chunk.cur >= chunk.end ) {

      return 0;

    }

    this.position = chunk.cur;

    try {

      var next = this.readChunk( data );
      chunk.cur += next.size;
      return next.id;

    } catch ( e ) {

      this.debugMessage( 'Unable to read chunk at ' + this.position );
      return 0;

    }

  },

  /**
   * Reset dataview position.
   *
   * @method resetPosition
   * @param {DataView} data Dataview.
   */
  resetPosition: function () {

    this.position -= 6;

  },

  /**
   * Read byte value.
   *
   * @method readByte
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readByte: function ( data ) {

    var v = data.getUint8( this.position, true );
    this.position += 1;
    return v;

  },

  /**
   * Read 32 bit float value.
   *
   * @method readFloat
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readFloat: function ( data ) {

    try {

      var v = data.getFloat32( this.position, true );
      this.position += 4;
      return v;

    } catch ( e ) {

      this.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );

    }

  },

  /**
   * Read 32 bit signed integer value.
   *
   * @method readInt
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readInt: function ( data ) {

    var v = data.getInt32( this.position, true );
    this.position += 4;
    return v;

  },

  /**
   * Read 16 bit signed integer value.
   *
   * @method readShort
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readShort: function ( data ) {

    var v = data.getInt16( this.position, true );
    this.position += 2;
    return v;

  },

  /**
   * Read 64 bit unsigned integer value.
   *
   * @method readDWord
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readDWord: function ( data ) {

    var v = data.getUint32( this.position, true );
    this.position += 4;
    return v;

  },

  /**
   * Read 32 bit unsigned integer value.
   *
   * @method readWord
   * @param {DataView} data Dataview to read data from.
   * @return {Number} Data read from the dataview.
   */
  readWord: function ( data ) {

    var v = data.getUint16( this.position, true );
    this.position += 2;
    return v;

  },

  /**
   * Read string value.
   *
   * @method readString
   * @param {DataView} data Dataview to read data from.
   * @param {Number} maxLength Max size of the string to be read.
   * @return {String} Data read from the dataview.
   */
  readString: function ( data, maxLength ) {

    var s = '';

    for ( var i = 0; i < maxLength; i ++ ) {

      var c = this.readByte( data );
      if ( ! c ) {

        break;

      }

      s += String.fromCharCode( c );

    }

    return s;

  },

  /**
   * Set resource path used to determine the file path to attached resources.
   *
   * @method setPath
   * @param {String} path Path to resources.
   * @return Self for chaining.
   */
  setPath: function ( path ) {

    if ( path !== undefined ) {

      this.path = path;

    }

    return this;

  },

  /**
   * Print debug message to the console.
   *
   * Is controlled by a flag to show or hide debug messages.
   *
   * @method debugMessage
   * @param {Object} message Debug message to print to the console.
   */
  debugMessage: function ( message ) {

    if ( this.debug ) {

      console.log( message );

    }

  }
};

var NULL_CHUNK = 0x0000;
var M3DMAGIC = 0x4D4D;
var SMAGIC = 0x2D2D;
var LMAGIC = 0x2D3D;
var MLIBMAGIC = 0x3DAA;
var MATMAGIC = 0x3DFF;
var CMAGIC = 0xC23D;
var M3D_VERSION = 0x0002;
var M3D_KFVERSION = 0x0005;
var COLOR_F = 0x0010;
var COLOR_24 = 0x0011;
var LIN_COLOR_24 = 0x0012;
var LIN_COLOR_F = 0x0013;
var INT_PERCENTAGE = 0x0030;
var FLOAT_PERCENTAGE = 0x0031;
var MDATA = 0x3D3D;
var MESH_VERSION = 0x3D3E;
var MASTER_SCALE = 0x0100;
var LO_SHADOW_BIAS = 0x1400;
var HI_SHADOW_BIAS = 0x1410;
var SHADOW_MAP_SIZE = 0x1420;
var SHADOW_SAMPLES = 0x1430;
var SHADOW_RANGE = 0x1440;
var SHADOW_FILTER = 0x1450;
var RAY_BIAS = 0x1460;
var O_CONSTS = 0x1500;
var AMBIENT_LIGHT = 0x2100;
var BIT_MAP = 0x1100;
var SOLID_BGND = 0x1200;
var V_GRADIENT = 0x1300;
var USE_BIT_MAP = 0x1101;
var USE_SOLID_BGND = 0x1201;
var USE_V_GRADIENT = 0x1301;
var FOG = 0x2200;
var FOG_BGND = 0x2210;
var LAYER_FOG = 0x2302;
var DISTANCE_CUE = 0x2300;
var DCUE_BGND = 0x2310;
var USE_FOG = 0x2201;
var USE_LAYER_FOG = 0x2303;
var USE_DISTANCE_CUE = 0x2301;
var MAT_ENTRY = 0xAFFF;
var MAT_NAME = 0xA000;
var MAT_AMBIENT = 0xA010;
var MAT_DIFFUSE = 0xA020;
var MAT_SPECULAR = 0xA030;
var MAT_SHININESS = 0xA040;
var MAT_SHIN2PCT = 0xA041;
var MAT_TRANSPARENCY = 0xA050;
var MAT_XPFALL = 0xA052;
var MAT_USE_XPFALL = 0xA240;
var MAT_REFBLUR = 0xA053;
var MAT_SHADING = 0xA100;
var MAT_USE_REFBLUR = 0xA250;
var MAT_SELF_ILLUM = 0xA084;
var MAT_TWO_SIDE = 0xA081;
var MAT_DECAL = 0xA082;
var MAT_ADDITIVE = 0xA083;
var MAT_WIRE = 0xA085;
var MAT_FACEMAP = 0xA088;
var MAT_TRANSFALLOFF_IN = 0xA08A;
var MAT_PHONGSOFT = 0xA08C;
var MAT_WIREABS = 0xA08E;
var MAT_WIRE_SIZE = 0xA087;
var MAT_TEXMAP = 0xA200;
var MAT_SXP_TEXT_DATA = 0xA320;
var MAT_TEXMASK = 0xA33E;
var MAT_SXP_TEXTMASK_DATA = 0xA32A;
var MAT_TEX2MAP = 0xA33A;
var MAT_SXP_TEXT2_DATA = 0xA321;
var MAT_TEX2MASK = 0xA340;
var MAT_SXP_TEXT2MASK_DATA = 0xA32C;
var MAT_OPACMAP = 0xA210;
var MAT_SXP_OPAC_DATA = 0xA322;
var MAT_OPACMASK = 0xA342;
var MAT_SXP_OPACMASK_DATA = 0xA32E;
var MAT_BUMPMAP = 0xA230;
var MAT_SXP_BUMP_DATA = 0xA324;
var MAT_BUMPMASK = 0xA344;
var MAT_SXP_BUMPMASK_DATA = 0xA330;
var MAT_SPECMAP = 0xA204;
var MAT_SXP_SPEC_DATA = 0xA325;
var MAT_SPECMASK = 0xA348;
var MAT_SXP_SPECMASK_DATA = 0xA332;
var MAT_SHINMAP = 0xA33C;
var MAT_SXP_SHIN_DATA = 0xA326;
var MAT_SHINMASK = 0xA346;
var MAT_SXP_SHINMASK_DATA = 0xA334;
var MAT_SELFIMAP = 0xA33D;
var MAT_SXP_SELFI_DATA = 0xA328;
var MAT_SELFIMASK = 0xA34A;
var MAT_SXP_SELFIMASK_DATA = 0xA336;
var MAT_REFLMAP = 0xA220;
var MAT_REFLMASK = 0xA34C;
var MAT_SXP_REFLMASK_DATA = 0xA338;
var MAT_ACUBIC = 0xA310;
var MAT_MAPNAME = 0xA300;
var MAT_MAP_TILING = 0xA351;
var MAT_MAP_TEXBLUR = 0xA353;
var MAT_MAP_USCALE = 0xA354;
var MAT_MAP_VSCALE = 0xA356;
var MAT_MAP_UOFFSET = 0xA358;
var MAT_MAP_VOFFSET = 0xA35A;
var MAT_MAP_ANG = 0xA35C;
var MAT_MAP_COL1 = 0xA360;
var MAT_MAP_COL2 = 0xA362;
var MAT_MAP_RCOL = 0xA364;
var MAT_MAP_GCOL = 0xA366;
var MAT_MAP_BCOL = 0xA368;
var NAMED_OBJECT = 0x4000;
var N_DIRECT_LIGHT = 0x4600;
var DL_OFF = 0x4620;
var DL_OUTER_RANGE = 0x465A;
var DL_INNER_RANGE = 0x4659;
var DL_MULTIPLIER = 0x465B;
var DL_EXCLUDE = 0x4654;
var DL_ATTENUATE = 0x4625;
var DL_SPOTLIGHT = 0x4610;
var DL_SPOT_ROLL = 0x4656;
var DL_SHADOWED = 0x4630;
var DL_LOCAL_SHADOW2 = 0x4641;
var DL_SEE_CONE = 0x4650;
var DL_SPOT_RECTANGULAR = 0x4651;
var DL_SPOT_ASPECT = 0x4657;
var DL_SPOT_PROJECTOR = 0x4653;
var DL_SPOT_OVERSHOOT = 0x4652;
var DL_RAY_BIAS = 0x4658;
var DL_RAYSHAD = 0x4627;
var N_CAMERA = 0x4700;
var CAM_SEE_CONE = 0x4710;
var CAM_RANGES = 0x4720;
var OBJ_HIDDEN = 0x4010;
var OBJ_VIS_LOFTER = 0x4011;
var OBJ_DOESNT_CAST = 0x4012;
var OBJ_DONT_RECVSHADOW = 0x4017;
var OBJ_MATTE = 0x4013;
var OBJ_FAST = 0x4014;
var OBJ_PROCEDURAL = 0x4015;
var OBJ_FROZEN = 0x4016;
var N_TRI_OBJECT = 0x4100;
var POINT_ARRAY = 0x4110;
var POINT_FLAG_ARRAY = 0x4111;
var FACE_ARRAY = 0x4120;
var MSH_MAT_GROUP = 0x4130;
var SMOOTH_GROUP = 0x4150;
var MSH_BOXMAP = 0x4190;
var TEX_VERTS = 0x4140;
var MESH_MATRIX = 0x4160;
var MESH_COLOR = 0x4165;
var MESH_TEXTURE_INFO = 0x4170;
var KFDATA = 0xB000;
var KFHDR = 0xB00A;
var KFSEG = 0xB008;
var KFCURTIME = 0xB009;
var AMBIENT_NODE_TAG = 0xB001;
var OBJECT_NODE_TAG = 0xB002;
var CAMERA_NODE_TAG = 0xB003;
var TARGET_NODE_TAG = 0xB004;
var LIGHT_NODE_TAG = 0xB005;
var L_TARGET_NODE_TAG = 0xB006;
var SPOTLIGHT_NODE_TAG = 0xB007;
var NODE_ID = 0xB030;
var NODE_HDR = 0xB010;
var PIVOT = 0xB013;
var INSTANCE_NAME = 0xB011;
var MORPH_SMOOTH = 0xB015;
var BOUNDBOX = 0xB014;
var POS_TRACK_TAG = 0xB020;
var COL_TRACK_TAG = 0xB025;
var ROT_TRACK_TAG = 0xB021;
var SCL_TRACK_TAG = 0xB022;
var MORPH_TRACK_TAG = 0xB026;
var FOV_TRACK_TAG = 0xB023;
var ROLL_TRACK_TAG = 0xB024;
var HOT_TRACK_TAG = 0xB027;
var FALL_TRACK_TAG = 0xB028;
var HIDE_TRACK_TAG = 0xB029;
var POLY_2D = 0x5000;
var SHAPE_OK = 0x5010;
var SHAPE_NOT_OK = 0x5011;
var SHAPE_HOOK = 0x5020;
var PATH_3D = 0x6000;
var PATH_MATRIX = 0x6005;
var SHAPE_2D = 0x6010;
var M_SCALE = 0x6020;
var M_TWIST = 0x6030;
var M_TEETER = 0x6040;
var M_FIT = 0x6050;
var M_BEVEL = 0x6060;
var XZ_CURVE = 0x6070;
var YZ_CURVE = 0x6080;
var INTERPCT = 0x6090;
var DEFORM_LIMIT = 0x60A0;
var USE_CONTOUR = 0x6100;
var USE_TWEEN = 0x6110;
var USE_SCALE = 0x6120;
var USE_TWIST = 0x6130;
var USE_TEETER = 0x6140;
var USE_FIT = 0x6150;
var USE_BEVEL = 0x6160;
var DEFAULT_VIEW = 0x3000;
var VIEW_TOP = 0x3010;
var VIEW_BOTTOM = 0x3020;
var VIEW_LEFT = 0x3030;
var VIEW_RIGHT = 0x3040;
var VIEW_FRONT = 0x3050;
var VIEW_BACK = 0x3060;
var VIEW_USER = 0x3070;
var VIEW_CAMERA = 0x3080;
var VIEW_WINDOW = 0x3090;
var VIEWPORT_LAYOUT_OLD = 0x7000;
var VIEWPORT_DATA_OLD = 0x7010;
var VIEWPORT_LAYOUT = 0x7001;
var VIEWPORT_DATA = 0x7011;
var VIEWPORT_DATA_3 = 0x7012;
var VIEWPORT_SIZE = 0x7020;
var NETWORK_VIEW = 0x7030;

/**
 * Loader for UTF8 version2 (after r51) encoded models generated by:
 *  http://code.google.com/p/webgl-loader/
 *
 * Code to load/decompress mesh is taken from r100 of this webgl-loader
 */

THREE.UTF8Loader = function () {};

/**
 * Load UTF8 encoded model
 * @param jsonUrl - URL from which to load json containing information about model
 * @param callback - Callback(THREE.Object3D) on successful loading of model
 * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)
 *                  Additional options include
 *                   geometryBase: Base url from which to load referenced geometries
 *                   materialBase: Base url from which to load referenced textures
 */

THREE.UTF8Loader.prototype.load = function ( jsonUrl, callback, options ) {

  this.downloadModelJson( jsonUrl, callback, options );

};

// BufferGeometryCreator

THREE.UTF8Loader.BufferGeometryCreator = function () {
};

THREE.UTF8Loader.BufferGeometryCreator.prototype.create = function ( attribArray, indices ) {

  var ntris = indices.length / 3;

  var geometry = new THREE.BufferGeometry();

  var positions = new Float32Array( ntris * 3 * 3 );
  var normals = new Float32Array( ntris * 3 * 3 );
  var uvs = new Float32Array( ntris * 3 * 2 );

  var i, j, offset;

  var end = attribArray.length;
  var stride = 8;

  // extract positions

  j = 0;
  offset = 0;

  for ( i = offset; i < end; i += stride ) {

    positions[ j ++ ] = attribArray[ i ];
    positions[ j ++ ] = attribArray[ i + 1 ];
    positions[ j ++ ] = attribArray[ i + 2 ];

  }

  // extract uvs

  j = 0;
  offset = 3;

  for ( i = offset; i < end; i += stride ) {

    uvs[ j ++ ] = attribArray[ i ];
    uvs[ j ++ ] = attribArray[ i + 1 ];

  }

  // extract normals

  j = 0;
  offset = 5;

  for ( i = offset; i < end; i += stride ) {

    normals[ j ++ ] = attribArray[ i ];
    normals[ j ++ ] = attribArray[ i + 1 ];
    normals[ j ++ ] = attribArray[ i + 2 ];

  }

  geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
  geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  geometry.computeBoundingSphere();

  return geometry;

};


// UTF-8 decoder from webgl-loader (r100)
// http://code.google.com/p/webgl-loader/

// Model manifest description. Contains objects like:
// name: {
//   materials: { 'material_name': { ... } ... },
//   decodeParams: {
//     decodeOffsets: [ ... ],
//     decodeScales: [ ... ],
//   },
//   urls: {
//     'url': [
//       { material: 'material_name',
//         attribRange: [#, #],
//         indexRange: [#, #],
//         names: [ 'object names' ... ],
//         lengths: [#, #, # ... ]
//       }
//     ],
//     ...
//   }
// }

var DEFAULT_DECODE_PARAMS = {

  decodeOffsets: [ - 4095, - 4095, - 4095, 0, 0, - 511, - 511, - 511 ],
  decodeScales: [ 1 / 8191, 1 / 8191, 1 / 8191, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023 ]

  // TODO: normal decoding? (see walt.js)
  // needs to know: input, output (from vertex format!)
  //
  // Should split attrib/index.
  // 1) Decode position and non-normal attributes.
  // 2) Decode indices, computing normals
  // 3) Maybe normalize normals? Only necessary for refinement, or fixed?
  // 4) Maybe refine normals? Should this be part of regular refinement?
  // 5) Morphing

};

// Triangle strips!

// TODO: will it be an optimization to specialize this method at
// runtime for different combinations of stride, decodeOffset and
// decodeScale?

THREE.UTF8Loader.prototype.decompressAttribsInner_ = function ( str, inputStart, inputEnd,
  output, outputStart, stride, decodeOffset, decodeScale ) {

  var prev = 0;

  for ( var j = inputStart; j < inputEnd; j ++ ) {

    var code = str.charCodeAt( j );
    prev += ( code >> 1 ) ^ ( - ( code & 1 ) );

    output[ outputStart ] = decodeScale * ( prev + decodeOffset );
    outputStart += stride;

  }

};

THREE.UTF8Loader.prototype.decompressIndices_ = function ( str, inputStart, numIndices, output, outputStart ) {

  var highest = 0;

  for ( var i = 0; i < numIndices; i ++ ) {

    var code = str.charCodeAt( inputStart ++ );

    output[ outputStart ++ ] = highest - code;

    if ( code === 0 ) {

      highest ++;

    }

  }

};

THREE.UTF8Loader.prototype.decompressAABBs_ = function ( str, inputStart, numBBoxen, decodeOffsets, decodeScales ) {

  var numFloats = 6 * numBBoxen;

  var inputEnd = inputStart + numFloats;
  var outputStart = 0;

  var bboxen = new Float32Array( numFloats );

  for ( var i = inputStart; i < inputEnd; i += 6 ) {

    var minX = str.charCodeAt( i + 0 ) + decodeOffsets[ 0 ];
    var minY = str.charCodeAt( i + 1 ) + decodeOffsets[ 1 ];
    var minZ = str.charCodeAt( i + 2 ) + decodeOffsets[ 2 ];

    var radiusX = ( str.charCodeAt( i + 3 ) + 1 ) >> 1;
    var radiusY = ( str.charCodeAt( i + 4 ) + 1 ) >> 1;
    var radiusZ = ( str.charCodeAt( i + 5 ) + 1 ) >> 1;

    bboxen[ outputStart ++ ] = decodeScales[ 0 ] * ( minX + radiusX );
    bboxen[ outputStart ++ ] = decodeScales[ 1 ] * ( minY + radiusY );
    bboxen[ outputStart ++ ] = decodeScales[ 2 ] * ( minZ + radiusZ );

    bboxen[ outputStart ++ ] = decodeScales[ 0 ] * radiusX;
    bboxen[ outputStart ++ ] = decodeScales[ 1 ] * radiusY;
    bboxen[ outputStart ++ ] = decodeScales[ 2 ] * radiusZ;

  }

  return bboxen;

};

THREE.UTF8Loader.prototype.decompressMesh = function ( str, meshParams, decodeParams, name, idx, callback ) {

  // Extract conversion parameters from attribArrays.

  var stride = decodeParams.decodeScales.length;

  var decodeOffsets = decodeParams.decodeOffsets;
  var decodeScales = decodeParams.decodeScales;

  var attribStart = meshParams.attribRange[ 0 ];
  var numVerts = meshParams.attribRange[ 1 ];

  // Decode attributes.

  var inputOffset = attribStart;
  var attribsOut = new Float32Array( stride * numVerts );

  for ( var j = 0; j < stride; j ++ ) {

    var end = inputOffset + numVerts;

    var decodeScale = decodeScales[ j ];

    if ( decodeScale ) {

      // Assume if decodeScale is never set, simply ignore the
      // attribute.

      this.decompressAttribsInner_( str, inputOffset, end, attribsOut, j, stride, decodeOffsets[ j ], decodeScale );

    }

    inputOffset = end;

  }

  var numIndices = 3 * meshParams.indexRange[ 1 ];

  var indicesOut = new Uint16Array( numIndices );

  this.decompressIndices_( str, inputOffset, numIndices, indicesOut, 0 );

  // Decode bboxen.

  var bboxen = undefined;
  var bboxOffset = meshParams.bboxes;

  if ( bboxOffset ) {

    bboxen = this.decompressAABBs_( str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales );

  }

  callback( name, idx, attribsOut, indicesOut, bboxen, meshParams );

};

THREE.UTF8Loader.prototype.copyAttrib = function ( stride, attribsOutFixed, lastAttrib, index ) {

  for ( var j = 0; j < stride; j ++ ) {

    lastAttrib[ j ] = attribsOutFixed[ stride * index + j ];

  }

};

THREE.UTF8Loader.prototype.decodeAttrib2 = function ( str, stride, decodeOffsets, decodeScales, deltaStart,
  numVerts, attribsOut, attribsOutFixed, lastAttrib, index ) {

  for ( var j = 0; j < 5; j ++ ) {

    var code = str.charCodeAt( deltaStart + numVerts * j + index );
    var delta = ( code >> 1 ) ^ ( - ( code & 1 ) );

    lastAttrib[ j ] += delta;
    attribsOutFixed[ stride * index + j ] = lastAttrib[ j ];
    attribsOut[ stride * index + j ] = decodeScales[ j ] * ( lastAttrib[ j ] + decodeOffsets[ j ] );

  }

};

THREE.UTF8Loader.prototype.accumulateNormal = function ( i0, i1, i2, attribsOutFixed, crosses ) {

  var p0x = attribsOutFixed[ 8 * i0 ];
  var p0y = attribsOutFixed[ 8 * i0 + 1 ];
  var p0z = attribsOutFixed[ 8 * i0 + 2 ];

  var p1x = attribsOutFixed[ 8 * i1 ];
  var p1y = attribsOutFixed[ 8 * i1 + 1 ];
  var p1z = attribsOutFixed[ 8 * i1 + 2 ];

  var p2x = attribsOutFixed[ 8 * i2 ];
  var p2y = attribsOutFixed[ 8 * i2 + 1 ];
  var p2z = attribsOutFixed[ 8 * i2 + 2 ];

  p1x -= p0x;
  p1y -= p0y;
  p1z -= p0z;

  p2x -= p0x;
  p2y -= p0y;
  p2z -= p0z;

  p0x = p1y * p2z - p1z * p2y;
  p0y = p1z * p2x - p1x * p2z;
  p0z = p1x * p2y - p1y * p2x;

  crosses[ 3 * i0 ] += p0x;
  crosses[ 3 * i0 + 1 ] += p0y;
  crosses[ 3 * i0 + 2 ] += p0z;

  crosses[ 3 * i1 ] += p0x;
  crosses[ 3 * i1 + 1 ] += p0y;
  crosses[ 3 * i1 + 2 ] += p0z;

  crosses[ 3 * i2 ] += p0x;
  crosses[ 3 * i2 + 1 ] += p0y;
  crosses[ 3 * i2 + 2 ] += p0z;

};

THREE.UTF8Loader.prototype.decompressMesh2 = function ( str, meshParams, decodeParams, name, idx, callback ) {

  var MAX_BACKREF = 96;

  // Extract conversion parameters from attribArrays.

  var stride = decodeParams.decodeScales.length;

  var decodeOffsets = decodeParams.decodeOffsets;
  var decodeScales = decodeParams.decodeScales;

  var deltaStart = meshParams.attribRange[ 0 ];
  var numVerts = meshParams.attribRange[ 1 ];

  var codeStart = meshParams.codeRange[ 0 ];

  var numIndices = 3 * meshParams.codeRange[ 2 ];

  var indicesOut = new Uint16Array( numIndices );

  var crosses = new Int32Array( 3 * numVerts );

  var lastAttrib = new Uint16Array( stride );

  var attribsOutFixed = new Uint16Array( stride * numVerts );
  var attribsOut = new Float32Array( stride * numVerts );

  var highest = 0;
  var outputStart = 0;

  for ( var i = 0; i < numIndices; i += 3 ) {

    var code = str.charCodeAt( codeStart ++ );

    var max_backref = Math.min( i, MAX_BACKREF );

    if ( code < max_backref ) {

      // Parallelogram

      var winding = code % 3;
      var backref = i - ( code - winding );
      var i0, i1, i2;

      switch ( winding ) {

        case 0:

          i0 = indicesOut[ backref + 2 ];
          i1 = indicesOut[ backref + 1 ];
          i2 = indicesOut[ backref + 0 ];
          break;

        case 1:

          i0 = indicesOut[ backref + 0 ];
          i1 = indicesOut[ backref + 2 ];
          i2 = indicesOut[ backref + 1 ];
          break;

        case 2:

          i0 = indicesOut[ backref + 1 ];
          i1 = indicesOut[ backref + 0 ];
          i2 = indicesOut[ backref + 2 ];
          break;

      }

      indicesOut[ outputStart ++ ] = i0;
      indicesOut[ outputStart ++ ] = i1;

      code = str.charCodeAt( codeStart ++ );

      var index = highest - code;
      indicesOut[ outputStart ++ ] = index;

      if ( code === 0 ) {

        for ( var j = 0; j < 5; j ++ ) {

          var deltaCode = str.charCodeAt( deltaStart + numVerts * j + highest );

          var prediction = ( ( deltaCode >> 1 ) ^ ( - ( deltaCode & 1 ) ) ) +
            attribsOutFixed[ stride * i0 + j ] +
            attribsOutFixed[ stride * i1 + j ] -
            attribsOutFixed[ stride * i2 + j ];

          lastAttrib[ j ] = prediction;

          attribsOutFixed[ stride * highest + j ] = prediction;
          attribsOut[ stride * highest + j ] = decodeScales[ j ] * ( prediction + decodeOffsets[ j ] );

        }

        highest ++;

      } else {

        this.copyAttrib( stride, attribsOutFixed, lastAttrib, index );

      }

      this.accumulateNormal( i0, i1, index, attribsOutFixed, crosses );

    } else {

      // Simple

      var index0 = highest - ( code - max_backref );

      indicesOut[ outputStart ++ ] = index0;

      if ( code === max_backref ) {

        this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,
          numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );

      } else {

        this.copyAttrib( stride, attribsOutFixed, lastAttrib, index0 );

      }

      code = str.charCodeAt( codeStart ++ );

      var index1 = highest - code;
      indicesOut[ outputStart ++ ] = index1;

      if ( code === 0 ) {

        this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,
          numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );

      } else {

        this.copyAttrib( stride, attribsOutFixed, lastAttrib, index1 );

      }

      code = str.charCodeAt( codeStart ++ );

      var index2 = highest - code;
      indicesOut[ outputStart ++ ] = index2;

      if ( code === 0 ) {

        for ( var j = 0; j < 5; j ++ ) {

          lastAttrib[ j ] = ( attribsOutFixed[ stride * index0 + j ] + attribsOutFixed[ stride * index1 + j ] ) / 2;

        }

        this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,
          numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );

      } else {

        this.copyAttrib( stride, attribsOutFixed, lastAttrib, index2 );

      }

      this.accumulateNormal( index0, index1, index2, attribsOutFixed, crosses );

    }

  }

  for ( var i = 0; i < numVerts; i ++ ) {

    var nx = crosses[ 3 * i ];
    var ny = crosses[ 3 * i + 1 ];
    var nz = crosses[ 3 * i + 2 ];

    var norm = 511.0 / Math.sqrt( nx * nx + ny * ny + nz * nz );

    var cx = str.charCodeAt( deltaStart + 5 * numVerts + i );
    var cy = str.charCodeAt( deltaStart + 6 * numVerts + i );
    var cz = str.charCodeAt( deltaStart + 7 * numVerts + i );

    attribsOut[ stride * i + 5 ] = norm * nx + ( ( cx >> 1 ) ^ ( - ( cx & 1 ) ) );
    attribsOut[ stride * i + 6 ] = norm * ny + ( ( cy >> 1 ) ^ ( - ( cy & 1 ) ) );
    attribsOut[ stride * i + 7 ] = norm * nz + ( ( cz >> 1 ) ^ ( - ( cz & 1 ) ) );

  }

  callback( name, idx, attribsOut, indicesOut, undefined, meshParams );

};

THREE.UTF8Loader.prototype.downloadMesh = function ( path, name, meshEntry, decodeParams, callback ) {

  var loader = this;
  var idx = 0;

  function onprogress( data ) {

    while ( idx < meshEntry.length ) {

      var meshParams = meshEntry[ idx ];
      var indexRange = meshParams.indexRange;

      if ( indexRange ) {

        var meshEnd = indexRange[ 0 ] + 3 * indexRange[ 1 ];

        if ( data.length < meshEnd ) break;

        loader.decompressMesh( data, meshParams, decodeParams, name, idx, callback );

      } else {

        var codeRange = meshParams.codeRange;
        var meshEnd = codeRange[ 0 ] + codeRange[ 1 ];

        if ( data.length < meshEnd ) break;

        loader.decompressMesh2( data, meshParams, decodeParams, name, idx, callback );

      }

      ++ idx;

    }

  }

  getHttpRequest( path, function ( data ) {

    onprogress( data );

    // TODO: handle errors.

  } );

};

THREE.UTF8Loader.prototype.downloadMeshes = function ( path, meshUrlMap, decodeParams, callback ) {

  for ( var url in meshUrlMap ) {

    var meshEntry = meshUrlMap[ url ];
    this.downloadMesh( path + url, url, meshEntry, decodeParams, callback );

  }

};

THREE.UTF8Loader.prototype.createMeshCallback = function ( materialBaseUrl, loadModelInfo, allDoneCallback ) {

  var nCompletedUrls = 0;
  var nExpectedUrls = 0;

  var expectedMeshesPerUrl = {};
  var decodedMeshesPerUrl = {};

  var modelParts = {};

  var meshUrlMap = loadModelInfo.urls;

  for ( var url in meshUrlMap ) {

    expectedMeshesPerUrl[ url ] = meshUrlMap[ url ].length;
    decodedMeshesPerUrl[ url ] = 0;

    nExpectedUrls ++;

    modelParts[ url ] = new THREE.Object3D();

  }

  var model = new THREE.Object3D();

  // Prepare materials first...

  var materialCreator = new THREE.MTLLoader.MaterialCreator( materialBaseUrl, loadModelInfo.options );
  materialCreator.setMaterials( loadModelInfo.materials );

  materialCreator.preload();

  // Create callback for creating mesh parts

  var bufferGeometryCreator = new THREE.UTF8Loader.BufferGeometryCreator();

  var meshCallback = function ( name, idx, attribArray, indexArray, bboxen, meshParams ) {

    // Got ourselves a new mesh

    // name identifies this part of the model (url)
    // idx is the mesh index of this mesh of the part
    // attribArray defines the vertices
    // indexArray defines the faces
    // bboxen defines the bounding box
    // meshParams contains the material info

    var geometry = bufferGeometryCreator.create( attribArray, indexArray );
    var material = materialCreator.create( meshParams.material );

    var mesh = new THREE.Mesh( geometry, material );
    modelParts[ name ].add( mesh );

    //model.add(new THREE.Mesh(geometry, material));

    decodedMeshesPerUrl[ name ] ++;

    if ( decodedMeshesPerUrl[ name ] === expectedMeshesPerUrl[ name ] ) {

      nCompletedUrls ++;

      model.add( modelParts[ name ] );

      if ( nCompletedUrls === nExpectedUrls ) {

        // ALL DONE!!!

        allDoneCallback( model );

      }

    }

  };

  return meshCallback;

};

THREE.UTF8Loader.prototype.downloadModel = function ( geometryBase, materialBase, model, callback ) {

  var meshCallback = this.createMeshCallback( materialBase, model, callback );
  this.downloadMeshes( geometryBase, model.urls, model.decodeParams, meshCallback );

};

THREE.UTF8Loader.prototype.downloadModelJson = function ( jsonUrl, callback, options ) {

  getJsonRequest( jsonUrl, function ( loaded ) {

    if ( ! loaded.decodeParams ) {

      if ( options && options.decodeParams ) {

        loaded.decodeParams = options.decodeParams;

      } else {

        loaded.decodeParams = DEFAULT_DECODE_PARAMS;

      }

    }

    loaded.options = options;

    var geometryBase = jsonUrl.substr( 0, jsonUrl.lastIndexOf( "/" ) + 1 );
    var materialBase = geometryBase;

    if ( options && options.geometryBase ) {

      geometryBase = options.geometryBase;

      if ( geometryBase.charAt( geometryBase.length - 1 ) !== "/" ) {

        geometryBase = geometryBase + "/";

      }

    }

    if ( options && options.materialBase ) {

      materialBase = options.materialBase;

      if ( materialBase.charAt( materialBase.length - 1 ) !== "/" ) {

        materialBase = materialBase + "/";

      }

    }

    this.downloadModel( geometryBase, materialBase, loaded, callback );

  }.bind( this ) );

};

// XMLHttpRequest stuff

function getHttpRequest( url, onload, opt_onprogress ) {

  var req = new THREE.FileLoader();
  req.load( url, onload, opt_onprogress );

}

function getJsonRequest( url, onjson ) {

  getHttpRequest( url, function ( e ) {

    onjson( JSON.parse( e ) );

  },
  function () {} );

}

function addListeners( dom, listeners ) {

  // TODO: handle event capture, object binding.

  for ( var key in listeners ) {

    dom.addEventListener( key, listeners[ key ] );

  }

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VRMLLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.VRMLLoader.prototype = {

  constructor: THREE.VRMLLoader,

  // for IndexedFaceSet support
  isRecordingPoints: false,
  isRecordingFaces: false,
  points: [],
  indexes: [],

  // for Background support
  isRecordingAngles: false,
  isRecordingColors: false,
  angles: [],
  colors: [],

  recordingFieldname: null,

  crossOrigin: 'Anonymous',

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( this.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( data ) {

    var texturePath = this.texturePath || '';

    var textureLoader = new THREE.TextureLoader( this.manager );
    textureLoader.setCrossOrigin( this.crossOrigin );

    function parseV1() {

      console.warn( 'THREE.VRMLLoader: V1.0 not supported yet.' );

    }

    function parseV2( lines, scene ) {

      var defines = {};
      var float_pattern = /(\b|\-|\+)([\d\.e]+)/;
      var float2_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;
      var float3_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;

      /**
       * Vertically paints the faces interpolating between the
       * specified colors at the specified angels. This is used for the Background
       * node, but could be applied to other nodes with multiple faces as well.
       *
       * When used with the Background node, default is directionIsDown is true if
       * interpolating the skyColor down from the Zenith. When interpolationg up from
       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.
       *
       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified
       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation
       * is linear along the Y axis in any case.
       *
       * You must specify one more color than you have angles at the beginning of the colors array.
       * This is the color of the Zenith (the top of the shape).
       *
       * @param geometry
       * @param radius
       * @param angles
       * @param colors
       * @param boolean topDown Whether to work top down or bottom up.
       */
      function paintFaces( geometry, radius, angles, colors, topDown ) {

        var direction = ( topDown === true ) ? 1 : - 1;

        var coord = [], A = {}, B = {}, applyColor = false;

        for ( var k = 0; k < angles.length; k ++ ) {

          // push the vector at which the color changes

          var vec = {
            x: direction * ( Math.cos( angles[ k ] ) * radius ),
            y: direction * ( Math.sin( angles[ k ] ) * radius )
          };

          coord.push( vec );

        }

        var index = geometry.index;
        var positionAttribute = geometry.attributes.position;
        var colorAttribute = new THREE.BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );

        var position = new THREE.Vector3();
        var color = new THREE.Color();

        for ( var i = 0; i < index.count; i ++ ) {

          var vertexIndex = index.getX( i );

          position.fromBufferAttribute( positionAttribute, vertexIndex );

          for ( var j = 0; j < colors.length; j ++ ) {

            // linear interpolation between aColor and bColor, calculate proportion
            // A is previous point (angle)

            if ( j === 0 ) {

              A.x = 0;
              A.y = ( topDown === true ) ? radius : - 1 * radius;

            } else {

              A.x = coord[ j - 1 ].x;
              A.y = coord[ j - 1 ].y;

            }

            // B is current point (angle)

            B = coord[ j ];

            if ( B !== undefined ) {

              // p has to be between the points A and B which we interpolate

              applyColor = ( topDown === true ) ? ( position.y <= A.y && position.y > B.y ) : ( position.y >= A.y && position.y < B.y );

              if ( applyColor === true ) {

                var aColor = colors[ j ];
                var bColor = colors[ j + 1 ];

                // below is simple linear interpolation

                var t = Math.abs( position.y - A.y ) / ( A.y - B.y );

                // to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y

                color.copy( aColor ).lerp( bColor, t );

                colorAttribute.setXYZ( vertexIndex, color.r, color.g, color.b );

              } else {

                var colorIndex = ( topDown === true ) ? colors.length - 1 : 0;
                var c = colors[ colorIndex ];
                colorAttribute.setXYZ( vertexIndex, c.r, c.g, c.b );

              }

            }

          }

        }

        geometry.addAttribute( 'color', colorAttribute );

      }

      var index = [];

      function parseProperty( node, line ) {

        var parts = [], part, property = {}, fieldName;

        /**
         * Expression for matching relevant information, such as a name or value, but not the separators
         * @type {RegExp}
         */
        var regex = /[^\s,\[\]]+/g;

        var point;

        while ( null !== ( part = regex.exec( line ) ) ) {

          parts.push( part[ 0 ] );

        }

        fieldName = parts[ 0 ];


        // trigger several recorders
        switch ( fieldName ) {

          case 'skyAngle':
          case 'groundAngle':
            this.recordingFieldname = fieldName;
            this.isRecordingAngles = true;
            this.angles = [];
            break;

          case 'skyColor':
          case 'groundColor':
            this.recordingFieldname = fieldName;
            this.isRecordingColors = true;
            this.colors = [];
            break;

          case 'point':
            this.recordingFieldname = fieldName;
            this.isRecordingPoints = true;
            this.points = [];
            break;

          case 'coordIndex':
          case 'texCoordIndex':
            this.recordingFieldname = fieldName;
            this.isRecordingFaces = true;
            this.indexes = [];
            break;

        }

        if ( this.isRecordingFaces ) {

          // the parts hold the indexes as strings
          if ( parts.length > 0 ) {

            for ( var ind = 0; ind < parts.length; ind ++ ) {

              // the part should either be positive integer or -1
              if ( ! /(-?\d+)/.test( parts[ ind ] ) ) {

                continue;

              }

              // end of current face
              if ( parts[ ind ] === '-1' ) {

                if ( index.length > 0 ) {

                  this.indexes.push( index );

                }

                // start new one
                index = [];

              } else {

                index.push( parseInt( parts[ ind ] ) );

              }

            }

          }

          // end
          if ( /]/.exec( line ) ) {

            if ( index.length > 0 ) {

              this.indexes.push( index );

            }

            // start new one
            index = [];

            this.isRecordingFaces = false;
            node[ this.recordingFieldname ] = this.indexes;

          }

        } else if ( this.isRecordingPoints ) {

          if ( node.nodeType == 'Coordinate' ) {

            while ( null !== ( parts = float3_pattern.exec( line ) ) ) {

              point = {
                x: parseFloat( parts[ 1 ] ),
                y: parseFloat( parts[ 2 ] ),
                z: parseFloat( parts[ 3 ] )
              };

              this.points.push( point );

            }

          }

          if ( node.nodeType == 'TextureCoordinate' ) {

            while ( null !== ( parts = float2_pattern.exec( line ) ) ) {

              point = {
                x: parseFloat( parts[ 1 ] ),
                y: parseFloat( parts[ 2 ] )
              };

              this.points.push( point );

            }

          }

          // end
          if ( /]/.exec( line ) ) {

            this.isRecordingPoints = false;
            node.points = this.points;

          }

        } else if ( this.isRecordingAngles ) {

          // the parts hold the angles as strings
          if ( parts.length > 0 ) {

            for ( var ind = 0; ind < parts.length; ind ++ ) {

              // the part should be a float
              if ( ! float_pattern.test( parts[ ind ] ) ) {

                continue;

              }

              this.angles.push( parseFloat( parts[ ind ] ) );

            }

          }

          // end
          if ( /]/.exec( line ) ) {

            this.isRecordingAngles = false;
            node[ this.recordingFieldname ] = this.angles;

          }

        } else if ( this.isRecordingColors ) {

          while ( null !== ( parts = float3_pattern.exec( line ) ) ) {

            var color = {
              r: parseFloat( parts[ 1 ] ),
              g: parseFloat( parts[ 2 ] ),
              b: parseFloat( parts[ 3 ] )
            };

            this.colors.push( color );

          }

          // end
          if ( /]/.exec( line ) ) {

            this.isRecordingColors = false;
            node[ this.recordingFieldname ] = this.colors;

          }

        } else if ( parts[ parts.length - 1 ] !== 'NULL' && fieldName !== 'children' ) {

          switch ( fieldName ) {

            case 'diffuseColor':
            case 'emissiveColor':
            case 'specularColor':
            case 'color':

              if ( parts.length !== 4 ) {

                console.warn( 'THREE.VRMLLoader: Invalid color format detected for %s.', fieldName );
                break;

              }

              property = {
                r: parseFloat( parts[ 1 ] ),
                g: parseFloat( parts[ 2 ] ),
                b: parseFloat( parts[ 3 ] )
              };

              break;

            case 'location':
            case 'direction':
            case 'translation':
            case 'scale':
            case 'size':
              if ( parts.length !== 4 ) {

                console.warn( 'THREE.VRMLLoader: Invalid vector format detected for %s.', fieldName );
                break;

              }

              property = {
                x: parseFloat( parts[ 1 ] ),
                y: parseFloat( parts[ 2 ] ),
                z: parseFloat( parts[ 3 ] )
              };

              break;

            case 'intensity':
            case 'cutOffAngle':
            case 'radius':
            case 'topRadius':
            case 'bottomRadius':
            case 'height':
            case 'transparency':
            case 'shininess':
            case 'ambientIntensity':
              if ( parts.length !== 2 ) {

                console.warn( 'THREE.VRMLLoader: Invalid single float value specification detected for %s.', fieldName );
                break;

              }

              property = parseFloat( parts[ 1 ] );

              break;

            case 'rotation':
              if ( parts.length !== 5 ) {

                console.warn( 'THREE.VRMLLoader: Invalid quaternion format detected for %s.', fieldName );
                break;

              }

              property = {
                x: parseFloat( parts[ 1 ] ),
                y: parseFloat( parts[ 2 ] ),
                z: parseFloat( parts[ 3 ] ),
                w: parseFloat( parts[ 4 ] )
              };

              break;

            case 'on':
            case 'ccw':
            case 'solid':
            case 'colorPerVertex':
            case 'convex':
              if ( parts.length !== 2 ) {

                console.warn( 'THREE.VRMLLoader: Invalid format detected for %s.', fieldName );
                break;

              }

              property = parts[ 1 ] === 'TRUE' ? true : false;

              break;

          }

          node[ fieldName ] = property;

        }

        return property;

      }

      function getTree( lines ) {

        var tree = { 'string': 'Scene', children: [] };
        var current = tree;
        var matches;
        var specification;

        for ( var i = 0; i < lines.length; i ++ ) {

          var comment = '';

          var line = lines[ i ];

          // omit whitespace only lines
          if ( null !== ( /^\s+?$/g.exec( line ) ) ) {

            continue;

          }

          line = line.trim();

          // skip empty lines
          if ( line === '' ) {

            continue;

          }

          if ( /#/.exec( line ) ) {

            var parts = line.split( '#' );

            // discard everything after the #, it is a comment
            line = parts[ 0 ];

            // well, let's also keep the comment
            comment = parts[ 1 ];

          }

          if ( matches = /([^\s]*){1}(?:\s+)?{/.exec( line ) ) {

            // first subpattern should match the Node name

            var block = { 'nodeType': matches[ 1 ], 'string': line, 'parent': current, 'children': [], 'comment': comment };
            current.children.push( block );
            current = block;

            if ( /}/.exec( line ) ) {

              // example: geometry Box { size 1 1 1 } # all on the same line
              specification = /{(.*)}/.exec( line )[ 1 ];

              // todo: remove once new parsing is complete?
              block.children.push( specification );

              parseProperty( current, specification );

              current = current.parent;

            }

          } else if ( /}/.exec( line ) ) {

            current = current.parent;

          } else if ( line !== '' ) {

            parseProperty( current, line );
            // todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way
            current.children.push( line );

          }

        }

        return tree;

      }

      function parseNode( data, parent ) {

        var object;

        if ( typeof data === 'string' ) {

          if ( /USE/.exec( data ) ) {

            var defineKey = /USE\s+?([^\s]+)/.exec( data )[ 1 ];

            if ( undefined == defines[ defineKey ] ) {

              console.warn( 'THREE.VRMLLoader: %s is not defined.', defineKey );

            } else {

              if ( /appearance/.exec( data ) && defineKey ) {

                parent.material = defines[ defineKey ].clone();

              } else if ( /geometry/.exec( data ) && defineKey ) {

                parent.geometry = defines[ defineKey ].clone();

                // the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it
                if ( undefined !== defines[ defineKey ].solid && defines[ defineKey ].solid === false ) {

                  parent.geometry.solid = false;
                  parent.material.side = THREE.DoubleSide;

                }

              } else if ( defineKey ) {

                object = defines[ defineKey ].clone();
                parent.add( object );

              }

            }

          }

          return;

        }

        object = parent;

        if ( data.string.indexOf( 'AmbientLight' ) > - 1 && data.nodeType === 'PointLight' ) {

          data.nodeType = 'AmbientLight';

        }

        var l_visible = data.on !== undefined ? data.on : true;
        var l_intensity = data.intensity !== undefined ? data.intensity : 1;
        var l_color = new THREE.Color();

        if ( data.color ) {

          l_color.copy( data.color );

        }

        if ( data.nodeType === 'AmbientLight' ) {

          object = new THREE.AmbientLight( l_color, l_intensity );
          object.visible = l_visible;

          parent.add( object );

        } else if ( data.nodeType === 'PointLight' ) {

          var l_distance = 0;

          if ( data.radius !== undefined && data.radius < 1000 ) {

            l_distance = data.radius;

          }

          object = new THREE.PointLight( l_color, l_intensity, l_distance );
          object.visible = l_visible;

          parent.add( object );

        } else if ( data.nodeType === 'SpotLight' ) {

          var l_intensity = 1;
          var l_distance = 0;
          var l_angle = Math.PI / 3;
          var l_penumbra = 0;
          var l_visible = true;

          if ( data.radius !== undefined && data.radius < 1000 ) {

            l_distance = data.radius;

          }

          if ( data.cutOffAngle !== undefined ) {

            l_angle = data.cutOffAngle;

          }

          object = new THREE.SpotLight( l_color, l_intensity, l_distance, l_angle, l_penumbra );
          object.visible = l_visible;

          parent.add( object );

        } else if ( data.nodeType === 'Transform' || data.nodeType === 'Group' ) {

          object = new THREE.Object3D();

          if ( /DEF/.exec( data.string ) ) {

            object.name = /DEF\s+([^\s]+)/.exec( data.string )[ 1 ];
            defines[ object.name ] = object;

          }

          if ( data.translation !== undefined ) {

            var t = data.translation;

            object.position.set( t.x, t.y, t.z );

          }

          if ( data.rotation !== undefined ) {

            var r = data.rotation;

            object.quaternion.setFromAxisAngle( new THREE.Vector3( r.x, r.y, r.z ), r.w );

          }

          if ( data.scale !== undefined ) {

            var s = data.scale;

            object.scale.set( s.x, s.y, s.z );

          }

          parent.add( object );

        } else if ( data.nodeType === 'Shape' ) {

          object = new THREE.Mesh();

          if ( /DEF/.exec( data.string ) ) {

            object.name = /DEF\s+([^\s]+)/.exec( data.string )[ 1 ];

            defines[ object.name ] = object;

          }

          parent.add( object );

        } else if ( data.nodeType === 'Background' ) {

          var segments = 20;

          // sky (full sphere):

          var radius = 2e4;

          var skyGeometry = new THREE.SphereBufferGeometry( radius, segments, segments );
          var skyMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide } );

          if ( data.skyColor.length > 1 ) {

            paintFaces( skyGeometry, radius, data.skyAngle, data.skyColor, true );

            skyMaterial.vertexColors = THREE.VertexColors;

          } else {

            var color = data.skyColor[ 0 ];
            skyMaterial.color.setRGB( color.r, color.b, color.g );

          }

          scene.add( new THREE.Mesh( skyGeometry, skyMaterial ) );

          // ground (half sphere):

          if ( data.groundColor !== undefined ) {

            radius = 1.2e4;

            var groundGeometry = new THREE.SphereBufferGeometry( radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );
            var groundMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide, vertexColors: THREE.VertexColors } );

            paintFaces( groundGeometry, radius, data.groundAngle, data.groundColor, false );

            scene.add( new THREE.Mesh( groundGeometry, groundMaterial ) );

          }

        } else if ( /geometry/.exec( data.string ) ) {

          if ( data.nodeType === 'Box' ) {

            var s = data.size;

            parent.geometry = new THREE.BoxBufferGeometry( s.x, s.y, s.z );

          } else if ( data.nodeType === 'Cylinder' ) {

            parent.geometry = new THREE.CylinderBufferGeometry( data.radius, data.radius, data.height );

          } else if ( data.nodeType === 'Cone' ) {

            parent.geometry = new THREE.CylinderBufferGeometry( data.topRadius, data.bottomRadius, data.height );

          } else if ( data.nodeType === 'Sphere' ) {

            parent.geometry = new THREE.SphereBufferGeometry( data.radius );

          } else if ( data.nodeType === 'IndexedFaceSet' ) {

            var geometry = new THREE.BufferGeometry();

            var positions = [];
            var uvs = [];

            var position, uv;

            var i, il, j, jl;

            for ( i = 0, il = data.children.length; i < il; i ++ ) {

              var child = data.children[ i ];

              // uvs

              if ( child.nodeType === 'TextureCoordinate' ) {

                if ( child.points ) {

                  for ( j = 0, jl = child.points.length; j < jl; j ++ ) {

                    uv = child.points[ j ];
                    uvs.push( uv.x, uv.y );

                  }

                }

              }

              // positions

              if ( child.nodeType === 'Coordinate' ) {

                if ( child.points ) {

                  for ( j = 0, jl = child.points.length; j < jl; j ++ ) {

                    position = child.points[ j ];
                    positions.push( position.x, position.y, position.z );

                  }

                }

                if ( child.string.indexOf( 'DEF' ) > - 1 ) {

                  var name = /DEF\s+([^\s]+)/.exec( child.string )[ 1 ];

                  defines[ name ] = positions.slice( 0 );

                }

                if ( child.string.indexOf( 'USE' ) > - 1 ) {

                  var defineKey = /USE\s+([^\s]+)/.exec( child.string )[ 1 ];

                  positions = defines[ defineKey ];

                }

              }

            }

            var skip = 0;

            // some shapes only have vertices for use in other shapes

            if ( data.coordIndex ) {

              var newPositions = [];
              var newUvs = [];

              position = new THREE.Vector3();
              uv = new THREE.Vector2();

              for ( i = 0, il = data.coordIndex.length; i < il; i ++ ) {

                var indexes = data.coordIndex[ i ];

                // VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here

                skip = 0;

                while ( indexes.length >= 3 && skip < ( indexes.length - 2 ) ) {

                  if ( data.ccw === undefined ) data.ccw = true; // ccw is true by default

                  var i1 = indexes[ 0 ];
                  var i2 = indexes[ skip + ( data.ccw ? 1 : 2 ) ];
                  var i3 = indexes[ skip + ( data.ccw ? 2 : 1 ) ];

                  // create non indexed geometry, necessary for face normal generation

                  position.fromArray( positions, i1 * 3 );
                  uv.fromArray( uvs, i1 * 2 );
                  newPositions.push( position.x, position.y, position.z );
                  newUvs.push( uv.x, uv.y );

                  position.fromArray( positions, i2 * 3 );
                  uv.fromArray( uvs, i2 * 2 );
                  newPositions.push( position.x, position.y, position.z );
                  newUvs.push( uv.x, uv.y );

                  position.fromArray( positions, i3 * 3 );
                  uv.fromArray( uvs, i3 * 2 );
                  newPositions.push( position.x, position.y, position.z );
                  newUvs.push( uv.x, uv.y );

                  skip ++;

                }

              }

              positions = newPositions;
              uvs = newUvs;

            } else {

              // do not add dummy mesh to the scene

              parent.parent.remove( parent );

            }

            if ( false === data.solid ) {

              parent.material.side = THREE.DoubleSide;

            }

            // we need to store it on the geometry for use with defines
            geometry.solid = data.solid;

            geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

            if ( uvs.length > 0 ) {

              geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );

            }

            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();

            // see if it's a define
            if ( /DEF/.exec( data.string ) ) {

              geometry.name = /DEF ([^\s]+)/.exec( data.string )[ 1 ];
              defines[ geometry.name ] = geometry;

            }

            parent.geometry = geometry;

          }

          return;

        } else if ( /appearance/.exec( data.string ) ) {

          for ( var i = 0; i < data.children.length; i ++ ) {

            var child = data.children[ i ];

            if ( child.nodeType === 'Material' ) {

              var material = new THREE.MeshPhongMaterial();

              if ( child.diffuseColor !== undefined ) {

                var d = child.diffuseColor;

                material.color.setRGB( d.r, d.g, d.b );

              }

              if ( child.emissiveColor !== undefined ) {

                var e = child.emissiveColor;

                material.emissive.setRGB( e.r, e.g, e.b );

              }

              if ( child.specularColor !== undefined ) {

                var s = child.specularColor;

                material.specular.setRGB( s.r, s.g, s.b );

              }

              if ( child.transparency !== undefined ) {

                var t = child.transparency;

                // transparency is opposite of opacity
                material.opacity = Math.abs( 1 - t );

                material.transparent = true;

              }

              if ( /DEF/.exec( data.string ) ) {

                material.name = /DEF ([^\s]+)/.exec( data.string )[ 1 ];

                defines[ material.name ] = material;

              }

              parent.material = material;

            }

            if ( child.nodeType === 'ImageTexture' ) {

              var textureName = /"([^"]+)"/.exec( child.children[ 0 ] );

              if ( textureName ) {

                parent.material.name = textureName[ 1 ];

                parent.material.map = textureLoader.load( texturePath + textureName[ 1 ] );

              }

            }

          }

          return;

        }

        for ( var i = 0, l = data.children.length; i < l; i ++ ) {

          parseNode( data.children[ i ], object );

        }

      }

      parseNode( getTree( lines ), scene );

    }

    var scene = new THREE.Scene();

    var lines = data.split( '\n' );

    // some lines do not have breaks

    for ( var i = lines.length - 1; i > - 1; i -- ) {

      var line = lines[ i ];

      // split lines with {..{ or {..[ - some have both
      if ( /{.*[{\[]/.test( line ) ) {

        var parts = line.split( '{' ).join( '{\n' ).split( '\n' );
        parts.unshift( 1 );
        parts.unshift( i );
        lines.splice.apply( lines, parts );

      } else if ( /\].*}/.test( line ) ) {

        // split lines with ]..}
        var parts = line.split( ']' ).join( ']\n' ).split( '\n' );
        parts.unshift( 1 );
        parts.unshift( i );
        lines.splice.apply( lines, parts );

      }

      if ( /}.*}/.test( line ) ) {

        // split lines with }..}
        var parts = line.split( '}' ).join( '}\n' ).split( '\n' );
        parts.unshift( 1 );
        parts.unshift( i );
        lines.splice.apply( lines, parts );

      }

      if ( /^\b[^\s]+\b$/.test( line.trim() ) ) {

        // prevent lines with single words like "coord" or "geometry", see #12209
        lines[ i + 1 ] = line + ' ' + lines[ i + 1 ].trim();
        lines.splice( i, 1 );

      } else if ( ( line.indexOf( 'coord' ) > - 1 ) && ( line.indexOf( '[' ) < 0 ) && ( line.indexOf( '{' ) < 0 ) ) {

        // force the parser to create Coordinate node for empty coords
        // coord USE something -> coord USE something Coordinate {}

        lines[ i ] += ' Coordinate {}';

      }

    }

    var header = lines.shift();

    if ( /V1.0/.exec( header ) ) {

      parseV1( lines, scene );

    } else if ( /V2.0/.exec( header ) ) {

      parseV2( lines, scene );

    }

    return scene;

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Alex Pletzer
 *
 * Updated on 22.03.2017
 * VTK header is now parsed and used to extract all the compressed data
 * @author Andrii Iudin https://github.com/andreyyudin
 * @author Paul Kibet Korir https://github.com/polarise
 * @author Sriram Somasundharam https://github.com/raamssundar
 */

THREE.VTKLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.VTKLoader.prototype, THREE.EventDispatcher.prototype, {

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setResponseType( 'arraybuffer' );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  parse: function ( data ) {

    function parseASCII( data ) {

      // connectivity of the triangles
      var indices = [];

      // triangles vertices
      var positions = [];

      // red, green, blue colors in the range 0 to 1
      var colors = [];

      // normal vector, one per vertex
      var normals = [];

      var result;

      // pattern for reading vertices, 3 floats or integers
      var pat3Floats = /(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g;

      // pattern for connectivity, an integer followed by any number of ints
      // the first integer is the number of polygon nodes
      var patConnectivity = /^(\d+)\s+([\s\d]*)/;

      // indicates start of vertex data section
      var patPOINTS = /^POINTS /;

      // indicates start of polygon connectivity section
      var patPOLYGONS = /^POLYGONS /;

      // indicates start of triangle strips section
      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;

      // POINT_DATA number_of_values
      var patPOINT_DATA = /^POINT_DATA[ ]+(\d+)/;

      // CELL_DATA number_of_polys
      var patCELL_DATA = /^CELL_DATA[ ]+(\d+)/;

      // Start of color section
      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\w+)[ ]+3/;

      // NORMALS Normals float
      var patNORMALS = /^NORMALS[ ]+(\w+)[ ]+(\w+)/;

      var inPointsSection = false;
      var inPolygonsSection = false;
      var inTriangleStripSection = false;
      var inPointDataSection = false;
      var inCellDataSection = false;
      var inColorSection = false;
      var inNormalsSection = false;

      var lines = data.split( '\n' );

      for ( var i in lines ) {

        var line = lines[ i ];

        if ( inPointsSection ) {

          // get the vertices
          while ( ( result = pat3Floats.exec( line ) ) !== null ) {

            var x = parseFloat( result[ 1 ] );
            var y = parseFloat( result[ 2 ] );
            var z = parseFloat( result[ 3 ] );
            positions.push( x, y, z );

          }

        } else if ( inPolygonsSection ) {

          if ( ( result = patConnectivity.exec( line ) ) !== null ) {

            // numVertices i0 i1 i2 ...
            var numVertices = parseInt( result[ 1 ] );
            var inds = result[ 2 ].split( /\s+/ );

            if ( numVertices >= 3 ) {

              var i0 = parseInt( inds[ 0 ] );
              var i1, i2;
              var k = 1;
              // split the polygon in numVertices - 2 triangles
              for ( var j = 0; j < numVertices - 2; ++ j ) {

                i1 = parseInt( inds[ k ] );
                i2 = parseInt( inds[ k + 1 ] );
                indices.push( i0, i1, i2 );
                k ++;

              }

            }

          }

        } else if ( inTriangleStripSection ) {

          if ( ( result = patConnectivity.exec( line ) ) !== null ) {

            // numVertices i0 i1 i2 ...
            var numVertices = parseInt( result[ 1 ] );
            var inds = result[ 2 ].split( /\s+/ );

            if ( numVertices >= 3 ) {

              var i0, i1, i2;
              // split the polygon in numVertices - 2 triangles
              for ( var j = 0; j < numVertices - 2; j ++ ) {

                if ( j % 2 === 1 ) {

                  i0 = parseInt( inds[ j ] );
                  i1 = parseInt( inds[ j + 2 ] );
                  i2 = parseInt( inds[ j + 1 ] );
                  indices.push( i0, i1, i2 );

                } else {

                  i0 = parseInt( inds[ j ] );
                  i1 = parseInt( inds[ j + 1 ] );
                  i2 = parseInt( inds[ j + 2 ] );
                  indices.push( i0, i1, i2 );

                }

              }

            }

          }

        } else if ( inPointDataSection || inCellDataSection ) {

          if ( inColorSection ) {

            // Get the colors

            while ( ( result = pat3Floats.exec( line ) ) !== null ) {

              var r = parseFloat( result[ 1 ] );
              var g = parseFloat( result[ 2 ] );
              var b = parseFloat( result[ 3 ] );
              colors.push( r, g, b );

            }

          } else if ( inNormalsSection ) {

            // Get the normal vectors

            while ( ( result = pat3Floats.exec( line ) ) !== null ) {

              var nx = parseFloat( result[ 1 ] );
              var ny = parseFloat( result[ 2 ] );
              var nz = parseFloat( result[ 3 ] );
              normals.push( nx, ny, nz );

            }

          }

        }

        if ( patPOLYGONS.exec( line ) !== null ) {

          inPolygonsSection = true;
          inPointsSection = false;
          inTriangleStripSection = false;

        } else if ( patPOINTS.exec( line ) !== null ) {

          inPolygonsSection = false;
          inPointsSection = true;
          inTriangleStripSection = false;

        } else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {

          inPolygonsSection = false;
          inPointsSection = false;
          inTriangleStripSection = true;

        } else if ( patPOINT_DATA.exec( line ) !== null ) {

          inPointDataSection = true;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;

        } else if ( patCELL_DATA.exec( line ) !== null ) {

          inCellDataSection = true;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;

        } else if ( patCOLOR_SCALARS.exec( line ) !== null ) {

          inColorSection = true;
          inNormalsSection = false;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;

        } else if ( patNORMALS.exec( line ) !== null ) {

          inNormalsSection = true;
          inColorSection = false;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;

        }

      }

      var geometry;
      var stagger = 'point';

      if ( colors.length == indices.length ) {

        stagger = 'cell';

      }

      if ( stagger == 'point' ) {

        // Nodal. Use BufferGeometry
        geometry = new THREE.BufferGeometry();
        geometry.setIndex( new THREE.BufferAttribute( new Uint32Array( indices ), 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions ), 3 ) );

        if ( colors.length == positions.length ) {

          geometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( colors ), 3 ) );

        }

        if ( normals.length == positions.length ) {

          geometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );

        }

      } else {

        // Cell centered colors. The only way to attach a solid color to each triangle
        // is to use Geometry, which is less efficient than BufferGeometry
        geometry = new THREE.Geometry();

        var numTriangles = indices.length / 3;
        var numPoints = positions.length / 3;
        var face;
        var ia, ib, ic;
        var x, y, z;
        var r, g, b;

        for ( var j = 0; j < numPoints; ++ j ) {

          x = positions[ 3 * j + 0 ];
          y = positions[ 3 * j + 1 ];
          z = positions[ 3 * j + 2 ];
          geometry.vertices.push( new THREE.Vector3( x, y, z ) );

        }

        for ( var i = 0; i < numTriangles; ++ i ) {

          ia = indices[ 3 * i + 0 ];
          ib = indices[ 3 * i + 1 ];
          ic = indices[ 3 * i + 2 ];
          geometry.faces.push( new THREE.Face3( ia, ib, ic ) );

        }

        if ( colors.length == numTriangles * 3 ) {

          for ( var i = 0; i < numTriangles; ++ i ) {

            face = geometry.faces[ i ];
            r = colors[ 3 * i + 0 ];
            g = colors[ 3 * i + 1 ];
            b = colors[ 3 * i + 2 ];
            face.color = new THREE.Color().setRGB( r, g, b );

          }

        }

      }

      return geometry;

    }

    function parseBinary( data ) {

      var count, pointIndex, i, numberOfPoints, s;
      var buffer = new Uint8Array( data );
      var dataView = new DataView( data );

      // Points and normals, by default, are empty
      var points = [];
      var normals = [];
      var indices = [];

      // Going to make a big array of strings
      var vtk = [];
      var index = 0;

      function findString( buffer, start ) {

        var index = start;
        var c = buffer[ index ];
        var s = [];
        while ( c != 10 ) {

          s.push( String.fromCharCode( c ) );
          index ++;
          c = buffer[ index ];

        }

        return { start: start,
          end: index,
          next: index + 1,
          parsedString: s.join( '' ) };

      }

      var state, line;

      while ( true ) {

        // Get a string
        state = findString( buffer, index );
        line = state.parsedString;

        if ( line.indexOf( 'POINTS' ) === 0 ) {

          vtk.push( line );
          // Add the points
          numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );

          // Each point is 3 4-byte floats
          count = numberOfPoints * 4 * 3;

          points = new Float32Array( numberOfPoints * 3 );

          pointIndex = state.next;
          for ( i = 0; i < numberOfPoints; i ++ ) {

            points[ 3 * i ] = dataView.getFloat32( pointIndex, false );
            points[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );
            points[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );
            pointIndex = pointIndex + 12;

          }
          // increment our next pointer
          state.next = state.next + count + 1;

        } else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {

          var numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );
          var size = parseInt( line.split( ' ' )[ 2 ], 10 );
          // 4 byte integers
          count = size * 4;

          indices = new Uint32Array( 3 * size - 9 * numberOfStrips );
          var indicesIndex = 0;

          pointIndex = state.next;
          for ( i = 0; i < numberOfStrips; i ++ ) {

            // For each strip, read the first value, then record that many more points
            var indexCount = dataView.getInt32( pointIndex, false );
            var strip = [];
            pointIndex += 4;
            for ( s = 0; s < indexCount; s ++ ) {

              strip.push( dataView.getInt32( pointIndex, false ) );
              pointIndex += 4;

            }

            // retrieves the n-2 triangles from the triangle strip
            for ( var j = 0; j < indexCount - 2; j ++ ) {

              if ( j % 2 ) {

                indices[ indicesIndex ++ ] = strip[ j ];
                indices[ indicesIndex ++ ] = strip[ j + 2 ];
                indices[ indicesIndex ++ ] = strip[ j + 1 ];

              } else {


                indices[ indicesIndex ++ ] = strip[ j ];
                indices[ indicesIndex ++ ] = strip[ j + 1 ];
                indices[ indicesIndex ++ ] = strip[ j + 2 ];

              }

            }

          }
          // increment our next pointer
          state.next = state.next + count + 1;

        } else if ( line.indexOf( 'POLYGONS' ) === 0 ) {

          var numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );
          var size = parseInt( line.split( ' ' )[ 2 ], 10 );
          // 4 byte integers
          count = size * 4;

          indices = new Uint32Array( 3 * size - 9 * numberOfStrips );
          var indicesIndex = 0;

          pointIndex = state.next;
          for ( i = 0; i < numberOfStrips; i ++ ) {

            // For each strip, read the first value, then record that many more points
            var indexCount = dataView.getInt32( pointIndex, false );
            var strip = [];
            pointIndex += 4;
            for ( s = 0; s < indexCount; s ++ ) {

              strip.push( dataView.getInt32( pointIndex, false ) );
              pointIndex += 4;

            }

            // divide the polygon in n-2 triangle
            for ( var j = 1; j < indexCount - 1; j ++ ) {

              indices[ indicesIndex ++ ] = strip[ 0 ];
              indices[ indicesIndex ++ ] = strip[ j ];
              indices[ indicesIndex ++ ] = strip[ j + 1 ];

            }

          }
          // increment our next pointer
          state.next = state.next + count + 1;

        } else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {

          numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );

          // Grab the next line
          state = findString( buffer, state.next );

          // Now grab the binary data
          count = numberOfPoints * 4 * 3;

          normals = new Float32Array( numberOfPoints * 3 );
          pointIndex = state.next;
          for ( i = 0; i < numberOfPoints; i ++ ) {

            normals[ 3 * i ] = dataView.getFloat32( pointIndex, false );
            normals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );
            normals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );
            pointIndex += 12;

          }

          // Increment past our data
          state.next = state.next + count;

        }

        // Increment index
        index = state.next;

        if ( index >= buffer.byteLength ) {

          break;

        }

      }

      var geometry = new THREE.BufferGeometry();
      geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
      geometry.addAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );

      if ( normals.length == points.length ) {

        geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

      }

      return geometry;

    }

    function Float32Concat( first, second ) {

        var firstLength = first.length, result = new Float32Array( firstLength + second.length );

        result.set( first );
        result.set( second, firstLength );

        return result;

    }

    function Int32Concat( first, second ) {

        var firstLength = first.length, result = new Int32Array( firstLength + second.length );

        result.set( first );
        result.set( second, firstLength );

        return result;

    }

    function parseXML( stringFile ) {

      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json

      function xmlToJson( xml ) {

        // Create the return object
        var obj = {};

        if ( xml.nodeType == 1 ) { // element

          // do attributes

          if ( xml.attributes ) {

            if ( xml.attributes.length > 0 ) {

              obj[ 'attributes' ] = {};

              for ( var j = 0; j < xml.attributes.length; j ++ ) {

                var attribute = xml.attributes.item( j );
                obj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();

              }

            }

          }

        } else if ( xml.nodeType == 3 ) { // text

          obj = xml.nodeValue.trim();

        }

        // do children
        if ( xml.hasChildNodes() ) {

          for ( var i = 0; i < xml.childNodes.length; i ++ ) {

            var item = xml.childNodes.item( i );
            var nodeName = item.nodeName;

            if ( typeof obj[ nodeName ] === 'undefined' ) {

              var tmp = xmlToJson( item );

              if ( tmp !== '' ) obj[ nodeName ] = tmp;

            } else {

              if ( typeof obj[ nodeName ].push === 'undefined' ) {

                var old = obj[ nodeName ];
                obj[ nodeName ] = [ old ];

              }

              var tmp = xmlToJson( item );

              if ( tmp !== '' ) obj[ nodeName ].push( tmp );

            }

          }

        }

        return obj;

      }

      // Taken from Base64-js
      function Base64toByteArray( b64 ) {

        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
        var i;
        var lookup = [];
        var revLookup = [];
        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        var len = code.length;

        for ( i = 0; i < len; i ++ ) {

          lookup[ i ] = code[ i ];

        }

        for ( i = 0; i < len; ++ i ) {

          revLookup[ code.charCodeAt( i ) ] = i;

        }

        revLookup[ '-'.charCodeAt( 0 ) ] = 62;
        revLookup[ '_'.charCodeAt( 0 ) ] = 63;

        var j, l, tmp, placeHolders, arr;
        var len = b64.length;

        if ( len % 4 > 0 ) {

          throw new Error( 'Invalid string. Length must be a multiple of 4' );

        }

        placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;
        arr = new Arr( len * 3 / 4 - placeHolders );
        l = placeHolders > 0 ? len - 4 : len;

        var L = 0;

        for ( i = 0, j = 0; i < l; i += 4, j += 3 ) {

          tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];
          arr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;
          arr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;
          arr[ L ++ ] = tmp & 0xFF;

        }

        if ( placeHolders === 2 ) {

          tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );
          arr[ L ++ ] = tmp & 0xFF;

        } else if ( placeHolders === 1 ) {

          tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );
          arr[ L ++ ] = ( tmp >> 8 ) & 0xFF;
          arr[ L ++ ] = tmp & 0xFF;

        }

        return arr;

      }

      function parseDataArray( ele, compressed ) {

        var numBytes = 0;

        if ( json.attributes.header_type == 'UInt64' ) {

          numBytes = 8;

        } else if ( json.attributes.header_type == 'UInt32' ) {

          numBytes = 4;

        }


        // Check the format
        if ( ele.attributes.format == 'binary' && compressed ) {

          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;

          if ( ele.attributes.type == 'Float32' ) {

            var txt = new Float32Array( );

          } else if ( ele.attributes.type === 'Int64' ) {

            var txt = new Int32Array( );

          }

          // VTP data with the header has the following structure:
          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]
          //
          // Each token is an integer value whose type is specified by "header_type" at the top of the file (UInt32 if no type specified). The token meanings are:
          // [#blocks] = Number of blocks
          // [#u-size] = Block size before compression
          // [#p-size] = Size of last partial block (zero if it not needed)
          // [#c-size-i] = Size in bytes of block i after compression
          //
          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is
          // computed by summing the compressed block sizes from preceding blocks according to the header.

          rawData = ele[ '#text' ];

          byteData = Base64toByteArray( rawData );

          blocks = byteData[ 0 ];
          for ( var i = 1; i < numBytes - 1; i ++ ) {

            blocks = blocks | ( byteData[ i ] << ( i * numBytes ) );

          }

          headerSize = ( blocks + 3 ) * numBytes;
          padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;
          headerSize = headerSize + padding;

          dataOffsets = [];
          currentOffset = headerSize;
          dataOffsets.push( currentOffset );

          // Get the blocks sizes after the compression.
          // There are three blocks before c-size-i, so we skip 3*numBytes
          cSizeStart = 3 * numBytes;

          for ( var i = 0; i < blocks; i ++ ) {

            var currentBlockSize = byteData[ i * numBytes + cSizeStart ];

            for ( var j = 1; j < numBytes - 1; j ++ ) {

              // Each data point consists of 8 bytes regardless of the header type
              currentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );

            }

            currentOffset = currentOffset + currentBlockSize;
            dataOffsets.push( currentOffset );

          }

          for ( var i = 0; i < dataOffsets.length - 1; i ++ ) {

            var inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef
            content = inflate.decompress();
            content = content.buffer;

            if ( ele.attributes.type == 'Float32' ) {

              content = new Float32Array( content );
              txt = Float32Concat( txt, content );

            } else if ( ele.attributes.type === 'Int64' ) {

              content = new Int32Array( content );
              txt = Int32Concat( txt, content );

            }

          }

          delete ele[ '#text' ];

          // Get the content and optimize it
          if ( ele.attributes.type == 'Float32' ) {

            if ( ele.attributes.format == 'binary' ) {

              if ( ! compressed ) {

                txt = txt.filter( function ( el, idx ) {

                  if ( idx !== 0 ) return true;

                } );

              }

            }

          } else if ( ele.attributes.type === 'Int64' ) {

            if ( ele.attributes.format == 'binary' ) {

              if ( ! compressed ) {

                txt = txt.filter( function ( el, idx ) {

                  if ( idx !== 0 ) return true;

                } );

              }

              txt = txt.filter( function ( el, idx ) {

                if ( idx % 2 !== 1 ) return true;

              } );

            }

          }

        } else {

          if ( ele.attributes.format == 'binary' && ! compressed ) {

            var content = Base64toByteArray( ele[ '#text' ] );

            //  VTP data for the uncompressed case has the following structure:
            // [#bytes][DATA]
            // where "[#bytes]" is an integer value specifying the number of bytes in the block of data following it.
            content = content.slice( numBytes ).buffer;

          } else {

            if ( ele[ '#text' ] ) {

              var content = ele[ '#text' ].split( /\s+/ ).filter( function ( el ) {

                if ( el !== '' ) return el;

              } );

            } else {

              var content = new Int32Array( 0 ).buffer;

            }

          }

          delete ele[ '#text' ];

          // Get the content and optimize it
          if ( ele.attributes.type == 'Float32' ) {

            var txt = new Float32Array( content );

          } else if ( ele.attributes.type == 'Int32' ) {

            var txt = new Int32Array( content );

          } else if ( ele.attributes.type === 'Int64' ) {

            var txt = new Int32Array( content );

            if ( ele.attributes.format == 'binary' ) {

              txt = txt.filter( function ( el, idx ) {

                if ( idx % 2 !== 1 ) return true;

              } );

            }

          }

        } // endif ( ele.attributes.format == 'binary' && compressed )

        return txt;

      }

      // Main part
      // Get Dom
      var dom = null;

      if ( window.DOMParser ) {

        try {

          dom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );

        } catch ( e ) {

          dom = null;

        }

      } else if ( window.ActiveXObject ) {

        try {

          dom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef
          dom.async = false;

          if ( ! dom.loadXML( /* xml */ ) ) {

            throw new Error( dom.parseError.reason + dom.parseError.srcText );

          }

        } catch ( e ) {

          dom = null;

        }

      } else {

        throw new Error( 'Cannot parse xml string!' );

      }

      // Get the doc
      var doc = dom.documentElement;
      // Convert to json
      var json = xmlToJson( doc );
      var points = [];
      var normals = [];
      var indices = [];

      if ( json.PolyData ) {

        var piece = json.PolyData.Piece;
        var compressed = json.attributes.hasOwnProperty( 'compressor' );

        // Can be optimized
        // Loop through the sections
        var sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];
        var sectionIndex = 0, numberOfSections = sections.length;

        while ( sectionIndex < numberOfSections ) {

          var section = piece[ sections[ sectionIndex ] ];

          // If it has a DataArray in it

          if ( section && section.DataArray ) {

            // Depending on the number of DataArrays

            if ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {

              var arr = section.DataArray;

            } else {

              var arr = [ section.DataArray ];

            }

            var dataArrayIndex = 0, numberOfDataArrays = arr.length;

            while ( dataArrayIndex < numberOfDataArrays ) {

              // Parse the DataArray
              if ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {

                arr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );

              }

              dataArrayIndex ++;

            }

            switch ( sections[ sectionIndex ] ) {

              // if iti is point data
              case 'PointData':

                var numberOfPoints = parseInt( piece.attributes.NumberOfPoints );
                var normalsName = section.attributes.Normals;

                if ( numberOfPoints > 0 ) {

                  for ( var i = 0, len = arr.length; i < len; i ++ ) {

                    if ( normalsName == arr[ i ].attributes.Name ) {

                      var components = arr[ i ].attributes.NumberOfComponents;
                      normals = new Float32Array( numberOfPoints * components );
                      normals.set( arr[ i ].text, 0 );

                    }

                  }

                }

                break;

              // if it is points
              case 'Points':

                var numberOfPoints = parseInt( piece.attributes.NumberOfPoints );

                if ( numberOfPoints > 0 ) {

                  var components = section.DataArray.attributes.NumberOfComponents;
                  points = new Float32Array( numberOfPoints * components );
                  points.set( section.DataArray.text, 0 );

                }

                break;

              // if it is strips
              case 'Strips':

                var numberOfStrips = parseInt( piece.attributes.NumberOfStrips );

                if ( numberOfStrips > 0 ) {

                  var connectivity = new Int32Array( section.DataArray[ 0 ].text.length );
                  var offset = new Int32Array( section.DataArray[ 1 ].text.length );
                  connectivity.set( section.DataArray[ 0 ].text, 0 );
                  offset.set( section.DataArray[ 1 ].text, 0 );

                  var size = numberOfStrips + connectivity.length;
                  indices = new Uint32Array( 3 * size - 9 * numberOfStrips );

                  var indicesIndex = 0;

                  for ( var i = 0, len = numberOfStrips; i < len; i ++ ) {

                    var strip = [];

                    for ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {

                      strip.push( connectivity[ s ] );

                      if ( i > 0 ) len0 = offset[ i - 1 ];

                    }

                    for ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {

                      if ( j % 2 ) {

                        indices[ indicesIndex ++ ] = strip[ j ];
                        indices[ indicesIndex ++ ] = strip[ j + 2 ];
                        indices[ indicesIndex ++ ] = strip[ j + 1 ];

                      } else {

                        indices[ indicesIndex ++ ] = strip[ j ];
                        indices[ indicesIndex ++ ] = strip[ j + 1 ];
                        indices[ indicesIndex ++ ] = strip[ j + 2 ];

                      }

                      if ( i > 0 ) len0 = offset[ i - 1 ];

                    }

                  }

                }

                break;

              // if it is polys
              case 'Polys':

                var numberOfPolys = parseInt( piece.attributes.NumberOfPolys );

                if ( numberOfPolys > 0 ) {

                  var connectivity = new Int32Array( section.DataArray[ 0 ].text.length );
                  var offset = new Int32Array( section.DataArray[ 1 ].text.length );
                  connectivity.set( section.DataArray[ 0 ].text, 0 );
                  offset.set( section.DataArray[ 1 ].text, 0 );

                  var size = numberOfPolys + connectivity.length;
                  indices = new Uint32Array( 3 * size - 9 * numberOfPolys );
                  var indicesIndex = 0, connectivityIndex = 0;
                  var i = 0, len = numberOfPolys, len0 = 0;

                  while ( i < len ) {

                    var poly = [];
                    var s = 0, len1 = offset[ i ];

                    while ( s < len1 - len0 ) {

                      poly.push( connectivity[ connectivityIndex ++ ] );
                      s ++;

                    }

                    var j = 1;

                    while ( j < len1 - len0 - 1 ) {

                      indices[ indicesIndex ++ ] = poly[ 0 ];
                      indices[ indicesIndex ++ ] = poly[ j ];
                      indices[ indicesIndex ++ ] = poly[ j + 1 ];
                      j ++;

                    }

                    i ++;
                    len0 = offset[ i - 1 ];

                  }

                }

                break;

              default:
                break;

            }

          }

          sectionIndex ++;

        }

        var geometry = new THREE.BufferGeometry();
        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );

        if ( normals.length == points.length ) {

          geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

        }

        return geometry;

      } else {

        // TODO for vtu,vti,and other xml formats

      }

    }

    function getStringFile( data ) {

      var stringFile = '';
      var charArray = new Uint8Array( data );
      var i = 0;
      var len = charArray.length;

      while ( len -- ) {

        stringFile += String.fromCharCode( charArray[ i ++ ] );

      }

      return stringFile;

    }

    // get the 5 first lines of the files to check if there is the key word binary
    var meta = String.fromCharCode.apply( null, new Uint8Array( data, 0, 250 ) ).split( '\n' );

    if ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {

      return parseXML( getStringFile( data ) );

    } else if ( meta[ 2 ].includes( 'ASCII' ) ) {

      return parseASCII( getStringFile( data ) );

    } else {

      return parseBinary( data );

    }

  }

} );


var LZMA = LZMA || {};

// browserify support
if ( typeof module === 'object' ) {

  module.exports = LZMA;

}

LZMA.OutWindow = function() {
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function(windowSize) {
  if ( (!this._buffer) || (this._windowSize !== windowSize) ) {
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function() {
  var size = this._pos - this._streamPos;
  if (size !== 0) {
    while (size --) {
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize) {
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function() {
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function(stream) {
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function(solid) {
  if (!solid) {
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function(distance, len) {
  var pos = this._pos - distance - 1;
  if (pos < 0) {
    pos += this._windowSize;
  }
  while (len --) {
    if (pos >= this._windowSize) {
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize) {
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function(b) {
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize) {
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function(distance) {
  var pos = this._pos - distance - 1;
  if (pos < 0) {
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function() {
};

LZMA.RangeDecoder.prototype.setStream = function(stream) {
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function() {
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function() {
  var i = 5;

  this._code = 0;
  this._range = -1;
  
  while (i --) {
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits) {
  var result = 0, i = numTotalBits, t;

  while (i --) {
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0) {
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function(probs, index) {
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ) {
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0) {
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0) {
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function(probs, len) {
  while (len --) {
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function(numBitLevels) {
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function() {
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder) {
  var m = 1, i = this._numBitLevels;

  while (i --) {
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder) {
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i) {
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels) {
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i) {
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function() {
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function(numPosStates) {
  for (; this._numPosStates < numPosStates; ++ this._numPosStates) {
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function() {
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while (i --) {
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState) {
  if (rangeDecoder.decodeBit(this._choice, 0) === 0) {
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0) {
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function() {
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function() {
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder) {
  var symbol = 1;

  do {
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while (symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte) {
  var symbol = 1, matchBit, bit;

  do {
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit) {
      while (symbol < 0x100) {
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while (symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function() {
};

LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits) {
  var i;

  if (this._coders
    && (this._numPrevBits === numPrevBits)
    && (this._numPosBits === numPosBits) ) {
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while (i --) {
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function() {
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while (i --) {
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte) {
  return this._coders[( (pos & this._posMask) << this._numPrevBits)
    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

LZMA.Decoder = function() {
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize) {
  if (dictionarySize < 0) {
    return false;
  }
  if (this._dictionarySize !== dictionarySize) {
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb) {
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4) {
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function() {
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while (i --) {
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize) {
  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while (outSize < 0 || nowPos64 < outSize) {
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0) {
      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

      if (state >= 7) {
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else {
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4 ? 0 : state - (state < 10 ? 3 : 6);

    }else {

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1) {
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0) {
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0) {
            state = state < 7 ? 9 : 11;
            len = 1;
          }
        }else {
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0) {
            distance = rep1;
          }else {
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0) {
              distance = rep2;
            }else {
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0) {
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7 ? 8 : 11;
        }
      }else {
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7 ? 7 : 10;

        posSlot = this._posSlotDecoder[len <= 5 ? len - 2 : 3].decode(this._rangeDecoder);
        if (posSlot >= 4) {

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < 14) {
            rep0 += LZMA.reverseDecode2(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else {
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0) {
              if (rep0 === -1) {
                break;
              }
              return false;
            }
          }
        }else {
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck) {
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function(properties) {
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5) {
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ) {
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function(properties, inStream, outStream, outSize) {
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ) {
    throw "Incorrect stream properties";
  }

  if ( !decoder.decode(inStream, outStream, outSize) ) {
    throw "Error in data stream";
  }

  return true;
};

/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "OpenCTM: The Open Compressed Triangle Mesh file format" by Marcus Geelnard
  http://openctm.sourceforge.net/
*/

var CTM = CTM || {};

// browserify support
if ( typeof module === 'object' ) {

  module.exports = CTM;

}

CTM.CompressionMethod = {
  RAW: 0x00574152,
  MG1: 0x0031474d,
  MG2: 0x0032474d
};

CTM.Flags = {
  NORMALS: 0x00000001
};

CTM.File = function(stream) {
  this.load(stream);
};

CTM.File.prototype.load = function(stream) {
  this.header = new CTM.FileHeader(stream);

  this.body = new CTM.FileBody(this.header);
  
  this.getReader().read(stream, this.body);
};

CTM.File.prototype.getReader = function() {
  var reader;

  switch (this.header.compressionMethod){
    case CTM.CompressionMethod.RAW:
      reader = new CTM.ReaderRAW();
      break;
    case CTM.CompressionMethod.MG1:
      reader = new CTM.ReaderMG1();
      break;
    case CTM.CompressionMethod.MG2:
      reader = new CTM.ReaderMG2();
      break;
  }

  return reader;
};

CTM.FileHeader = function(stream) {
  stream.readInt32(); //magic "OCTM"
  this.fileFormat = stream.readInt32();
  this.compressionMethod = stream.readInt32();
  this.vertexCount = stream.readInt32();
  this.triangleCount = stream.readInt32();
  this.uvMapCount = stream.readInt32();
  this.attrMapCount = stream.readInt32();
  this.flags = stream.readInt32();
  this.comment = stream.readString();
};

CTM.FileHeader.prototype.hasNormals = function() {
  return this.flags & CTM.Flags.NORMALS;
};

CTM.FileBody = function(header) {
  var i = header.triangleCount * 3,
      v = header.vertexCount * 3,
      n = header.hasNormals() ? header.vertexCount * 3 : 0,
      u = header.vertexCount * 2,
      a = header.vertexCount * 4,
      j = 0;

  var data = new ArrayBuffer(
    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);

  this.indices = new Uint32Array(data, 0, i);

  this.vertices = new Float32Array(data, i * 4, v);

  if ( header.hasNormals() ) {
    this.normals = new Float32Array(data, (i + v) * 4, n);
  }
  
  if (header.uvMapCount) {
    this.uvMaps = [];
    for (j = 0; j < header.uvMapCount; ++ j) {
      this.uvMaps[j] = { uv: new Float32Array(data,
        (i + v + n + (j * u) ) * 4, u) };
    }
  }
  
  if (header.attrMapCount) {
    this.attrMaps = [];
    for (j = 0; j < header.attrMapCount; ++ j) {
      this.attrMaps[j] = { attr: new Float32Array(data,
        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };
    }
  }
};

CTM.FileMG2Header = function(stream) {
  stream.readInt32(); //magic "MG2H"
  this.vertexPrecision = stream.readFloat32();
  this.normalPrecision = stream.readFloat32();
  this.lowerBoundx = stream.readFloat32();
  this.lowerBoundy = stream.readFloat32();
  this.lowerBoundz = stream.readFloat32();
  this.higherBoundx = stream.readFloat32();
  this.higherBoundy = stream.readFloat32();
  this.higherBoundz = stream.readFloat32();
  this.divx = stream.readInt32();
  this.divy = stream.readInt32();
  this.divz = stream.readInt32();
  
  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;
  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;
  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;
};

CTM.ReaderRAW = function() {
};

CTM.ReaderRAW.prototype.read = function(stream, body) {
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals) {
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps) {
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps) {
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderRAW.prototype.readIndices = function(stream, indices) {
  stream.readInt32(); //magic "INDX"
  stream.readArrayInt32(indices);
};

CTM.ReaderRAW.prototype.readVertices = function(stream, vertices) {
  stream.readInt32(); //magic "VERT"
  stream.readArrayFloat32(vertices);
};

CTM.ReaderRAW.prototype.readNormals = function(stream, normals) {
  stream.readInt32(); //magic "NORM"
  stream.readArrayFloat32(normals);
};

CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps) {
  var i = 0;
  for (; i < uvMaps.length; ++ i) {
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    stream.readArrayFloat32(uvMaps[i].uv);
  }
};

CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps) {
  var i = 0;
  for (; i < attrMaps.length; ++ i) {
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    stream.readArrayFloat32(attrMaps[i].attr);
  }
};

CTM.ReaderMG1 = function() {
};

CTM.ReaderMG1.prototype.read = function(stream, body) {
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals) {
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps) {
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps) {
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG1.prototype.readIndices = function(stream, indices) {
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG1.prototype.readVertices = function(stream, vertices) {
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(vertices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readNormals = function(stream, normals) {
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps) {
  var i = 0;
  for (; i < uvMaps.length; ++ i) {
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps) {
  var i = 0;
  for (; i < attrMaps.length; ++ i) {
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG2 = function() {
};

CTM.ReaderMG2.prototype.read = function(stream, body) {
  this.MG2Header = new CTM.FileMG2Header(stream);
  
  this.readVertices(stream, body.vertices);
  this.readIndices(stream, body.indices);
  
  if (body.normals) {
    this.readNormals(stream, body);
  }
  if (body.uvMaps) {
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps) {
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG2.prototype.readVertices = function(stream, vertices) {
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(vertices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  var gridIndices = this.readGridIndices(stream, vertices);
  
  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);
};

CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices) {
  stream.readInt32(); //magic "GIDX"
  stream.readInt32(); //packed size
  
  var gridIndices = new Uint32Array(vertices.length / 3);
  
  var interleaved = new CTM.InterleavedStream(gridIndices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  CTM.restoreGridIndices(gridIndices, gridIndices.length);
  
  return gridIndices;
};

CTM.ReaderMG2.prototype.readIndices = function(stream, indices) {
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG2.prototype.readNormals = function(stream, body) {
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(body.normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);

  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);
};

CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps) {
  var i = 0;
  for (; i < uvMaps.length; ++ i) {
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(uvMaps[i].uv, 2, precision);
  }
};

CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps) {
  var i = 0;
  for (; i < attrMaps.length; ++ i) {
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(attrMaps[i].attr, 4, precision);
  }
};

CTM.restoreIndices = function(indices, len) {
  var i = 3;
  if (len > 0) {
    indices[2] += indices[0];
    indices[1] += indices[0];
  }
  for (; i < len; i += 3) {
    indices[i] += indices[i - 3];
    
    if (indices[i] === indices[i - 3]) {
      indices[i + 1] += indices[i - 2];
    }else {
      indices[i + 1] += indices[i];
    }

    indices[i + 2] += indices[i];
  }
};

CTM.restoreGridIndices = function(gridIndices, len) {
  var i = 1;
  for (; i < len; ++ i) {
    gridIndices[i] += gridIndices[i - 1];
  }
};

CTM.restoreVertices = function(vertices, grid, gridIndices, precision) {
  var gridIdx, delta, x, y, z,
      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),
      ydiv = grid.divx, zdiv = ydiv * grid.divy,
      prevGridIdx = 0x7fffffff, prevDelta = 0,
      i = 0, j = 0, len = gridIndices.length;

  for (; i < len; j += 3) {
    x = gridIdx = gridIndices[i ++];
    
    z = ~~(x / zdiv);
    x -= ~~(z * zdiv);
    y = ~~(x / ydiv);
    x -= ~~(y * ydiv);

    delta = intVertices[j];
    if (gridIdx === prevGridIdx) {
      delta += prevDelta;
    }

    vertices[j]     = grid.lowerBoundx +
      x * grid.sizex + precision * delta;
    vertices[j + 1] = grid.lowerBoundy +
      y * grid.sizey + precision * intVertices[j + 1];
    vertices[j + 2] = grid.lowerBoundz +
      z * grid.sizez + precision * intVertices[j + 2];

    prevGridIdx = gridIdx;
    prevDelta = delta;
  }
};

CTM.restoreNormals = function(normals, smooth, precision) {
  var ro, phi, theta, sinPhi,
      nx, ny, nz, by, bz, len,
      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),
      i = 0, k = normals.length,
      PI_DIV_2 = 3.141592653589793238462643 * 0.5;

  for (; i < k; i += 3) {
    ro = intNormals[i] * precision;
    phi = intNormals[i + 1];

    if (phi === 0) {
      normals[i]     = smooth[i]     * ro;
      normals[i + 1] = smooth[i + 1] * ro;
      normals[i + 2] = smooth[i + 2] * ro;
    }else {
      
      if (phi <= 4) {
        theta = (intNormals[i + 2] - 2) * PI_DIV_2;
      }else {
        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;
      }
      
      phi *= precision * PI_DIV_2;
      sinPhi = ro * Math.sin(phi);

      nx = sinPhi * Math.cos(theta);
      ny = sinPhi * Math.sin(theta);
      nz = ro * Math.cos(phi);

      bz = smooth[i + 1];
      by = smooth[i] - smooth[i + 2];

      len = Math.sqrt(2 * bz * bz + by * by);
      if (len > 1e-20) {
        by /= len;
        bz /= len;
      }

      normals[i]     = smooth[i]     * nz +
        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;
      normals[i + 1] = smooth[i + 1] * nz -
        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;
      normals[i + 2] = smooth[i + 2] * nz +
        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;
    }
  }
};

CTM.restoreMap = function(map, count, precision) {
  var delta, value,
      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),
      i = 0, j, len = map.length;

  for (; i < count; ++ i) {
    delta = 0;

    for (j = i; j < len; j += count) {
      value = intMap[j];
      
      delta += value & 1 ? -( (value + 1) >> 1) : value >> 1;
      
      map[j] = delta * precision;
    }
  }
};

CTM.calcSmoothNormals = function(indices, vertices) {
  var smooth = new Float32Array(vertices.length),
      indx, indy, indz, nx, ny, nz,
      v1x, v1y, v1z, v2x, v2y, v2z, len,
      i, k;

  for (i = 0, k = indices.length; i < k;) {
    indx = indices[i ++] * 3;
    indy = indices[i ++] * 3;
    indz = indices[i ++] * 3;

    v1x = vertices[indy]     - vertices[indx];
    v2x = vertices[indz]     - vertices[indx];
    v1y = vertices[indy + 1] - vertices[indx + 1];
    v2y = vertices[indz + 1] - vertices[indx + 1];
    v1z = vertices[indy + 2] - vertices[indx + 2];
    v2z = vertices[indz + 2] - vertices[indx + 2];
    
    nx = v1y * v2z - v1z * v2y;
    ny = v1z * v2x - v1x * v2z;
    nz = v1x * v2y - v1y * v2x;
    
    len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len > 1e-10) {
      nx /= len;
      ny /= len;
      nz /= len;
    }
    
    smooth[indx]     += nx;
    smooth[indx + 1] += ny;
    smooth[indx + 2] += nz;
    smooth[indy]     += nx;
    smooth[indy + 1] += ny;
    smooth[indy + 2] += nz;
    smooth[indz]     += nx;
    smooth[indz + 1] += ny;
    smooth[indz + 2] += nz;
  }

  for (i = 0, k = smooth.length; i < k; i += 3) {
    len = Math.sqrt(smooth[i] * smooth[i] + 
      smooth[i + 1] * smooth[i + 1] +
      smooth[i + 2] * smooth[i + 2]);

    if (len > 1e-10) {
      smooth[i]     /= len;
      smooth[i + 1] /= len;
      smooth[i + 2] /= len;
    }
  }

  return smooth;
};

CTM.isLittleEndian = (function() {
  var buffer = new ArrayBuffer(2),
      bytes = new Uint8Array(buffer),
      ints = new Uint16Array(buffer);

  bytes[0] = 1;

  return ints[0] === 1;
}());

CTM.InterleavedStream = function(data, count) {
  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  this.offset = CTM.isLittleEndian ? 3 : 0;
  this.count = count * 4;
  this.len = this.data.length;
};

CTM.InterleavedStream.prototype.writeByte = function(value) {
  this.data[this.offset] = value;
  
  this.offset += this.count;
  if (this.offset >= this.len) {
  
    this.offset -= this.len - 4;
    if (this.offset >= this.count) {
    
      this.offset -= this.count + (CTM.isLittleEndian ? 1 : -1);
    }
  }
};

CTM.Stream = function(data) {
  this.data = data;
  this.offset = 0;
};

CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);

CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);

CTM.Stream.prototype.readByte = function() {
  return this.data[this.offset ++] & 0xff;
};

CTM.Stream.prototype.readInt32 = function() {
  var i = this.readByte();
  i |= this.readByte() << 8;
  i |= this.readByte() << 16;
  return i | (this.readByte() << 24);
};

CTM.Stream.prototype.readFloat32 = function() {
  var m = this.readByte();
  m += this.readByte() << 8;

  var b1 = this.readByte();
  var b2 = this.readByte();

  m += (b1 & 0x7f) << 16; 
  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);
  var s = b2 & 0x80 ? -1 : 1;

  if (e === 255) {
    return m !== 0 ? NaN : s * Infinity;
  }
  if (e > 0) {
    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);
  }
  if (m !== 0) {
    return s * m * this.TWO_POW_MINUS126;
  }
  return s * 0;
};

CTM.Stream.prototype.readString = function() {
  var len = this.readInt32();

  this.offset += len;

  return String.fromCharCode.apply(null, this.data.subarray(this.offset - len, this.offset));
};

CTM.Stream.prototype.readArrayInt32 = function(array) {
  var i = 0, len = array.length;
  
  while (i < len) {
    array[i ++] = this.readInt32();
  }

  return array;
};

CTM.Stream.prototype.readArrayFloat32 = function(array) {
  var i = 0, len = array.length;

  while (i < len) {
    array[i ++] = this.readFloat32();
  }

  return array;
};

/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *  http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *  http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function () {

  THREE.Loader.call( this );

};

THREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );
THREE.CTMLoader.prototype.constructor = THREE.CTMLoader;

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function ( url, callback, parameters ) {

  parameters = parameters || {};

  var scope = this;

  var xhr = new XMLHttpRequest();

  var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );

  xhr.onreadystatechange = function () {

    if ( xhr.readyState === 4 ) {

      if ( xhr.status === 200 || xhr.status === 0 ) {

        var jsonObject = JSON.parse( xhr.responseText );

        var materials = [], geometries = [], counter = 0;

        function callbackFinal( geometry ) {

          counter += 1;

          geometries.push( geometry );

          if ( counter === jsonObject.offsets.length ) {

            callback( geometries, materials );

          }

        }


        // init materials

        for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

          materials[ i ] = scope.createMaterial( jsonObject.materials[ i ], basePath );

        }

        // load joined CTM file

        var partUrl = basePath + jsonObject.data;
        var parametersPart = { useWorker: parameters.useWorker, worker: parameters.worker, offsets: jsonObject.offsets };
        scope.load( partUrl, callbackFinal, parametersPart );

      }

    }

  };

  xhr.open( "GET", url, true );
  xhr.setRequestHeader( "Content-Type", "text/plain" );
  xhr.send( null );

};

// Load CTMLoader compressed models
//  - parameters
//    - url (required)
//    - callback (required)

THREE.CTMLoader.prototype.load = function ( url, callback, parameters ) {

  parameters = parameters || {};

  var scope = this;

  var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];

  var xhr = new XMLHttpRequest(),
    callbackProgress = null;

  var length = 0;

  xhr.onreadystatechange = function () {

    if ( xhr.readyState === 4 ) {

      if ( xhr.status === 200 || xhr.status === 0 ) {

        var binaryData = new Uint8Array( xhr.response );

        var s = Date.now();

        if ( parameters.useWorker ) {

          var worker = parameters.worker || new Worker( 'js/loaders/ctm/CTMWorker.js' );

          worker.onmessage = function ( event ) {

            var files = event.data;

            for ( var i = 0; i < files.length; i ++ ) {

              var ctmFile = files[ i ];

              var e1 = Date.now();
              // console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

              scope.createModel( ctmFile, callback );

              var e = Date.now();
              console.log( "model load time [worker]: " + ( e - e1 ) + " ms, total: " + ( e - s ) );

            }


          };

          worker.postMessage( { "data": binaryData, "offsets": offsets }, [ binaryData.buffer ] );

        } else {

          for ( var i = 0; i < offsets.length; i ++ ) {

            var stream = new CTM.Stream( binaryData );
            stream.offset = offsets[ i ];

            var ctmFile = new CTM.File( stream );

            scope.createModel( ctmFile, callback );

          }

          //var e = Date.now();
          //console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

        }

      } else {

        console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

      }

    } else if ( xhr.readyState === 3 ) {

      if ( callbackProgress ) {

        if ( length === 0 ) {

          length = xhr.getResponseHeader( "Content-Length" );

        }

        callbackProgress( { total: length, loaded: xhr.responseText.length } );

      }

    } else if ( xhr.readyState === 2 ) {

      length = xhr.getResponseHeader( "Content-Length" );

    }

  };

  xhr.open( "GET", url, true );
  xhr.responseType = "arraybuffer";

  xhr.send( null );

};


THREE.CTMLoader.prototype.createModel = function ( file, callback ) {

  var Model = function () {

    THREE.BufferGeometry.call( this );

    this.materials = [];

    var indices = file.body.indices;
    var positions = file.body.vertices;
    var normals = file.body.normals;

    var uvs, colors;

    var uvMaps = file.body.uvMaps;

    if ( uvMaps !== undefined && uvMaps.length > 0 ) {

      uvs = uvMaps[ 0 ].uv;

    }

    var attrMaps = file.body.attrMaps;

    if ( attrMaps !== undefined && attrMaps.length > 0 && attrMaps[ 0 ].name === 'Color' ) {

      colors = attrMaps[ 0 ].attr;

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    if ( normals !== undefined ) {

      this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

    }

    if ( uvs !== undefined ) {

      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    }

    if ( colors !== undefined ) {

      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );

    }

  };

  Model.prototype = Object.create( THREE.BufferGeometry.prototype );
  Model.prototype.constructor = Model;

  var geometry = new Model();

  // compute vertex normals if not present in the CTM model
  if ( geometry.attributes.normal === undefined ) {

    geometry.computeVertexNormals();

  }

  callback( geometry );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJExporter = function () {};

THREE.OBJExporter.prototype = {

  constructor: THREE.OBJExporter,

  parse: function ( object ) {

    var output = '';

    var indexVertex = 0;
    var indexVertexUvs = 0;
    var indexNormals = 0;

    var vertex = new THREE.Vector3();
    var normal = new THREE.Vector3();
    var uv = new THREE.Vector2();

    var i, j, k, l, m, face = [];

    var parseMesh = function ( mesh ) {

      var nbVertex = 0;
      var nbNormals = 0;
      var nbVertexUvs = 0;

      var geometry = mesh.geometry;

      var normalMatrixWorld = new THREE.Matrix3();

      if ( geometry instanceof THREE.Geometry ) {

        geometry = new THREE.BufferGeometry().setFromObject( mesh );

      }

      if ( geometry instanceof THREE.BufferGeometry ) {

        // shortcuts
        var vertices = geometry.getAttribute( 'position' );
        var normals = geometry.getAttribute( 'normal' );
        var uvs = geometry.getAttribute( 'uv' );
        var indices = geometry.getIndex();

        // name of the mesh object
        output += 'o ' + mesh.name + '\n';

        // name of the mesh material
        if ( mesh.material && mesh.material.name ) {

          output += 'usemtl ' + mesh.material.name + '\n';

        }

        // vertices

        if ( vertices !== undefined ) {

          for ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

            vertex.x = vertices.getX( i );
            vertex.y = vertices.getY( i );
            vertex.z = vertices.getZ( i );

            // transfrom the vertex to world space
            vertex.applyMatrix4( mesh.matrixWorld );

            // transform the vertex to export format
            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

          }

        }

        // uvs

        if ( uvs !== undefined ) {

          for ( i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {

            uv.x = uvs.getX( i );
            uv.y = uvs.getY( i );

            // transform the uv to export format
            output += 'vt ' + uv.x + ' ' + uv.y + '\n';

          }

        }

        // normals

        if ( normals !== undefined ) {

          normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

          for ( i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {

            normal.x = normals.getX( i );
            normal.y = normals.getY( i );
            normal.z = normals.getZ( i );

            // transfrom the normal to world space
            normal.applyMatrix3( normalMatrixWorld );

            // transform the normal to export format
            output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';

          }

        }

        // faces

        if ( indices !== null ) {

          for ( i = 0, l = indices.count; i < l; i += 3 ) {

            for ( m = 0; m < 3; m ++ ) {

              j = indices.getX( i + m ) + 1;

              face[ m ] = ( indexVertex + j ) + '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + '/' + ( indexNormals + j );

            }

            // transform the face to export format
            output += 'f ' + face.join( ' ' ) + "\n";

          }

        } else {

          for ( i = 0, l = vertices.count; i < l; i += 3 ) {

            for ( m = 0; m < 3; m ++ ) {

              j = i + m + 1;

              face[ m ] = ( indexVertex + j ) + '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + '/' + ( indexNormals + j );

            }

            // transform the face to export format
            output += 'f ' + face.join( ' ' ) + "\n";

          }

        }

      } else {

        console.warn( 'THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry );

      }

      // update index
      indexVertex += nbVertex;
      indexVertexUvs += nbVertexUvs;
      indexNormals += nbNormals;

    };

    var parseLine = function ( line ) {

      var nbVertex = 0;

      var geometry = line.geometry;
      var type = line.type;

      if ( geometry instanceof THREE.Geometry ) {

        geometry = new THREE.BufferGeometry().setFromObject( line );

      }

      if ( geometry instanceof THREE.BufferGeometry ) {

        // shortcuts
        var vertices = geometry.getAttribute( 'position' );

        // name of the line object
        output += 'o ' + line.name + '\n';

        if ( vertices !== undefined ) {

          for ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

            vertex.x = vertices.getX( i );
            vertex.y = vertices.getY( i );
            vertex.z = vertices.getZ( i );

            // transfrom the vertex to world space
            vertex.applyMatrix4( line.matrixWorld );

            // transform the vertex to export format
            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

          }

        }

        if ( type === 'Line' ) {

          output += 'l ';

          for ( j = 1, l = vertices.count; j <= l; j ++ ) {

            output += ( indexVertex + j ) + ' ';

          }

          output += '\n';

        }

        if ( type === 'LineSegments' ) {

          for ( j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {

            output += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\n';

          }

        }

      } else {

        console.warn( 'THREE.OBJExporter.parseLine(): geometry type unsupported', geometry );

      }

      // update index
      indexVertex += nbVertex;

    };

    object.traverse( function ( child ) {

      if ( child instanceof THREE.Mesh ) {

        parseMesh( child );

      }

      if ( child instanceof THREE.Line ) {

        parseLine( child );

      }

    } );

    return output;

  }

};

/**
 * @author fernandojsg / http://fernandojsg.com
 */

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
var WEBGL_CONSTANTS = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,

  UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT: 0x1403,
  FLOAT: 0x1406,
  UNSIGNED_INT: 0x1405,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,

  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703
};

var THREE_TO_WEBGL = {
  // @TODO Replace with computed property name [THREE.*] when available on es6
  1003: WEBGL_CONSTANTS.NEAREST,
  1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,
  1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,
  1006: WEBGL_CONSTANTS.LINEAR,
  1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,
  1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR
};

//------------------------------------------------------------------------------
// GLTF Exporter
//------------------------------------------------------------------------------
THREE.GLTFExporter = function () {};

THREE.GLTFExporter.prototype = {

  constructor: THREE.GLTFExporter,

  /**
   * Parse scenes and generate GLTF output
   * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   *                          trs: Exports position, rotation and scale instead of matrix
   */
  parse: function ( input, onDone, options ) {

    var DEFAULT_OPTIONS = {
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true
    };

    options = Object.assign( {}, DEFAULT_OPTIONS, options );

    var outputJSON = {

      asset: {

        version: "2.0",
        generator: "THREE.GLTFExporter"

      }

    };

    var byteOffset = 0;
    var dataViews = [];
    var cachedData = {

      images: {},
      materials: {}

    };

    /**
     * Compare two arrays
     */
    /**
     * Compare two arrays
     * @param  {Array} array1 Array 1 to compare
     * @param  {Array} array2 Array 2 to compare
     * @return {Boolean}        Returns true if both arrays are equal
     */
    function equalArray( array1, array2 ) {

      return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

        return element === array2[ index ];

      } );

    }

    /**
     * Get the min and he max vectors from the given attribute
     * @param  {THREE.WebGLAttribute} attribute Attribute to find the min/max
     * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
     */
    function getMinMax( attribute ) {

      var output = {

        min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
        max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

      };

      for ( var i = 0; i < attribute.count; i ++ ) {

        for ( var a = 0; a < attribute.itemSize; a ++ ) {

          var value = attribute.array[ i * attribute.itemSize + a ];
          output.min[ a ] = Math.min( output.min[ a ], value );
          output.max[ a ] = Math.max( output.max[ a ], value );

        }

      }

      return output;

    }

    /**
     * Process a buffer to append to the default one.
     * @param  {THREE.BufferAttribute} attribute     Attribute to store
     * @param  {Integer} componentType Component type (Unsigned short, unsigned int or float)
     * @return {Integer}               Index of the buffer created (Currently always 0)
     */
    function processBuffer( attribute, componentType, start, count ) {

      if ( ! outputJSON.buffers ) {

        outputJSON.buffers = [

          {

            byteLength: 0,
            uri: ''

          }

        ];

      }

      var offset = 0;
      var componentSize = componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ? 2 : 4;

      // Create a new dataview and dump the attribute's array into it
      var byteLength = count * attribute.itemSize * componentSize;

      var dataView = new DataView( new ArrayBuffer( byteLength ) );

      for ( var i = start; i < start + count; i ++ ) {

        for ( var a = 0; a < attribute.itemSize; a ++ ) {

          var value = attribute.array[ i * attribute.itemSize + a ];

          if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

            dataView.setFloat32( offset, value, true );

          } else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

            dataView.setUint8( offset, value, true );

          } else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

            dataView.setUint16( offset, value, true );

          }

          offset += componentSize;

        }

      }

      // We just use one buffer
      dataViews.push( dataView );

      // Always using just one buffer
      return 0;

    }

    /**
     * Process and generate a BufferView
     * @param  {[type]} data [description]
     * @return {[type]}      [description]
     */
    function processBufferView( data, componentType, start, count ) {

      var isVertexAttributes = componentType === WEBGL_CONSTANTS.FLOAT;

      if ( ! outputJSON.bufferViews ) {

        outputJSON.bufferViews = [];

      }

      var componentSize = componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ? 2 : 4;

      // Create a new dataview and dump the attribute's array into it
      var byteLength = count * data.itemSize * componentSize;

      var gltfBufferView = {

        buffer: processBuffer( data, componentType, start, count ),
        byteOffset: byteOffset,
        byteLength: byteLength,
        byteStride: data.itemSize * componentSize,
        target: isVertexAttributes ? WEBGL_CONSTANTS.ARRAY_BUFFER : WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER

      };

      byteOffset += byteLength;

      outputJSON.bufferViews.push( gltfBufferView );

      // @TODO Ideally we'll have just two bufferviews: 0 is for vertex attributes, 1 for indices
      var output = {

        id: outputJSON.bufferViews.length - 1,
        byteLength: 0

      };

      return output;

    }

    /**
     * Process attribute to generate an accessor
     * @param  {THREE.WebGLAttribute} attribute Attribute to process
     * @return {Integer}           Index of the processed accessor on the "accessors" array
     */
    function processAccessor( attribute, geometry ) {

      if ( ! outputJSON.accessors ) {

        outputJSON.accessors = [];

      }

      var types = [

        'SCALAR',
        'VEC2',
        'VEC3',
        'VEC4'

      ];

      var componentType;

      // Detect the component type of the attribute array (float, uint or ushort)
      if ( attribute.array.constructor === Float32Array ) {

        componentType = WEBGL_CONSTANTS.FLOAT;

      } else if ( attribute.array.constructor === Uint32Array ) {

        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

      } else if ( attribute.array.constructor === Uint16Array ) {

        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

      } else {

        throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );

      }

      var minMax = getMinMax( attribute );

      var start = 0;
      var count = attribute.count;

      // @TODO Indexed buffer geometry with drawRange not supported yet
      if ( options.truncateDrawRange && geometry.index === null ) {

        start = geometry.drawRange.start;
        count = geometry.drawRange.count !== Infinity ? geometry.drawRange.count : attribute.count;

      }

      var bufferView = processBufferView( attribute, componentType, start, count );

      var gltfAccessor = {

        bufferView: bufferView.id,
        byteOffset: bufferView.byteOffset,
        componentType: componentType,
        count: count,
        max: minMax.max,
        min: minMax.min,
        type: types[ attribute.itemSize - 1 ]

      };

      outputJSON.accessors.push( gltfAccessor );

      return outputJSON.accessors.length - 1;

    }

    /**
     * Process image
     * @param  {Texture} map Texture to process
     * @return {Integer}     Index of the processed texture in the "images" array
     */
    function processImage( map ) {

      if ( cachedData.images[ map.uuid ] ) {

        return cachedData.images[ map.uuid ];

      }

      if ( ! outputJSON.images ) {

        outputJSON.images = [];

      }

      var gltfImage = {};

      if ( options.embedImages ) {

        // @TODO { bufferView, mimeType }

      } else {

        // @TODO base64 based on options
        gltfImage.uri = map.image.src;

      }

      outputJSON.images.push( gltfImage );

      var index = outputJSON.images.length - 1;
      cachedData.images[ map.uuid ] = index;

      return index;

    }

    /**
     * Process sampler
     * @param  {Texture} map Texture to process
     * @return {Integer}     Index of the processed texture in the "samplers" array
     */
    function processSampler( map ) {

      if ( ! outputJSON.samplers ) {

        outputJSON.samplers = [];

      }

      var gltfSampler = {

        magFilter: THREE_TO_WEBGL[ map.magFilter ],
        minFilter: THREE_TO_WEBGL[ map.minFilter ],
        wrapS: THREE_TO_WEBGL[ map.wrapS ],
        wrapT: THREE_TO_WEBGL[ map.wrapT ]

      };

      outputJSON.samplers.push( gltfSampler );

      return outputJSON.samplers.length - 1;

    }

    /**
     * Process texture
     * @param  {Texture} map Map to process
     * @return {Integer}     Index of the processed texture in the "textures" array
     */
    function processTexture( map ) {

      if ( ! outputJSON.textures ) {

        outputJSON.textures = [];

      }

      var gltfTexture = {

        sampler: processSampler( map ),
        source: processImage( map )

      };

      outputJSON.textures.push( gltfTexture );

      return outputJSON.textures.length - 1;

    }

    /**
     * Process material
     * @param  {THREE.Material} material Material to process
     * @return {Integer}      Index of the processed material in the "materials" array
     */
    function processMaterial( material ) {

      if ( cachedData.materials[ material.uuid ] ) {

        return cachedData.materials[ material.uuid ];

      }

      if ( ! outputJSON.materials ) {

        outputJSON.materials = [];

      }

      if ( material instanceof THREE.ShaderMaterial ) {

        console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
        return null;

      }


      if ( ! ( material instanceof THREE.MeshStandardMaterial ) ) {

        console.warn( 'GLTFExporter: Currently just THREE.StandardMaterial is supported. Material conversion may lose information.' );

      }

      // @QUESTION Should we avoid including any attribute that has the default value?
      var gltfMaterial = {

        pbrMetallicRoughness: {}

      };

      // pbrMetallicRoughness.baseColorFactor
      var color = material.color.toArray().concat( [ material.opacity ] );

      if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

        gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;

      }

      if ( material instanceof THREE.MeshStandardMaterial ) {

        gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;
        gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;

      } else {

        gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
        gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;

      }

      // pbrMetallicRoughness.baseColorTexture
      if ( material.map ) {

        gltfMaterial.pbrMetallicRoughness.baseColorTexture = {

          index: processTexture(material.map )

        };

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
        material instanceof THREE.LineBasicMaterial ||
        material instanceof THREE.PointsMaterial ) {

      } else {

        // emissiveFactor
        var emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();

        if ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {

          gltfMaterial.emissiveFactor = emissive;

        }

        // emissiveTexture
        if ( material.emissiveMap ) {

          gltfMaterial.emissiveTexture = {

            index: processTexture(material.emissiveMap )

          };

        }

      }

      // normalTexture
      if ( material.normalMap ) {

        gltfMaterial.normalTexture = {

          index: processTexture(material.normalMap )

        };

        if ( material.normalScale.x !== - 1 ) {

          if ( material.normalScale.x !== material.normalScale.y ) {

            console.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );

          }

          gltfMaterial.normalTexture.scale = material.normalScale.x;

        }

      }

      // occlusionTexture
      if ( material.aoMap ) {

        gltfMaterial.occlusionTexture = {

          index: processTexture(material.aoMap )

        };

        if ( material.aoMapIntensity !== 1.0 ) {

          gltfMaterial.occlusionTexture.strength = material.aoMapIntensity;

        }

      }

      // alphaMode
      if ( material.transparent ) {

        gltfMaterial.alphaMode = 'MASK'; // @FIXME We should detect MASK or BLEND

        if ( material.alphaTest !== 0.5 ) {

          gltfMaterial.alphaCutoff = material.alphaTest;

        }

      }

      // doubleSided
      if ( material.side === THREE.DoubleSide ) {

        gltfMaterial.doubleSided = true;

      }

      if ( material.name ) {

        gltfMaterial.name = material.name;

      }

      outputJSON.materials.push( gltfMaterial );

      var index = outputJSON.materials.length - 1;
      cachedData.materials[ material.uuid ] = index;

      return index;

    }

    /**
     * Process mesh
     * @param  {THREE.Mesh} mesh Mesh to process
     * @return {Integer}      Index of the processed mesh in the "meshes" array
     */
    function processMesh( mesh ) {

      if ( ! outputJSON.meshes ) {

        outputJSON.meshes = [];

      }

      var geometry = mesh.geometry;

      var mode;

      // Use the correct mode
      if ( mesh instanceof THREE.LineSegments ) {

        mode = WEBGL_CONSTANTS.LINES;

      } else if ( mesh instanceof THREE.LineLoop ) {

        mode = WEBGL_CONSTANTS.LINE_LOOP;

      } else if ( mesh instanceof THREE.Line ) {

        mode = WEBGL_CONSTANTS.LINE_STRIP;

      } else if ( mesh instanceof THREE.Points ) {

        mode = WEBGL_CONSTANTS.POINTS;

      } else {

        if ( ! geometry.isBufferGeometry ) {

          var geometryTemp = new THREE.BufferGeometry();
          geometryTemp.fromGeometry( geometry );
          geometry = geometryTemp;

        }

        if ( mesh.drawMode === THREE.TriangleFanDrawMode ) {

          console.warn( 'GLTFExporter: TriangleFanDrawMode and wireframe incompatible.' );
          mode = WEBGL_CONSTANTS.TRIANGLE_FAN;

        } else if ( mesh.drawMode === THREE.TriangleStripDrawMode ) {

          mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;

        } else {

          mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

        }

      }

      var gltfMesh = {
        primitives: [
          {
            mode: mode,
            attributes: {},
          }
        ]
      };

      var material = processMaterial( mesh.material );
      if ( material !== null ) {

        gltfMesh.primitives[ 0 ].material = material;

      }


      if ( geometry.index ) {

        gltfMesh.primitives[ 0 ].indices = processAccessor( geometry.index, geometry );

      }

      // We've just one primitive per mesh
      var gltfAttributes = gltfMesh.primitives[ 0 ].attributes;

      // Conversion between attributes names in threejs and gltf spec
      var nameConversion = {

        uv: 'TEXCOORD_0',
        uv2: 'TEXCOORD_1',
        color: 'COLOR_0',
        skinWeight: 'WEIGHTS_0',
        skinIndex: 'JOINTS_0'

      };

      // @QUESTION Detect if .vertexColors = THREE.VertexColors?
      // For every attribute create an accessor
      for ( var attributeName in geometry.attributes ) {

        var attribute = geometry.attributes[ attributeName ];
        attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();
        gltfAttributes[ attributeName ] = processAccessor( attribute, geometry );

      }

      outputJSON.meshes.push( gltfMesh );

      return outputJSON.meshes.length - 1;

    }

    /**
     * Process camera
     * @param  {THREE.Camera} camera Camera to process
     * @return {Integer}      Index of the processed mesh in the "camera" array
     */
    function processCamera( camera ) {

      if ( ! outputJSON.cameras ) {

        outputJSON.cameras = [];

      }

      var isOrtho = camera instanceof THREE.OrthographicCamera;

      var gltfCamera = {

        type: isOrtho ? 'orthographic' : 'perspective'

      };

      if ( isOrtho ) {

        gltfCamera.orthographic = {

          xmag: camera.right * 2,
          ymag: camera.top * 2,
          zfar: camera.far,
          znear: camera.near

        };

      } else {

        gltfCamera.perspective = {

          aspectRatio: camera.aspect,
          yfov: THREE.Math.degToRad( camera.fov ) / camera.aspect,
          zfar: camera.far,
          znear: camera.near

        };

      }

      if ( camera.name ) {

        gltfCamera.name = camera.type;

      }

      outputJSON.cameras.push( gltfCamera );

      return outputJSON.cameras.length - 1;

    }

    /**
     * Process Object3D node
     * @param  {THREE.Object3D} node Object3D to processNode
     * @return {Integer}      Index of the node in the nodes list
     */
    function processNode( object ) {

      if ( object instanceof THREE.Light ) {

        console.warn( 'GLTFExporter: Unsupported node type:', object.constructor.name );
        return null;

      }

      if ( ! outputJSON.nodes ) {

        outputJSON.nodes = [];

      }

      var gltfNode = {};

      if ( options.trs ) {

        var rotation = object.quaternion.toArray();
        var position = object.position.toArray();
        var scale = object.scale.toArray();

        if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

          gltfNode.rotation = rotation;

        }

        if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

          gltfNode.position = position;

        }

        if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

          gltfNode.scale = scale;

        }

      } else {

        object.updateMatrix();
        if ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {

          gltfNode.matrix = object.matrix.elements;

        }

      }

      if ( object.name ) {

        gltfNode.name = object.name;

      }

      if ( object.userData && Object.keys( object.userData ).length > 0 ) {

        try {

          gltfNode.extras = JSON.parse( JSON.stringify( object.userData ) );

        } catch ( e ) {

          throw new Error( 'THREE.GLTFExporter: userData can\'t be serialized' );

        }

      }

      if ( object instanceof THREE.Mesh ||
        object instanceof THREE.Line ||
        object instanceof THREE.Points ) {

        gltfNode.mesh = processMesh( object );

      } else if ( object instanceof THREE.Camera ) {

        gltfNode.camera = processCamera( object );

      }

      if ( object.children.length > 0 ) {

        var children = [];

        for ( var i = 0, l = object.children.length; i < l; i ++ ) {

          var child = object.children[ i ];

          if ( child.visible || options.onlyVisible === false ) {

            var node = processNode( child );

            if ( node !== null ) {

              children.push( node );

            }

          }

        }

        if ( children.length > 0 ) {

          gltfNode.children = children;

        }


      }

      outputJSON.nodes.push( gltfNode );

      return outputJSON.nodes.length - 1;

    }

    /**
     * Process Scene
     * @param  {THREE.Scene} node Scene to process
     */
    function processScene( scene ) {

      if ( ! outputJSON.scenes ) {

        outputJSON.scenes = [];
        outputJSON.scene = 0;

      }

      var gltfScene = {

        nodes: []

      };

      if ( scene.name ) {

        gltfScene.name = scene.name;

      }

      outputJSON.scenes.push( gltfScene );

      var nodes = [];

      for ( var i = 0, l = scene.children.length; i < l; i ++ ) {

        var child = scene.children[ i ];

        if ( child.visible || options.onlyVisible === false ) {

          var node = processNode( child );

          if ( node !== null ) {

            nodes.push( node );

          }

        }

      }

      if ( nodes.length > 0 ) {

        gltfScene.nodes = nodes;

      }

    }

    /**
     * Creates a THREE.Scene to hold a list of objects and parse it
     * @param  {Array} objects List of objects to process
     */
    function processObjects( objects ) {

      var scene = new THREE.Scene();
      scene.name = 'AuxScene';

      for ( var i = 0; i < objects.length; i ++ ) {

        // We push directly to children instead of calling `add` to prevent
        // modify the .parent and break its original scene and hierarchy
        scene.children.push( objects[ i ] );

      }

      processScene( scene );

    }

    function processInput( input ) {

      input = input instanceof Array ? input : [ input ];

      var objectsWithoutScene = [];

      for ( var i = 0; i < input.length; i ++ ) {

        if ( input[ i ] instanceof THREE.Scene ) {

          processScene( input[ i ] );

        } else {

          objectsWithoutScene.push( input[ i ] );

        }

      }

      if ( objectsWithoutScene.length > 0 ) {

        processObjects( objectsWithoutScene );

      }

    }

    processInput( input );

    // Generate buffer
    // Create a new blob with all the dataviews from the buffers
    var blob = new Blob( dataViews, { type: 'application/octet-stream' } );

    // Update the bytlength of the only main buffer and update the uri with the base64 representation of it
    if ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {

      outputJSON.buffers[ 0 ].byteLength = blob.size;
      var objectURL = URL.createObjectURL( blob );

      var reader = new window.FileReader();
      reader.readAsDataURL( blob );
      reader.onloadend = function () {

        var base64data = reader.result;
        outputJSON.buffers[ 0 ].uri = base64data;
        onDone( outputJSON );

      };

    } else {

      onDone( outputJSON );

    }

  }

};

/**
 * @author kovacsv / http://kovacsv.hu/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.STLExporter = function () {};

THREE.STLExporter.prototype = {

  constructor: THREE.STLExporter,

  parse: ( function () {

    var vector = new THREE.Vector3();
    var normalMatrixWorld = new THREE.Matrix3();

    return function parse( scene ) {

      var output = '';

      output += 'solid exported\n';

      scene.traverse( function ( object ) {

        if ( object instanceof THREE.Mesh ) {

          var geometry = object.geometry;
          var matrixWorld = object.matrixWorld;

          if ( geometry instanceof THREE.BufferGeometry ) {

            geometry = new THREE.Geometry().fromBufferGeometry( geometry );

          }

          if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var faces = geometry.faces;

            normalMatrixWorld.getNormalMatrix( matrixWorld );

            for ( var i = 0, l = faces.length; i < l; i ++ ) {

              var face = faces[ i ];

              vector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();

              output += '\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
              output += '\t\touter loop\n';

              var indices = [ face.a, face.b, face.c ];

              for ( var j = 0; j < 3; j ++ ) {

                vector.copy( vertices[ indices[ j ] ] ).applyMatrix4( matrixWorld );

                output += '\t\t\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';

              }

              output += '\t\tendloop\n';
              output += '\tendfacet\n';

            }

          }

        }

      } );

      output += 'endsolid exported\n';

      return output;

    };

  }() )

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.RenderableObject = function () {

  this.id = 0;

  this.object = null;
  this.z = 0;
  this.renderOrder = 0;

};

//

THREE.RenderableFace = function () {

  this.id = 0;

  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();

  this.normalModel = new THREE.Vector3();

  this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
  this.vertexNormalsLength = 0;

  this.color = new THREE.Color();
  this.material = null;
  this.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];

  this.z = 0;
  this.renderOrder = 0;

};

//

THREE.RenderableVertex = function () {


  this.position = new THREE.Vector3();
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();

  this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

  this.positionWorld.copy( vertex.positionWorld );
  this.positionScreen.copy( vertex.positionScreen );

};

//

THREE.RenderableLine = function () {

  this.id = 0;

  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();

  this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
  this.material = null;

  this.z = 0;
  this.renderOrder = 0;

};

//

THREE.RenderableSprite = function () {

  this.id = 0;

  this.object = null;

  this.x = 0;
  this.y = 0;
  this.z = 0;

  this.rotation = 0;
  this.scale = new THREE.Vector2();

  this.material = null;
  this.renderOrder = 0;

};

//

THREE.Projector = function () {

  var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
    _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
    _face, _faceCount, _facePool = [], _facePoolLength = 0,
    _line, _lineCount, _linePool = [], _linePoolLength = 0,
    _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

    _renderData = { objects: [], lights: [], elements: [] },

    _vector3 = new THREE.Vector3(),
    _vector4 = new THREE.Vector4(),

    _clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),
    _boundingBox = new THREE.Box3(),
    _points3 = new Array( 3 ),

    _viewMatrix = new THREE.Matrix4(),
    _viewProjectionMatrix = new THREE.Matrix4(),

    _modelMatrix,
    _modelViewProjectionMatrix = new THREE.Matrix4(),

    _normalMatrix = new THREE.Matrix3(),

    _frustum = new THREE.Frustum(),

    _clippedVertex1PositionScreen = new THREE.Vector4(),
    _clippedVertex2PositionScreen = new THREE.Vector4();

  //

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function () {

    console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  };

  //

  var RenderList = function () {

    var normals = [];
    var colors = [];
    var uvs = [];

    var object = null;
    var material = null;

    var normalMatrix = new THREE.Matrix3();

    function setObject( value ) {

      object = value;
      material = object.material;

      normalMatrix.getNormalMatrix( object.matrixWorld );

      normals.length = 0;
      colors.length = 0;
      uvs.length = 0;

    }

    function projectVertex( vertex ) {

      var position = vertex.position;
      var positionWorld = vertex.positionWorld;
      var positionScreen = vertex.positionScreen;

      positionWorld.copy( position ).applyMatrix4( _modelMatrix );
      positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

      var invW = 1 / positionScreen.w;

      positionScreen.x *= invW;
      positionScreen.y *= invW;
      positionScreen.z *= invW;

      vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&
           positionScreen.y >= - 1 && positionScreen.y <= 1 &&
           positionScreen.z >= - 1 && positionScreen.z <= 1;

    }

    function pushVertex( x, y, z ) {

      _vertex = getNextVertexInPool();
      _vertex.position.set( x, y, z );

      projectVertex( _vertex );

    }

    function pushNormal( x, y, z ) {

      normals.push( x, y, z );

    }

    function pushColor( r, g, b ) {

      colors.push( r, g, b );

    }

    function pushUv( x, y ) {

      uvs.push( x, y );

    }

    function checkTriangleVisibility( v1, v2, v3 ) {

      if ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;

      _points3[ 0 ] = v1.positionScreen;
      _points3[ 1 ] = v2.positionScreen;
      _points3[ 2 ] = v3.positionScreen;

      return _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );

    }

    function checkBackfaceCulling( v1, v2, v3 ) {

      return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
            ( v2.positionScreen.y - v1.positionScreen.y ) -
            ( v3.positionScreen.y - v1.positionScreen.y ) *
            ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

    }

    function pushLine( a, b ) {

      var v1 = _vertexPool[ a ];
      var v2 = _vertexPool[ b ];

      // Clip

      v1.positionScreen.copy( v1.position ).applyMatrix4( _modelViewProjectionMatrix );
      v2.positionScreen.copy( v2.position ).applyMatrix4( _modelViewProjectionMatrix );

      if ( clipLine( v1.positionScreen, v2.positionScreen ) === true ) {

        // Perform the perspective divide
        v1.positionScreen.multiplyScalar( 1 / v1.positionScreen.w );
        v2.positionScreen.multiplyScalar( 1 / v2.positionScreen.w );

        _line = getNextLineInPool();
        _line.id = object.id;
        _line.v1.copy( v1 );
        _line.v2.copy( v2 );
        _line.z = Math.max( v1.positionScreen.z, v2.positionScreen.z );
        _line.renderOrder = object.renderOrder;

        _line.material = object.material;

        if ( object.material.vertexColors === THREE.VertexColors ) {

          _line.vertexColors[ 0 ].fromArray( colors, a * 3 );
          _line.vertexColors[ 1 ].fromArray( colors, b * 3 );

        }

        _renderData.elements.push( _line );

      }

    }

    function pushTriangle( a, b, c ) {

      var v1 = _vertexPool[ a ];
      var v2 = _vertexPool[ b ];
      var v3 = _vertexPool[ c ];

      if ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;

      if ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {

        _face = getNextFaceInPool();

        _face.id = object.id;
        _face.v1.copy( v1 );
        _face.v2.copy( v2 );
        _face.v3.copy( v3 );
        _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;
        _face.renderOrder = object.renderOrder;

        // use first vertex normal as face normal

        _face.normalModel.fromArray( normals, a * 3 );
        _face.normalModel.applyMatrix3( normalMatrix ).normalize();

        for ( var i = 0; i < 3; i ++ ) {

          var normal = _face.vertexNormalsModel[ i ];
          normal.fromArray( normals, arguments[ i ] * 3 );
          normal.applyMatrix3( normalMatrix ).normalize();

          var uv = _face.uvs[ i ];
          uv.fromArray( uvs, arguments[ i ] * 2 );

        }

        _face.vertexNormalsLength = 3;

        _face.material = object.material;

        _renderData.elements.push( _face );

      }

    }

    return {
      setObject: setObject,
      projectVertex: projectVertex,
      checkTriangleVisibility: checkTriangleVisibility,
      checkBackfaceCulling: checkBackfaceCulling,
      pushVertex: pushVertex,
      pushNormal: pushNormal,
      pushColor: pushColor,
      pushUv: pushUv,
      pushLine: pushLine,
      pushTriangle: pushTriangle
    };

  };

  var renderList = new RenderList();

  function projectObject( object ) {

    if ( object.visible === false ) return;

    if ( object instanceof THREE.Light ) {

      _renderData.lights.push( object );

    } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

      if ( object.material.visible === false ) return;
      if ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;

      addObject( object );

    } else if ( object instanceof THREE.Sprite ) {

      if ( object.material.visible === false ) return;
      if ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;

      addObject( object );

    }

    var children = object.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      projectObject( children[ i ] );

    }

  }

  function addObject( object ) {

    _object = getNextObjectInPool();
    _object.id = object.id;
    _object.object = object;

    _vector3.setFromMatrixPosition( object.matrixWorld );
    _vector3.applyMatrix4( _viewProjectionMatrix );
    _object.z = _vector3.z;
    _object.renderOrder = object.renderOrder;

    _renderData.objects.push( _object );

  }

  this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

    _faceCount = 0;
    _lineCount = 0;
    _spriteCount = 0;

    _renderData.elements.length = 0;

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
    if ( camera.parent === null ) camera.updateMatrixWorld();

    _viewMatrix.copy( camera.matrixWorldInverse );
    _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

    _frustum.setFromMatrix( _viewProjectionMatrix );

    //

    _objectCount = 0;

    _renderData.objects.length = 0;
    _renderData.lights.length = 0;

    projectObject( scene );

    if ( sortObjects === true ) {

      _renderData.objects.sort( painterSort );

    }

    //

    var objects = _renderData.objects;

    for ( var o = 0, ol = objects.length; o < ol; o ++ ) {

      var object = objects[ o ].object;
      var geometry = object.geometry;

      renderList.setObject( object );

      _modelMatrix = object.matrixWorld;

      _vertexCount = 0;

      if ( object instanceof THREE.Mesh ) {

        if ( geometry instanceof THREE.BufferGeometry ) {

          var attributes = geometry.attributes;
          var groups = geometry.groups;

          if ( attributes.position === undefined ) continue;

          var positions = attributes.position.array;

          for ( var i = 0, l = positions.length; i < l; i += 3 ) {

            renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

          }

          if ( attributes.normal !== undefined ) {

            var normals = attributes.normal.array;

            for ( var i = 0, l = normals.length; i < l; i += 3 ) {

              renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

            }

          }

          if ( attributes.uv !== undefined ) {

            var uvs = attributes.uv.array;

            for ( var i = 0, l = uvs.length; i < l; i += 2 ) {

              renderList.pushUv( uvs[ i ], uvs[ i + 1 ] );

            }

          }

          if ( geometry.index !== null ) {

            var indices = geometry.index.array;

            if ( groups.length > 0 ) {

              for ( var g = 0; g < groups.length; g ++ ) {

                var group = groups[ g ];

                for ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {

                  renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

              }

            } else {

              for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

              }

            }

          } else {

            for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

              renderList.pushTriangle( i, i + 1, i + 2 );

            }

          }

        } else if ( geometry instanceof THREE.Geometry ) {

          var vertices = geometry.vertices;
          var faces = geometry.faces;
          var faceVertexUvs = geometry.faceVertexUvs[ 0 ];

          _normalMatrix.getNormalMatrix( _modelMatrix );

          var material = object.material;

          var isMultiMaterial = Array.isArray( material );

          for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

            var vertex = vertices[ v ];

            _vector3.copy( vertex );

            if ( material.morphTargets === true ) {

              var morphTargets = geometry.morphTargets;
              var morphInfluences = object.morphTargetInfluences;

              for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                var influence = morphInfluences[ t ];

                if ( influence === 0 ) continue;

                var target = morphTargets[ t ];
                var targetVertex = target.vertices[ v ];

                _vector3.x += ( targetVertex.x - vertex.x ) * influence;
                _vector3.y += ( targetVertex.y - vertex.y ) * influence;
                _vector3.z += ( targetVertex.z - vertex.z ) * influence;

              }

            }

            renderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );

          }

          for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

            var face = faces[ f ];

            material = isMultiMaterial === true
               ? object.material[ face.materialIndex ]
               : object.material;

            if ( material === undefined ) continue;

            var side = material.side;

            var v1 = _vertexPool[ face.a ];
            var v2 = _vertexPool[ face.b ];
            var v3 = _vertexPool[ face.c ];

            if ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;

            var visible = renderList.checkBackfaceCulling( v1, v2, v3 );

            if ( side !== THREE.DoubleSide ) {

              if ( side === THREE.FrontSide && visible === false ) continue;
              if ( side === THREE.BackSide && visible === true ) continue;

            }

            _face = getNextFaceInPool();

            _face.id = object.id;
            _face.v1.copy( v1 );
            _face.v2.copy( v2 );
            _face.v3.copy( v3 );

            _face.normalModel.copy( face.normal );

            if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

              _face.normalModel.negate();

            }

            _face.normalModel.applyMatrix3( _normalMatrix ).normalize();

            var faceVertexNormals = face.vertexNormals;

            for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

              var normalModel = _face.vertexNormalsModel[ n ];
              normalModel.copy( faceVertexNormals[ n ] );

              if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

                normalModel.negate();

              }

              normalModel.applyMatrix3( _normalMatrix ).normalize();

            }

            _face.vertexNormalsLength = faceVertexNormals.length;

            var vertexUvs = faceVertexUvs[ f ];

            if ( vertexUvs !== undefined ) {

              for ( var u = 0; u < 3; u ++ ) {

                _face.uvs[ u ].copy( vertexUvs[ u ] );

              }

            }

            _face.color = face.color;
            _face.material = material;

            _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;
            _face.renderOrder = object.renderOrder;

            _renderData.elements.push( _face );

          }

        }

      } else if ( object instanceof THREE.Line ) {

        _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

        if ( geometry instanceof THREE.BufferGeometry ) {

          var attributes = geometry.attributes;

          if ( attributes.position !== undefined ) {

            var positions = attributes.position.array;

            for ( var i = 0, l = positions.length; i < l; i += 3 ) {

              renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

            }

            if ( attributes.color !== undefined ) {

              var colors = attributes.color.array;

              for ( var i = 0, l = colors.length; i < l; i += 3 ) {

                renderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );

              }

            }

            if ( geometry.index !== null ) {

              var indices = geometry.index.array;

              for ( var i = 0, l = indices.length; i < l; i += 2 ) {

                renderList.pushLine( indices[ i ], indices[ i + 1 ] );

              }

            } else {

              var step = object instanceof THREE.LineSegments ? 2 : 1;

              for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {

                renderList.pushLine( i, i + 1 );

              }

            }

          }

        } else if ( geometry instanceof THREE.Geometry ) {

          var vertices = object.geometry.vertices;

          if ( vertices.length === 0 ) continue;

          v1 = getNextVertexInPool();
          v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

          var step = object instanceof THREE.LineSegments ? 2 : 1;

          for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

            v1 = getNextVertexInPool();
            v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

            if ( ( v + 1 ) % step > 0 ) continue;

            v2 = _vertexPool[ _vertexCount - 2 ];

            _clippedVertex1PositionScreen.copy( v1.positionScreen );
            _clippedVertex2PositionScreen.copy( v2.positionScreen );

            if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

              // Perform the perspective divide
              _clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
              _clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

              _line = getNextLineInPool();

              _line.id = object.id;
              _line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
              _line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

              _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );
              _line.renderOrder = object.renderOrder;

              _line.material = object.material;

              if ( object.material.vertexColors === THREE.VertexColors ) {

                _line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
                _line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

              }

              _renderData.elements.push( _line );

            }

          }

        }

      } else if ( object instanceof THREE.Points ) {

        _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

        if ( geometry instanceof THREE.Geometry ) {

          var vertices = object.geometry.vertices;

          for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

            var vertex = vertices[ v ];

            _vector4.set( vertex.x, vertex.y, vertex.z, 1 );
            _vector4.applyMatrix4( _modelViewProjectionMatrix );

            pushPoint( _vector4, object, camera );

          }

        } else if ( geometry instanceof THREE.BufferGeometry ) {

          var attributes = geometry.attributes;

          if ( attributes.position !== undefined ) {

            var positions = attributes.position.array;

            for ( var i = 0, l = positions.length; i < l; i += 3 ) {

              _vector4.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ], 1 );
              _vector4.applyMatrix4( _modelViewProjectionMatrix );

              pushPoint( _vector4, object, camera );

            }

          }

        }

      } else if ( object instanceof THREE.Sprite ) {

        _vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );
        _vector4.applyMatrix4( _viewProjectionMatrix );

        pushPoint( _vector4, object, camera );

      }

    }

    if ( sortElements === true ) {

      _renderData.elements.sort( painterSort );

    }

    return _renderData;

  };

  function pushPoint( _vector4, object, camera ) {

    var invW = 1 / _vector4.w;

    _vector4.z *= invW;

    if ( _vector4.z >= - 1 && _vector4.z <= 1 ) {

      _sprite = getNextSpriteInPool();
      _sprite.id = object.id;
      _sprite.x = _vector4.x * invW;
      _sprite.y = _vector4.y * invW;
      _sprite.z = _vector4.z;
      _sprite.renderOrder = object.renderOrder;
      _sprite.object = object;

      _sprite.rotation = object.rotation;

      _sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );
      _sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );

      _sprite.material = object.material;

      _renderData.elements.push( _sprite );

    }

  }

  // Pools

  function getNextObjectInPool() {

    if ( _objectCount === _objectPoolLength ) {

      var object = new THREE.RenderableObject();
      _objectPool.push( object );
      _objectPoolLength ++;
      _objectCount ++;
      return object;

    }

    return _objectPool[ _objectCount ++ ];

  }

  function getNextVertexInPool() {

    if ( _vertexCount === _vertexPoolLength ) {

      var vertex = new THREE.RenderableVertex();
      _vertexPool.push( vertex );
      _vertexPoolLength ++;
      _vertexCount ++;
      return vertex;

    }

    return _vertexPool[ _vertexCount ++ ];

  }

  function getNextFaceInPool() {

    if ( _faceCount === _facePoolLength ) {

      var face = new THREE.RenderableFace();
      _facePool.push( face );
      _facePoolLength ++;
      _faceCount ++;
      return face;

    }

    return _facePool[ _faceCount ++ ];


  }

  function getNextLineInPool() {

    if ( _lineCount === _linePoolLength ) {

      var line = new THREE.RenderableLine();
      _linePool.push( line );
      _linePoolLength ++;
      _lineCount ++;
      return line;

    }

    return _linePool[ _lineCount ++ ];

  }

  function getNextSpriteInPool() {

    if ( _spriteCount === _spritePoolLength ) {

      var sprite = new THREE.RenderableSprite();
      _spritePool.push( sprite );
      _spritePoolLength ++;
      _spriteCount ++;
      return sprite;

    }

    return _spritePool[ _spriteCount ++ ];

  }

  //

  function painterSort( a, b ) {

    if ( a.renderOrder !== b.renderOrder ) {

      return a.renderOrder - b.renderOrder;

    } else if ( a.z !== b.z ) {

      return b.z - a.z;

    } else if ( a.id !== b.id ) {

      return a.id - b.id;

    } else {

      return 0;

    }

  }

  function clipLine( s1, s2 ) {

    var alpha1 = 0, alpha2 = 1,

    // Calculate the boundary coordinate of each vertex for the near and far clip planes,
    // Z = -1 and Z = +1, respectively.

      bc1near = s1.z + s1.w,
      bc2near = s2.z + s2.w,
      bc1far = - s1.z + s1.w,
      bc2far = - s2.z + s2.w;

    if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

      // Both vertices lie entirely within all clip planes.
      return true;

    } else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {

      // Both vertices lie entirely outside one of the clip planes.
      return false;

    } else {

      // The line segment spans at least one clip plane.

      if ( bc1near < 0 ) {

        // v1 lies outside the near plane, v2 inside
        alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

      } else if ( bc2near < 0 ) {

        // v2 lies outside the near plane, v1 inside
        alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

      }

      if ( bc1far < 0 ) {

        // v1 lies outside the far plane, v2 inside
        alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

      } else if ( bc2far < 0 ) {

        // v2 lies outside the far plane, v2 inside
        alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

      }

      if ( alpha2 < alpha1 ) {

        // The line segment spans two boundaries, but is outside both of them.
        // (This can't happen when we're only clipping against just near/far but good
        //  to leave the check here for future usage if other clip planes are added.)
        return false;

      } else {

        // Update the s1 and s2 vertices to match the clipped line segment.
        s1.lerp( s2, alpha1 );
        s2.lerp( s1, 1 - alpha2 );

        return true;

      }

    }

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SpriteCanvasMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteCanvasMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.program = function () {};

  this.setValues( parameters );

};

THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial;
THREE.SpriteCanvasMaterial.prototype.isSpriteCanvasMaterial = true;

THREE.SpriteCanvasMaterial.prototype.clone = function () {

  var material = new THREE.SpriteCanvasMaterial();

  material.copy( this );
  material.color.copy( this.color );
  material.program = this.program;

  return material;

};

//

THREE.CanvasRenderer = function ( parameters ) {

  console.log( 'THREE.CanvasRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _this = this,
    _renderData, _elements, _lights,
    _projector = new THREE.Projector(),

    _canvas = parameters.canvas !== undefined
         ? parameters.canvas
         : document.createElement( 'canvas' ),

    _canvasWidth = _canvas.width,
    _canvasHeight = _canvas.height,
    _canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
    _canvasHeightHalf = Math.floor( _canvasHeight / 2 ),

    _viewportX = 0,
    _viewportY = 0,
    _viewportWidth = _canvasWidth,
    _viewportHeight = _canvasHeight,

    _pixelRatio = 1,

    _context = _canvas.getContext( '2d', {
      alpha: parameters.alpha === true
    } ),

    _clearColor = new THREE.Color( 0x000000 ),
    _clearAlpha = parameters.alpha === true ? 0 : 1,

    _contextGlobalAlpha = 1,
    _contextGlobalCompositeOperation = 0,
    _contextStrokeStyle = null,
    _contextFillStyle = null,
    _contextLineWidth = null,
    _contextLineCap = null,
    _contextLineJoin = null,
    _contextLineDash = [],

    _v1, _v2, _v3,

    _v1x, _v1y, _v2x, _v2y, _v3x, _v3y,

    _color = new THREE.Color(),

    _diffuseColor = new THREE.Color(),
    _emissiveColor = new THREE.Color(),

    _lightColor = new THREE.Color(),

    _patterns = {},

    _uvs,
    _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

    _clipBox = new THREE.Box2(),
    _clearBox = new THREE.Box2(),
    _elemBox = new THREE.Box2(),

    _ambientLight = new THREE.Color(),
    _directionalLights = new THREE.Color(),
    _pointLights = new THREE.Color(),

    _vector3 = new THREE.Vector3(), // Needed for PointLight
    _centroid = new THREE.Vector3(),
    _normal = new THREE.Vector3(),
    _normalViewMatrix = new THREE.Matrix3();

  /* TODO
  _canvas.mozImageSmoothingEnabled = false;
  _canvas.webkitImageSmoothingEnabled = false;
  _canvas.msImageSmoothingEnabled = false;
  _canvas.imageSmoothingEnabled = false;
  */

  // dash+gap fallbacks for Firefox and everything else

  if ( _context.setLineDash === undefined ) {

    _context.setLineDash = function () {};

  }

  this.domElement = _canvas;

  this.autoClear = true;
  this.sortObjects = true;
  this.sortElements = true;

  this.info = {

    render: {

      vertices: 0,
      faces: 0

    }

  };

  // WebGLRenderer compatibility

  this.supportsVertexTextures = function () {};
  this.setFaceCulling = function () {};

  // API

  this.getContext = function () {

    return _context;

  };

  this.getContextAttributes = function () {

    return _context.getContextAttributes();

  };

  this.getPixelRatio = function () {

    return _pixelRatio;

  };

  this.setPixelRatio = function ( value ) {

    if ( value !== undefined ) _pixelRatio = value;

  };

  this.setSize = function ( width, height, updateStyle ) {

    _canvasWidth = width * _pixelRatio;
    _canvasHeight = height * _pixelRatio;

    _canvas.width = _canvasWidth;
    _canvas.height = _canvasHeight;

    _canvasWidthHalf = Math.floor( _canvasWidth / 2 );
    _canvasHeightHalf = Math.floor( _canvasHeight / 2 );

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    _clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
    _clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

    _clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
    _clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

    _contextGlobalAlpha = 1;
    _contextGlobalCompositeOperation = 0;
    _contextStrokeStyle = null;
    _contextFillStyle = null;
    _contextLineWidth = null;
    _contextLineCap = null;
    _contextLineJoin = null;

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewportX = x * _pixelRatio;
    _viewportY = y * _pixelRatio;

    _viewportWidth = width * _pixelRatio;
    _viewportHeight = height * _pixelRatio;

  };

  this.setScissor = function () {};
  this.setScissorTest = function () {};

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );
    _clearAlpha = alpha !== undefined ? alpha : 1;

    _clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
    _clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

  };

  this.setClearColorHex = function ( hex, alpha ) {

    console.warn( 'THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
    this.setClearColor( hex, alpha );

  };

  this.getClearColor = function () {

    return _clearColor;

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.getMaxAnisotropy = function () {

    return 0;

  };

  this.clear = function () {

    if ( _clearBox.isEmpty() === false ) {

      _clearBox.intersect( _clipBox );
      _clearBox.expandByScalar( 2 );

      _clearBox.min.x =   _clearBox.min.x + _canvasWidthHalf;
      _clearBox.min.y = - _clearBox.min.y + _canvasHeightHalf;    // higher y value !
      _clearBox.max.x =   _clearBox.max.x + _canvasWidthHalf;
      _clearBox.max.y = - _clearBox.max.y + _canvasHeightHalf;    // lower y value !

      if ( _clearAlpha < 1 ) {

        _context.clearRect(
          _clearBox.min.x | 0,
          _clearBox.max.y | 0,
          ( _clearBox.max.x - _clearBox.min.x ) | 0,
          ( _clearBox.min.y - _clearBox.max.y ) | 0
        );

      }

      if ( _clearAlpha > 0 ) {

        setOpacity( 1 );
        setBlending( THREE.NormalBlending );

        setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );

        _context.fillRect(
          _clearBox.min.x | 0,
          _clearBox.max.y | 0,
          ( _clearBox.max.x - _clearBox.min.x ) | 0,
          ( _clearBox.min.y - _clearBox.max.y ) | 0
        );

      }

      _clearBox.makeEmpty();

    }

  };

  // compatibility

  this.clearColor = function () {};
  this.clearDepth = function () {};
  this.clearStencil = function () {};

  this.render = function ( scene, camera ) {

    if ( camera.isCamera === undefined ) {

      console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var background = scene.background;

    if ( background && background.isColor ) {

      setOpacity( 1 );
      setBlending( THREE.NormalBlending );

      setFillStyle( background.getStyle() );
      _context.fillRect( 0, 0, _canvasWidth, _canvasHeight );

    } else if ( this.autoClear === true ) {

      this.clear();

    }

    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;

    _context.setTransform( _viewportWidth / _canvasWidth, 0, 0, - _viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY );
    _context.translate( _canvasWidthHalf, _canvasHeightHalf );

    _renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
    _elements = _renderData.elements;
    _lights = _renderData.lights;

    _normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );

    /* DEBUG
    setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
    _context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
    */

    calculateLights();

    for ( var e = 0, el = _elements.length; e < el; e ++ ) {

      var element = _elements[ e ];

      var material = element.material;

      if ( material === undefined || material.opacity === 0 ) continue;

      _elemBox.makeEmpty();

      if ( element instanceof THREE.RenderableSprite ) {

        _v1 = element;
        _v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

        renderSprite( _v1, element, material );

      } else if ( element instanceof THREE.RenderableLine ) {

        _v1 = element.v1; _v2 = element.v2;

        _v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

        _elemBox.setFromPoints( [
          _v1.positionScreen,
          _v2.positionScreen
        ] );

        if ( _clipBox.intersectsBox( _elemBox ) === true ) {

          renderLine( _v1, _v2, element, material );

        }

      } else if ( element instanceof THREE.RenderableFace ) {

        _v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

        if ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) continue;
        if ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) continue;
        if ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) continue;

        _v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
        _v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

        if ( material.overdraw > 0 ) {

          expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
          expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
          expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );

        }

        _elemBox.setFromPoints( [
          _v1.positionScreen,
          _v2.positionScreen,
          _v3.positionScreen
        ] );

        if ( _clipBox.intersectsBox( _elemBox ) === true ) {

          renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

        }

      }

      /* DEBUG
      setLineWidth( 1 );
      setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
      _context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
      */

      _clearBox.union( _elemBox );

    }

    /* DEBUG
    setLineWidth( 1 );
    setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
    _context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
    */

    _context.setTransform( 1, 0, 0, 1, 0, 0 );

  };

  //

  function calculateLights() {

    _ambientLight.setRGB( 0, 0, 0 );
    _directionalLights.setRGB( 0, 0, 0 );
    _pointLights.setRGB( 0, 0, 0 );

    for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

      var light = _lights[ l ];
      var lightColor = light.color;

      if ( light.isAmbientLight ) {

        _ambientLight.add( lightColor );

      } else if ( light.isDirectionalLight ) {

        // for sprites

        _directionalLights.add( lightColor );

      } else if ( light.isPointLight ) {

        // for sprites

        _pointLights.add( lightColor );

      }

    }

  }

  function calculateLight( position, normal, color ) {

    for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

      var light = _lights[ l ];

      _lightColor.copy( light.color );

      if ( light.isDirectionalLight ) {

        var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

        var amount = normal.dot( lightPosition );

        if ( amount <= 0 ) continue;

        amount *= light.intensity;

        color.add( _lightColor.multiplyScalar( amount ) );

      } else if ( light.isPointLight ) {

        var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

        var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

        if ( amount <= 0 ) continue;

        amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

        if ( amount == 0 ) continue;

        amount *= light.intensity;

        color.add( _lightColor.multiplyScalar( amount ) );

      }

    }

  }

  function renderSprite( v1, element, material ) {

    setOpacity( material.opacity );
    setBlending( material.blending );

    var scaleX = element.scale.x * _canvasWidthHalf;
    var scaleY = element.scale.y * _canvasHeightHalf;

    var dist = Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite
    _elemBox.min.set( v1.x - dist, v1.y - dist );
    _elemBox.max.set( v1.x + dist, v1.y + dist );

    if ( material.isSpriteMaterial ) {

      var texture = material.map;

      if ( texture !== null ) {

        var pattern = _patterns[ texture.id ];

        if ( pattern === undefined || pattern.version !== texture.version ) {

          pattern = textureToPattern( texture );
          _patterns[ texture.id ] = pattern;

        }

        if ( pattern.canvas !== undefined ) {

          setFillStyle( pattern.canvas );

          var bitmap = texture.image;

          var ox = bitmap.width * texture.offset.x;
          var oy = bitmap.height * texture.offset.y;

          var sx = bitmap.width * texture.repeat.x;
          var sy = bitmap.height * texture.repeat.y;

          var cx = scaleX / sx;
          var cy = scaleY / sy;

          _context.save();
          _context.translate( v1.x, v1.y );
          if ( material.rotation !== 0 ) _context.rotate( material.rotation );
          _context.translate( - scaleX / 2, - scaleY / 2 );
          _context.scale( cx, cy );
          _context.translate( - ox, - oy );
          _context.fillRect( ox, oy, sx, sy );
          _context.restore();

        }

      } else {

        // no texture

        setFillStyle( material.color.getStyle() );

        _context.save();
        _context.translate( v1.x, v1.y );
        if ( material.rotation !== 0 ) _context.rotate( material.rotation );
        _context.scale( scaleX, - scaleY );
        _context.fillRect( - 0.5, - 0.5, 1, 1 );
        _context.restore();

      }

    } else if ( material.isSpriteCanvasMaterial ) {

      setStrokeStyle( material.color.getStyle() );
      setFillStyle( material.color.getStyle() );

      _context.save();
      _context.translate( v1.x, v1.y );
      if ( material.rotation !== 0 ) _context.rotate( material.rotation );
      _context.scale( scaleX, scaleY );

      material.program( _context );

      _context.restore();

    } else if ( material.isPointsMaterial ) {

      setFillStyle( material.color.getStyle() );

      _context.save();
      _context.translate( v1.x, v1.y );
      if ( material.rotation !== 0 ) _context.rotate( material.rotation );
      _context.scale( scaleX * material.size, - scaleY * material.size );
      _context.fillRect( - 0.5, - 0.5, 1, 1 );
      _context.restore();

    }

    /* DEBUG
    setStrokeStyle( 'rgb(255,255,0)' );
    _context.beginPath();
    _context.moveTo( v1.x - 10, v1.y );
    _context.lineTo( v1.x + 10, v1.y );
    _context.moveTo( v1.x, v1.y - 10 );
    _context.lineTo( v1.x, v1.y + 10 );
    _context.stroke();
    */

  }

  function renderLine( v1, v2, element, material ) {

    setOpacity( material.opacity );
    setBlending( material.blending );

    _context.beginPath();
    _context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
    _context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

    if ( material.isLineBasicMaterial ) {

      setLineWidth( material.linewidth );
      setLineCap( material.linecap );
      setLineJoin( material.linejoin );

      if ( material.vertexColors !== THREE.VertexColors ) {

        setStrokeStyle( material.color.getStyle() );

      } else {

        var colorStyle1 = element.vertexColors[ 0 ].getStyle();
        var colorStyle2 = element.vertexColors[ 1 ].getStyle();

        if ( colorStyle1 === colorStyle2 ) {

          setStrokeStyle( colorStyle1 );

        } else {

          try {

            var grad = _context.createLinearGradient(
              v1.positionScreen.x,
              v1.positionScreen.y,
              v2.positionScreen.x,
              v2.positionScreen.y
            );
            grad.addColorStop( 0, colorStyle1 );
            grad.addColorStop( 1, colorStyle2 );

          } catch ( exception ) {

            grad = colorStyle1;

          }

          setStrokeStyle( grad );

        }

      }

      if ( material.isLineDashedMaterial ) {

        setLineDash( [ material.dashSize, material.gapSize ] );

      }

      _context.stroke();
      _elemBox.expandByScalar( material.linewidth * 2 );

      if ( material.isLineDashedMaterial ) {

        setLineDash( [] );

      }

    }

  }

  function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

    _this.info.render.vertices += 3;
    _this.info.render.faces ++;

    setOpacity( material.opacity );
    setBlending( material.blending );

    _v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
    _v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
    _v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

    drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

    if ( ( material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) && material.map === null ) {

      _diffuseColor.copy( material.color );
      _emissiveColor.copy( material.emissive );

      if ( material.vertexColors === THREE.FaceColors ) {

        _diffuseColor.multiply( element.color );

      }

      _color.copy( _ambientLight );

      _centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );

      calculateLight( _centroid, element.normalModel, _color );

      _color.multiply( _diffuseColor ).add( _emissiveColor );

      material.wireframe === true
         ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
         : fillPath( _color );

    } else if ( material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) {

      if ( material.map !== null ) {

        var mapping = material.map.mapping;

        if ( mapping === THREE.UVMapping ) {

          _uvs = element.uvs;
          patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

        }

      } else if ( material.envMap !== null ) {

        if ( material.envMap.mapping === THREE.SphericalReflectionMapping ) {

          _normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );
          _uv1x = 0.5 * _normal.x + 0.5;
          _uv1y = 0.5 * _normal.y + 0.5;

          _normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );
          _uv2x = 0.5 * _normal.x + 0.5;
          _uv2y = 0.5 * _normal.y + 0.5;

          _normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );
          _uv3x = 0.5 * _normal.x + 0.5;
          _uv3y = 0.5 * _normal.y + 0.5;

          patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

        }

      } else {

        _color.copy( material.color );

        if ( material.vertexColors === THREE.FaceColors ) {

          _color.multiply( element.color );

        }

        material.wireframe === true
           ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
           : fillPath( _color );

      }

    } else if ( material.isMeshNormalMaterial ) {

      _normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );

      _color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

      material.wireframe === true
         ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
         : fillPath( _color );

    } else {

      _color.setRGB( 1, 1, 1 );

      material.wireframe === true
         ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
         : fillPath( _color );

    }

  }

  //

  function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

    _context.beginPath();
    _context.moveTo( x0, y0 );
    _context.lineTo( x1, y1 );
    _context.lineTo( x2, y2 );
    _context.closePath();

  }

  function strokePath( color, linewidth, linecap, linejoin ) {

    setLineWidth( linewidth );
    setLineCap( linecap );
    setLineJoin( linejoin );
    setStrokeStyle( color.getStyle() );

    _context.stroke();

    _elemBox.expandByScalar( linewidth * 2 );

  }

  function fillPath( color ) {

    setFillStyle( color.getStyle() );
    _context.fill();

  }

  function textureToPattern( texture ) {

    if ( texture.version === 0 ||
      texture instanceof THREE.CompressedTexture ||
      texture instanceof THREE.DataTexture ) {

      return {
        canvas: undefined,
        version: texture.version
      };

    }

    var image = texture.image;

    if ( image.complete === false ) {

      return {
        canvas: undefined,
        version: 0
      };

    }

    var repeatX = texture.wrapS === THREE.RepeatWrapping || texture.wrapS === THREE.MirroredRepeatWrapping;
    var repeatY = texture.wrapT === THREE.RepeatWrapping || texture.wrapT === THREE.MirroredRepeatWrapping;

    var mirrorX = texture.wrapS === THREE.MirroredRepeatWrapping;
    var mirrorY = texture.wrapT === THREE.MirroredRepeatWrapping;

    //

    var canvas = document.createElement( 'canvas' );
    canvas.width = image.width * ( mirrorX ? 2 : 1 );
    canvas.height = image.height * ( mirrorY ? 2 : 1 );

    var context = canvas.getContext( '2d' );
    context.setTransform( 1, 0, 0, - 1, 0, image.height );
    context.drawImage( image, 0, 0 );

    if ( mirrorX === true ) {

      context.setTransform( - 1, 0, 0, - 1, image.width, image.height );
      context.drawImage( image, - image.width, 0 );

    }

    if ( mirrorY === true ) {

      context.setTransform( 1, 0, 0, 1, 0, 0 );
      context.drawImage( image, 0, image.height );

    }

    if ( mirrorX === true && mirrorY === true ) {

      context.setTransform( - 1, 0, 0, 1, image.width, 0 );
      context.drawImage( image, - image.width, image.height );

    }

    var repeat = 'no-repeat';

    if ( repeatX === true && repeatY === true ) {

      repeat = 'repeat';

    } else if ( repeatX === true ) {

      repeat = 'repeat-x';

    } else if ( repeatY === true ) {

      repeat = 'repeat-y';

    }

    var pattern = _context.createPattern( canvas, repeat );

    if ( texture.onUpdate ) texture.onUpdate( texture );

    return {
      canvas: pattern,
      version: texture.version
    };

  }

  function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

    var pattern = _patterns[ texture.id ];

    if ( pattern === undefined || pattern.version !== texture.version ) {

      pattern = textureToPattern( texture );
      _patterns[ texture.id ] = pattern;

    }

    if ( pattern.canvas !== undefined ) {

      setFillStyle( pattern.canvas );

    } else {

      setFillStyle( 'rgba( 0, 0, 0, 1)' );
      _context.fill();
      return;

    }

    // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

    var a, b, c, d, e, f, det, idet,
      offsetX = texture.offset.x / texture.repeat.x,
      offsetY = texture.offset.y / texture.repeat.y,
      width = texture.image.width * texture.repeat.x,
      height = texture.image.height * texture.repeat.y;

    u0 = ( u0 + offsetX ) * width;
    v0 = ( v0 + offsetY ) * height;

    u1 = ( u1 + offsetX ) * width;
    v1 = ( v1 + offsetY ) * height;

    u2 = ( u2 + offsetX ) * width;
    v2 = ( v2 + offsetY ) * height;

    x1 -= x0; y1 -= y0;
    x2 -= x0; y2 -= y0;

    u1 -= u0; v1 -= v0;
    u2 -= u0; v2 -= v0;

    det = u1 * v2 - u2 * v1;

    if ( det === 0 ) return;

    idet = 1 / det;

    a = ( v2 * x1 - v1 * x2 ) * idet;
    b = ( v2 * y1 - v1 * y2 ) * idet;
    c = ( u1 * x2 - u2 * x1 ) * idet;
    d = ( u1 * y2 - u2 * y1 ) * idet;

    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;

    _context.save();
    _context.transform( a, b, c, d, e, f );
    _context.fill();
    _context.restore();

  }

  /*
  function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

    // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

    var a, b, c, d, e, f, det, idet,
    width = image.width - 1,
    height = image.height - 1;

    u0 *= width; v0 *= height;
    u1 *= width; v1 *= height;
    u2 *= width; v2 *= height;

    x1 -= x0; y1 -= y0;
    x2 -= x0; y2 -= y0;

    u1 -= u0; v1 -= v0;
    u2 -= u0; v2 -= v0;

    det = u1 * v2 - u2 * v1;

    idet = 1 / det;

    a = ( v2 * x1 - v1 * x2 ) * idet;
    b = ( v2 * y1 - v1 * y2 ) * idet;
    c = ( u1 * x2 - u2 * x1 ) * idet;
    d = ( u1 * y2 - u2 * y1 ) * idet;

    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;

    _context.save();
    _context.transform( a, b, c, d, e, f );
    _context.clip();
    _context.drawImage( image, 0, 0 );
    _context.restore();

  }
  */

  // Hide anti-alias gaps

  function expand( v1, v2, pixels ) {

    var x = v2.x - v1.x, y = v2.y - v1.y,
      det = x * x + y * y, idet;

    if ( det === 0 ) return;

    idet = pixels / Math.sqrt( det );

    x *= idet; y *= idet;

    v2.x += x; v2.y += y;
    v1.x -= x; v1.y -= y;

  }

  // Context cached methods.

  function setOpacity( value ) {

    if ( _contextGlobalAlpha !== value ) {

      _context.globalAlpha = value;
      _contextGlobalAlpha = value;

    }

  }

  function setBlending( value ) {

    if ( _contextGlobalCompositeOperation !== value ) {

      if ( value === THREE.NormalBlending ) {

        _context.globalCompositeOperation = 'source-over';

      } else if ( value === THREE.AdditiveBlending ) {

        _context.globalCompositeOperation = 'lighter';

      } else if ( value === THREE.SubtractiveBlending ) {

        _context.globalCompositeOperation = 'darker';

      } else if ( value === THREE.MultiplyBlending ) {

        _context.globalCompositeOperation = 'multiply';

      }

      _contextGlobalCompositeOperation = value;

    }

  }

  function setLineWidth( value ) {

    if ( _contextLineWidth !== value ) {

      _context.lineWidth = value;
      _contextLineWidth = value;

    }

  }

  function setLineCap( value ) {

    // "butt", "round", "square"

    if ( _contextLineCap !== value ) {

      _context.lineCap = value;
      _contextLineCap = value;

    }

  }

  function setLineJoin( value ) {

    // "round", "bevel", "miter"

    if ( _contextLineJoin !== value ) {

      _context.lineJoin = value;
      _contextLineJoin = value;

    }

  }

  function setStrokeStyle( value ) {

    if ( _contextStrokeStyle !== value ) {

      _context.strokeStyle = value;
      _contextStrokeStyle = value;

    }

  }

  function setFillStyle( value ) {

    if ( _contextFillStyle !== value ) {

      _context.fillStyle = value;
      _contextFillStyle = value;

    }

  }

  function setLineDash( value ) {

    if ( _contextLineDash.length !== value.length ) {

      _context.setLineDash( value );
      _contextLineDash = value;

    }

  }

};

/**
 * RaytracingRenderer renders by raytracing it's scene. However, it does not
 * compute the pixels itself but it hands off and coordinates the taks for workers.
 * The workers compute the pixel values and this renderer simply paints it to the Canvas.
 *
 * @author zz85 / http://github.com/zz85
 */

THREE.RaytracingRenderer = function ( parameters ) {

  console.log( 'THREE.RaytracingRenderer', THREE.REVISION );

  parameters = parameters || {};

  var scope = this;
  var pool = [];
  var renderering = false;

  var canvas = document.createElement( 'canvas' );
  var context = canvas.getContext( '2d', {
    alpha: parameters.alpha === true
  } );

  var maxRecursionDepth = 3;

  var canvasWidth, canvasHeight;

  var clearColor = new THREE.Color( 0x000000 );

  this.domElement = canvas;

  this.autoClear = true;

  var workers = parameters.workers;
  var blockSize = parameters.blockSize || 64;
  this.randomize = parameters.randomize;

  var toRender = [], workerId = 0, sceneId = 0;

  console.log( '%cSpinning off ' + workers + ' Workers ', 'font-size: 20px; background: black; color: white; font-family: monospace;' );

  this.setWorkers = function( w ) {

    workers = w || navigator.hardwareConcurrency || 4;

    while ( pool.length < workers ) {
      var worker = new Worker( parameters.workerPath );
      worker.id = workerId++;

      worker.onmessage = function( e ) {

        var data = e.data;

        if ( ! data ) return;

        if ( data.blockSize && sceneId == data.sceneId ) { // we match sceneId here to be sure

          var imagedata = new ImageData( new Uint8ClampedArray( data.data ), data.blockSize, data.blockSize );
          context.putImageData( imagedata, data.blockX, data.blockY );

          // completed

          console.log( 'Worker ' + this.id, data.time / 1000, ( Date.now() - reallyThen ) / 1000 + ' s' );

          if ( pool.length > workers ) {

            pool.splice( pool.indexOf( this ), 1 );
            return this.terminate();

          }

          renderNext( this );

        }

      };

      worker.color = new THREE.Color().setHSL( Math.random() , 0.8, 0.8 ).getHexString();
      pool.push( worker );

      if ( renderering ) {

        updateSettings( worker );

        worker.postMessage( {
          scene: sceneJSON,
          camera: cameraJSON,
          annex: materials,
          sceneId: sceneId
        } );

        renderNext( worker );

      }

    }

    if ( ! renderering ) {

      while ( pool.length > workers ) {

        pool.pop().terminate();

      }

    }

  };

  this.setWorkers( workers );

  this.setClearColor = function ( color, alpha ) {

    clearColor.set( color );

  };

  this.setPixelRatio = function () {};

  this.setSize = function ( width, height ) {

    canvas.width = width;
    canvas.height = height;

    canvasWidth = canvas.width;
    canvasHeight = canvas.height;

    context.fillStyle = 'white';

    pool.forEach( updateSettings );

  };

  this.setSize( canvas.width, canvas.height );

  this.clear = function () {

  };

  //

  var totalBlocks, xblocks, yblocks;

  function updateSettings( worker ) {

    worker.postMessage( {

      init: [ canvasWidth, canvasHeight ],
      worker: worker.id,
      // workers: pool.length,
      blockSize: blockSize

    } );

  }

  function renderNext( worker ) {
    if ( ! toRender.length ) {

      renderering = false;
      return scope.dispatchEvent( { type: "complete" } );

    }

    var current = toRender.pop();

    var blockX = ( current % xblocks ) * blockSize;
    var blockY = ( current / xblocks | 0 ) * blockSize;

    worker.postMessage( {
      render: true,
      x: blockX,
      y: blockY,
      sceneId: sceneId
    } );

    context.fillStyle = '#' + worker.color;

    context.fillRect( blockX, blockY, blockSize, blockSize );

  }

  var materials = {};

  var sceneJSON, cameraJSON, reallyThen;

  // additional properties that were not serialize automatically

  var _annex = {

    mirror: 1,
    reflectivity: 1,
    refractionRatio: 1,
    glass: 1

  };

  function serializeObject( o ) {

    var mat = o.material;

    if ( ! mat || mat.uuid in materials ) return;

    var props = {};
    for ( var m in _annex ) {

      if ( mat[ m ] !== undefined ) {

        props[ m ] = mat[ m ];

      }

    }

    materials[ mat.uuid ] = props;
  }

  this.render = function ( scene, camera ) {

    renderering = true;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices

    if ( camera.parent === null ) camera.updateMatrixWorld();


    sceneJSON = scene.toJSON();
    cameraJSON = camera.toJSON();
    ++ sceneId;

    scene.traverse( serializeObject );

    pool.forEach( function( worker ) {

      worker.postMessage( {
        scene: sceneJSON,
        camera: cameraJSON,
        annex: materials,
        sceneId: sceneId
      } );
    } );

    context.clearRect( 0, 0, canvasWidth, canvasHeight );
    reallyThen = Date.now();

    xblocks = Math.ceil( canvasWidth / blockSize );
    yblocks = Math.ceil( canvasHeight / blockSize );
    totalBlocks = xblocks * yblocks;

    toRender = [];

    for ( var i = 0; i < totalBlocks; i ++ ) {

      toRender.push( i );

    }


    // Randomize painting :)

    if ( scope.randomize ) {

      for ( var i = 0; i < totalBlocks; i ++ ) {

        var swap = Math.random()  * totalBlocks | 0;
        var tmp = toRender[ swap ];
        toRender[ swap ] = toRender[ i ];
        toRender[ i ] = tmp;

      }

    }


    pool.forEach( renderNext );

  };

};

Object.assign( THREE.RaytracingRenderer.prototype, THREE.EventDispatcher.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author ryg / http://farbrausch.de/~fg
 * @author mraleph / http://mrale.ph/
 * @author daoshengmu / http://dsmu.me/
 */

THREE.SoftwareRenderer = function ( parameters ) {

  console.log( 'THREE.SoftwareRenderer', THREE.REVISION );

  parameters = parameters || {};

  var canvas = parameters.canvas !== undefined
       ? parameters.canvas
       : document.createElement( 'canvas' );

  var context = canvas.getContext( '2d', {
    alpha: parameters.alpha === true
  } );

  var alpha = parameters.alpha;

  var shaders = {};
  var textures = {};

  var canvasWidth, canvasHeight;
  var canvasWBlocks, canvasHBlocks;
  var viewportXScale, viewportYScale, viewportZScale;
  var viewportXOffs, viewportYOffs, viewportZOffs;

  var clearColor = new THREE.Color( 0x000000 );

  var imagedata, data, zbuffer;
  var numBlocks, blockMaxZ, blockFlags;

  var BLOCK_ISCLEAR = ( 1 << 0 );
  var BLOCK_NEEDCLEAR = ( 1 << 1 );

  var subpixelBits = 4;
  var subpixelBias = ( 1 << subpixelBits ) - 1;
  var blockShift = 3;
  var blockSize = 1 << blockShift;
  var maxZVal = ( 1 << 24 ); // Note: You want to size this so you don't get overflows.
  var lineMode = false;
  var lookVector = new THREE.Vector3( 0, 0, 1 );
  var crossVector = new THREE.Vector3();

  var rectx1 = Infinity, recty1 = Infinity;
  var rectx2 = 0, recty2 = 0;

  var prevrectx1 = Infinity, prevrecty1 = Infinity;
  var prevrectx2 = 0, prevrecty2 = 0;

  var projector = new THREE.Projector();

  var spriteV1 = new THREE.Vector4();
  var spriteV2 = new THREE.Vector4();
  var spriteV3 = new THREE.Vector4();

  var spriteUV1 = new THREE.Vector2();
  var spriteUV2 = new THREE.Vector2();
  var spriteUV3 = new THREE.Vector2();

  var mpVPool = [];
  var mpVPoolCount = 0;
  var mpNPool = [];
  var mpNPoolCount = 0;
  var mpUVPool = [];
  var mpUVPoolCount = 0;

  this.domElement = canvas;

  this.autoClear = true;

  // WebGLRenderer compatibility

  this.supportsVertexTextures = function () {};
  this.setFaceCulling = function () {};

  this.setClearColor = function ( color ) {

    clearColor.set( color );
    clearColorBuffer( clearColor );

  };

  this.setPixelRatio = function () {};

  this.setSize = function ( width, height ) {

    canvasWBlocks = Math.floor( width / blockSize );
    canvasHBlocks = Math.floor( height / blockSize );
    canvasWidth   = canvasWBlocks * blockSize;
    canvasHeight  = canvasHBlocks * blockSize;

    var fixScale = 1 << subpixelBits;

    viewportXScale =  fixScale * canvasWidth  / 2;
    viewportYScale = - fixScale * canvasHeight / 2;
    viewportZScale =             maxZVal      / 2;

    viewportXOffs  =  fixScale * canvasWidth  / 2 + 0.5;
    viewportYOffs  =  fixScale * canvasHeight / 2 + 0.5;
    viewportZOffs  =             maxZVal      / 2 + 0.5;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    context.fillStyle = alpha ? "rgba(0, 0, 0, 0)" : clearColor.getStyle();
    context.fillRect( 0, 0, canvasWidth, canvasHeight );

    imagedata = context.getImageData( 0, 0, canvasWidth, canvasHeight );
    data = imagedata.data;

    zbuffer = new Int32Array( data.length / 4 );

    numBlocks = canvasWBlocks * canvasHBlocks;
    blockMaxZ = new Int32Array( numBlocks );
    blockFlags = new Uint8Array( numBlocks );

    for ( var i = 0, l = zbuffer.length; i < l; i ++ ) {

      zbuffer[ i ] = maxZVal;

    }

    for ( var i = 0; i < numBlocks; i ++ ) {

      blockFlags[ i ] = BLOCK_ISCLEAR;

    }

    clearColorBuffer( clearColor );

  };

  this.setSize( canvas.width, canvas.height );

  this.clear = function () {

    rectx1 = Infinity;
    recty1 = Infinity;
    rectx2 = 0;
    recty2 = 0;
    mpVPoolCount = 0;
    mpNPoolCount = 0;
    mpUVPoolCount = 0;

    for ( var i = 0; i < numBlocks; i ++ ) {

      blockMaxZ[ i ] = maxZVal;
      blockFlags[ i ] = ( blockFlags[ i ] & BLOCK_ISCLEAR ) ? BLOCK_ISCLEAR : BLOCK_NEEDCLEAR;

    }

  };


  this.render = function ( scene, camera ) {

    // TODO: Check why autoClear can't be false.
    this.clear();

    var background = scene.background;

    if ( background && background.isColor ) {

      clearColorBuffer( background );

    }

    var renderData = projector.projectScene( scene, camera, false, false );
    var elements = renderData.elements;

    for ( var e = 0, el = elements.length; e < el; e ++ ) {

      var element = elements[ e ];
      var material = element.material;
      var shader = getMaterialShader( material );

      if ( ! shader ) continue;

      if ( element instanceof THREE.RenderableFace ) {

        if ( ! element.uvs ) {

          drawTriangle(
            element.v1.positionScreen,
            element.v2.positionScreen,
            element.v3.positionScreen,
            null, null, null,
            shader, element, material
          );

        } else {

          drawTriangle(
            element.v1.positionScreen,
            element.v2.positionScreen,
            element.v3.positionScreen,
            element.uvs[ 0 ], element.uvs[ 1 ], element.uvs[ 2 ],
            shader, element, material
          );

        }


      } else if ( element instanceof THREE.RenderableSprite ) {

        var scaleX = element.scale.x * 0.5;
        var scaleY = element.scale.y * 0.5;

        spriteV1.copy( element );
        spriteV1.x -= scaleX;
        spriteV1.y += scaleY;

        spriteV2.copy( element );
        spriteV2.x -= scaleX;
        spriteV2.y -= scaleY;

        spriteV3.copy( element );
        spriteV3.x += scaleX;
        spriteV3.y += scaleY;

        if ( material.map ) {

          spriteUV1.set( 0, 1 );
          spriteUV2.set( 0, 0 );
          spriteUV3.set( 1, 1 );

          drawTriangle(
            spriteV1, spriteV2, spriteV3,
            spriteUV1, spriteUV2, spriteUV3,
            shader, element, material
          );

        } else {

          drawTriangle(
            spriteV1, spriteV2, spriteV3,
            null, null, null,
            shader, element, material
          );

        }

        spriteV1.copy( element );
        spriteV1.x += scaleX;
        spriteV1.y += scaleY;

        spriteV2.copy( element );
        spriteV2.x -= scaleX;
        spriteV2.y -= scaleY;

        spriteV3.copy( element );
        spriteV3.x += scaleX;
        spriteV3.y -= scaleY;

        if ( material.map ) {

          spriteUV1.set( 1, 1 );
          spriteUV2.set( 0, 0 );
          spriteUV3.set( 1, 0 );

          drawTriangle(
            spriteV1, spriteV2, spriteV3,
            spriteUV1, spriteUV2, spriteUV3,
            shader, element, material
          );

        } else {

          drawTriangle(
            spriteV1, spriteV2, spriteV3,
            null, null, null,
            shader, element, material
          );

        }

      } else if ( element instanceof THREE.RenderableLine ) {

        var shader = getMaterialShader( material );

        drawLine(
          element.v1.positionScreen,
          element.v2.positionScreen,
          element.vertexColors[ 0 ],
          element.vertexColors[ 1 ],
          shader,
          material
        );
      }

    }

    finishClear();

    var x = Math.min( rectx1, prevrectx1 );
    var y = Math.min( recty1, prevrecty1 );
    var width = Math.max( rectx2, prevrectx2 ) - x;
    var height = Math.max( recty2, prevrecty2 ) - y;

    /*
    // debug; draw zbuffer

    for ( var i = 0, l = zbuffer.length; i < l; i++ ) {

      var o = i * 4;
      var v = (65535 - zbuffer[ i ]) >> 3;
      data[ o + 0 ] = v;
      data[ o + 1 ] = v;
      data[ o + 2 ] = v;
      data[ o + 3 ] = 255;
    }
    */

    if ( x !== Infinity ) {

      context.putImageData( imagedata, 0, 0, x, y, width, height );

    }

    prevrectx1 = rectx1; prevrecty1 = recty1;
    prevrectx2 = rectx2; prevrecty2 = recty2;

  };

  function setSize( width, height ) {

    canvasWBlocks = Math.floor( width / blockSize );
    canvasHBlocks = Math.floor( height / blockSize );
    canvasWidth   = canvasWBlocks * blockSize;
    canvasHeight  = canvasHBlocks * blockSize;

    var fixScale = 1 << subpixelBits;

    viewportXScale =  fixScale * canvasWidth  / 2;
    viewportYScale = -fixScale * canvasHeight / 2;
    viewportZScale =             maxZVal      / 2;

    viewportXOffs  =  fixScale * canvasWidth  / 2 + 0.5;
    viewportYOffs  =  fixScale * canvasHeight / 2 + 0.5;
    viewportZOffs  =             maxZVal      / 2 + 0.5;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    context.fillStyle = alpha ? "rgba(0, 0, 0, 0)" : clearColor.getStyle();
    context.fillRect( 0, 0, canvasWidth, canvasHeight );

    imagedata = context.getImageData( 0, 0, canvasWidth, canvasHeight );
    data = imagedata.data;

    zbuffer = new Int32Array( data.length / 4 );

    numBlocks = canvasWBlocks * canvasHBlocks;
    blockMaxZ = new Int32Array( numBlocks );
    blockFlags = new Uint8Array( numBlocks );

    for ( var i = 0, l = zbuffer.length; i < l; i ++ ) {

      zbuffer[ i ] = maxZVal;

    }

    for ( var i = 0; i < numBlocks; i ++ ) {

      blockFlags[ i ] = BLOCK_ISCLEAR;

    }

    clearColorBuffer( clearColor );

  }

  function clearColorBuffer( color ) {

    var size = canvasWidth * canvasHeight * 4;

    for ( var i = 0; i < size; i += 4 ) {

      data[ i ] = color.r * 255 | 0;
      data[ i + 1 ] = color.g * 255 | 0;
      data[ i + 2 ] = color.b * 255 | 0;
      data[ i + 3 ] = alpha ? 0 : 255;

    }

    context.fillStyle = alpha ? "rgba(0, 0, 0, 0)" : color.getStyle();
    context.fillRect( 0, 0, canvasWidth, canvasHeight );

  }

  function getPalette( material, bSimulateSpecular ) {

    var i = 0, j = 0;
    var diffuseR = material.color.r * 255;
    var diffuseG = material.color.g * 255;
    var diffuseB = material.color.b * 255;
    var palette = new Uint8Array( 256 * 3 );

    if ( bSimulateSpecular ) {

      while ( i < 204 ) {

        palette[ j ++ ] = Math.min( i * diffuseR / 204, 255 );
        palette[ j ++ ] = Math.min( i * diffuseG / 204, 255 );
        palette[ j ++ ] = Math.min( i * diffuseB / 204, 255 );
        ++ i;

      }

      while ( i < 256 ) {

        // plus specular highlight
        palette[ j ++ ] = Math.min( diffuseR + ( i - 204 ) * ( 255 - diffuseR ) / 82, 255 );
        palette[ j ++ ] = Math.min( diffuseG + ( i - 204 ) * ( 255 - diffuseG ) / 82, 255 );
        palette[ j ++ ] = Math.min( diffuseB + ( i - 204 ) * ( 255 - diffuseB ) / 82, 255 );
        ++ i;

      }

    } else {

      while ( i < 256 ) {

        palette[ j ++ ] = Math.min( i * diffuseR / 255, 255 );
        palette[ j ++ ] = Math.min( i * diffuseG / 255, 255 );
        palette[ j ++ ] = Math.min( i * diffuseB / 255, 255 );
        ++ i;

      }

    }

    return palette;

  }

  function basicMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {

    var colorOffset = offset * 4;

    var texture = textures[ material.map.id ];

    if ( ! texture.data )
      return;

    var tdim = texture.width;
    var isTransparent = material.transparent;
    var tbound = tdim - 1;
    var tdata = texture.data;
    var tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;

    if ( ! isTransparent ) {

      buffer[ colorOffset ] = tdata[ tIndex ];
      buffer[ colorOffset + 1 ] = tdata[ tIndex + 1 ];
      buffer[ colorOffset + 2 ] = tdata[ tIndex + 2 ];
      buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;
      depthBuf[ offset ] = depth;

    } else {

      var srcR = tdata[ tIndex ];
      var srcG = tdata[ tIndex + 1 ];
      var srcB = tdata[ tIndex + 2 ];
      var opaci = tdata[ tIndex + 3 ] * material.opacity / 255;
      var destR = buffer[ colorOffset ];
      var destG = buffer[ colorOffset + 1 ];
      var destB = buffer[ colorOffset + 2 ];

      buffer[ colorOffset ] = ( srcR * opaci + destR * ( 1 - opaci ) );
      buffer[ colorOffset + 1 ] = ( srcG * opaci + destG * ( 1 - opaci ) );
      buffer[ colorOffset + 2 ] = ( srcB * opaci + destB * ( 1 - opaci ) );
      buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;

      if ( buffer[ colorOffset + 3 ] == 255 ) // Only opaue pixls write to the depth buffer
        depthBuf[ offset ] = depth;

    }

  }

  function lightingMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {

    var colorOffset = offset * 4;

    var texture = textures[ material.map.id ];

    if ( ! texture.data )
      return;

    var tdim = texture.width;
    var isTransparent = material.transparent;
    var cIndex = ( n > 0 ? ( ~~ n ) : 0 ) * 3;
    var tbound = tdim - 1;
    var tdata = texture.data;
    var tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;

    if ( ! isTransparent ) {

      buffer[ colorOffset ] = ( material.palette[ cIndex ] * tdata[ tIndex ] ) >> 8;
      buffer[ colorOffset + 1 ] = ( material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ] ) >> 8;
      buffer[ colorOffset + 2 ] = ( material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ] ) >> 8;
      buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;
      depthBuf[ offset ] = depth;

    } else {

      var foreColorR = material.palette[ cIndex ] * tdata[ tIndex ];
      var foreColorG = material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ];
      var foreColorB = material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ];
      var opaci = tdata[ tIndex + 3 ] * material.opacity / 256;
      var destR = buffer[ colorOffset ];
      var destG = buffer[ colorOffset + 1 ];
      var destB = buffer[ colorOffset + 2 ];

      buffer[ colorOffset ] = foreColorR * opaci + destR * ( 1 - opaci );
      buffer[ colorOffset + 1 ] = foreColorG * opaci + destG * ( 1 - opaci );
      buffer[ colorOffset + 2 ] = foreColorB * opaci + destB * ( 1 - opaci );
      buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;

      if ( buffer[ colorOffset + 3 ] == 255 ) // Only opaue pixls write to the depth buffer
        depthBuf[ offset ] = depth;
    }

  }

  function getMaterialShader( material ) {

    var id = material.id;
    var shader = shaders[ id ];

    if ( shader && material.map && !textures[ material.map.id ] ) delete shaders[ id ];

    if ( shaders[ id ] === undefined || material.needsUpdate === true ) {

      if ( material instanceof THREE.MeshBasicMaterial ||
        material instanceof THREE.MeshLambertMaterial ||
        material instanceof THREE.MeshPhongMaterial ||
        material instanceof THREE.SpriteMaterial ) {

        if ( material instanceof THREE.MeshLambertMaterial ) {

          // Generate color palette
          if ( ! material.palette ) {

            material.palette = getPalette( material, false );

          }

        } else if ( material instanceof THREE.MeshPhongMaterial ) {

          // Generate color palette
          if ( ! material.palette ) {

            material.palette = getPalette( material, true );

          }

        }

        var string;

        if ( material.map ) {

          var texture = new THREE.SoftwareRenderer.Texture();
          texture.fromImage( material.map.image );

          if ( ! texture.data ) return;

          textures[ material.map.id ] = texture;

          if ( material instanceof THREE.MeshBasicMaterial
            || material instanceof THREE.SpriteMaterial ) {

            shader = basicMaterialShader;

          } else {

            shader = lightingMaterialShader;

          }


        } else {

          if ( material.vertexColors === THREE.FaceColors ) {

            string = [
              'var colorOffset = offset * 4;',
              'buffer[ colorOffset ] = face.color.r * 255;',
              'buffer[ colorOffset + 1 ] = face.color.g * 255;',
              'buffer[ colorOffset + 2 ] = face.color.b * 255;',
              'buffer[ colorOffset + 3 ] = material.opacity * 255;',
              'depthBuf[ offset ] = depth;'
            ].join( '\n' );

          } else {

            string = [
              'var colorOffset = offset * 4;',
              'buffer[ colorOffset ] = material.color.r * 255;',
              'buffer[ colorOffset + 1 ] = material.color.g * 255;',
              'buffer[ colorOffset + 2 ] = material.color.b * 255;',
              'buffer[ colorOffset + 3 ] = material.opacity * 255;',
              'depthBuf[ offset ] = depth;'
            ].join( '\n' );

          }

          shader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );

        }

      } else if ( material instanceof THREE.LineBasicMaterial ) {

        var string = [
          'var colorOffset = offset * 4;',
          'buffer[ colorOffset ] = material.color.r * (color1.r+color2.r) * 0.5 * 255;',
          'buffer[ colorOffset + 1 ] = material.color.g * (color1.g+color2.g) * 0.5 * 255;',
          'buffer[ colorOffset + 2 ] = material.color.b * (color1.b+color2.b) * 0.5 * 255;',
          'buffer[ colorOffset + 3 ] = 255;',
          'depthBuf[ offset ] = depth;'
        ].join( '\n' );

        shader = new Function( 'buffer, depthBuf, offset, depth, color1, color2, material', string );

      } else {

        var string = [
          'var colorOffset = offset * 4;',
          'buffer[ colorOffset ] = u * 255;',
          'buffer[ colorOffset + 1 ] = v * 255;',
          'buffer[ colorOffset + 2 ] = 0;',
          'buffer[ colorOffset + 3 ] = 255;',
          'depthBuf[ offset ] = depth;'
        ].join( '\n' );

        shader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );

      }

      shaders[ id ] = shader;

      material.needsUpdate = false;

    }

    return shader;

  }

  /*
  function clearRectangle( x1, y1, x2, y2 ) {

    var xmin = Math.max( Math.min( x1, x2 ), 0 );
    var xmax = Math.min( Math.max( x1, x2 ), canvasWidth );
    var ymin = Math.max( Math.min( y1, y2 ), 0 );
    var ymax = Math.min( Math.max( y1, y2 ), canvasHeight );

    var offset = ( xmin + ymin * canvasWidth ) * 4 + 3;
    var linestep = ( canvasWidth - ( xmax - xmin ) ) * 4;

    for ( var y = ymin; y < ymax; y ++ ) {

      for ( var x = xmin; x < xmax; x ++ ) {

        data[ offset += 4 ] = 0;

      }

      offset += linestep;

    }

  }
  */

  function drawTriangle( v1, v2, v3, uv1, uv2, uv3, shader, face, material ) {

    // TODO: Implement per-pixel z-clipping

    if ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 || v3.z < - 1 || v3.z > 1 ) return;

    // https://gist.github.com/2486101
    // explanation: http://pouet.net/topic.php?which=8760&page=1

    var fixscale = ( 1 << subpixelBits );

    // 28.4 fixed-point coordinates

    var x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;
    var x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;
    var x3 = ( v3.x * viewportXScale + viewportXOffs ) | 0;

    var y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;
    var y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;
    var y3 = ( v3.y * viewportYScale + viewportYOffs ) | 0;

    var bHasNormal = face.vertexNormalsModel && face.vertexNormalsModel.length;
    var bHasUV = uv1 && uv2 && uv3;

    var longestSide = Math.max(
      Math.sqrt( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ),
      Math.sqrt( ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ),
      Math.sqrt( ( x3 - x1 ) * ( x3 - x1 ) + ( y3 - y1 ) * ( y3 - y1 ) )
    );

    if ( ! ( face instanceof THREE.RenderableSprite ) && ( longestSide > 100 * fixscale ) ) {

      // 1
      // |\
      // |a\
      // |__\
      // |\c|\
      // |b\|d\
      // |__\__\
      // 2      3
      var tempFace = { vertexNormalsModel: [], color: face.color };
      var mpUV12, mpUV23, mpUV31;

      if ( bHasUV ) {

        if ( mpUVPoolCount === mpUVPool.length ) {

          mpUV12 = new THREE.Vector2();
          mpUVPool.push( mpUV12 );
          ++mpUVPoolCount;

          mpUV23 = new THREE.Vector2();
          mpUVPool.push( mpUV23 );
          ++mpUVPoolCount;

          mpUV31 = new THREE.Vector2();
          mpUVPool.push( mpUV31 );
          ++mpUVPoolCount;

        } else {

          mpUV12 = mpUVPool[ mpUVPoolCount ];
          ++mpUVPoolCount;

          mpUV23 = mpUVPool[ mpUVPoolCount ];
          ++mpUVPoolCount;

          mpUV31 = mpUVPool[ mpUVPoolCount ];
          ++mpUVPoolCount;

        }

        var weight;

        weight = ( 1 + v2.z ) * ( v2.w / v1.w ) / ( 1 + v1.z );
        mpUV12.copy( uv1 ).multiplyScalar( weight ).add( uv2 ).multiplyScalar( 1 / ( weight + 1 ) );

        weight = ( 1 + v3.z ) * ( v3.w / v2.w ) / ( 1 + v2.z );
        mpUV23.copy( uv2 ).multiplyScalar( weight ).add( uv3 ).multiplyScalar( 1 / ( weight + 1 ) );

        weight = ( 1 + v1.z ) * ( v1.w / v3.w ) / ( 1 + v3.z );
        mpUV31.copy( uv3 ).multiplyScalar( weight ).add( uv1 ).multiplyScalar( 1 / ( weight + 1 ) );

      }

      var mpV12, mpV23, mpV31;

      if ( mpVPoolCount === mpVPool.length ) {

        mpV12 = new THREE.Vector4();
        mpVPool.push( mpV12 );
        ++mpVPoolCount;

        mpV23 = new THREE.Vector4();
        mpVPool.push( mpV23 );
        ++mpVPoolCount;

        mpV31 = new THREE.Vector4();
        mpVPool.push( mpV31 );
        ++mpVPoolCount;

      } else {

        mpV12 = mpVPool[ mpVPoolCount ];
        ++mpVPoolCount;

        mpV23 = mpVPool[ mpVPoolCount ];
        ++mpVPoolCount;

        mpV31 = mpVPool[ mpVPoolCount ];
        ++mpVPoolCount;

      }

      mpV12.copy( v1 ).add( v2 ).multiplyScalar( 0.5 );
      mpV23.copy( v2 ).add( v3 ).multiplyScalar( 0.5 );
      mpV31.copy( v3 ).add( v1 ).multiplyScalar( 0.5 );

      var mpN12, mpN23, mpN31;

      if ( bHasNormal ) {

        if ( mpNPoolCount === mpNPool.length ) {

          mpN12 = new THREE.Vector3();
          mpNPool.push( mpN12 );
          ++mpNPoolCount;

          mpN23 = new THREE.Vector3();
          mpNPool.push( mpN23 );
          ++mpNPoolCount;

          mpN31 = new THREE.Vector3();
          mpNPool.push( mpN31 );
          ++mpNPoolCount;

        } else {

          mpN12 = mpNPool[ mpNPoolCount ];
          ++mpNPoolCount;

          mpN23 = mpNPool[ mpNPoolCount ];
          ++mpNPoolCount;

          mpN31 = mpNPool[ mpNPoolCount ];
          ++mpNPoolCount;

        }

        mpN12.copy( face.vertexNormalsModel[ 0 ] ).add( face.vertexNormalsModel[ 1 ] ).normalize();
        mpN23.copy( face.vertexNormalsModel[ 1 ] ).add( face.vertexNormalsModel[ 2 ] ).normalize();
        mpN31.copy( face.vertexNormalsModel[ 2 ] ).add( face.vertexNormalsModel[ 0 ] ).normalize();

      }

      // a
      if ( bHasNormal ) {

        tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 0 ];
        tempFace.vertexNormalsModel[ 1 ] = mpN12;
        tempFace.vertexNormalsModel[ 2 ] = mpN31;

      }

      drawTriangle( v1, mpV12, mpV31, uv1, mpUV12, mpUV31, shader, tempFace, material );

      // b
      if ( bHasNormal ) {

        tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 1 ];
        tempFace.vertexNormalsModel[ 1 ] = mpN23;
        tempFace.vertexNormalsModel[ 2 ] = mpN12;

      }

      drawTriangle( v2, mpV23, mpV12, uv2, mpUV23, mpUV12, shader, tempFace, material );

      // c
      if ( bHasNormal ) {

        tempFace.vertexNormalsModel[ 0 ] = mpN12;
        tempFace.vertexNormalsModel[ 1 ] = mpN23;
        tempFace.vertexNormalsModel[ 2 ] = mpN31;

      }

      drawTriangle( mpV12, mpV23, mpV31, mpUV12, mpUV23, mpUV31, shader, tempFace, material );

      // d
      if ( bHasNormal ) {

        tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 2 ];
        tempFace.vertexNormalsModel[ 1 ] = mpN31;
        tempFace.vertexNormalsModel[ 2 ] = mpN23;

      }

      drawTriangle( v3, mpV31, mpV23, uv3, mpUV31, mpUV23, shader, tempFace, material );

      return;

    }

    // Z values (.28 fixed-point)

    var z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;
    var z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;
    var z3 = ( v3.z * viewportZScale + viewportZOffs ) | 0;

    // UV values
    var bHasUV = false;
    var tu1, tv1, tu2, tv2, tu3, tv3;

    if ( uv1 && uv2 && uv3 ) {

      bHasUV = true;

      tu1 = uv1.x;
      tv1 = 1 - uv1.y;
      tu2 = uv2.x;
      tv2 = 1 - uv2.y;
      tu3 = uv3.x;
      tv3 = 1 - uv3.y;

    }

    // Normal values
    var n1, n2, n3, nz1, nz2, nz3;

    if ( bHasNormal ) {

      n1 = face.vertexNormalsModel[ 0 ];
      n2 = face.vertexNormalsModel[ 1 ];
      n3 = face.vertexNormalsModel[ 2 ];
      nz1 = n1.z * 255;
      nz2 = n2.z * 255;
      nz3 = n3.z * 255;

    }

    // Deltas

    var dx12 = x1 - x2, dy12 = y2 - y1;
    var dx23 = x2 - x3, dy23 = y3 - y2;
    var dx31 = x3 - x1, dy31 = y1 - y3;

    // Bounding rectangle

    var minx = Math.max( ( Math.min( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, 0 );
    var maxx = Math.min( ( Math.max( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, canvasWidth );
    var miny = Math.max( ( Math.min( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, 0 );
    var maxy = Math.min( ( Math.max( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, canvasHeight );

    rectx1 = Math.min( minx, rectx1 );
    rectx2 = Math.max( maxx, rectx2 );
    recty1 = Math.min( miny, recty1 );
    recty2 = Math.max( maxy, recty2 );

    // Block size, standard 8x8 (must be power of two)

    var q = blockSize;

    // Start in corner of 8x8 block

    minx &= ~ ( q - 1 );
    miny &= ~ ( q - 1 );

    // Constant part of half-edge functions

    var minXfixscale = ( minx << subpixelBits );
    var minYfixscale = ( miny << subpixelBits );

    var c1 = dy12 * ( ( minXfixscale ) - x1 ) + dx12 * ( ( minYfixscale ) - y1 );
    var c2 = dy23 * ( ( minXfixscale ) - x2 ) + dx23 * ( ( minYfixscale ) - y2 );
    var c3 = dy31 * ( ( minXfixscale ) - x3 ) + dx31 * ( ( minYfixscale ) - y3 );

    // Correct for fill convention

    if ( dy12 > 0 || ( dy12 == 0 && dx12 > 0 ) ) c1 ++;
    if ( dy23 > 0 || ( dy23 == 0 && dx23 > 0 ) ) c2 ++;
    if ( dy31 > 0 || ( dy31 == 0 && dx31 > 0 ) ) c3 ++;

    // Note this doesn't kill subpixel precision, but only because we test for >=0 (not >0).
    // It's a bit subtle. :)
    c1 = ( c1 - 1 ) >> subpixelBits;
    c2 = ( c2 - 1 ) >> subpixelBits;
    c3 = ( c3 - 1 ) >> subpixelBits;

    // Z interpolation setup

    var dz12 = z1 - z2, dz31 = z3 - z1;
    var invDet = 1.0 / ( dx12 * dy31 - dx31 * dy12 );
    var dzdx = ( invDet * ( dz12 * dy31 - dz31 * dy12 ) ); // dz per one subpixel step in x
    var dzdy = ( invDet * ( dz12 * dx31 - dx12 * dz31 ) ); // dz per one subpixel step in y

    // Z at top/left corner of rast area

    var cz = ( z1 + ( ( minXfixscale ) - x1 ) * dzdx + ( ( minYfixscale ) - y1 ) * dzdy ) | 0;

    // Z pixel steps

    dzdx = ( dzdx * fixscale ) | 0;
    dzdy = ( dzdy * fixscale ) | 0;

    var dtvdx, dtvdy, cbtu, cbtv;
    if ( bHasUV ) {

      // UV interpolation setup
      var dtu12 = tu1 - tu2, dtu31 = tu3 - tu1;
      var dtudx = ( invDet * ( dtu12 * dy31 - dtu31 * dy12 ) ); // dtu per one subpixel step in x
      var dtudy = ( invDet * ( dtu12 * dx31 - dx12 * dtu31 ) ); // dtu per one subpixel step in y
      var dtv12 = tv1 - tv2, dtv31 = tv3 - tv1;
      dtvdx = ( invDet * ( dtv12 * dy31 - dtv31 * dy12 ) ); // dtv per one subpixel step in x
      dtvdy = ( invDet * ( dtv12 * dx31 - dx12 * dtv31 ) ); // dtv per one subpixel step in y

      // UV at top/left corner of rast area
      cbtu = ( tu1 + ( minXfixscale - x1 ) * dtudx + ( minYfixscale - y1 ) * dtudy );
      cbtv = ( tv1 + ( minXfixscale - x1 ) * dtvdx + ( minYfixscale - y1 ) * dtvdy );

      // UV pixel steps
      dtudx = dtudx * fixscale;
      dtudy = dtudy * fixscale;
      dtvdx = dtvdx * fixscale;
      dtvdy = dtvdy * fixscale;

    }

    var dnzdy, cbnz;

    if ( bHasNormal ) {

       // Normal interpolation setup
      var dnz12 = nz1 - nz2, dnz31 = nz3 - nz1;
      var dnzdx = ( invDet * ( dnz12 * dy31 - dnz31 * dy12 ) ); // dnz per one subpixel step in x
      var dnzdy = ( invDet * ( dnz12 * dx31 - dx12 * dnz31 ) ); // dnz per one subpixel step in y

      // Normal at top/left corner of rast area
      cbnz = ( nz1 + ( minXfixscale - x1 ) * dnzdx + ( minYfixscale - y1 ) * dnzdy );

      // Normal pixel steps
      dnzdx = ( dnzdx * fixscale );
      dnzdy = ( dnzdy * fixscale );

    }

    // Set up min/max corners
    var qm1 = q - 1; // for convenience
    var nmin1 = 0, nmax1 = 0;
    var nmin2 = 0, nmax2 = 0;
    var nmin3 = 0, nmax3 = 0;
    var nminz = 0, nmaxz = 0;
    if ( dx12 >= 0 ) nmax1 -= qm1 * dx12; else nmin1 -= qm1 * dx12;
    if ( dy12 >= 0 ) nmax1 -= qm1 * dy12; else nmin1 -= qm1 * dy12;
    if ( dx23 >= 0 ) nmax2 -= qm1 * dx23; else nmin2 -= qm1 * dx23;
    if ( dy23 >= 0 ) nmax2 -= qm1 * dy23; else nmin2 -= qm1 * dy23;
    if ( dx31 >= 0 ) nmax3 -= qm1 * dx31; else nmin3 -= qm1 * dx31;
    if ( dy31 >= 0 ) nmax3 -= qm1 * dy31; else nmin3 -= qm1 * dy31;
    if ( dzdx >= 0 ) nmaxz += qm1 * dzdx; else nminz += qm1 * dzdx;
    if ( dzdy >= 0 ) nmaxz += qm1 * dzdy; else nminz += qm1 * dzdy;

    // Loop through blocks
    var linestep = canvasWidth - q;

    var cb1 = c1;
    var cb2 = c2;
    var cb3 = c3;
    var cbz = cz;
    var qstep = - q;
    var e1x = qstep * dy12;
    var e2x = qstep * dy23;
    var e3x = qstep * dy31;
    var ezx = qstep * dzdx;

    var etux, etvx;
    if ( bHasUV ) {

      etux = qstep * dtudx;
      etvx = qstep * dtvdx;

    }

    var enzx;
    if ( bHasNormal ) {

      enzx = qstep * dnzdx;

    }

    var x0 = minx;

    for ( var y0 = miny; y0 < maxy; y0 += q ) {

      // New block line - keep hunting for tri outer edge in old block line dir
      while ( x0 >= minx && x0 < maxx && cb1 >= nmax1 && cb2 >= nmax2 && cb3 >= nmax3 ) {

        x0 += qstep;
        cb1 += e1x;
        cb2 += e2x;
        cb3 += e3x;
        cbz += ezx;

        if ( bHasUV ) {

          cbtu += etux;
          cbtv += etvx;

        }

        if ( bHasNormal ) {

          cbnz += enzx;

        }

      }

      // Okay, we're now in a block we know is outside. Reverse direction and go into main loop.
      qstep = - qstep;
      e1x = - e1x;
      e2x = - e2x;
      e3x = - e3x;
      ezx = - ezx;

      if ( bHasUV ) {

        etux = - etux;
        etvx = - etvx;

      }

      if ( bHasNormal ) {

        enzx = - enzx;

      }

      while ( 1 ) {

        // Step everything
        x0 += qstep;
        cb1 += e1x;
        cb2 += e2x;
        cb3 += e3x;
        cbz += ezx;

        if ( bHasUV ) {

          cbtu += etux;
          cbtv += etvx;

        }

        if ( bHasNormal ) {

          cbnz += enzx;

        }

        // We're done with this block line when at least one edge completely out
        // If an edge function is too small and decreasing in the current traversal
        // dir, we're done with this line.
        if ( x0 < minx || x0 >= maxx ) break;
        if ( cb1 < nmax1 ) if ( e1x < 0 ) break; else continue;
        if ( cb2 < nmax2 ) if ( e2x < 0 ) break; else continue;
        if ( cb3 < nmax3 ) if ( e3x < 0 ) break; else continue;

        // We can skip this block if it's already fully covered
        var blockX = x0 >> blockShift;
        var blockY = y0 >> blockShift;
        var blockId = blockX + blockY * canvasWBlocks;
        var minz = cbz + nminz;

        // farthest point in block closer than closest point in our tri?
        if ( blockMaxZ[ blockId ] < minz ) continue;

        // Need to do a deferred clear?
        var bflags = blockFlags[ blockId ];
        if ( bflags & BLOCK_NEEDCLEAR ) clearBlock( blockX, blockY );
        blockFlags[ blockId ] = bflags & ~ ( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );

        // Offset at top-left corner
        var offset = x0 + y0 * canvasWidth;

        // Accept whole block when fully covered
        if ( cb1 >= nmin1 && cb2 >= nmin2 && cb3 >= nmin3 ) {

          var maxz = cbz + nmaxz;
          blockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );

          var cy1 = cb1;
          var cy2 = cb2;
          var cyz = cbz;

          var cytu, cytv;
          if ( bHasUV ) {

            cytu = cbtu;
            cytv = cbtv;

          }

          var cynz;
          if ( bHasNormal ) {

            cynz = cbnz;

          }


          for ( var iy = 0; iy < q; iy ++ ) {

            var cx1 = cy1;
            var cx2 = cy2;
            var cxz = cyz;

            var cxtu;
            var cxtv;
            if ( bHasUV ) {

              cxtu = cytu;
              cxtv = cytv;

            }

            var cxnz;
            if ( bHasNormal ) {

              cxnz = cynz;

            }

            for ( var ix = 0; ix < q; ix ++ ) {

              var z = cxz;

              if ( z < zbuffer[ offset ] ) {

                shader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );

              }

              cx1 += dy12;
              cx2 += dy23;
              cxz += dzdx;

              if ( bHasUV ) {

                cxtu += dtudx;
                cxtv += dtvdx;

              }

              if ( bHasNormal ) {

                cxnz += dnzdx;

              }

              offset ++;

            }

            cy1 += dx12;
            cy2 += dx23;
            cyz += dzdy;

            if ( bHasUV ) {

              cytu += dtudy;
              cytv += dtvdy;

            }

            if ( bHasNormal ) {

              cynz += dnzdy;

            }

            offset += linestep;

          }

        } else {

          // Partially covered block

          var cy1 = cb1;
          var cy2 = cb2;
          var cy3 = cb3;
          var cyz = cbz;

          var cytu, cytv;
          if ( bHasUV ) {

            cytu = cbtu;
            cytv = cbtv;

          }

          var cynz;
          if ( bHasNormal ) {

            cynz = cbnz;

          }

          for ( var iy = 0; iy < q; iy ++ ) {

            var cx1 = cy1;
            var cx2 = cy2;
            var cx3 = cy3;
            var cxz = cyz;

            var cxtu;
            var cxtv;
            if ( bHasUV ) {

              cxtu = cytu;
              cxtv = cytv;

            }

            var cxnz;
            if ( bHasNormal ) {

              cxnz = cynz;

            }

            for ( var ix = 0; ix < q; ix ++ ) {

              if ( ( cx1 | cx2 | cx3 ) >= 0 ) {

                var z = cxz;

                if ( z < zbuffer[ offset ] ) {

                  shader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );

                }

              }

              cx1 += dy12;
              cx2 += dy23;
              cx3 += dy31;
              cxz += dzdx;

              if ( bHasUV ) {

                cxtu += dtudx;
                cxtv += dtvdx;

              }

              if ( bHasNormal ) {

                cxnz += dnzdx;

              }

              offset ++;

            }

            cy1 += dx12;
            cy2 += dx23;
            cy3 += dx31;
            cyz += dzdy;

            if ( bHasUV ) {

              cytu += dtudy;
              cytv += dtvdy;

            }

            if ( bHasNormal ) {

              cynz += dnzdy;

            }

            offset += linestep;

          }

        }

      }

      // Advance to next row of blocks
      cb1 += q * dx12;
      cb2 += q * dx23;
      cb3 += q * dx31;
      cbz += q * dzdy;

      if ( bHasUV ) {

        cbtu += q * dtudy;
        cbtv += q * dtvdy;

      }

      if ( bHasNormal ) {

        cbnz += q * dnzdy;

      }

    }

  }

  // When drawing line, the blockShiftShift has to be zero. In order to clean pixel
  // Using color1 and color2 to interpolation pixel color
  // LineWidth is according to material.linewidth
  function drawLine( v1, v2, color1, color2, shader, material ) {

    // While the line mode is enable, blockSize has to be changed to 0.
    if ( ! lineMode ) {

      lineMode = true;
      blockShift = 0;
      blockSize = 1 << blockShift;

      setSize( canvas.width, canvas.height );

    }

    // TODO: Implement per-pixel z-clipping
    if ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 ) return;

    var halfLineWidth = Math.floor( ( material.linewidth - 1 ) * 0.5 );

    // https://gist.github.com/2486101
    // explanation: http://pouet.net/topic.php?which=8760&page=1

    // 28.4 fixed-point coordinates
    var x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;
    var x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;

    var y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;
    var y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;

    var z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;
    var z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;

    // Deltas
    var dx12 = x1 - x2, dy12 = y1 - y2, dz12 = z1 - z2;

    // Bounding rectangle
    var minx = Math.max( ( Math.min( x1, x2 ) + subpixelBias ) >> subpixelBits, 0 );
    var maxx = Math.min( ( Math.max( x1, x2 ) + subpixelBias ) >> subpixelBits, canvasWidth );
    var miny = Math.max( ( Math.min( y1, y2 ) + subpixelBias ) >> subpixelBits, 0 );
    var maxy = Math.min( ( Math.max( y1, y2 ) + subpixelBias ) >> subpixelBits, canvasHeight );
    var minz = Math.max( ( Math.min( z1, z2 ) + subpixelBias ) >> subpixelBits, 0 );
    var maxz = ( Math.max( z1, z2 ) + subpixelBias ) >> subpixelBits;

    rectx1 = Math.min( minx, rectx1 );
    rectx2 = Math.max( maxx, rectx2 );
    recty1 = Math.min( miny, recty1 );
    recty2 = Math.max( maxy, recty2 );

    // Get the line's unit vector and cross vector
    var length = Math.sqrt( ( dy12 * dy12 ) + ( dx12 * dx12 ) );
    var unitX = ( dx12 / length );
    var unitY = ( dy12 / length );
    var unitZ = ( dz12 / length );
    var pixelX, pixelY, pixelZ;
    var pX, pY, pZ;
    crossVector.set( unitX, unitY, unitZ );
    crossVector.cross( lookVector );
    crossVector.normalize();

    while ( length > 0 ) {

      // Get this pixel.
      pixelX = x2 + length * unitX;
      pixelY = y2 + length * unitY;
      pixelZ = z2 + length * unitZ;

      pixelX = ( pixelX + subpixelBias ) >> subpixelBits;
      pixelY = ( pixelY + subpixelBias ) >> subpixelBits;
      pZ = ( pixelZ + subpixelBias ) >> subpixelBits;

      // Draw line with line width
      for ( var i = - halfLineWidth; i <= halfLineWidth; ++ i ) {

        // Compute the line pixels.
        // Get the pixels on the vector that crosses to the line vector
        pX = Math.floor( ( pixelX + crossVector.x * i ) );
        pY = Math.floor( ( pixelY + crossVector.y * i ) );

        // if pixel is over the rect. Continue
        if ( rectx1 >= pX || rectx2 <= pX || recty1 >= pY || recty2 <= pY )
          continue;

        // Find this pixel at which block
        var blockX = pX >> blockShift;
        var blockY = pY >> blockShift;
        var blockId = blockX + blockY * canvasWBlocks;

        // Compare the pixel depth width z block.
        if ( blockMaxZ[ blockId ] < minz ) continue;

        blockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );

        var bflags = blockFlags[ blockId ];
        if ( bflags & BLOCK_NEEDCLEAR ) clearBlock( blockX, blockY );
        blockFlags[ blockId ] = bflags & ~( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );

        // draw pixel
        var offset = pX + pY * canvasWidth;

        if ( pZ < zbuffer[ offset ] ) {

          shader( data, zbuffer, offset, pZ, color1, color2, material );

        }

      }

      --length;

    }

  }

  function clearBlock( blockX, blockY ) {

    var zoffset = blockX * blockSize + blockY * blockSize * canvasWidth;
    var poffset = zoffset * 4;

    var zlinestep = canvasWidth - blockSize;
    var plinestep = zlinestep * 4;

    for ( var y = 0; y < blockSize; y ++ ) {

      for ( var x = 0; x < blockSize; x ++ ) {

        zbuffer[ zoffset ++ ] = maxZVal;

        data[ poffset ++ ] = clearColor.r * 255 | 0;
        data[ poffset ++ ] = clearColor.g * 255 | 0;
        data[ poffset ++ ] = clearColor.b * 255 | 0;
        data[ poffset ++ ] = alpha ? 0 : 255;

      }

      zoffset += zlinestep;
      poffset += plinestep;

    }

  }

  function finishClear( ) {

    var block = 0;

    for ( var y = 0; y < canvasHBlocks; y ++ ) {

      for ( var x = 0; x < canvasWBlocks; x ++ ) {

        if ( blockFlags[ block ] & BLOCK_NEEDCLEAR ) {

          clearBlock( x, y );
          blockFlags[ block ] = BLOCK_ISCLEAR;

        }

        block ++;

      }

    }

  }

};

THREE.SoftwareRenderer.Texture = function () {

  var canvas;

  this.fromImage = function ( image ) {

    if ( ! image || image.width <= 0 || image.height <= 0 )
      return;

    if ( canvas === undefined ) {

      canvas = document.createElement( 'canvas' );

    }

    var size = image.width > image.height ? image.width : image.height;
    size = THREE.Math.nextPowerOfTwo( size );

    if ( canvas.width != size || canvas.height != size ) {

      canvas.width = size;
      canvas.height = size;

    }

    var ctx = canvas.getContext( '2d' );
    ctx.clearRect( 0, 0, size, size );
    ctx.drawImage( image, 0, 0, size, size );

    var imgData = ctx.getImageData( 0, 0, size, size );

    this.data = imgData.data;
    this.width = size;
    this.height = size;
    this.srcUrl = image.src;

  };

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SVGObject = function ( node ) {

  THREE.Object3D.call( this );

  this.node = node;

};

THREE.SVGObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.SVGObject.prototype.constructor = THREE.SVGObject;

THREE.SVGRenderer = function () {

  console.log( 'THREE.SVGRenderer', THREE.REVISION );

  var _this = this,
  _renderData, _elements, _lights,
  _projector = new THREE.Projector(),
  _svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ),
  _svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,

  _v1, _v2, _v3, _v4,

  _clipBox = new THREE.Box2(),
  _elemBox = new THREE.Box2(),

  _color = new THREE.Color(),
  _diffuseColor = new THREE.Color(),
  _ambientLight = new THREE.Color(),
  _directionalLights = new THREE.Color(),
  _pointLights = new THREE.Color(),
  _clearColor = new THREE.Color(),
  _clearAlpha = 1,

  _vector3 = new THREE.Vector3(), // Needed for PointLight
  _centroid = new THREE.Vector3(),
  _normal = new THREE.Vector3(),
  _normalViewMatrix = new THREE.Matrix3(),

  _viewMatrix = new THREE.Matrix4(),
  _viewProjectionMatrix = new THREE.Matrix4(),

  _svgPathPool = [],
  _svgNode, _pathCount = 0,

  _currentPath, _currentStyle,

  _quality = 1, _precision = null;

  this.domElement = _svg;

  this.autoClear = true;
  this.sortObjects = true;
  this.sortElements = true;

  this.info = {

    render: {

      vertices: 0,
      faces: 0

    }

  };

  this.setQuality = function( quality ) {

    switch ( quality ) {

      case "high": _quality = 1; break;
      case "low": _quality = 0; break;

    }

  };

  // WebGLRenderer compatibility

  this.supportsVertexTextures = function () {};
  this.setFaceCulling = function () {};

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );
    _clearAlpha = alpha !== undefined ? alpha : 1;

  };

  this.setPixelRatio = function () {};

  this.setSize = function( width, height ) {

    _svgWidth = width; _svgHeight = height;
    _svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;

    _svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );
    _svg.setAttribute( 'width', _svgWidth );
    _svg.setAttribute( 'height', _svgHeight );

    _clipBox.min.set( - _svgWidthHalf, - _svgHeightHalf );
    _clipBox.max.set( _svgWidthHalf, _svgHeightHalf );

  };

  this.setPrecision = function ( precision ) {

    _precision = precision;

  };

  function removeChildNodes() {

    _pathCount = 0;

    while ( _svg.childNodes.length > 0 ) {

      _svg.removeChild( _svg.childNodes[ 0 ] );

    }

  }

  function getSvgColor ( color, opacity ) {

    var arg = Math.floor( color.r * 255 ) + ',' + Math.floor( color.g * 255 ) + ',' + Math.floor( color.b * 255 );

    if ( opacity === undefined || opacity === 1 ) return 'rgb(' + arg + ')';

    return 'rgb(' + arg + '); fill-opacity: ' + opacity;

  }

  function convert ( c ) {

    return _precision !== null ? c.toFixed(_precision) : c;

  }

  this.clear = function () {

    removeChildNodes();
    _svg.style.backgroundColor = getSvgColor( _clearColor, _clearAlpha );

  };

  this.render = function ( scene, camera ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.SVGRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var background = scene.background;

    if ( background && background.isColor ) {

      removeChildNodes();
      _svg.style.backgroundColor = getSvgColor( background );

    } else if ( this.autoClear === true ) {

      this.clear();

    }

    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;

    _viewMatrix.copy( camera.matrixWorldInverse );
    _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

    _renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
    _elements = _renderData.elements;
    _lights = _renderData.lights;

    _normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );

    calculateLights( _lights );

     // reset accumulated path

    _currentPath = '';
    _currentStyle = '';

    for ( var e = 0, el = _elements.length; e < el; e ++ ) {

      var element = _elements[ e ];
      var material = element.material;

      if ( material === undefined || material.opacity === 0 ) continue;

      _elemBox.makeEmpty();

      if ( element instanceof THREE.RenderableSprite ) {

        _v1 = element;
        _v1.x *= _svgWidthHalf; _v1.y *= - _svgHeightHalf;

        renderSprite( _v1, element, material );

      } else if ( element instanceof THREE.RenderableLine ) {

        _v1 = element.v1; _v2 = element.v2;

        _v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
        _v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;

        _elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );

        if ( _clipBox.intersectsBox( _elemBox ) === true ) {

          renderLine( _v1, _v2, element, material );

        }

      } else if ( element instanceof THREE.RenderableFace ) {

        _v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

        if ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) continue;
        if ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) continue;
        if ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) continue;

        _v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
        _v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;
        _v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;

        _elemBox.setFromPoints( [
          _v1.positionScreen,
          _v2.positionScreen,
          _v3.positionScreen
        ] );

        if ( _clipBox.intersectsBox( _elemBox ) === true ) {

          renderFace3( _v1, _v2, _v3, element, material );

        }

      }

    }

    flushPath(); // just to flush last svg:path

    scene.traverseVisible( function ( object ) {

       if ( object instanceof THREE.SVGObject ) {

        _vector3.setFromMatrixPosition( object.matrixWorld );
        _vector3.applyMatrix4( _viewProjectionMatrix );

        var x =   _vector3.x * _svgWidthHalf;
        var y = - _vector3.y * _svgHeightHalf;

        var node = object.node;
        node.setAttribute( 'transform', 'translate(' + x + ',' + y + ')' );

        _svg.appendChild( node );

      }

    } );

  };

  function calculateLights( lights ) {

    _ambientLight.setRGB( 0, 0, 0 );
    _directionalLights.setRGB( 0, 0, 0 );
    _pointLights.setRGB( 0, 0, 0 );

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];
      var lightColor = light.color;

      if ( light instanceof THREE.AmbientLight ) {

        _ambientLight.r += lightColor.r;
        _ambientLight.g += lightColor.g;
        _ambientLight.b += lightColor.b;

      } else if ( light instanceof THREE.DirectionalLight ) {

        _directionalLights.r += lightColor.r;
        _directionalLights.g += lightColor.g;
        _directionalLights.b += lightColor.b;

      } else if ( light instanceof THREE.PointLight ) {

        _pointLights.r += lightColor.r;
        _pointLights.g += lightColor.g;
        _pointLights.b += lightColor.b;

      }

    }

  }

  function calculateLight( lights, position, normal, color ) {

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];
      var lightColor = light.color;

      if ( light instanceof THREE.DirectionalLight ) {

        var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

        var amount = normal.dot( lightPosition );

        if ( amount <= 0 ) continue;

        amount *= light.intensity;

        color.r += lightColor.r * amount;
        color.g += lightColor.g * amount;
        color.b += lightColor.b * amount;

      } else if ( light instanceof THREE.PointLight ) {

        var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

        var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

        if ( amount <= 0 ) continue;

        amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

        if ( amount == 0 ) continue;

        amount *= light.intensity;

        color.r += lightColor.r * amount;
        color.g += lightColor.g * amount;
        color.b += lightColor.b * amount;

      }

    }

  }

  function renderSprite( v1, element, material ) {

    var scaleX = element.scale.x * _svgWidthHalf;
    var scaleY = element.scale.y * _svgHeightHalf;

    if ( material.isPointsMaterial ) {
      scaleX *= material.size;
      scaleY *= material.size;
    }

    var path = 'M' + convert( v1.x - scaleX * 0.5 ) + ',' + convert( v1.y - scaleY * 0.5 ) + 'h' + convert( scaleX ) + 'v' + convert( scaleY ) + 'h' + convert(-scaleX) + 'z';
    var style = "";

    if ( material.isSpriteMaterial || material.isPointsMaterial ) {

      style = 'fill:' + getSvgColor( material.color, material.opacity );

    }

    addPath( style, path );

  }

  function renderLine( v1, v2, element, material ) {

    var path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y );

    if ( material.isLineBasicMaterial ) {

      var style = 'fill:none;stroke:' + getSvgColor( material.color, material.opacity ) + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;

      if ( material.isLineDashedMaterial ) {

        style = style + ';stroke-dasharray:' + material.dashSize + "," + material.gapSize;

      }

      addPath( style, path );

    }

  }

  function renderFace3( v1, v2, v3, element, material ) {

    _this.info.render.vertices += 3;
    _this.info.render.faces ++;

    var path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y ) + 'L' + convert( v3.positionScreen.x ) + ',' + convert( v3.positionScreen.y ) + 'z';
    var style = '';

    if ( material instanceof THREE.MeshBasicMaterial ) {

      _color.copy( material.color );

      if ( material.vertexColors === THREE.FaceColors ) {

        _color.multiply( element.color );

      }

    } else if ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

      _diffuseColor.copy( material.color );

      if ( material.vertexColors === THREE.FaceColors ) {

        _diffuseColor.multiply( element.color );

      }

      _color.copy( _ambientLight );

      _centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );

      calculateLight( _lights, _centroid, element.normalModel, _color );

      _color.multiply( _diffuseColor ).add( material.emissive );

    } else if ( material instanceof THREE.MeshNormalMaterial ) {

      _normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );

      _color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

    }

    if ( material.wireframe ) {

      style = 'fill:none;stroke:' + getSvgColor( _color, material.opacity ) + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;

    } else {

      style = 'fill:' + getSvgColor( _color, material.opacity );

    }

    addPath( style, path );

  }

  function addPath ( style, path ) {

    if ( _currentStyle === style ) {

      _currentPath += path

    } else {

      flushPath();

      _currentStyle = style;
      _currentPath = path;

    }

  }

  function flushPath() {

    if ( _currentPath ) {

      _svgNode = getPathNode( _pathCount ++ );
      _svgNode.setAttribute( 'd', _currentPath );
      _svgNode.setAttribute( 'style', _currentStyle );
      _svg.appendChild( _svgNode );

    }

    _currentPath = '';
    _currentStyle = '';

  }

  function getPathNode( id ) {

    if ( _svgPathPool[ id ] == null ) {

      _svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );

      if ( _quality == 0 ) {

        _svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed

      }

      return _svgPathPool[ id ];

    }

    return _svgPathPool[ id ];

  }

};

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    (this || window).CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) this.zeroWidthHack();
        this.checkedZeroWidth = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
    },
    zeroWidthHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed;
      this.disableVert = new Delayed;
    },
    enableZeroWidthBar: function(bar, delay) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // left corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
        if (elt != bar) bar.style.pointerEvents = "none";
        else delay.set(1000, maybeDisable);
      }
      delay.set(1000, maybeDisable);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                      "px; width: " + dims.gutterTotalWidth + "px");
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = doc.splitLines(inserted), multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.length; i++)
            multiPaste.push(doc.splitLines(lastCopied[i]));
        }
      } else if (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, function(l) { return [l]; });
      }
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !paste) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) return;
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          indented = indentLine(cm, range.head.line, "smart");
      }
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        if (input.composing) input.composing.range.clear()
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput && !this.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        return false;

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) prevInput = "\u200b";
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, self.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;

        if (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      input.wrapper.style.cssText = "position: absolute"
      var wrapperBox = input.wrapper.getBoundingClientRect()
      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function(val) {
      if (!val) this.reset();
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div);

      on(div, "paste", function(e) {
        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);
      })

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (cm.isReadOnly() || !input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && this.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) sel.addRange(rng);
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.lineDiv.lastChild;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (this.cm.isReadOnly())
        operation(this.cm, regChange)(this.cm)
      else if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.contentEditable = "false"
    },

    onKeyPress: function(e) {
      e.preventDefault();
      if (!this.cm.isReadOnly())
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    readOnlyChanged: function(val) {
      this.div.contentEditable = String(val != "nocursor")
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += lineSep;
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel, options);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) break;
            else {--i; continue;}
          }
        }
        if (!m.atomic) continue;

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff;
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            return skipAtomicInner(doc, near, pos, dir, mayClear);
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
      else return null;
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
      else return null;
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range.head, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i].call(null);
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))
      ensureFocus(op.cm);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function(e){onDragStart(cm, e);},
      drop: operation(cm, onDrop),
      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != CodeMirror.Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      // #3261: make sure, that we're not starting a second selection
      if (cm.state.selectingText)
        cm.state.selectingText(e);
      else if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else cm.curOp.focus = activeElt();

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
        (cmp(contained.to(), start) > 0 || start.xRel < 0))
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display, startTime = +new Date;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date - 200 < startTime)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          return;

        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove"

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) return;
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return false
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return false
      } else ch = next;
      return true;
    }

    if (unit == "char") {
      moveOnce()
    } else if (unit == "column") {
      moveOnce(true)
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
    if (!cmp(pos, result)) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("lineSeparator", null, function(cm, val) {
    cm.doc.lineSep = val;
    if (!val) return;
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function(line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
    }
    cm.display.input.readOnlyChanged(val)
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = (css ? css + ";" : "") + m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.extend = false;

    if (typeof text == "string") text = this.splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || this.lineSeparator());
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function(line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + sepSize;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;},

    splitLines: function(str) {
      if (this.lineSep) return str.split(this.lineSep);
      return splitLinesAuto(str);
    },
    lineSeparator: function() { return this.lineSep || "\n"; }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var noHandlers = []
  function getHandlers(emitter, type, copy) {
    var arr = emitter._handlers && emitter._handlers[type]
    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
    else return arr || noHandlers
  }

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var handlers = getHandlers(emitter, type, false)
      for (var i = 0; i < handlers.length; ++i)
        if (handlers[i] == f) { handlers.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type, true)
    if (!handlers.length) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type, false)
    if (!arr.length) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() {
    var activeElement = document.activeElement;
    while (activeElement && activeElement.root && activeElement.root.activeElement)
      activeElement = activeElement.root.activeElement;
    return activeElement;
  }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = CodeMirror.keyNames = {
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2)
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.14.2";

  return CodeMirror;
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

function expressionAllowed(stream, state, backUp) {
  return /^(?:operator|sof|keyword c|case|new|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
    (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
}

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("class"),
        "implements": C,
        "namespace": C,
        "module": kw("module"),
        "enum": kw("module"),

        // scope modifiers
        "public": kw("modifier"),
        "private": kw("modifier"),
        "protected": kw("modifier"),
        "abstract": kw("modifier"),

        // operators
        "as": operator,

        // types
        "string": type, "number": type, "boolean": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/o/i)) {
      stream.eatWhile(/[0-7]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/b/i)) {
      stream.eatWhile(/[01]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "class") return cont(pushlex("form"), className, poplex);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (type == "modifier") {
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expression);
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function maybedefault(_, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function typedef(type) {
    if (type == "variable") {cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "modifier") return cont(pattern)
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype, maybedefault);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "extends") return cont(expression, classNameAfter);
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      if (value == "static") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
      return cont(functiondef, classBody);
    }
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
  }
  function classGetterSetter(type) {
    if (type != "variable") return pass();
    cx.marked = "property";
    return cont();
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,
    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

// Full source: 
//
//    https://github.com/hughsk/glsl-editor 
//
// (C) Copyright Hugh Kennedy
//
// This software is released under the MIT license:
//
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEAL-
// INGS IN THE SOFTWARE.

// The original source code has been slightly modified for the purpose of
// integration (tschw).

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

  CodeMirror.defineMode("glsl", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || words(glslKeywords),
        builtins = parserConfig.builtins || words(glslBuiltins),
        blockKeywords = parserConfig.blockKeywords || words("case do else for if switch while struct"),
        atoms = parserConfig.atoms || words("null"),
        hooks = parserConfig.hooks || {},
        multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;

    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return "bracket";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (ch == "#") {
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        return "comment";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(cur)) {
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      return "word";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {end = true; break;}
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = tokenBase;
        return "string";
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      return state.context = new Context(state.indented, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    // Interface

    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },

      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return 0;
        var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
        else if (ctx.align) return ctx.column + (closing ? 0 : 1);
        else return ctx.indented + (closing ? 0 : indentUnit);
      },

      electricChars: "{}"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var glslKeywords = "attribute const uniform varying break continue " +
    "do for while if else in out inout float int void bool true false " +
    "lowp mediump highp precision invariant discard return mat2 mat3 " +
    "mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D " +
    "samplerCube struct gl_FragCoord gl_FragColor";
  var glslBuiltins = "radians degrees sin cos tan asin acos atan pow " +
    "exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod " +
    "min max clamp mix step smoothstep length distance dot cross " +
    "normalize faceforward reflect refract matrixCompMult lessThan " +
    "lessThanEqual greaterThan greaterThanEqual equal notEqual any all " +
    "not dFdx dFdy fwidth texture2D texture2DProj texture2DLod " +
    "texture2DProjLod textureCube textureCubeLod require export";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  ;(function() {
    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
      var next;
      while ((next = stream.next()) != null) {
        if (next == '"' && !stream.eat('"')) {
          state.tokenize = null;
          break;
        }
      }
      return "string";
    }

    CodeMirror.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: words(glslKeywords),
      builtins: words(glslBuiltins),
      blockKeywords: words("case do else for if switch while struct"),
      atoms: words("null"),
      hooks: {"#": cppHook}
    });
  }());
});

/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: {
            type: 'ArrowParameterPlaceHolder'
        }
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwUnexpectedToken();
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwUnexpectedToken();
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwUnexpectedToken();
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwUnexpectedToken();
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwUnexpectedToken();
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern,
            value;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode code point
            // escape sequence with a single ASCII symbol to avoid throwing on
            // regular expressions that are only valid in combination with the
            // `/u` flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it
            // would be replaced by `[x-b]` which throws an error.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                    if (parseInt($1, 16) <= 0x10FFFF) {
                        return 'x';
                    }
                    throwError(Messages.InvalidRegExp);
                })
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
        }

        // First, detect invalid regular expressions.
        try {
            value = new RegExp(tmp);
        } catch (e) {
            throwError(Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError(Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError(Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError(Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
            this.start = {
                line: startToken.startLineNumber,
                column: startToken.start - startToken.startLineStart
            };
        } else {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
        }
        this.end = null;
    }

    function Node() {
        // Skip comment.
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
            lineNumber = lookahead.startLineNumber;
            lineStart = lookahead.startLineStart;
        } else {
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
        }
        if (extra.range) {
            this.range = [index, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = index;
            }
            if (extra.loc) {
                this.loc.end = new Position();
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = guardedHandlers;
            this.handlers = handlers;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    function createError(line, pos, description) {
        var error = new Error('Line ' + line + ': ' + description);
        error.index = pos;
        error.lineNumber = line;
        error.column = pos - lineStart + 1;
        error.description = description;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lineNumber, index, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, index, msg);
        if (extra.errors) {
            extra.errors.push(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var msg = Messages.UnexpectedToken;

        if (token) {
            msg = message ? message :
                (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                Messages.UnexpectedToken;

            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    msg = Messages.UnexpectedReserved;
                } else if (strict && isStrictModeReservedWord(token.value)) {
                    msg = Messages.StrictReservedWord;
                }
            }
        }

        msg = msg.replace('%0', token ? token.value : 'ILLEGAL');

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(lineNumber, index, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            extra.errors.push(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber,
            oldLineStart = lineStart, oldLookahead = lookahead;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node();

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, node = new Node();

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            tolerateUnexpectedToken(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
    }

    function parsePropertyMethodFunction() {
        var previousStrict, param, method;

        previousStrict = strict;
        strict = true;
        param = parseParams();
        method = parsePropertyFunction(param.params);
        strict = previousStrict;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node();

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, node = new Node();

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return node.finishProperty('get', key, value, false, false);
            }
            if (token.value === 'set' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    tolerateUnexpectedToken(token);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return node.finishProperty('set', key, value, false, false);
            }
            if (match(':')) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty('init', id, value, false, false);
            }
            if (match('(')) {
                value = parsePropertyMethodFunction();
                return node.finishProperty('init', id, value, true, false);
            }

            value = id;
            return node.finishProperty('init', id, value, false, true);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpectedToken(token);
        } else {
            key = parseObjectPropertyKey();
            if (match(':')) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty('init', key, value, false, false);
            }
            if (match('(')) {
                value = parsePropertyMethodFunction();
                return node.finishProperty('init', key, value, true, false);
            }
            throwUnexpectedToken(lex());
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        tolerateError(Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        tolerateError(Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        if (match(')')) {
            lex();
            return PlaceHolders.ArrowParameterPlaceHolder;
        }

        ++state.parenthesisCount;

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = node.finishThisExpression();
            } else {
                throwUnexpectedToken(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = node.finishLiteral(collectRegex());
            } else {
                expr = node.finishLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
            return left;
        }

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
            return expr;
        }
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest, token;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var oldParenthesisCount, token, expr, right, list, startToken;

        oldParenthesisCount = state.parenthesisCount;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            if (state.parenthesisCount === oldParenthesisCount ||
                    state.parenthesisCount === (oldParenthesisCount + 1)) {
                if (expr.type === Syntax.Identifier) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.AssignmentExpression) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.SequenceExpression) {
                    list = reinterpretAsCoverFormalsList(expr.expressions);
                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
                    list = reinterpretAsCoverFormalsList([]);
                }
                if (list) {
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
            }
        }

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expressions = [expr];

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(parseAssignmentExpression());
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                throwUnexpectedToken(token);
            }
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, node = new Node();

        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, node = new Node();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, kind);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        var node = new Node();
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, node = new Node();

        token = lex();
        declarations = parseVariableDeclarationList();

        return node.finishVariableDeclaration(declarations, token.value);
    }

    function parseForStatement(node) {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(sourceElements);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match('=')) {
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, node;

        skipComment();
        peek();
        node = new Node();
        strict = false;

        body = parseSourceElements();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            parenthesisCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.0.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

// Full source:
//
//    https://github.com/zaach/jsonlint
//
// Copyright (C) 2012 Zachary Carter
//
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEAL-
// INGS IN THE SOFTWARE.

/* Jison generated parser */
var jsonlint = (function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: // replace escaped characters with actual character
          this.$ = yytext.replace(/\\(\\|")/g, "$"+"1")
                     .replace(/\\n/g,'\n')
                     .replace(/\\r/g,'\r')
                     .replace(/\\t/g,'\t')
                     .replace(/\\v/g,'\v')
                     .replace(/\\f/g,'\f')
                     .replace(/\\b/g,'\b');
        
break;
case 2:this.$ = Number(yytext);
break;
case 3:this.$ = null;
break;
case 4:this.$ = true;
break;
case 5:this.$ = false;
break;
case 6:return this.$ = $$[$0-1];
break;
case 13:this.$ = {};
break;
case 14:this.$ = $$[$0-1];
break;
case 15:this.$ = [$$[$0-2], $$[$0]];
break;
case 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
break;
case 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];
break;
case 18:this.$ = [];
break;
case 19:this.$ = $$[$0-1];
break;
case 20:this.$ = [$$[$0]];
break;
case 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
break;
}
},
table: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],
defaultActions: {16:[2,6]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    //this.reductionCount = this.shiftCount = 0;

    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    if (typeof this.lexer.yylloc == 'undefined')
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);

    if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

    function popStack (n) {
        stack.length = stack.length - 2*n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

    function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length-1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol == null)
                symbol = lex();
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        _handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {

            if (!recovering) {
                // Report error
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                    expected.push("'"+this.terminals_[p]+"'");
                }
                var errStr = '';
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + this.terminals_[symbol]+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr,
                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                }

                // discard current lookahead and grab another
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            while (1) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    break;
                }
                if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                }
                popStack(1);
                state = stack[stack.length-1];
            }

            preErrorSymbol = symbol; // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {

            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                        recovering--;
                } else { // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2: // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3: // accept
                return true;
        }

    }

    return true;
}};
/* Jison generated lexer */
var lexer = (function(){
var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parseError) {
            this.yy.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext+=ch;
        this.yyleng++;
        this.match+=ch;
        this.matched+=ch;
        var lines = ch.match(/\n/);
        if (lines) this.yylineno++;
        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        this._input = ch + this._input;
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
less:function (n) {
        this._input = this.match.slice(n) + this._input;
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            tempMatch,
            index,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex) break;
            }
        }
        if (match) {
            lines = match[0].match(/\n.*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {first_line: this.yylloc.last_line,
                           last_line: this.yylineno+1,
                           first_column: this.yylloc.last_column,
                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}
            this.yytext += match[0];
            this.match += match[0];
            this.yyleng = this.yytext.length;
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;
            else return;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(), 
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.options = {};
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 6
break;
case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
break;
case 3:return 17
break;
case 4:return 18
break;
case 5:return 23
break;
case 6:return 24
break;
case 7:return 22
break;
case 8:return 21
break;
case 9:return 10
break;
case 10:return 11
break;
case 11:return 8
break;
case 12:return 14
break;
case 13:return 'INVALID'
break;
}
};
lexer.rules = [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/];
lexer.conditions = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}};


;
return lexer;})()
parser.lexer = lexer;
return parser;
})();
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = jsonlint;
exports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }
exports.main = function commonjsMain(args) {
    if (!args[1])
        throw new Error('Usage: '+args[0]+' FILE');
    if (typeof process !== 'undefined') {
        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), "utf8");
    } else {
        var cwd = require("file").path(require("file").cwd());
        var source = cwd.join(args[1]).read({charset: "utf-8"});
    }
    return exports.parser.parse(source);
}
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
}
}

/* Copyright 2011-2015 Roy Williams, Tobias Schwinger and the Closure team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function(){var aa=this;function da(c){return void 0!==c}
function ea(c){var f=typeof c;if("object"==f)if(c){if(c instanceof Array)return"array";if(c instanceof Object)return f;var k=Object.prototype.toString.call(c);if("[object Window]"==k)return"object";if("[object Array]"==k||"number"==typeof c.length&&"undefined"!=typeof c.splice&&"undefined"!=typeof c.propertyIsEnumerable&&!c.propertyIsEnumerable("splice"))return"array";if("[object Function]"==k||"undefined"!=typeof c.call&&"undefined"!=typeof c.propertyIsEnumerable&&!c.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==f&&"undefined"==typeof c.call)return"object";return f}function fa(c,f,k){return c.call.apply(c.bind,arguments)}function ga(c,f,k){if(!c)throw Error();if(2<arguments.length){var n=Array.prototype.slice.call(arguments,2);return function(){var g=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(g,n);return c.apply(f,g)}}return function(){return c.apply(f,arguments)}}
function ia(c,f,k){ia=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?fa:ga;return ia.apply(null,arguments)}function ka(c,f){var k=c.split("."),n=aa;k[0]in n||!n.execScript||n.execScript("var "+k[0]);for(var g;k.length&&(g=k.shift());)!k.length&&da(f)?n[g]=f:n[g]?n=n[g]:n=n[g]={}}
function v(c,f){function k(){}k.prototype=f.prototype;c.Ma=f.prototype;c.prototype=new k;c.prototype.constructor=c;c.La=function(c,g,k){for(var B=Array(arguments.length-2),q=2;q<arguments.length;q++)B[q-2]=arguments[q];return f.prototype[g].apply(c,B)}};var la={};
function z(c,f){function k(b){var a=b.charCodeAt(0),e;255>=a?(b="x",e=2):(b="u",e=4);var d=a.toString(16).toUpperCase(),a=d;e-=d.length;for(d=0;d<e;d++)a="0"+a;return"\\"+b+a}function n(b){return'"'+b.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,k)+'"'}function g(c){b<ta||(b>ta&&(ta=b,ob=[]),ob.push(c))}function u(){var w="newLine@"+b,a=p[w];if(a)return b=
a.b,a.result;var e;e=b;/^[\n]/.test(c.charAt(b))?(a=c.charAt(b),b++):(a=null,0===l&&g("[\\n]"));null!==a&&(a="\n");null===a&&(b=e);p[w]={b:b,result:a};return a}function B(){var w="EOF@"+b,a=p[w];if(a)return b=a.b,a.result;var e;e=b;l++;c.length>b?(a=c.charAt(b),b++):(a=null,0===l&&g("any character"));l--;null===a?a="":(a=null,b=e);p[w]={b:b,result:a};return a}function q(){var w="_@"+b,a=p[w];if(a)return b=a.b,a.result;var e;l++;e=u();null===e&&(/^[\\\n]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,
0===l&&g("[\\\\\\n]")),null===e&&(/^[\r\t\f\x0B ]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[\\r\\t\\f\\x0B ]")),null===e&&(e=C())));if(null!==e)for(a=[];null!==e;)a.push(e),e=u(),null===e&&(/^[\\\n]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[\\\\\\n]")),null===e&&(/^[\r\t\f\x0B ]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[\\r\\t\\f\\x0B ]")),null===e&&(e=C())));else a=null;l--;0===l&&null===a&&g("whitespace");p[w]={b:b,result:a};return a}function x(){var w=
"noNewlineComment@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t;m=b;"/*"===c.substr(b,2)?(a="/*",b+=2):(a=null,0===l&&g('"/*"'));if(null!==a){e=[];h=t=b;l++;"*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"'));l--;null===d?d="":(d=null,b=h);null!==d?(c.length>b?(h=c.charAt(b),b++):(h=null,0===l&&g("any character")),null!==h?d=[d,h]:(d=null,b=t)):(d=null,b=t);for(;null!==d;)e.push(d),h=t=b,l++,"*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"')),l--,null===d?d="":(d=null,b=h),
null!==d?(c.length>b?(h=c.charAt(b),b++):(h=null,0===l&&g("any character")),null!==h?d=[d,h]:(d=null,b=t)):(d=null,b=t);null!==e?("*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"')),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)}else a=null,b=m;if(null===a)if(m=b,"//"===c.substr(b,2)?(a="//",b+=2):(a=null,0===l&&g('"//"')),null!==a){e=[];/^[^\n]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[^\\n]"));for(;null!==d;)e.push(d),/^[^\n]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,
0===l&&g("[^\\n]"));null!==e?a=[a,e]:(a=null,b=m)}else a=null,b=m;p[w]={b:b,result:a};return a}function ha(){var w="noNewlineWhitespace@"+b,a=p[w];if(a)return b=a.b,a.result;var e;/^[\r\t\f\x0B ]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[\\r\\t\\f\\x0B ]"));null===e&&(e=x());if(null!==e)for(a=[];null!==e;)a.push(e),/^[\r\t\f\x0B ]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[\\r\\t\\f\\x0B ]")),null===e&&(e=x());else a=null;p[w]={b:b,result:a};return a}function C(){var w=
"comment@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t;l++;m=b;"/*"===c.substr(b,2)?(a="/*",b+=2):(a=null,0===l&&g('"/*"'));if(null!==a){e=[];h=t=b;l++;"*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"'));l--;null===d?d="":(d=null,b=h);null!==d?(c.length>b?(h=c.charAt(b),b++):(h=null,0===l&&g("any character")),null!==h?d=[d,h]:(d=null,b=t)):(d=null,b=t);for(;null!==d;)e.push(d),h=t=b,l++,"*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"')),l--,null===d?d="":(d=null,b=h),null!==
d?(c.length>b?(h=c.charAt(b),b++):(h=null,0===l&&g("any character")),null!==h?d=[d,h]:(d=null,b=t)):(d=null,b=t);null!==e?("*/"===c.substr(b,2)?(d="*/",b+=2):(d=null,0===l&&g('"*/"')),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)}else a=null,b=m;if(null===a)if(m=b,"//"===c.substr(b,2)?(a="//",b+=2):(a=null,0===l&&g('"//"')),null!==a){e=[];/^[^\n]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[^\\n]"));for(;null!==d;)e.push(d),/^[^\n]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&
g("[^\\n]"));null!==e?(d=u(),null===d&&(d=B()),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)}else a=null,b=m;l--;0===l&&null===a&&g("comment");p[w]={b:b,result:a};return a}function A(){var w="semicolon@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(59===c.charCodeAt(b)?(e=";",b+=1):(e=null,0===l&&g('";"')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function H(){var w="comma@"+b,a=p[w];
if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(44===c.charCodeAt(b)?(e=",",b+=1):(e=null,0===l&&g('","')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function ua(){var w="left_bracket@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(91===c.charCodeAt(b)?(e="[",b+=1):(e=null,0===l&&g('"["')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,
b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function va(){var w="right_bracket@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(93===c.charCodeAt(b)?(e="]",b+=1):(e=null,0===l&&g('"]"')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function cc(){var w="equals@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(61===c.charCodeAt(b)?(e="=",b+=1):(e=null,
0===l&&g('"="')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function ba(){var w="left_paren@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(40===c.charCodeAt(b)?(e="(",b+=1):(e=null,0===l&&g('"("')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function ca(){var w="right_paren@"+b,a=p[w];if(a)return b=a.b,a.result;
var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(41===c.charCodeAt(b)?(e=")",b+=1):(e=null,0===l&&g('")"')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function pb(){var w="left_brace@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(123===c.charCodeAt(b)?(e="{",b+=1):(e=null,0===l&&g('"{"')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,
result:a};return a}function qb(){var w="right_brace@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h;h=b;a=q();a=null!==a?a:"";null!==a?(125===c.charCodeAt(b)?(e="}",b+=1):(e=null,0===l&&g('"}"')),null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=h)):(a=null,b=h)):(a=null,b=h);p[w]={b:b,result:a};return a}function ja(){var c="external_statement_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,a=b;e=[];for(d=rb();null!==d;)e.push(d),d=rb();if(null!==e){d=new y({type:"root",C:[]});for(var h=
0;h<e.length;h++)e[h]&&(d.C=d.C.concat(e[h]));e=d}null===e&&(b=a);p[c]={b:b,result:e};return e}function rb(){var c="external_statement@"+b,a=p[c];if(a)return b=a.b,a.result;var e;e=b;a=dc();null===a&&(a=ec());null===a&&(b=e);null===a&&(e=b,a=q(),null!==a&&(a=""),null===a&&(b=e));p[c]={b:b,result:a};return a}function ec(){var c="external_declaration@"+b,a=p[c];if(a)return b=a.b,a.result;a=fc();null===a&&(a=gc(),null===a&&(a=sb(),null===a&&(a=tb(),null===a&&(a=hc(),null===a&&(a=Oa())))));p[c]={b:b,
result:a};return a}function tb(){var w="preprocessor_operator@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k;f=t=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));if(null!==a)if("undef"===c.substr(b,5)?(e="undef",b+=5):(e=null,0===l&&g('"undef"')),null===e&&("pragma"===c.substr(b,6)?(e="pragma",b+=6):(e=null,0===l&&g('"pragma"')),null===e&&("version"===c.substr(b,7)?(e="version",b+=7):(e=null,0===l&&g('"version"')),null===e&&("error"===c.substr(b,5)?(e="error",b+=5):(e=null,0===
l&&g('"error"')),null===e&&("extension"===c.substr(b,9)?(e="extension",b+=9):(e=null,0===l&&g('"extension"')),null===e&&("line"===c.substr(b,4)?(e="line",b+=4):(e=null,0===l&&g('"line"'))))))),null!==e)if(d=q(),null!==d){k=b;h=[];/^[^\n]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[^\\n]"));for(;null!==m;)h.push(m),/^[^\n]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[^\\n]"));null!==h&&(h=h.join(""));null===h&&(b=k);null!==h?(m=u(),null===m&&(m=B()),null!==m?a=[a,e,d,h,m]:
(a=null,b=f)):(a=null,b=f)}else a=null,b=f;else a=null,b=f;else a=null,b=f;null!==a&&(a=new y({type:"preprocessor",B:"#"+a[1],value:a[3]}));null===a&&(b=t);p[w]={b:b,result:a};return a}function na(){var w="macro_identifier@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;/^[A-Za-z_]/.test(c.charAt(b))?(a=c.charAt(b),b++):(a=null,0===l&&g("[A-Za-z_]"));if(null!==a){e=[];/^[A-Za-z_0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[A-Za-z_0-9]"));for(;null!==d;)e.push(d),/^[A-Za-z_0-9]/.test(c.charAt(b))?
(d=c.charAt(b),b++):(d=null,0===l&&g("[A-Za-z_0-9]"));null!==e?a=[a,e]:(a=null,b=m)}else a=null,b=m;null!==a&&(a=new y({type:"identifier",name:a[0]+a[1].join("")}));null===a&&(b=h);p[w]={b:b,result:a};return a}function ic(){var w="preprocessor_parameter_list@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k;f=t=b;40===c.charCodeAt(b)?(a="(",b+=1):(a=null,0===l&&g('"("'));if(null!==a)if(e=na(),e=null!==e?e:"",null!==e){d=[];k=b;h=H();null!==h?(m=na(),null!==m?h=[h,m]:(h=null,b=k)):(h=null,b=
k);for(;null!==h;)d.push(h),k=b,h=H(),null!==h?(m=na(),null!==m?h=[h,m]:(h=null,b=k)):(h=null,b=k);null!==d?(h=ca(),null!==h?a=[a,e,d,h]:(a=null,b=f)):(a=null,b=f)}else a=null,b=f;else a=null,b=f;null!==a&&(a=function(a,b){return a?[a].concat(b.map(function(a){return a[1]})):[]}(a[1],a[2]));null===a&&(b=t);p[w]={b:b,result:a};return a}function ub(){var w="macro_paren_parameter@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k,r;f=t=b;a=ba();if(null!==a){r=k=b;e=[];/^[^()]/.test(c.charAt(b))?
(d=c.charAt(b),b++):(d=null,0===l&&g("[^()]"));for(;null!==d;)e.push(d),/^[^()]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[^()]"));if(null!==e)if(d=ub(),d=null!==d?d:"",null!==d){h=[];/^[^()]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[^()]"));for(;null!==m;)h.push(m),/^[^()]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[^()]"));null!==h?e=[e,d,h]:(e=null,b=r)}else e=null,b=r;else e=null,b=r;null!==e&&(e=e[0].join("")+e[1]+e[2].join(""));null===e&&(b=k);null!==
e?(d=ca(),null!==d?a=[a,e,d]:(a=null,b=f)):(a=null,b=f)}else a=null,b=f;null!==a&&(a="("+a[1]+")");null===a&&(b=t);p[w]={b:b,result:a};return a}function Pa(){var w="macro_call_parameter@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,a=ub();if(null===a){d=b;a=[];/^[^,)]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[^,)]"));for(;null!==e;)a.push(e),/^[^,)]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[^,)]"));null!==a&&(a=a.join(""));null===a&&(b=d)}p[w]={b:b,result:a};return a}
function Oa(){var w="macro_call@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f;f=a=b;e=na();null!==e?(d=q(),d=null!==d?d:"",null!==d?(h=ba(),null!==h?(m=vb(),m=null!==m?m:"",null!==m?(41===c.charCodeAt(b)?(t=")",b+=1):(t=null,0===l&&g('")"')),null!==t?e=[e,d,h,m,t]:(e=null,b=f)):(e=null,b=f)):(e=null,b=f)):(e=null,b=f)):(e=null,b=f);null!==e&&(d=e[3],e=new y({type:"macro_call",oa:e[0],l:d}),d||(e.l=[]));null===e&&(b=a);p[w]={b:b,result:e};return e}function sb(){var w="preprocessor_define@"+
b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k,r,n,x,A;x=n=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));if(null!==a)if(e=q(),e=null!==e?e:"",null!==e)if("define"===c.substr(b,6)?(d="define",b+=6):(d=null,0===l&&g('"define"')),null!==d)if(h=q(),null!==h)if(m=na(),null!==m)if(t=ic(),t=null!==t?t:"",null!==t){f=[];/^[ \t]/.test(c.charAt(b))?(k=c.charAt(b),b++):(k=null,0===l&&g("[ \\t]"));for(;null!==k;)f.push(k),/^[ \t]/.test(c.charAt(b))?(k=c.charAt(b),b++):(k=null,0===l&&g("[ \\t]"));
if(null!==f){A=b;k=[];/^[^\n]/.test(c.charAt(b))?(r=c.charAt(b),b++):(r=null,0===l&&g("[^\\n]"));for(;null!==r;)k.push(r),/^[^\n]/.test(c.charAt(b))?(r=c.charAt(b),b++):(r=null,0===l&&g("[^\\n]"));null!==k&&(k=k.join(""));null===k&&(b=A);null!==k?(r=u(),null===r&&(r=B()),null!==r?a=[a,e,d,h,m,t,f,k,r]:(a=null,b=x)):(a=null,b=x)}else a=null,b=x}else a=null,b=x;else a=null,b=x;else a=null,b=x;else a=null,b=x;else a=null,b=x;else a=null,b=x;null!==a&&(a=new y({type:"preprocessor",B:"#define",identifier:a[4].name,
pa:a[7],l:a[5]||null}));null===a&&(b=n);p[w]={b:b,result:a};return a}function wb(){var w="preprocessor_if@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k,r;k=f=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));if(null!==a)if(e=q(),e=null!==e?e:"",null!==e)if("ifdef"===c.substr(b,5)?(d="ifdef",b+=5):(d=null,0===l&&g('"ifdef"')),null===d&&("ifndef"===c.substr(b,6)?(d="ifndef",b+=6):(d=null,0===l&&g('"ifndef"')),null===d&&("if"===c.substr(b,2)?(d="if",b+=2):(d=null,0===l&&g('"if"')))),
null!==d)if(h=q(),null!==h){r=b;m=[];/^[^\n]/.test(c.charAt(b))?(t=c.charAt(b),b++):(t=null,0===l&&g("[^\\n]"));for(;null!==t;)m.push(t),/^[^\n]/.test(c.charAt(b))?(t=c.charAt(b),b++):(t=null,0===l&&g("[^\\n]"));null!==m&&(m=m.join(""));null===m&&(b=r);null!==m?(t=u(),null===t&&(t=B()),null!==t?a=[a,e,d,h,m,t]:(a=null,b=k)):(a=null,b=k)}else a=null,b=k;else a=null,b=k;else a=null,b=k;else a=null,b=k;null!==a&&(a=new y({type:"preprocessor",B:"#"+a[2],value:a[4]}));null===a&&(b=f);p[w]={b:b,result:a};
return a}function wa(){var w="preprocessor_else_if@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,t,f,k,r;k=f=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));if(null!==a)if(e=q(),e=null!==e?e:"",null!==e)if("elif"===c.substr(b,4)?(d="elif",b+=4):(d=null,0===l&&g('"elif"')),null!==d)if(h=q(),null!==h){r=b;m=[];/^[^\n]/.test(c.charAt(b))?(t=c.charAt(b),b++):(t=null,0===l&&g("[^\\n]"));for(;null!==t;)m.push(t),/^[^\n]/.test(c.charAt(b))?(t=c.charAt(b),b++):(t=null,0===l&&g("[^\\n]"));
null!==m&&(m=m.join(""));null===m&&(b=r);null!==m?(t=u(),null===t&&(t=B()),null!==t?a=[a,e,d,h,m,t]:(a=null,b=k)):(a=null,b=k)}else a=null,b=k;else a=null,b=k;else a=null,b=k;else a=null,b=k;null!==a&&(a=new y({type:"preprocessor",B:"#elif",value:a[4]}));null===a&&(b=f);p[w]={b:b,result:a};return a}function xb(){var w="preprocessor_else@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,f,k;k=f=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));null!==a?(e=q(),e=null!==e?e:"",null!==e?("else"===
c.substr(b,4)?(d="else",b+=4):(d=null,0===l&&g('"else"')),null!==d?(h=ha(),h=null!==h?h:"",null!==h?(m=u(),null!==m?a=[a,e,d,h,m]:(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k);null!==a&&(a=new y({type:"preprocessor",B:"#else"}));null===a&&(b=f);p[w]={b:b,result:a};return a}function yb(){var w="preprocessor_end@"+b,a=p[w];if(a)return b=a.b,a.result;var e,d,h,m,f,k;k=b;35===c.charCodeAt(b)?(a="#",b+=1):(a=null,0===l&&g('"#"'));null!==a?(e=q(),e=null!==e?e:"",null!==e?("endif"===
c.substr(b,5)?(d="endif",b+=5):(d=null,0===l&&g('"endif"')),null!==d?(h=ha(),h=null!==h?h:"",null!==h?(m=u(),null===m&&(m=B()),null!==m?(f=q(),f=null!==f?f:"",null!==f?a=[a,e,d,h,m,f]:(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k);p[w]={b:b,result:a};return a}function dc(){var c="preprocessor_external_branch@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,g,f;f=g=m=b;a=wb();null!==a?(e=ja(),null!==e?a=[a,e]:(a=null,b=f)):(a=null,b=f);if(null!==a){e=[];f=b;d=wa();
null!==d?(h=ja(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f);for(;null!==d;)e.push(d),f=b,d=wa(),null!==d?(h=ja(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f);null!==e?(f=b,d=xb(),null!==d?(h=ja(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f),d=null!==d?d:"",null!==d?(h=yb(),null!==h?a=[a,e,d,h]:(a=null,b=g)):(a=null,b=g)):(a=null,b=g)}else a=null,b=g;null!==a&&(a=jc(a[0],a[1],a[2]));null===a&&(b=m);p[c]={b:b,result:a};return a}function zb(){var c="preprocessor_statement_branch@"+b,a=p[c];if(a)return b=
a.b,a.result;var e,d,h,m,g,f;f=g=m=b;a=wb();null!==a?(e=oa(),null!==e?a=[a,e]:(a=null,b=f)):(a=null,b=f);if(null!==a){e=[];f=b;d=wa();null!==d?(h=oa(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f);for(;null!==d;)e.push(d),f=b,d=wa(),null!==d?(h=oa(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f);null!==e?(f=b,d=xb(),null!==d?(h=oa(),null!==h?d=[d,h]:(d=null,b=f)):(d=null,b=f),d=null!==d?d:"",null!==d?(h=yb(),null!==h?a=[a,e,d,h]:(a=null,b=g)):(a=null,b=g)):(a=null,b=g)}else a=null,b=g;null!==a&&(a=jc(a[0],
a[1],a[2]));null===a&&(b=m);p[c]={b:b,result:a};return a}function fc(){var c="function_definition@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h;h=d=b;a=Ab();null!==a?(e=Qa(),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(e=a[0],a=L=new y({type:"function_declaration",name:e.name,ma:e.ma,l:e.l,body:a[1]}));null===a&&(b=d);p[c]={b:b,result:a};return a}function Qa(){var c="compound_statement@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;m=a=b;e=pb();null!==e?(d=oa(),d=null!==d?d:"",null!==
d?(h=qb(),null!==h?e=[e,d,h]:(e=null,b=m)):(e=null,b=m)):(e=null,b=m);null!==e&&(e=e[1],L=new y({type:"scope",C:[]}),e&&e.C&&(L.C=e.C),e=L);null===e&&(b=a);p[c]={b:b,result:e};return e}function oa(){var c="statement_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;a=q();a=null!==a?a:"";if(null!==a){e=[];for(d=xa();null!==d;)e.push(d),d=xa();null!==e?(d=q(),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)}else a=null,b=m;null!==a&&(a={C:a[1]});null===a&&(b=h);p[c]={b:b,result:a};
return a}function xa(){var c="statement_no_new_scope@"+b,a=p[c];if(a)return b=a.b,a.result;a=Qa();null===a&&(a=Bb(),null===a&&(a=zb()));p[c]={b:b,result:a};return a}function Ra(){var c="statement_with_scope@"+b,a=p[c];if(a)return b=a.b,a.result;a=Qa();null===a&&(a=Bb(),null===a&&(a=zb()));p[c]={b:b,result:a};return a}function Bb(){var c="simple_statement@"+b,a=p[c];if(a)return b=a.b,a.result;var e;e=b;a=Sa();null===a&&(a=Cb(),null===a&&(a=kc(),null===a&&(a=lc(),null===a&&(a=mc(),null===a&&(a=sb(),
null===a&&(a=tb(),null===a&&(a=Oa())))))));null===a&&(b=e);p[c]={b:b,result:a};return a}function kc(){var f="selection_statement@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t,k,n,r,u,x;u=r=b;"if"===c.substr(b,2)?(a="if",b+=2):(a=null,0===l&&g('"if"'));null!==a?(e=ba(),null!==e?(d=S(),null!==d?(h=ca(),null!==h?(m=Ra(),null!==m?(x=b,"else"===c.substr(b,4)?(t="else",b+=4):(t=null,0===l&&g('"else"')),null!==t?(k=q(),k=null!==k?k:"",null!==k?(n=Ra(),null!==n?t=[t,k,n]:(t=null,b=x)):(t=null,b=x)):
(t=null,b=x),t=null!==t?t:"",null!==t?a=[a,e,d,h,m,t]:(a=null,b=u)):(a=null,b=u)):(a=null,b=u)):(a=null,b=u)):(a=null,b=u)):(a=null,b=u);null!==a&&(e=a[5],L=new y({type:"if_statement",F:a[2],body:a[4]}),e&&(L.M=e[2]),a=L);null===a&&(b=r);p[f]={b:b,result:a};return a}function nc(){var f="for_loop@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t,k,q,r,n;n=r=b;"for"===c.substr(b,3)?(a="for",b+=3):(a=null,0===l&&g('"for"'));null!==a?(e=ba(),null!==e?(d=Cb(),null===d&&(d=Sa()),null!==d?(h=Db(),h=null!==
h?h:"",null!==h?(m=A(),null!==m?(t=S(),t=null!==t?t:"",null!==t?(k=ca(),null!==k?(q=xa(),null!==q?a=[a,e,d,h,m,t,k,q]:(a=null,b=n)):(a=null,b=n)):(a=null,b=n)):(a=null,b=n)):(a=null,b=n)):(a=null,b=n)):(a=null,b=n)):(a=null,b=n);null!==a&&(a=new y({type:"for_statement",H:a[2],F:a[3],Fa:a[5],body:a[7]}));null===a&&(b=r);p[f]={b:b,result:a};return a}function Eb(){var f="while_statement@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t;t=m=b;"while"===c.substr(b,5)?(a="while",b+=5):(a=null,0===l&&
g('"while"'));null!==a?(e=ba(),null!==e?(d=Db(),null!==d?(h=ca(),null!==h?a=[a,e,d,h]:(a=null,b=t)):(a=null,b=t)):(a=null,b=t)):(a=null,b=t);null!==a&&(a={F:a[2]});null===a&&(b=m);p[f]={b:b,result:a};return a}function oc(){var c="while_loop@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h;h=d=b;a=Eb();null!==a?(e=xa(),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"while_statement",F:a[0].F,body:a[1]}));null===a&&(b=d);p[c]={b:b,result:a};return a}function pc(){var f="do_while@"+
b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;"do"===c.substr(b,2)?(a="do",b+=2):(a=null,0===l&&g('"do"'));null!==a?(e=Ra(),null!==e?(d=Eb(),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(a=new y({type:"do_statement",F:a[2].F,body:a[1]}));null===a&&(b=h);p[f]={b:b,result:a};return a}function lc(){var c="iteration_statement@"+b,a=p[c];if(a)return b=a.b,a.result;a=oc();null===a&&(a=pc(),null===a&&(a=nc()));p[c]={b:b,result:a};return a}function mc(){var f="jump_statement@"+
b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t;t=m=b;"return"===c.substr(b,6)?(a="return",b+=6):(a=null,0===l&&g('"return"'));null!==a?(e=q(),e=null!==e?e:"",null!==e?(d=S(),null!==d?(h=A(),null!==h?a=[a,e,d,h]:(a=null,b=t)):(a=null,b=t)):(a=null,b=t)):(a=null,b=t);null!==a&&(a=new y({type:"return",value:a[2]}));null===a&&(b=m);null===a&&(t=m=b,"continue"===c.substr(b,8)?(a="continue",b+=8):(a=null,0===l&&g('"continue"')),null!==a?(e=A(),null!==e?a=[a,e]:(a=null,b=t)):(a=null,b=t),null===a&&(t=
b,"break"===c.substr(b,5)?(a="break",b+=5):(a=null,0===l&&g('"break"')),null!==a?(e=A(),null!==e?a=[a,e]:(a=null,b=t)):(a=null,b=t),null===a&&(t=b,"return"===c.substr(b,6)?(a="return",b+=6):(a=null,0===l&&g('"return"')),null!==a?(e=A(),null!==e?a=[a,e]:(a=null,b=t)):(a=null,b=t),null===a&&(h=d=t=b,a="fs"==ya?"":null,null!==a?("discard"===c.substr(b,7)?(e="discard",b+=7):(e=null,0===l&&g('"discard"')),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h),null!==a&&(a="discard"),null===a&&(b=d),null!==a?(e=A(),
null!==e?a=[a,e]:(a=null,b=t)):(a=null,b=t)))),null!==a&&(a=new y({type:a[0]})),null===a&&(b=m));p[f]={b:b,result:a};return a}function Cb(){var c="expression_statement@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h;h=d=b;a=S();a=null!==a?a:"";null!==a?(e=A(),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"expression",N:a[0]}));null===a&&(b=d);p[c]={b:b,result:a};return a}function Sa(){var f="declaration@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t,k,n,r,u;l++;r=n=b;a=
Ab();null!==a?(e=A(),null!==e?a=[a,e]:(a=null,b=r)):(a=null,b=r);null!==a&&(a=a[0]);null===a&&(b=n);if(null===a&&(r=n=b,a=za(),null!==a?(e=q(),null!==e?(d=Fb(),null!==d?(h=A(),null!==h?a=[a,e,d,h]:(a=null,b=r)):(a=null,b=r)):(a=null,b=r)):(a=null,b=r),null!==a&&(a=new y({type:"declarator",w:a[0],A:a[2]})),null===a&&(b=n),null===a)){r=n=b;a="vs"==ya?"":null;if(null!==a)if("invariant"===c.substr(b,9)?(e="invariant",b+=9):(e=null,0===l&&g('"invariant"')),null!==e)if(d=q(),null!==d)if(h=Q(),null!==h){m=
[];u=b;t=H();null!==t?(k=Q(),null!==k?t=[t,k]:(t=null,b=u)):(t=null,b=u);for(;null!==t;)m.push(t),u=b,t=H(),null!==t?(k=Q(),null!==k?t=[t,k]:(t=null,b=u)):(t=null,b=u);null!==m?(t=A(),null!==t?a=[a,e,d,h,m,t]:(a=null,b=r)):(a=null,b=r)}else a=null,b=r;else a=null,b=r;else a=null,b=r;else a=null,b=r;null!==a&&(a=function(a,b){var d=[a].concat(b.map(function(a){return a[1]}));return new y({type:"invariant",Ea:d})}(a[3],a[4]));null===a&&(b=n);null===a&&(r=n=b,"precision"===c.substr(b,9)?(a="precision",
b+=9):(a=null,0===l&&g('"precision"')),null!==a?(e=q(),null!==e?(d=Ta(),null!==d?(h=q(),null!==h?(m=Aa(),null!==m?(t=A(),null!==t?a=[a,e,d,h,m,t]:(a=null,b=r)):(a=null,b=r)):(a=null,b=r)):(a=null,b=r)):(a=null,b=r)):(a=null,b=r),null!==a&&(a=new y({type:"precision",precision:a[2],typeName:a[4]})),null===a&&(b=n))}l--;0===l&&null===a&&g("declaration");p[f]={b:b,result:a};return a}function gc(){var c="global_declaration@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,a=Sa();null===a&&(f=m=b,a=qc(),
null!==a?(e=q(),null!==e?(d=Fb(),null!==d?(h=A(),null!==h?a=[a,e,d,h]:(a=null,b=f)):(a=null,b=f)):(a=null,b=f)):(a=null,b=f),null!==a&&(a=new y({type:"declarator",w:a[0],A:a[2]})),null===a&&(b=m),null===a&&(f=m=b,a=rc(),null!==a?(e=q(),null!==e?(d=sc(),null!==d?(h=A(),null!==h?a=[a,e,d,h]:(a=null,b=f)):(a=null,b=f)):(a=null,b=f)):(a=null,b=f),null!==a&&(a=new y({type:"declarator",w:a[0],A:a[2]})),null===a&&(b=m)));p[c]={b:b,result:a};return a}function tc(){var f="function_prototype_parameter_list@"+
b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,t,k;"void"===c.substr(b,4)?(a="void",b+=4):(a=null,0===l&&g('"void"'));if(null===a){t=m=b;a=Ua();if(null!==a){e=[];k=b;d=H();null!==d?(h=Ua(),null!==h?d=[d,h]:(d=null,b=k)):(d=null,b=k);for(;null!==d;)e.push(d),k=b,d=H(),null!==d?(h=Ua(),null!==h?d=[d,h]:(d=null,b=k)):(d=null,b=k);null!==e?a=[a,e]:(a=null,b=t)}else a=null,b=t;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m)}p[f]={b:b,result:a};
return a}function Ab(){var c="function_prototype@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g,k;k=g=b;a=uc();null===a&&(a=Ba());null!==a?(e=q(),null!==e?(d=Q(),null!==d?(h=ba(),null!==h?(m=tc(),m=null!==m?m:"",null!==m?(f=ca(),null!==f?a=[a,e,d,h,m,f]:(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k)):(a=null,b=k);null!==a&&(e=a[4],L=new y({type:"function_prototype",name:a[2].name,ma:a[0],l:e}),"void"!=e&&e||(L.l=[]),a=L);null===a&&(b=g);p[c]={b:b,result:a};return a}function vc(){var f=
"parameter_qualifier@"+b,a=p[f];if(a)return b=a.b,a.result;"inout"===c.substr(b,5)?(a="inout",b+=5):(a=null,0===l&&g('"inout"'));null===a&&("in"===c.substr(b,2)?(a="in",b+=2):(a=null,0===l&&g('"in"')),null===a&&("out"===c.substr(b,3)?(a="out",b+=3):(a=null,0===l&&g('"out"'))));p[f]={b:b,result:a};return a}function Ua(){var c="parameter_declaration@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g,k,l,n,u,x;x=u=a=b;e=Va();null!==e?(d=q(),null!==d?e=[e,d]:(e=null,b=x)):(e=null,b=x);e=null!==e?e:
"";null!==e?(x=b,d=vc(),null!==d?(h=q(),null!==h?d=[d,h]:(d=null,b=x)):(d=null,b=x),d=null!==d?d:"",null!==d?(x=b,h=Ta(),null!==h?(m=q(),null!==m?h=[h,m]:(h=null,b=x)):(h=null,b=x),h=null!==h?h:"",null!==h?(m=Aa(),null!==m?(f=q(),null!==f?(g=Q(),null!==g?(x=b,k=ua(),null!==k?(l=pa(),null!==l?(n=va(),null!==n?k=[k,l,n]:(k=null,b=x)):(k=null,b=x)):(k=null,b=x),k=null!==k?k:"",null!==k?e=[e,d,h,m,f,g,k]:(e=null,b=u)):(e=null,b=u)):(e=null,b=u)):(e=null,b=u)):(e=null,b=u)):(e=null,b=u)):(e=null,b=u);
null!==e&&(d=e[0],h=e[1],m=e[2],f=e[6],e=new y({type:"parameter",Ka:e[3],name:e[5].name}),d&&(e.qa=d[0]),h&&(e.la=h[0]),m&&(e.precision=m[0]),f&&(e.$=f[1]),e=e.qa&&e.la&&"in"!=e.la?null:e);null===e&&(b=a);p[c]={b:b,result:e};return e}function Fb(){var c="init_declarator_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g;f=m=b;a=Wa();if(null!==a){e=[];g=b;d=H();null!==d?(h=Wa(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);for(;null!==d;)e.push(d),g=b,d=H(),null!==d?(h=Wa(),null!==h?d=[d,h]:
(d=null,b=g)):(d=null,b=g);null!==e?a=[a,e]:(a=null,b=f)}else a=null,b=f;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m);p[c]={b:b,result:a};return a}function wc(){var c="declarator_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g;f=m=b;a=Ca();if(null!==a){e=[];g=b;d=H();null!==d?(h=Ca(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);for(;null!==d;)e.push(d),g=b,d=H(),null!==d?(h=Ca(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);null!==
e?a=[a,e]:(a=null,b=f)}else a=null,b=f;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m);p[c]={b:b,result:a};return a}function sc(){var c="declarator_list_no_array@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g;f=m=b;a=Da();if(null!==a){e=[];g=b;d=H();null!==d?(h=Da(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);for(;null!==d;)e.push(d),g=b,d=H(),null!==d?(h=Da(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);null!==e?a=[a,e]:(a=null,b=f)}else a=
null,b=f;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m);p[c]={b:b,result:a};return a}function Gb(){var c="declarator_list_arrays_have_size@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g;f=m=b;a=Ea();if(null!==a){e=[];g=b;d=H();null!==d?(h=Ea(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);for(;null!==d;)e.push(d),g=b,d=H(),null!==d?(h=Ea(),null!==h?d=[d,h]:(d=null,b=g)):(d=null,b=g);null!==e?a=[a,e]:(a=null,b=f)}else a=null,b=f;null!==
a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m);p[c]={b:b,result:a};return a}function Da(){var c="declarator_no_array@"+b,a=p[c];if(a)return b=a.b,a.result;var e;e=b;a=Q();null!==a&&(a=new y({type:"declarator_item",name:a}));null===a&&(b=e);p[c]={b:b,result:a};return a}function Ea(){var c="declarator_array_with_size@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f;f=m=b;a=Q();null!==a?(e=ua(),null!==e?(d=pa(),null!==d?(h=va(),null!==h?a=[a,e,d,
h]:(a=null,b=f)):(a=null,b=f)):(a=null,b=f)):(a=null,b=f);null!==a&&(a=new y({type:"declarator_item",name:a[0],$:a[2],isArray:!0}));null===a&&(b=m);null===a&&(a=Da());p[c]={b:b,result:a};return a}function Ca(){var c="declarator@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;a=Q();null!==a?(e=ua(),null!==e?(d=va(),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(a=new y({type:"declarator_item",name:a[0],isArray:!0}));null===a&&(b=h);null===a&&(a=Ea());p[c]={b:b,result:a};
return a}function Wa(){var c="init_declarator@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;a=Q();null!==a?(e=cc(),null!==e?(d=pa(),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(a=new y({type:"declarator_item",name:a[0],H:a[2]}));null===a&&(b=h);null===a&&(a=Ca());p[c]={b:b,result:a};return a}function xc(){var c="member_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m,f,g;g=f=b;e=za();null!==e?(d=q(),null!==d?(h=Gb(),null!==h?(m=A(),null!==m?e=[e,d,h,m]:(e=
null,b=g)):(e=null,b=g)):(e=null,b=g)):(e=null,b=g);if(null!==e)for(a=[];null!==e;)a.push(e),g=b,e=za(),null!==e?(d=q(),null!==d?(h=Gb(),null!==h?(m=A(),null!==m?e=[e,d,h,m]:(e=null,b=g)):(e=null,b=g)):(e=null,b=g)):(e=null,b=g);else a=null;null!==a&&(a=function(a){return a.map(function(a){return new y({type:"declarator",w:a[0],A:a[2]})})}(a));null===a&&(b=f);p[c]={b:b,result:a};return a}function hc(){var f="struct_definition@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k,n,u,r,x;k=x=a=b;e=Hb();
null===e&&(e=Ib());null!==e?(d=q(),null!==d?e=[e,d]:(e=null,b=k)):(e=null,b=k);e=null!==e?e:"";null!==e?("struct"===c.substr(b,6)?(d="struct",b+=6):(d=null,0===l&&g('"struct"')),null!==d?(k=b,h=q(),null!==h?(m=Q(),null!==m?h=[h,m]:(h=null,b=k)):(h=null,b=k),h=null!==h?h:"",null!==h?(m=pb(),null!==m?(k=xc(),null!==k?(n=qb(),null!==n?(u=wc(),u=null!==u?u:"",null!==u?(r=A(),null!==r?e=[e,d,h,m,k,n,u,r]:(e=null,b=x)):(e=null,b=x)):(e=null,b=x)):(e=null,b=x)):(e=null,b=x)):(e=null,b=x)):(e=null,b=x)):
(e=null,b=x);null!==e&&(d=e[0],h=e[2],m=e[6],e=new y({type:"struct_definition",Ia:e[4]}),d&&(e.qualifier=d[0]),h&&(e.name=h[1].name,yc[e.name]=e),m&&(e.A=m));null===e&&(b=a);p[f]={b:b,result:e};return e}function Ba(){var c="precision_type@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;m=h=a=b;e=Ta();null!==e?(d=q(),null!==d?e=[e,d]:(e=null,b=m)):(e=null,b=m);e=null!==e?e:"";null!==e?(d=Aa(),null!==d?e=[e,d]:(e=null,b=h)):(e=null,b=h);null!==e&&(d=e[0],e=new y({type:"type",name:e[1]}),d&&(e.precision=
d[0]));null===e&&(b=a);p[c]={b:b,result:e};return e}function za(){var c="locally_specified_type@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;l++;m=h=a=b;e=Va();null!==e?(d=q(),null!==d?e=[e,d]:(e=null,b=m)):(e=null,b=m);e=null!==e?e:"";null!==e?(d=Ba(),null!==d?e=[e,d]:(e=null,b=h)):(e=null,b=h);null!==e&&(d=e[0],e=e[1],d&&(e.qualifier=d[0]));null===e&&(b=a);l--;0===l&&null===e&&g("locally specified type");p[c]={b:b,result:e};return e}function Ib(){var f="attribute_qualifier@"+b,a=p[f];if(a)return b=
a.b,a.result;var e,d,h;h=d=b;a="vs"==ya?"":null;null!==a?("attribute"===c.substr(b,9)?(e="attribute",b+=9):(e=null,0===l&&g('"attribute"')),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a="attribute");null===a&&(b=d);p[f]={b:b,result:a};return a}function rc(){var c="attribute_type@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;l++;m=h=b;a=Ib();null!==a?(e=q(),null!==e?(d=Ba(),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(e=a[2],e.qualifier=a[0],a=e);null===a&&
(b=h);l--;0===l&&null===a&&g("locally specified type");p[c]={b:b,result:a};return a}function qc(){var c="fully_specified_type@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,m;l++;m=h=a=b;e=Hb();null!==e?(d=q(),null!==d?e=[e,d]:(e=null,b=m)):(e=null,b=m);e=null!==e?e:"";null!==e?(d=Ba(),null!==d?e=[e,d]:(e=null,b=h)):(e=null,b=h);null!==e&&(d=e[0],e=e[1],d&&(e.qualifier=d[0]));null===e&&(b=a);l--;0===l&&null===e&&g("fully specified type");p[c]={b:b,result:e};return e}function Ta(){var f="precision_qualifier@"+
b,a=p[f];if(a)return b=a.b,a.result;l++;"highp"===c.substr(b,5)?(a="highp",b+=5):(a=null,0===l&&g('"highp"'));null===a&&("mediump"===c.substr(b,7)?(a="mediump",b+=7):(a=null,0===l&&g('"mediump"')),null===a&&("lowp"===c.substr(b,4)?(a="lowp",b+=4):(a=null,0===l&&g('"lowp"'))));l--;0===l&&null===a&&g("precision qualifier");p[f]={b:b,result:a};return a}function Va(){var f="const_qualifier@"+b,a=p[f];if(a)return b=a.b,a.result;"const"===c.substr(b,5)?(a="const",b+=5):(a=null,0===l&&g('"const"'));p[f]=
{b:b,result:a};return a}function Hb(){var f="type_qualifier@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;l++;a=Va();null===a&&("varying"===c.substr(b,7)?(a="varying",b+=7):(a=null,0===l&&g('"varying"')),null===a&&(m=h=b,"invariant"===c.substr(b,9)?(a="invariant",b+=9):(a=null,0===l&&g('"invariant"')),null!==a?(e=q(),null!==e?("varying"===c.substr(b,7)?(d="varying",b+=7):(d=null,0===l&&g('"varying"')),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m),null!==a&&(a="invariant varying"),
null===a&&(b=h),null===a&&("uniform"===c.substr(b,7)?(a="uniform",b+=7):(a=null,0===l&&g('"uniform"')))));l--;0===l&&null===a&&g("type qualifier");p[f]={b:b,result:a};return a}function uc(){var f="void_type@"+b,a=p[f];if(a)return b=a.b,a.result;var e;l++;e=b;"void"===c.substr(b,4)?(a="void",b+=4):(a=null,0===l&&g('"void"'));null!==a&&(a=new y({type:"type",name:"void"}));null===a&&(b=e);l--;0===l&&null===a&&g("void");p[f]={b:b,result:a};return a}function Aa(){var f="type_name@"+b,a=p[f];if(a)return b=
a.b,a.result;var e;l++;"float"===c.substr(b,5)?(a="float",b+=5):(a=null,0===l&&g('"float"'));null===a&&("int"===c.substr(b,3)?(a="int",b+=3):(a=null,0===l&&g('"int"')),null===a&&("bool"===c.substr(b,4)?(a="bool",b+=4):(a=null,0===l&&g('"bool"')),null===a&&("sampler2D"===c.substr(b,9)?(a="sampler2D",b+=9):(a=null,0===l&&g('"sampler2D"')),null===a&&("samplerCube"===c.substr(b,11)?(a="samplerCube",b+=11):(a=null,0===l&&g('"samplerCube"')),null===a&&(a=Jb(),null===a&&(a=Kb(),null===a&&(e=b,a=Q(),null!==
a&&(a=a.name in yc?a.name:null),null===a&&(b=e))))))));l--;0===l&&null===a&&g("type name");p[f]={b:b,result:a};return a}function Q(){var f="identifier@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k;l++;d=k=m=b;l++;h=b;a=zc();null!==a?(/^[^A-Za-z_0-9]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[^A-Za-z_0-9]")),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);l--;null===a?a="":(a=null,b=d);if(null!==a)if(/^[A-Za-z_]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[A-Za-z_]")),
null!==e){d=[];/^[A-Za-z_0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z_0-9]"));for(;null!==h;)d.push(h),/^[A-Za-z_0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z_0-9]"));null!==d?a=[a,e,d]:(a=null,b=k)}else a=null,b=k;else a=null,b=k;null!==a&&(a=new y({type:"identifier",name:a[1]+a[2].join("")}));null===a&&(b=m);l--;0===l&&null===a&&g("identifier");p[f]={b:b,result:a};return a}function zc(){var f="keyword@"+b,a=p[f];if(a)return b=a.b,a.result;l++;"attribute"===
c.substr(b,9)?(a="attribute",b+=9):(a=null,0===l&&g('"attribute"'));null===a&&("const"===c.substr(b,5)?(a="const",b+=5):(a=null,0===l&&g('"const"')),null===a&&("bool"===c.substr(b,4)?(a="bool",b+=4):(a=null,0===l&&g('"bool"')),null===a&&("float"===c.substr(b,5)?(a="float",b+=5):(a=null,0===l&&g('"float"')),null===a&&("int"===c.substr(b,3)?(a="int",b+=3):(a=null,0===l&&g('"int"')),null===a&&("break"===c.substr(b,5)?(a="break",b+=5):(a=null,0===l&&g('"break"')),null===a&&("continue"===c.substr(b,8)?
(a="continue",b+=8):(a=null,0===l&&g('"continue"')),null===a&&("do"===c.substr(b,2)?(a="do",b+=2):(a=null,0===l&&g('"do"')),null===a&&("else"===c.substr(b,4)?(a="else",b+=4):(a=null,0===l&&g('"else"')),null===a&&("for"===c.substr(b,3)?(a="for",b+=3):(a=null,0===l&&g('"for"')),null===a&&("if"===c.substr(b,2)?(a="if",b+=2):(a=null,0===l&&g('"if"')),null===a&&("discard"===c.substr(b,7)?(a="discard",b+=7):(a=null,0===l&&g('"discard"')),null===a&&("return"===c.substr(b,6)?(a="return",b+=6):(a=null,0===
l&&g('"return"')),null===a&&(a=Jb(),null===a&&(a=Kb(),null===a&&("in"===c.substr(b,2)?(a="in",b+=2):(a=null,0===l&&g('"in"')),null===a&&("out"===c.substr(b,3)?(a="out",b+=3):(a=null,0===l&&g('"out"')),null===a&&("inout"===c.substr(b,5)?(a="inout",b+=5):(a=null,0===l&&g('"inout"')),null===a&&("uniform"===c.substr(b,7)?(a="uniform",b+=7):(a=null,0===l&&g('"uniform"')),null===a&&("varying"===c.substr(b,7)?(a="varying",b+=7):(a=null,0===l&&g('"varying"')),null===a&&("sampler2D"===c.substr(b,9)?(a="sampler2D",
b+=9):(a=null,0===l&&g('"sampler2D"')),null===a&&("samplerCube"===c.substr(b,11)?(a="samplerCube",b+=11):(a=null,0===l&&g('"samplerCube"')),null===a&&("struct"===c.substr(b,6)?(a="struct",b+=6):(a=null,0===l&&g('"struct"')),null===a&&("void"===c.substr(b,4)?(a="void",b+=4):(a=null,0===l&&g('"void"')),null===a&&("while"===c.substr(b,5)?(a="while",b+=5):(a=null,0===l&&g('"while"')),null===a&&("highp"===c.substr(b,5)?(a="highp",b+=5):(a=null,0===l&&g('"highp"')),null===a&&("mediump"===c.substr(b,7)?
(a="mediump",b+=7):(a=null,0===l&&g('"mediump"')),null===a&&("lowp"===c.substr(b,4)?(a="lowp",b+=4):(a=null,0===l&&g('"lowp"')),null===a&&("true"===c.substr(b,4)?(a="true",b+=4):(a=null,0===l&&g('"true"')),null===a&&("false"===c.substr(b,5)?(a="false",b+=5):(a=null,0===l&&g('"false"')))))))))))))))))))))))))))))));l--;0===l&&null===a&&g("keyword");p[f]={b:b,result:a};return a}function Jb(){var f="vector@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;/^[bi]/.test(c.charAt(b))?(a=c.charAt(b),
b++):(a=null,0===l&&g("[bi]"));a=null!==a?a:"";null!==a?("vec"===c.substr(b,3)?(e="vec",b+=3):(e=null,0===l&&g('"vec"')),null!==e?(/^[234]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[234]")),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(a=a.join(""));null===a&&(b=h);p[f]={b:b,result:a};return a}function Kb(){var f="matrix@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h;h=d=b;"mat"===c.substr(b,3)?(a="mat",b+=3):(a=null,0===l&&g('"mat"'));null!==a?(/^[234]/.test(c.charAt(b))?
(e=c.charAt(b),b++):(e=null,0===l&&g("[234]")),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=a.join(""));null===a&&(b=d);p[f]={b:b,result:a};return a}function Lb(){var f="single_underscore_identifier@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;m=b;a=[];/^[A-Za-z0-9]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[A-Za-z0-9]"));for(;null!==e;)a.push(e),/^[A-Za-z0-9]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[A-Za-z0-9]"));if(null!==a)if(95===c.charCodeAt(b)?
(e="_",b+=1):(e=null,0===l&&g('"_"')),null!==e){/^[A-Za-z0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z0-9]"));if(null!==h)for(d=[];null!==h;)d.push(h),/^[A-Za-z0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z0-9]"));else d=null;null!==d?a=[a,e,d]:(a=null,b=m)}else a=null,b=m;else a=null,b=m;p[f]={b:b,result:a};return a}function Ac(){var f="int_constant@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k;k=m=b;/^[1-9]/.test(c.charAt(b))?(a=c.charAt(b),b++):
(a=null,0===l&&g("[1-9]"));if(null!==a){e=[];/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));for(;null!==d;)e.push(d),/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));null!==e?a=[a,e]:(a=null,b=k)}else a=null,b=k;null!==a&&(a=new y({type:"int",value:parseInt([a[0]].concat(a[1]).join(""),10)}));null===a&&(b=m);if(null===a){k=m=b;48===c.charCodeAt(b)?(a="0",b+=1):(a=null,0===l&&g('"0"'));if(null!==a)if(/^[Xx]/.test(c.charAt(b))?(e=c.charAt(b),b++):
(e=null,0===l&&g("[Xx]")),null!==e){/^[0-9A-Fa-f]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[0-9A-Fa-f]"));if(null!==h)for(d=[];null!==h;)d.push(h),/^[0-9A-Fa-f]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[0-9A-Fa-f]"));else d=null;null!==d?a=[a,e,d]:(a=null,b=k)}else a=null,b=k;else a=null,b=k;null!==a&&(a=new y({type:"int",value:parseInt(a[2].join(""),16)}));null===a&&(b=m);if(null===a){k=m=b;48===c.charCodeAt(b)?(a="0",b+=1):(a=null,0===l&&g('"0"'));if(null!==a){/^[0-7]/.test(c.charAt(b))?
(d=c.charAt(b),b++):(d=null,0===l&&g("[0-7]"));if(null!==d)for(e=[];null!==d;)e.push(d),/^[0-7]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-7]"));else e=null;null!==e?a=[a,e]:(a=null,b=k)}else a=null,b=k;null!==a&&(a=new y({type:"int",value:parseInt(a[1].join(""),8)}));null===a&&(b=m);null===a&&(m=b,48===c.charCodeAt(b)?(a="0",b+=1):(a=null,0===l&&g('"0"')),null!==a&&(a=new y({type:"int",value:0})),null===a&&(b=m))}}p[f]={b:b,result:a};return a}function Bc(){var f="float_constant@"+
b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k;k=a=b;e=[];/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));for(;null!==d;)e.push(d),/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));if(null!==e)if(46===c.charCodeAt(b)?(d=".",b+=1):(d=null,0===l&&g('"."')),null!==d){/^[0-9]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[0-9]"));if(null!==m)for(h=[];null!==m;)h.push(m),/^[0-9]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[0-9]"));
else h=null;null!==h?(m=Xa(),m=null!==m?m:"",null!==m?e=[e,d,h,m]:(e=null,b=k)):(e=null,b=k)}else e=null,b=k;else e=null,b=k;if(null===e){k=b;/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));if(null!==d)for(e=[];null!==d;)e.push(d),/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));else e=null;if(null!==e)if(46===c.charCodeAt(b)?(d=".",b+=1):(d=null,0===l&&g('"."')),null!==d){h=[];/^[0-9]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[0-9]"));
for(;null!==m;)h.push(m),/^[0-9]/.test(c.charAt(b))?(m=c.charAt(b),b++):(m=null,0===l&&g("[0-9]"));null!==h?(m=Xa(),m=null!==m?m:"",null!==m?e=[e,d,h,m]:(e=null,b=k)):(e=null,b=k)}else e=null,b=k;else e=null,b=k}null!==e&&(e[0]=e[0].join(""),e[2]=e[2].join(""),e=new y({type:"float",value:parseFloat(e.join(""))}));null===e&&(b=a);if(null===e){k=a=b;/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[0-9]"));if(null!==d)for(e=[];null!==d;)e.push(d),/^[0-9]/.test(c.charAt(b))?(d=c.charAt(b),
b++):(d=null,0===l&&g("[0-9]"));else e=null;null!==e?(d=Xa(),null!==d?e=[e,d]:(e=null,b=k)):(e=null,b=k);null!==e&&(e=new y({type:"float",value:parseFloat(e[0].join("")+e[1])}));null===e&&(b=a)}p[f]={b:b,result:e};return e}function Xa(){var f="float_exponent@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k;k=m=b;/^[Ee]/.test(c.charAt(b))?(a=c.charAt(b),b++):(a=null,0===l&&g("[Ee]"));if(null!==a)if(/^[+\-]/.test(c.charAt(b))?(e=c.charAt(b),b++):(e=null,0===l&&g("[+\\-]")),e=null!==e?e:"",null!==
e){/^[0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[0-9]"));if(null!==h)for(d=[];null!==h;)d.push(h),/^[0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[0-9]"));else d=null;null!==d?a=[a,e,d]:(a=null,b=k)}else a=null,b=k;else a=null,b=k;null!==a&&(a=["e",a[1]].concat(a[2]).join(""));null===a&&(b=m);p[f]={b:b,result:a};return a}function Cc(){var c="paren_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f;f=h=b;a=ba();null!==a?(e=S(),null!==e?(d=ca(),null!==
d?a=[a,e,d]:(a=null,b=f)):(a=null,b=f)):(a=null,b=f);null!==a&&(a=a[1]);null===a&&(b=h);p[c]={b:b,result:a};return a}function Dc(){var f="bool_constant@"+b,a=p[f];if(a)return b=a.b,a.result;var e;e=b;"true"===c.substr(b,4)?(a="true",b+=4):(a=null,0===l&&g('"true"'));null===a&&("false"===c.substr(b,5)?(a="false",b+=5):(a=null,0===l&&g('"false"')));null!==a&&(a=new y({type:"bool",value:"true"==a}));null===a&&(b=e);p[f]={b:b,result:a};return a}function Ec(){var c="primary_expression@"+b,a=p[c];if(a)return b=
a.b,a.result;a=Fc();null===a&&(a=Q(),null===a&&(a=Bc(),null===a&&(a=Ac(),null===a&&(a=Dc(),null===a&&(a=Cc())))));p[c]={b:b,result:a};return a}function Fa(){var c="index_accessor@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f;f=h=b;a=ua();null!==a?(e=S(),null!==e?(d=va(),null!==d?a=[a,e,d]:(a=null,b=f)):(a=null,b=f)):(a=null,b=f);null!==a&&(a=new y({type:"accessor",index:a[1]}));null===a&&(b=h);p[c]={b:b,result:a};return a}function Ga(){var f="field_selector@"+b,a=p[f];if(a)return b=a.b,a.result;
var e,d,h;h=d=b;46===c.charCodeAt(b)?(a=".",b+=1):(a=null,0===l&&g('"."'));null!==a?(e=Q(),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"field_selector",selection:a[1].name}));null===a&&(b=d);p[f]={b:b,result:a};return a}function Gc(){var c="postfix_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f;f=a=b;e=Ec();if(null!==e){d=[];h=Ga();for(null===h&&(h=Fa());null!==h;)d.push(h),h=Ga(),null===h&&(h=Fa());null!==d?e=[e,d]:(e=null,b=f)}else e=null,b=f;if(null!==e)for(d=
e[1],e=e[0],h=0;h<d.length;h++)e=new y({type:"postfix",j:d[h],N:e});null===e&&(b=a);p[c]={b:b,result:e};return e}function Hc(){var f="postfix_expression_no_repeat@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k,n;n=a=b;e=Gc();if(null!==e)if(d=q(),d=null!==d?d:"",null!==d)if("++"===c.substr(b,2)?(h="++",b+=2):(h=null,0===l&&g('"++"')),null===h&&("--"===c.substr(b,2)?(h="--",b+=2):(h=null,0===l&&g('"--"'))),h=null!==h?h:"",null!==h){m=[];k=Ga();for(null===k&&(k=Fa());null!==k;)m.push(k),k=Ga(),
null===k&&(k=Fa());null!==m?e=[e,d,h,m]:(e=null,b=n)}else e=null,b=n;else e=null,b=n;else e=null,b=n;if(null!==e)for(h=e[2],d=e[3],e=e[0],h&&(e=new y({type:"postfix",j:new y({id:Ic++,type:"operator",j:h}),N:e})),h=0;h<d.length;h++)e=new y({type:"postfix",j:d[h],N:e});null===e&&(b=a);p[f]={b:b,result:e};return e}function vb(){var f="parameter_list@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m,k,n;m=b;"void"===c.substr(b,4)?(a="void",b+=4):(a=null,0===l&&g('"void"'));null!==a&&(a=[]);null===a&&
(b=m);if(null===a){k=m=b;a=S();if(null!==a){e=[];n=b;d=H();null!==d?(h=S(),null!==h?d=[d,h]:(d=null,b=n)):(d=null,b=n);for(;null!==d;)e.push(d),n=b,d=H(),null!==d?(h=S(),null!==h?d=[d,h]:(d=null,b=n)):(d=null,b=n);null!==e?a=[a,e]:(a=null,b=k)}else a=null,b=k;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=m)}p[f]={b:b,result:a};return a}function Fc(){var c="function_call@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f,g;g=a=b;e=Jc();null!==
e?(d=ba(),null!==d?(h=vb(),h=null!==h?h:"",null!==h?(f=ca(),null!==f?e=[e,d,h,f]:(e=null,b=g)):(e=null,b=g)):(e=null,b=g)):(e=null,b=g);null!==e&&(d=e[2],e=new y({type:"function_call",I:e[0],l:d}),d||(e.l=[]));null===e&&(b=a);p[c]={b:b,result:e};return e}function Jc(){var c="function_identifier@"+b,a=p[c];if(a)return b=a.b,a.result;var e;e=b;a=Q();null!==a&&(a=a.name);null===a&&(b=e);null===a&&(a=Aa());p[c]={b:b,result:a};return a}function Ya(){var f="unary_expression@"+b,a=p[f];if(a)return b=a.b,
a.result;var e,d,h,m;m=h=b;"++"===c.substr(b,2)?(a="++",b+=2):(a=null,0===l&&g('"++"'));null===a&&("--"===c.substr(b,2)?(a="--",b+=2):(a=null,0===l&&g('"--"')),null===a&&(33===c.charCodeAt(b)?(a="!",b+=1):(a=null,0===l&&g('"!"')),null===a&&(126===c.charCodeAt(b)?(a="~",b+=1):(a=null,0===l&&g('"~"')),null===a&&(43===c.charCodeAt(b)?(a="+",b+=1):(a=null,0===l&&g('"+"')),null===a&&(45===c.charCodeAt(b)?(a="-",b+=1):(a=null,0===l&&g('"-"')))))));a=null!==a?a:"";null!==a?(e=q(),e=null!==e?e:"",null!==
e?(d=Hc(),null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(e=a[0],L=a[2],e&&(L=new y({type:"unary",N:L,j:new y({type:"operator",j:e})})),a=L);null===a&&(b=h);p[f]={b:b,result:a};return a}function Mb(){var f="multiplicative_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;h=d=b;42===c.charCodeAt(b)?(a="*",b+=1):(a=null,0===l&&g('"*"'));null===a&&(47===c.charCodeAt(b)?(a="/",b+=1):(a=null,0===l&&g('"/"')),null===a&&(37===c.charCodeAt(b)?(a="%",b+=1):(a=null,0===l&&g('"%"'))));
null!==a?(m=b,l++,61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="')),l--,null===e?e="":(e=null,b=m),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:a[0]}));null===a&&(b=d);p[f]={b:b,result:a};return a}function Za(){var c="multiplicative_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f,g,k,l,n;l=k=b;a=Ya();if(null!==a){e=[];n=b;d=q();d=null!==d?d:"";null!==d?(h=Mb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=Ya(),null!==g?d=[d,h,f,g]:(d=null,b=
n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);for(;null!==d;)e.push(d),n=b,d=q(),d=null!==d?d:"",null!==d?(h=Mb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=Ya(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);null!==e?a=[a,e]:(a=null,b=l)}else a=null,b=l;null!==a&&(a=X(a[0],a[1]));null===a&&(b=k);p[c]={b:b,result:a};return a}function Nb(){var f="additive_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;h=d=b;43===c.charCodeAt(b)?(a="+",b+=1):(a=null,0===l&&g('"+"'));
null!==a?(m=b,l++,43===c.charCodeAt(b)?(e="+",b+=1):(e=null,0===l&&g('"+"')),null===e&&(61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="'))),l--,null===e?e="":(e=null,b=m),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:"+"}));null===a&&(b=d);null===a&&(h=d=b,45===c.charCodeAt(b)?(a="-",b+=1):(a=null,0===l&&g('"-"')),null!==a?(m=b,l++,45===c.charCodeAt(b)?(e="-",b+=1):(e=null,0===l&&g('"-"')),null===e&&(61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="'))),
l--,null===e?e="":(e=null,b=m),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h),null!==a&&(a=new y({type:"operator",j:"-"})),null===a&&(b=d));p[f]={b:b,result:a};return a}function $a(){var c="additive_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f,g,k,l,n;l=k=b;a=Za();if(null!==a){e=[];n=b;d=q();d=null!==d?d:"";null!==d?(h=Nb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=Za(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);for(;null!==d;)e.push(d),n=b,d=q(),d=
null!==d?d:"",null!==d?(h=Nb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=Za(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);null!==e?a=[a,e]:(a=null,b=l)}else a=null,b=l;null!==a&&(a=X(a[0],a[1]));null===a&&(b=k);p[c]={b:b,result:a};return a}function Ob(){var f="shift_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;h=d=b;"<<"===c.substr(b,2)?(a="<<",b+=2):(a=null,0===l&&g('"<<"'));null===a&&(">>"===c.substr(b,2)?(a=">>",b+=2):(a=null,0===l&&g('">>"')));null!==
a?(m=b,l++,61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="')),l--,null===e?e="":(e=null,b=m),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:a[0]}));null===a&&(b=d);p[f]={b:b,result:a};return a}function ab(){var c="shift_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f,g,k,l,n;l=k=b;a=$a();if(null!==a){e=[];n=b;d=q();d=null!==d?d:"";null!==d?(h=Ob(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=$a(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):
(d=null,b=n)):(d=null,b=n);for(;null!==d;)e.push(d),n=b,d=q(),d=null!==d?d:"",null!==d?(h=Ob(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=$a(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);null!==e?a=[a,e]:(a=null,b=l)}else a=null,b=l;null!==a&&(a=X(a[0],a[1]));null===a&&(b=k);p[c]={b:b,result:a};return a}function Pb(){var f="relational_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;m=h=b;60===c.charCodeAt(b)?(a="<",b+=1):(a=null,0===l&&g('"<"'));null!==
a?(d=b,l++,60===c.charCodeAt(b)?(e="<",b+=1):(e=null,0===l&&g('"<"')),l--,null===e?e="":(e=null,b=d),null!==e?(61===c.charCodeAt(b)?(d="=",b+=1):(d=null,0===l&&g('"="')),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m);null!==a&&(a=new y({type:"operator",j:"<"+a[2]}));null===a&&(b=h);null===a&&(m=h=b,62===c.charCodeAt(b)?(a=">",b+=1):(a=null,0===l&&g('">"')),null!==a?(d=b,l++,62===c.charCodeAt(b)?(e=">",b+=1):(e=null,0===l&&g('">"')),l--,null===e?e="":(e=null,b=d),null!==
e?(61===c.charCodeAt(b)?(d="=",b+=1):(d=null,0===l&&g('"="')),d=null!==d?d:"",null!==d?a=[a,e,d]:(a=null,b=m)):(a=null,b=m)):(a=null,b=m),null!==a&&(a=new y({type:"operator",j:">"+a[2]})),null===a&&(b=h));p[f]={b:b,result:a};return a}function bb(){var c="relational_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,h,f,g,k,l,n;l=k=b;a=ab();if(null!==a){e=[];n=b;d=q();d=null!==d?d:"";null!==d?(h=Pb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=ab(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,
b=n)):(d=null,b=n)):(d=null,b=n);for(;null!==d;)e.push(d),n=b,d=q(),d=null!==d?d:"",null!==d?(h=Pb(),null!==h?(f=q(),f=null!==f?f:"",null!==f?(g=ab(),null!==g?d=[d,h,f,g]:(d=null,b=n)):(d=null,b=n)):(d=null,b=n)):(d=null,b=n);null!==e?a=[a,e]:(a=null,b=l)}else a=null,b=l;null!==a&&(a=X(a[0],a[1]));null===a&&(b=k);p[c]={b:b,result:a};return a}function Qb(){var f="equality_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e;e=b;"=="===c.substr(b,2)?(a="==",b+=2):(a=null,0===l&&g('"=="'));null===a&&
("!="===c.substr(b,2)?(a="!=",b+=2):(a=null,0===l&&g('"!="')));null!==a&&(a=new y({type:"operator",j:a}));null===a&&(b=e);p[f]={b:b,result:a};return a}function cb(){var c="equality_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=bb();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Qb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=bb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==
d?(f=Qb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=bb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Rb(){var f="bitwise_and_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,m;h=d=b;38===c.charCodeAt(b)?(a="&",b+=1):(a=null,0===l&&g('"&"'));null!==a?(m=b,l++,61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="')),null===e&&(38===
c.charCodeAt(b)?(e="&",b+=1):(e=null,0===l&&g('"&"'))),l--,null===e?e="":(e=null,b=m),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:"&"}));null===a&&(b=d);p[f]={b:b,result:a};return a}function db(){var c="bitwise_and_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=cb();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Rb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=cb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,
b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Rb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=cb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Sb(){var f="bitwise_xor_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k;h=d=b;94===c.charCodeAt(b)?(a="^",b+=1):(a=null,0===l&&g('"^"'));null!==a?(k=b,
l++,61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="')),null===e&&(94===c.charCodeAt(b)?(e="^",b+=1):(e=null,0===l&&g('"^"'))),l--,null===e?e="":(e=null,b=k),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:"^"}));null===a&&(b=d);p[f]={b:b,result:a};return a}function eb(){var c="bitwise_xor_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=db();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Sb(),null!==f?(g=q(),g=null!==g?
g:"",null!==g?(k=db(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Sb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=db(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Tb(){var f="bitwise_or_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k;h=
d=b;124===c.charCodeAt(b)?(a="|",b+=1):(a=null,0===l&&g('"|"'));null!==a?(k=b,l++,61===c.charCodeAt(b)?(e="=",b+=1):(e=null,0===l&&g('"="')),null===e&&(124===c.charCodeAt(b)?(e="|",b+=1):(e=null,0===l&&g('"|"'))),l--,null===e?e="":(e=null,b=k),null!==e?a=[a,e]:(a=null,b=h)):(a=null,b=h);null!==a&&(a=new y({type:"operator",j:"|"}));null===a&&(b=d);p[f]={b:b,result:a};return a}function fb(){var c="bitwise_or_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=eb();if(null!==
a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Tb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=eb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Tb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=eb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Ub(){var f=
"logical_and_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e;e=b;"&&"===c.substr(b,2)?(a="&&",b+=2):(a=null,0===l&&g('"&&"'));null!==a&&(a=new y({type:"operator",j:"&&"}));null===a&&(b=e);p[f]={b:b,result:a};return a}function gb(){var c="logical_and_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=fb();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Ub(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=fb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,
b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Ub(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=fb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Vb(){var f="logical_xor_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e;e=b;"^^"===c.substr(b,2)?(a="^^",b+=2):(a=null,0===l&&g('"^^"'));null!==a&&(a=new y({type:"operator",
j:"^^"}));null===a&&(b=e);p[f]={b:b,result:a};return a}function hb(){var c="logical_xor_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l,n,r;n=l=b;a=gb();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Vb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=gb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Vb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=gb(),null!==k?d=[d,f,g,k]:(d=null,
b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};return a}function Wb(){var f="logical_or_operator@"+b,a=p[f];if(a)return b=a.b,a.result;var e;e=b;"||"===c.substr(b,2)?(a="||",b+=2):(a=null,0===l&&g('"||"'));null!==a&&(a=new y({type:"operator",j:"||"}));null===a&&(b=e);p[f]={b:b,result:a};return a}function Kc(){var c="logical_or_expression@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,
l,n,r;n=l=b;a=hb();if(null!==a){e=[];r=b;d=q();d=null!==d?d:"";null!==d?(f=Wb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=hb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);for(;null!==d;)e.push(d),r=b,d=q(),d=null!==d?d:"",null!==d?(f=Wb(),null!==f?(g=q(),g=null!==g?g:"",null!==g?(k=hb(),null!==k?d=[d,f,g,k]:(d=null,b=r)):(d=null,b=r)):(d=null,b=r)):(d=null,b=r);null!==e?a=[a,e]:(a=null,b=n)}else a=null,b=n;null!==a&&(a=X(a[0],a[1]));null===a&&(b=l);p[c]={b:b,result:a};
return a}function pa(){var f="conditional_expression@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k,n,u,x,r,B,A,C;A=a=b;e=Kc();null!==e?(C=b,d=q(),d=null!==d?d:"",null!==d?(63===c.charCodeAt(b)?(h="?",b+=1):(h=null,0===l&&g('"?"')),null!==h?(k=q(),k=null!==k?k:"",null!==k?(n=S(),null!==n?(u=q(),u=null!==u?u:"",null!==u?(58===c.charCodeAt(b)?(x=":",b+=1):(x=null,0===l&&g('":"')),null!==x?(r=q(),r=null!==r?r:"",null!==r?(B=S(),null!==B?d=[d,h,k,n,u,x,r,B]:(d=null,b=C)):(d=null,b=C)):(d=null,b=C)):
(d=null,b=C)):(d=null,b=C)):(d=null,b=C)):(d=null,b=C)):(d=null,b=C),d=null!==d?d:"",null!==d?e=[e,d]:(e=null,b=A)):(e=null,b=A);null!==e&&(d=e[0],e=e[1],L=d,e&&(L=new y({type:"ternary",F:d,Ha:e[3],Ga:e[7]})),e=L);null===e&&(b=a);p[f]={b:b,result:e};return e}function S(){var f="assignment_expression@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k,n,u;u=n=b;a=pa();null!==a?(e=q(),e=null!==e?e:"",null!==e?(61===c.charCodeAt(b)?(d="=",b+=1):(d=null,0===l&&g('"="')),null===d&&("*="===c.substr(b,2)?
(d="*=",b+=2):(d=null,0===l&&g('"*="')),null===d&&("/="===c.substr(b,2)?(d="/=",b+=2):(d=null,0===l&&g('"/="')),null===d&&("%="===c.substr(b,2)?(d="%=",b+=2):(d=null,0===l&&g('"%="')),null===d&&("+="===c.substr(b,2)?(d="+=",b+=2):(d=null,0===l&&g('"+="')),null===d&&("-="===c.substr(b,2)?(d="-=",b+=2):(d=null,0===l&&g('"-="')),null===d&&("<<="===c.substr(b,3)?(d="<<=",b+=3):(d=null,0===l&&g('"<<="')),null===d&&(">>="===c.substr(b,3)?(d=">>=",b+=3):(d=null,0===l&&g('">>="')),null===d&&("&="===c.substr(b,
2)?(d="&=",b+=2):(d=null,0===l&&g('"&="')),null===d&&("^="===c.substr(b,2)?(d="^=",b+=2):(d=null,0===l&&g('"^="')),null===d&&("|="===c.substr(b,2)?(d="|=",b+=2):(d=null,0===l&&g('"|="')))))))))))),null!==d?(h=q(),h=null!==h?h:"",null!==h?(k=S(),null!==k?a=[a,e,d,h,k]:(a=null,b=u)):(a=null,b=u)):(a=null,b=u)):(a=null,b=u)):(a=null,b=u);null!==a&&(e=a[0],d=a[4],a=new y({type:"binary",j:new y({type:"operator",j:a[2]}),left:e,right:d}));null===a&&(b=n);null===a&&(a=pa());p[f]={b:b,result:a};return a}
function Db(){var f="condition@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k,n,u,x;x=b;a=za();null!==a?(e=q(),null!==e?(d=Q(),null!==d?(h=q(),h=null!==h?h:"",null!==h?(61===c.charCodeAt(b)?(k="=",b+=1):(k=null,0===l&&g('"="')),null!==k?(n=q(),n=null!==n?n:"",null!==n?(u=S(),null!==u?a=[a,e,d,h,k,n,u]:(a=null,b=x)):(a=null,b=x)):(a=null,b=x)):(a=null,b=x)):(a=null,b=x)):(a=null,b=x)):(a=null,b=x);null===a&&(a=S());p[f]={b:b,result:a};return a}function nd(){var f;a:{f=ob;f.sort();for(var a=null,
e=[],d=0;d<f.length;d++)f[d]!==a&&(e.push(f[d]),a=f[d]);switch(e.length){case 0:f="end of input";break a;case 1:f=e[0];break a;default:f=e.slice(0,e.length-1).join(", ")+" or "+e[e.length-1]}}a=Math.max(b,ta);a=a<c.length?n(c.charAt(a)):"end of input";return"Expected "+f+" but "+a+" found."}function Lc(){for(var f=1,a=1,e=!1,d=0;d<Math.max(b,ta);d++){var g=c.charAt(d);"\n"===g?(e||f++,a=1,e=!1):"\r"===g||"\u2028"===g||"\u2029"===g?(f++,a=1,e=!0):(a++,e=!1)}return{ka:f,Da:a}}function y(b){this.id=
Ic++;this.ka=Lc().ka;for(var a in b)b.hasOwnProperty(a)&&(this[a]=b[a])}function X(b,a){for(var c=b,d=0;d<a.length;d++)c=new y({type:"binary",j:a[d][1],left:c,right:a[d][3]});return c}function jc(b,a,c){c&&(a=a.concat([c]));c=b[0];c.ia=b[1].C;b=c;for(var d=0;d<a.length;d++)b.M=a[d][0],b.M.ia=a[d][1].C,b=b.M;return c}var Mc={EOF:B,_:q,additive_expression:$a,additive_operator:Nb,assignment_expression:S,attribute_qualifier:Ib,attribute_type:rc,bitwise_and_expression:db,bitwise_and_operator:Rb,bitwise_or_expression:fb,
bitwise_or_operator:Tb,bitwise_xor_expression:eb,bitwise_xor_operator:Sb,bool_constant:Dc,comma:H,comment:C,compound_statement:Qa,condition:Db,conditional_expression:pa,const_qualifier:Va,declaration:Sa,declarator:Ca,declarator_array_with_size:Ea,declarator_list:wc,declarator_list_arrays_have_size:Gb,declarator_list_no_array:sc,declarator_no_array:Da,do_while:pc,equality_expression:cb,equality_operator:Qb,equals:cc,expression_statement:Cb,external_declaration:ec,external_statement:rb,external_statement_list:ja,
field_selector:Ga,float_constant:Bc,float_exponent:Xa,for_loop:nc,fragment_start:function(){var c="fragment_start@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f;f=d=b;ya="fs";a="";null!==a?(e=ja(),null!==e?a=[a,e]:(a=null,b=f)):(a=null,b=f);null!==a&&(a=a[1]);null===a&&(b=d);p[c]={b:b,result:a};return a},fully_specified_type:qc,function_call:Fc,function_definition:fc,function_identifier:Jc,function_prototype:Ab,function_prototype_parameter_list:tc,global_declaration:gc,identifier:Q,index_accessor:Fa,
init_declarator:Wa,init_declarator_list:Fb,int_constant:Ac,iteration_statement:lc,jump_statement:mc,keyword:zc,left_brace:pb,left_bracket:ua,left_paren:ba,locally_specified_type:za,logical_and_expression:gb,logical_and_operator:Ub,logical_or_expression:Kc,logical_or_operator:Wb,logical_xor_expression:hb,logical_xor_operator:Vb,macro_call:Oa,macro_call_line:function(){var f="macro_call_line@"+b,a=p[f];if(a)return b=a.b,a.result;var e,d,h,k;k=h=b;a=Oa();a=null!==a?a:"";if(null!==a){e=[];/^[^\n]/.test(c.charAt(b))?
(d=c.charAt(b),b++):(d=null,0===l&&g("[^\\n]"));for(;null!==d;)e.push(d),/^[^\n]/.test(c.charAt(b))?(d=c.charAt(b),b++):(d=null,0===l&&g("[^\\n]"));null!==e?a=[a,e]:(a=null,b=k)}else a=null,b=k;null!==a&&(a={aa:a[0],Ja:a[1].join("")});null===a&&(b=h);p[f]={b:b,result:a};return a},macro_call_parameter:Pa,macro_call_parameter_list:function(){var c="macro_call_parameter_list@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f,g,k,l;k=g=b;a=Pa();if(null!==a){e=[];l=b;d=H();null!==d?(f=Pa(),null!==f?d=[d,
f]:(d=null,b=l)):(d=null,b=l);for(;null!==d;)e.push(d),l=b,d=H(),null!==d?(f=Pa(),null!==f?d=[d,f]:(d=null,b=l)):(d=null,b=l);null!==e?a=[a,e]:(a=null,b=k)}else a=null,b=k;null!==a&&(a=function(a,b){return[a].concat(b.map(function(a){return a[1]}))}(a[0],a[1]));null===a&&(b=g);p[c]={b:b,result:a};return a},macro_identifier:na,macro_paren_parameter:ub,matrix:Kb,member_list:xc,multiplicative_expression:Za,multiplicative_operator:Mb,newLine:u,noNewlineComment:x,noNewlineWhitespace:ha,parameter_declaration:Ua,
parameter_list:vb,parameter_qualifier:vc,paren_expression:Cc,postfix_expression:Gc,postfix_expression_no_repeat:Hc,precision_qualifier:Ta,precision_type:Ba,preprocessor_define:sb,preprocessor_else:xb,preprocessor_else_if:wa,preprocessor_end:yb,preprocessor_external_branch:dc,preprocessor_if:wb,preprocessor_operator:tb,preprocessor_parameter_list:ic,preprocessor_statement_branch:zb,primary_expression:Ec,relational_expression:bb,relational_operator:Pb,reserved:function(){var f="reserved@"+b,a=p[f];
if(a)return b=a.b,a.result;var e,d,h,k;l++;k=b;a=[];for(e=Lb();null!==e;)a.push(e),e=Lb();if(null!==a)if("__"===c.substr(b,2)?(e="__",b+=2):(e=null,0===l&&g('"__"')),null!==e){d=[];/^[A-Za-z_0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z_0-9]"));for(;null!==h;)d.push(h),/^[A-Za-z_0-9]/.test(c.charAt(b))?(h=c.charAt(b),b++):(h=null,0===l&&g("[A-Za-z_0-9]"));null!==d?a=[a,e,d]:(a=null,b=k)}else a=null,b=k;else a=null,b=k;l--;0===l&&null===a&&g("reserved name");p[f]={b:b,result:a};
return a},right_brace:qb,right_bracket:va,right_paren:ca,selection_statement:kc,semicolon:A,shift_expression:ab,shift_operator:Ob,simple_statement:Bb,single_underscore_identifier:Lb,statement_list:oa,statement_no_new_scope:xa,statement_with_scope:Ra,struct_definition:hc,type_name:Aa,type_qualifier:Hb,unary_expression:Ya,vector:Jb,vertex_start:function(){var c="vertex_start@"+b,a=p[c];if(a)return b=a.b,a.result;var e,d,f;f=d=b;ya="vs";a="";null!==a?(e=ja(),null!==e?a=[a,e]:(a=null,b=f)):(a=null,b=
f);null!==a&&(a=a[1]);null===a&&(b=d);p[c]={b:b,result:a};return a},void_type:uc,while_loop:oc,while_statement:Eb};if(void 0!==f){if(void 0===Mc[f])throw Error("Invalid rule name: "+n(f)+".");}else f="external_statement_list";var b=0,l=0,ta=0,ob=[],p={},yc={},Ic=0,ya="vs",L=Mc[f]();if(null===L||b!==c.length){var Nc=Lc();throw new la.SyntaxError(nd(),Nc.ka,Nc.Da);}return L}la.SyntaxError=function(c,f,k){this.name="SyntaxError";this.message=c;this.line=f;this.column=k};la.SyntaxError.prototype=Error.prototype;function ma(c){return c.split(/_/g).map(function(c){return c.slice(0,1).toUpperCase()+c.slice(1).toLowerCase()}).join("")}["varying mediump vec4 gl_FragCoord;","varying bool gl_FrontFacing;","varying mediump vec2 gl_PointCoord;"].map(function(c){return z(c,"global_declaration")});var qa=Array.prototype,D=qa.forEach?function(c,f,k){qa.forEach.call(c,f,k)}:function(c,f,k){for(var n=c.length,g="string"==typeof c?c.split(""):c,u=0;u<n;u++)u in g&&f.call(k,g[u],u,c)};function ra(c,f,k){for(var n="string"==typeof c?c.split(""):c,g=c.length-1;0<=g;--g)g in n&&f.call(k,n[g],g,c)}var sa=qa.every?function(c,f,k){return qa.every.call(c,f,k)}:function(c,f,k){for(var n=c.length,g="string"==typeof c?c.split(""):c,u=0;u<n;u++)if(u in g&&!f.call(k,g[u],u,c))return!1;return!0};
function Ha(c){var f=c.length;if(0<f){for(var k=Array(f),n=0;n<f;n++)k[n]=c[n];return k}return[]};function Ia(){}Ia.prototype.i=function(c){return this["beforeVisit"+ma(c.type)]};Ia.prototype.u=function(c){return this["afterVisit"+ma(c.type)]};Ia.prototype.m=function(c){return this["visit"+ma(c.type)]};function E(c,f){if(f&&f.type){var k=c.i(f);k&&k.apply(c,[f]);(k=c.m(f))?k.apply(c,[f]):Ja(c,f);(k=c.u(f))&&k.apply(c,[f])}}function Ka(c,f){D(f,function(c){E(this,c)},c)}
function Ja(c,f){for(var k in f){var n=f[k];if("array"==ea(n))Ka(c,n);else{var g=typeof n;("object"==g&&null!=n||"function"==g)&&n.type&&E(c,n)}}};function F(c,f){this.c=c||"\n";this.h=!!f;this.a="";this.f=0}v(F,Ia);ka("glslunit.Generator",F);function G(c,f,k){this.a=c;this.c=f||0;this.f=k||2}
var La={function_call:new G(0,2),identifier:new G(0,2),"float":new G(0,2),"int":new G(0,2),bool:new G(0,2),postfix:new G(1,0,1),unary:new G(2,1,1),"*":new G(3,0),"/":new G(3),"%":new G(3),"+":new G(4,0),"-":new G(4),"<<":new G(5),">>":new G(5),"<":new G(6),">":new G(6),"<=":new G(6),">=":new G(6),"==":new G(7),"!=":new G(7),"&":new G(8,0),"^":new G(9,0),"|":new G(10,0),"&&":new G(11,0),"^^":new G(12,0),"||":new G(13,0),ternary:new G(14,1,3),"=":new G(15),"-=":new G(15),"+=":new G(15),"*=":new G(15),
"/=":new G(15),"%=":new G(15),"<<=":new G(15),">>=":new G(15),"&=":new G(15),"^=":new G(15),"|=":new G(15)};function I(c,f,k){f=new F(f,k);E(f,c);return f.a}function Ma(c,f,k){return f?c+f+k:""}function Na(c,f,k){for(var n=0;n<f.length;n++)0!=n&&(c.a+=k),E(c,f[n])}function ib(c){c.h&&(c.a+=c.c+Array(c.f+1).join("  "))}function jb(c){c.h&&"  "==c.a.slice(-2)&&(c.a=c.a.slice(0,-2))}
F.prototype.za=function(c){this.a+=Ma("",c.qualifier," ");this.a+="struct";this.a+=Ma(" ",c.name,"");this.a+="{";this.f++;Na(this,c.Ia,"");this.f--;jb(this);this.a+="}";c.A&&Na(this,c.A,",");this.a+=";";ib(this)};F.prototype.visitStructDefinition=F.prototype.za;F.prototype.ya=function(c){this.a+="{";this.f++;ib(this);Na(this,c.C,"");this.f--;jb(this);this.a+="}";ib(this)};F.prototype.visitScope=F.prototype.ya;F.prototype.va=function(c){this.a+="precision "+c.precision+" "+c.typeName+";";ib(this)};
F.prototype.visitPrecision=F.prototype.va;F.prototype.ha=function(c){this.a+="invariant ";Na(this,c.Ea,",");this.a+=";";ib(this)};F.prototype.visitInvariant=F.prototype.ha;F.prototype.ta=function(c){this.a+=Ma("",c.qa," ");this.a+=Ma("",c.la," ");this.a+=Ma("",c.precision," ");this.a+=c.Ka+" "+c.name;c.$&&(this.a+="[",E(this,c.$),this.a+="]")};F.prototype.visitParameter=F.prototype.ta;function kb(c,f){E(c,f.ma);c.a+=" "+f.name+"(";Na(c,f.l,",");c.a+=")"}
F.prototype.da=function(c){kb(this,c);this.a+=";";ib(this)};F.prototype.visitFunctionPrototype=F.prototype.da;F.prototype.ca=function(c){kb(this,c);E(this,c.body)};F.prototype.visitFunctionDeclaration=F.prototype.ca;
F.prototype.wa=function(c){var f=this.a.slice(-1*this.c.length);f&&f!=this.c&&(this.a+=this.c);this.a+=c.B;"#define"==c.B?(this.a+=" "+c.identifier,c.l&&(this.a+="(",Na(this,c.l,","),this.a+=")"),this.a+=Ma(" ",c.pa,"")):this.a+=Ma(" ",c.value,"");this.a+=this.c;c.ia&&(Na(this,c.ia,""),c.M&&E(this,c.M),"#if"==c.B.slice(0,3)&&(f=this.a.slice(-1*this.c.length),f!=this.c&&(this.a+=this.c),this.a+="#endif"+this.c))};F.prototype.visitPreprocessor=F.prototype.wa;
function lb(c,f){c.a+="while(";E(c,f.F);c.a+=")"}F.prototype.U=function(c){this.a+="do";"scope"!=c.body.type&&(this.a+=" ");E(this,c.body);lb(this,c)};F.prototype.visitDoStatement=F.prototype.U;F.prototype.Ca=function(c){lb(this,c);E(this,c.body)};F.prototype.visitWhileStatement=F.prototype.Ca;F.prototype.ba=function(c){this.a+="for(";E(this,c.H);E(this,c.F);this.a+=";";E(this,c.Fa);this.a+=")";E(this,c.body)};F.prototype.visitForStatement=F.prototype.ba;
F.prototype.fa=function(c){this.a+="if(";E(this,c.F);this.a+=")";E(this,c.body);c.M&&(this.a+="else","scope"!=c.M.type&&(this.a+=" "),E(this,c.M))};F.prototype.visitIfStatement=F.prototype.fa;F.prototype.S=function(c){E(this,c.name);c.isArray&&(this.a+="[",c.$&&E(this,c.$),this.a+="]");c.H&&(this.a+="=",E(this,c.H))};F.prototype.visitDeclaratorItem=F.prototype.S;F.prototype.K=function(c){E(this,c.w);this.a+=" ";Na(this,c.A,",");this.a+=";";ib(this)};F.prototype.visitDeclarator=F.prototype.K;
F.prototype.Ba=function(c){this.a+=Ma("",c.qualifier," ");this.a+=Ma("",c.precision," ");this.a+=c.name};F.prototype.visitType=F.prototype.Ba;F.prototype.X=function(c){E(this,c.N);this.a+=";";ib(this)};F.prototype.visitExpression=F.prototype.X;F.prototype.g=function(c){this.a+=c.type;c.value&&(this.a+=" ",E(this,c.value));this.a+=";";ib(this)};F.prototype.visitJump=F.prototype.g;F.prototype.xa=F.prototype.g;F.prototype.visitReturn=F.prototype.xa;F.prototype.W=F.prototype.g;
F.prototype.visitBreak=F.prototype.W;F.prototype.T=F.prototype.g;F.prototype.visitDiscard=F.prototype.T;F.prototype.J=F.prototype.g;F.prototype.visitContinue=F.prototype.J;F.prototype.ra=function(c){this.a.slice(-1)==c.j.j&&(this.a+=" ");E(this,c.j);mb(this,c.N,c,0)};F.prototype.visitUnary=F.prototype.ra;F.prototype.ua=function(c){mb(this,c.N,c,0);E(this,c.j)};F.prototype.visitPostfix=F.prototype.ua;F.prototype.sa=function(c){this.a+=c.j};F.prototype.visitOperator=F.prototype.sa;
F.prototype.Y=function(c){this.a+="."+c.selection};F.prototype.visitFieldSelector=F.prototype.Y;F.prototype.D=function(c){this.a+="[";E(this,c.index);this.a+="]"};F.prototype.visitAccessor=F.prototype.D;F.prototype.v=function(c){this.a+=c.I+"(";Na(this,c.l,",");this.a+=")"};F.prototype.visitFunctionCall=F.prototype.v;F.prototype.ea=function(c){this.a+=c.name};F.prototype.visitIdentifier=F.prototype.ea;
function nb(c){function f(c){return c.toLowerCase().replace(/^0*|\+/g,"").replace(/(?:(\.[1-9]+)|\.)0*e/g,"$1e")}if(0==c)return"0.";var k=f(""+c);c=f(c.toExponential());-1==k.indexOf(".")&&-1==k.indexOf("e")&&(k+=".");return k.length<=c.length?k:c}F.prototype.Z=function(c){this.a+=nb(c.value)};F.prototype.visitFloat=F.prototype.Z;F.prototype.o=function(c){this.a+=c.value};F.prototype.visitValue=F.prototype.o;
F.prototype.ga=function(c){var f=c.value;c=f.toString(10);f=(0>f?"-":"")+"0x"+Math.abs(f).toString(16).toLowerCase();this.a+=c.length<=f.length?c:f};F.prototype.visitInt=F.prototype.ga;F.prototype.P=F.prototype.o;F.prototype.visitBool=F.prototype.P;F.prototype.O=function(c){mb(this,c.left,c,0);E(this,c.j);mb(this,c.right,c,1)};F.prototype.visitBinary=F.prototype.O;F.prototype.Aa=function(c){mb(this,c.F,c,0);this.a+="?";mb(this,c.Ha,c,1);this.a+=":";mb(this,c.Ga,c,2)};F.prototype.visitTernary=F.prototype.Aa;
function mb(c,f,k,n){var g=La["binary"==f.type?f.j.j:f.type];k=La["binary"==k.type?k.j.j:k.type];var u=!1;if(u=g.a>k.a?!0:g.a==k.a?0==k.c&&0==n||1==k.c&&n==k.f-1?!1:!0:!1)c.a+="(";E(c,f);u&&(c.a+=")")};function J(c,f){this.U=c||null;this.o=!!f;this.D={};this.h=[];this.a=[];this.v={};this.c=[]}v(J,Ia);ka("glslunit.VariableScopeVisitor",J);function Xb(c){var f={};ra(c.h.concat([c.a]),function(c){D(c,function(c){"declarator"==c.type?D(c.A,function(g){da(f[g.name.name])||(f[g.name.name]=c)},this):"parameter"==c.type&&(f[c.name]=c)},this)},c);return f}J.prototype.g=function(){this.h.push(this.a);this.a=[];[].push.apply(this.a,this.c);this.c=[]};J.prototype.beforeVisitScope=J.prototype.g;
J.prototype.f=function(c){this.v[c.id]=this.a;c==this.U&&(this.D=Xb(this));this.a=this.h.pop()};J.prototype.afterVisitScope=J.prototype.f;J.prototype.K=J.prototype.g;J.prototype.beforeVisitRoot=J.prototype.K;J.prototype.O=function(c){this.o||this.f(c)};J.prototype.afterVisitPreprocessor=J.prototype.O;J.prototype.J=function(){this.o||this.g()};J.prototype.beforeVisitPreprocessor=J.prototype.J;J.prototype.P=J.prototype.f;J.prototype.afterVisitRoot=J.prototype.P;J.prototype.W=function(c){this.a.push(c)};
J.prototype.beforeVisitDeclarator=J.prototype.W;J.prototype.T=function(c){this.c=c.l};J.prototype.beforeVisitFunctionDeclaration=J.prototype.T;J.prototype.S=function(){this.c=[]};J.prototype.afterVisitFunctionDeclaration=J.prototype.S;function Yb(c){var f=new J;E(f,c);return f.v}J.getScopeToDeclarationMap=Yb;function Zb(c,f){var k=new J(f,!0);E(k,c);return k.D};function $b(c){this.c=[];this.a=[];this.f=c}v($b,Ia);$b.prototype.g=function(c){this.f(c,this.a.slice(0,-1))&&this.c.push(c);Ja(this,c)};$b.prototype.i=function(){return ia(Array.prototype.push,this.a)};$b.prototype.u=function(){return ia(Array.prototype.pop,this.a)};$b.prototype.m=function(){return this.g};function ac(c,f){var k=new $b(f);E(k,c);return k.c};function K(){this.a={};this.a[bc]=[];this.c=bc}v(K,Ia);var bc="#";K.prototype.g=function(c){c.name in this.a||(this.a[c.name]=[]);this.c=c.name};K.prototype.beforeVisitFunctionDeclaration=K.prototype.g;K.prototype.f=function(){this.c=bc};K.prototype.afterVisitFunctionDeclaration=K.prototype.f;K.prototype.h=function(c){this.a[this.c].push(c.I);Ja(this,c)};K.prototype.visitFunctionCall=K.prototype.h;function Oc(c){c=ac(c,function(c,f){return"declarator"==c.type&&"struct_definition"==f.slice(-1)[0].type});var f=[];D(c,function(c){f[c.id]=!0});return f};function M(c){var f={},k;for(k in c)f[k]=c[k];return f};function N(){this.c=[]}var Pc=-1;function O(c){c=M(c);c.id=Pc--;return c}N.prototype.W=function(c){return this["transform"+ma(c.type)]};function Qc(c,f,k,n){var g=c[k+ma(f.type)];return ia(function(c){D(this.c,function(f){var g=n(f).apply(f,[c]);g&&g.apply(f,[c])});g&&g.apply(this,[c])},c)}N.prototype.P=function(c){return Qc(this,c,"beforeTransform",function(c){return c.i})};N.prototype.O=function(c){return Qc(this,c,"afterTransform",function(c){return c.u})};
function P(c,f){var k=!1,n=c.P(f);n&&n.apply(c,[f]);var n=O(f),g;for(g in f){var u=f[g];if("array"==ea(u)){n[g]=[];for(var B=0;B<u.length;B++){var q=u[B],x=P(c,q);x!=q&&(k=!0);null!=x&&Array.prototype.push.apply(n[g],"array"==ea(x)?x:[x])}}else u&&u.type&&(x=P(c,u),x!=u&&(k=!0,null!=x?n[g]=x:delete n[g]))}g=c.W(f);n=k?n:f;g&&(n=g.apply(c,[n,f]));(k=c.O(f))&&k.apply(c,[f,n]);return n};function Rc(c,f,k,n,g){this.c=[];this.u=g;this.i=c;this.a=f;this.h=k;this.f=n}v(Rc,N);ka("glslunit.SpliceTransformer",Rc);Rc.prototype.g=function(c){if(c==this.i){c=O(c);if("array"==ea(c[this.a])){var f=this.u.map(O);c[this.a]=Ha(c[this.a]);[].splice.apply(c[this.a],[this.h,this.f].concat(f));return c}throw this.a+" wasn't an array.";}return c};Rc.prototype.W=function(){return this.g};function Sc(){this.s=this.a="";this.c=[]}Sc.prototype.clone=function(){var c=M(this);c.c=Ha(this.c);return c};function Tc(){this.f=this.s="";this.c=this.a=this.g=0}function Uc(){this.type=this.a=this.s=""}function R(){this.i=[];this.f=[];this.h={};this.L={};this.R={};this.g=[];this.a={};this.c={};this.u={}}
R.prototype.clone=function(){var c=M(this);c.L=M(this.L);c.R=M(this.R);c.h=M(this.h);c.i=Ha(this.i);c.u=M(this.u);c.f=this.f.map(function(c){return M(c)});c.g=this.g.map(function(c){return c.clone()});return c};R.prototype.P=function(c){return I(this.c,c||"\\n",!1)};R.prototype.getVertexSource=R.prototype.P;R.prototype.o=function(c){return I(this.a,c||"\\n",!1)};R.prototype.getFragmentSource=R.prototype.o;R.prototype.v=function(c){return"".replace(/\n/g,c||"\\n").replace(/'/g,"\\'")};
R.prototype.getOriginalFragmentSource=R.prototype.v;R.prototype.D=function(c){return"".replace(/\n/g,c||"\\n").replace(/'/g,"\\'")};R.prototype.getOriginalVertexSource=R.prototype.D;R.prototype.m=function(){var c=[],f;for(f in this.L)c.push(this.L[f]);0<c.length&&(c[c.length-1].last=!0);return c};R.prototype.getAttributes=R.prototype.m;R.prototype.O=function(){var c=[],f;for(f in this.R)c.push(this.R[f]);0<c.length&&(c[c.length-1].last=!0);return c};R.prototype.getUniforms=R.prototype.O;
function Vc(c){D(c.f,function(c){""==c.s&&(c.s=c.a)});var f={},k;for(k in c.L){var n=c.L[k];f[n.s]=n}k={};for(var g in c.R)n=c.R[g],k[n.s]=n;Wc(c,c.c,f,k);Wc(c,c.a,f,k)}
function Wc(c,f,k,n){f=ac(f,function(c){return"declarator"==c.type&&("attribute"==c.w.qualifier||"uniform"==c.w.qualifier)});D(f,function(c){D(c.A,function(f){f=f.name.name;var B=c.w.name;if("attribute"==c.w.qualifier){var q=k[f];if(!q){q=new Tc;q.s=f;q.f=f;var x=I(c),ha="".search(x),B=parseInt(B.slice(3,4),10);q.g=isNaN(B)?1:B;q.a=ha;q.c=x.length;this.L[f]=q}}else q=n[f],q||(q=new Uc,q.s=f,q.a=f,q.type=B,this.R[f]=q)},this)},c)};function T(){this.c=[];this.a=[]}v(T,N);var Xc={vec2:2,vec3:3,vec4:4,bvec2:2,bvec3:3,bvec4:4,ivec2:2,ivec3:3,ivec4:4,mat2:4,mat3:9,mat4:16,"float":1,"int":1,bool:1};T.prototype.P=function(){return ia(Array.prototype.push,this.a)};T.prototype.O=function(){return ia(Array.prototype.pop,this.a)};function Yc(c){c=c.a.slice(-2)[0];return"function_call"==c.type&&c.I in Xc}
T.prototype.i=function(c){if(Yc(this)&&65536>Math.abs(c.value)&&c.value==Math.round(c.value)){var f=O(c);f.type="int";f.value=Number(c.value);return f}return c};T.prototype.o=T.prototype.i;T.prototype.transformFloat=T.prototype.o;T.prototype.m=T.prototype.i;T.prototype.transformBool=T.prototype.m;
T.prototype.h=function(c){var f=Xc[c.I];if(f){if(Yc(this)&&c.l.length==f)return c.l;if(c.l&&1<c.l.length){var k=I(c.l[0]),n=!1;if("mat"==c.I.slice(0,3)){if(c.l.length==f){for(var f=!0,g=parseInt(c.I.slice(-1),10),u=0;u<g&&f;u++)for(var B=0;B<g&&f;B++)f=I(c.l[u*g+B])==(u==B?k:"0");f&&(n=!0)}}else sa(c.l,function(c){return I(c)==k})&&(n=!0);if(n)return n=O(c),n.l=[c.l[0]],n}}return c};T.prototype.transformFunctionCall=T.prototype.h;T.prototype.f=function(){return"ConstructorMinifier"};
T.prototype.g=function(){return[]};T.prototype.u=function(c,f){var k=new T;f.c=P(new T,f.c);f.a=P(k,f.a);return[]};function U(){this.c=[]}v(U,N);function Zc(c,f){var k=c[f],n=c;k&&"scope"==k.type&&1==k.C.length&&(n=O(c),n[f]=k.C[0]);return n}U.prototype.h=function(c){c=Zc(c,"body");return Zc(c,"elseBody")};U.prototype.transformIfStatement=U.prototype.h;U.prototype.m=function(c){return Zc(c,"body")};U.prototype.transformWhileStatement=U.prototype.m;U.prototype.a=function(c){return Zc(c,"body")};U.prototype.transformDoStatement=U.prototype.a;U.prototype.i=function(c){return Zc(c,"body")};
U.prototype.transformForStatement=U.prototype.i;U.prototype.f=function(){return"BraceReducer"};U.prototype.g=function(){return[]};U.prototype.u=function(c,f){var k=new U;f.c=P(new U,f.c);f.a=P(k,f.a);return[]};function V(){this.c=[];this.a={}}v(V,N);V.prototype.h=function(c){var f=new K;E(f,c);c=f.a;this.a={};for(var k in c)this.a[k]=!1;$c(this,"main",c);$c(this,bc,c)};V.prototype.beforeTransformRoot=V.prototype.h;function $c(c,f,k){f in c.a&&!c.a[f]&&(c.a[f]=!0,D(k[f],function(c){$c(this,c,k)},c))}V.prototype.i=function(c){return this.a[c.name]?c:null};V.prototype.transformFunctionDeclaration=V.prototype.i;V.prototype.m=V.prototype.i;V.prototype.transformFunctionPrototype=V.prototype.m;V.prototype.f=function(){return"DeadFunctionRemover"};
V.prototype.g=function(){return[]};V.prototype.u=function(c,f){var k=new V;f.c=P(new V,f.c);f.a=P(k,f.a);return[]};function W(c){this.c=[];this.J={};this.h=null;this.a=[];this.o=[];this.v=[];this.i=c}v(W,N);W.prototype.X=function(c){var f=ac(c,function(c){return"for_statement"==c.type});D(f,function(c){this.o[c.H.id]=!0},this);this.v=Oc(c);var f=Yb(c),k;for(k in f){var n={};D(f[+k],function(f){if("declarator"==f.type&&ad(this,f,k==c.id)){var u=I(f.w);n[u]||(n[u]=[]);D(f.A,function(c){var f=c;f.H&&(f=O(c),delete f.H);n[u].push(f)},this)}},this);this.J[+k]=n}this.m(c)};W.prototype.beforeTransformRoot=W.prototype.X;
W.prototype.U=function(c){this.h=c};W.prototype.beforeTransformDeclarator=W.prototype.U;W.prototype.T=function(){this.h=null};W.prototype.afterTransformDeclarator=W.prototype.T;W.prototype.m=function(c){this.a.push(this.J[c.id])};W.prototype.beforeTransformScope=W.prototype.m;W.prototype.S=W.prototype.m;W.prototype.beforeTransformPreprocessor=W.prototype.S;W.prototype.D=function(){this.a.pop()};W.prototype.afterTransformScope=W.prototype.D;W.prototype.K=W.prototype.D;
W.prototype.afterTransformPreprocessor=W.prototype.K;function ad(c,f,k){var n=I(f.w),g=null;0<c.a.length&&(g=c.a.slice(-1)[0][n]);return null!=f&&(c.i||"attribute"!=f.w.qualifier)&&"const"!=f.w.qualifier&&(!g||1<g.length)&&!(f.id in c.o)&&!(f.id in c.v)&&!(k&&!sa(f.A,function(c){return!da(c.H)}))}W.prototype.Z=function(c){return ad(this,this.h,1==this.a.length)?c.H?{id:Pc--,type:"expression",N:{id:Pc--,type:"binary",j:{id:Pc--,type:"operator",j:"="},left:c.name,right:c.H}}:null:c};
W.prototype.transformDeclaratorItem=W.prototype.Z;W.prototype.Y=function(c){if(!ad(this,c,1==this.a.length))return c;var f=[],k=I(c.w),n=this.a.slice(-1)[0],g=n[k];g&&(f=O(c),f.A=g,f=[f],delete n[k]);c.A&&0!=c.A.length&&Array.prototype.push.apply(f,c.A);return f};W.prototype.transformDeclarator=W.prototype.Y;W.prototype.f=function(){return"DeclarationConsolidation"};W.prototype.g=function(){return[]};W.prototype.u=function(c,f){var k=new W(this.i);f.c=P(new W(this.i),f.c);f.a=P(k,f.a);return[]};function bd(c){this.a={};this.i=c;this.f={};this.c={};D(cd,function(c){this.a[c]=[]},this)}var cd=[0,1];function dd(c,f){c.c[f.f()]=f;c.a[1].push(f)}function ed(c){D(cd,function(c){D(this.a[c],function(c){fd(this,c,[])},this)},c);return c.i}function fd(c,f,k){var n=f.f(),g=k.concat(n);if(-1!=k.indexOf(n))throw"Circular dependcy in compiler steps.  "+g.join("->");n in c.f||(D(f.g(),function(c){c in this.c&&fd(this,this.c[c],g)},c),c.f[n]=f.u(c.f,c.i))};function gd(){this.c={};this.g={};this.f=this.a=0}function hd(c){var f="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[c%52];for(c=Math.floor(c/52);0<c;)--c,f+="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"[c%62],c=Math.floor(c/62);return f}function id(c){return"_"+hd(c)}function jd(c,f){if(c.c[f])return c.c[f];for(var k=null;!k||k in c.g;)k=hd(c.a++);c.g[k]=!0;return c.c[f]=k}function kd(c,f){return c.c[f]||f}
gd.prototype.clone=function(){var c=new gd;c.c=M(this.c);c.g=M(this.g);c.a=this.a;c.f=this.f;return c};function Y(c){this.c=[];this.K=[];this.a=new gd;this.h=null;this.m=0;this.D=c;this.J=[]}v(Y,N);function ld(c,f){if(!f)return!1;var k=f.w.qualifier;return(c.D||"uniform"!=k&&"attribute"!=k)&&!(f.id in c.J)}Y.prototype.ea=function(c){this.J=Oc(c);var f=[];c=Zb(c,c);for(var k in c){var n=c[k];ld(this,n)&&(n=n.w.qualifier,"varying"==n||"uniform"==n?jd(this.a,k):f.push(k))}this.v();D(f,function(c){jd(this.a,c)},this)};Y.prototype.beforeTransformRoot=Y.prototype.ea;Y.prototype.ba=function(c){this.h=c};
Y.prototype.beforeTransformDeclarator=Y.prototype.ba;Y.prototype.Y=function(){this.h=null};Y.prototype.afterTransformDeclarator=Y.prototype.Y;Y.prototype.ha=function(c){var f=O(c);f.name=jd(this.a,c.name);return f};Y.prototype.transformParameter=Y.prototype.ha;Y.prototype.v=function(){this.K.push(this.a);this.a=this.a.clone()};Y.prototype.o=function(){this.m=Math.max(this.m,this.a.a);this.a=this.K.pop()};Y.prototype.fa=Y.prototype.v;Y.prototype.beforeTransformScope=Y.prototype.fa;Y.prototype.Z=Y.prototype.o;
Y.prototype.afterTransformScope=Y.prototype.Z;Y.prototype.U=Y.prototype.o;Y.prototype.afterTransformRoot=Y.prototype.U;Y.prototype.ca=Y.prototype.v;Y.prototype.beforeTransformFunctionDeclaration=Y.prototype.ca;Y.prototype.S=Y.prototype.o;Y.prototype.afterTransformFunctionDeclaration=Y.prototype.S;Y.prototype.da=Y.prototype.v;Y.prototype.beforeTransformFunctionPrototype=Y.prototype.da;Y.prototype.T=Y.prototype.o;Y.prototype.afterTransformFunctionPrototype=Y.prototype.T;
Y.prototype.X=function(c){var f=c.name.name,k;this.h&&(k=this.h.w.qualifier);ld(this,this.h)&&(f=jd(this.a,c.name.name));this.i&&this.h&&("attribute"==k?this.i.L[c.name.name].s=f:"uniform"==k&&(this.i.R[c.name.name].s=f));return c};Y.prototype.beforeTransformDeclaratorItem=Y.prototype.X;Y.prototype.ga=function(c){var f=kd(this.a,c.name);c.name!=f&&(c=O(c),c.name=f);return c};Y.prototype.transformIdentifier=Y.prototype.ga;Y.prototype.f=function(){return"VariableMinifier"};Y.prototype.g=function(){return[]};
Y.prototype.u=function(c,f){var k=new Y(this.D);k.i=f;f.c=P(k,f.c);var n=new Y(this.D);n.i=f;n.a=k.a;f.a=P(n,f.a);return{vertexMaxId:k.m,fragmentMaxId:n.m}};function Z(){this.c=[];this.a=new gd}v(Z,N);var md={main:!0};Z.prototype.i=function(c){c.name in md||jd(this.a,c.name)};Z.prototype.beforeTransformFunctionDeclaration=Z.prototype.i;Z.prototype.h=function(c){var f=kd(this.a,c.name);f!=c.name&&(c=O(c),c.name=f);return c};Z.prototype.transformFunctionDeclaration=Z.prototype.h;Z.prototype.o=function(c){var f=kd(this.a,c.I);f!=c.I&&(c=O(c),c.I=f);return c};Z.prototype.transformFunctionCall=Z.prototype.o;Z.prototype.m=Z.prototype.i;
Z.prototype.beforeTransformFunctionPrototype=Z.prototype.m;Z.prototype.v=Z.prototype.h;Z.prototype.transformFunctionPrototype=Z.prototype.v;Z.prototype.f=function(){return"Function Minifier"};Z.prototype.g=function(){return["VariableMinifier"]};Z.prototype.u=function(c,f){var k=0,n=0;"VariableMinifier"in c&&(k=c.VariableMinifier.vertexMaxId,n=c.VariableMinifier.fragmentMaxId);var g=new Z;g.a.a=k;k=new Z;f.c=P(g,f.c);k.a.a=n;f.a=P(k,f.a);return[]};function od(c,f,k,n){this.c=c;this.a=f;this.i=k;this.h=n}function pd(c){this.c=[];this.f=!1;this.g=c;this.a=!0}v(pd,N);function qd(c,f){c.a&&(c.a=0==ac(f,ia(function(c,f){if("function_call"==c.type||"operator"==c.type||"int"==c.type||"binary"==c.type||"unary"==c.type)return!1;if("identifier"==c.type){var g=this.g[c.name];if(g=da(g)&&g.a)this.f=!0;return!(g||0<f.length&&"function_call"==f.slice(-1)[0].type)}return!0},c)).length)}
function rd(c,f){var k=z(c,"condition"),n=new pd(f),k=P(n,k),g="";n.a&&(g=sd(I(k),f),k=z(g,"condition"),qd(n,k));g={ja:n.a,G:n.f,value:0,na:g};if(n.a&&!n.f)try{g.value=Number(eval(I(k)))}catch(u){g.ja=!1}return g}var td=/([\.=;,\(\)\[\]{}\+\-:?!\|&<>\/\*]|[ \t\n]+)/g,ud=/[A-Za-z_][A-Za-z_0-9]*/g;function vd(c,f){this.name=c.identifier;this.arguments=c.l?c.l.map(function(c){return c.name}):null;this.c=c.pa.split(td).filter(function(c){return 0<c.length});this.a=f||null}
function wd(c,f,k){if(c in k)return c;var n=f[c],g=c;if(da(n))if(n.a)g=n.a.s||n.name;else if(!n.arguments){var u=M(k);u[c]=!0;g=n.c.map(function(c){return wd(c,f,u)}).join("")}return g}
function xd(c,f,k,n){for(var g in c){var u=f[c[g]];if(da(u)&&u.arguments){var B=c.slice(g).join(""),B=z(B,"macro_call_line");if(B.aa&&B.aa.l.length==u.arguments.length&&!(B.aa.oa.name in n)){var q=B.aa,x=M(n);x[B.aa.oa.name]=!0;var q=q.l.map(function(c){return sd(I(c),f,k,x)}),ha={},C;for(C in u.arguments)ha[u.arguments[C]]=q[C];u=sd(u.c.join(""),f,ha,x);B=sd(B.Ja,f,k,n);return sd(c.slice(0,g).join("")+u+B,f,k,n)}}}return c.join("")}
function sd(c,f,k,n){k=k||{};n=n||{};var g=M(f),u;for(u in k)g[u]=new vd(z("#define "+u+" "+k[u],"preprocessor_define"));c=c.split(td).filter(function(c){return 0<c.length}).map(function(c){return wd(c,g,{})});return xd(c,f,k,n)}function yd(c,f,k){this.status=c;this.V=f;this.G=k}
function zd(c,f,k){var n={};D(f,function(c){var f=z("#define "+c.a,"preprocessor_define");n[c.a]=new vd(f,c);c.s&&(f=z("#define "+c.s,"preprocessor_define"),n[c.s]=new vd(f,c))});c=I(c);var g=[new yd(1,!0,!1)],u=0,B=[];D(c.split(/\n/g),function(c){var f=g.slice(-1)[0],k=0==f.status;if(0!=c.search("#define")||k)if(0!=c.search("#undef")||k)if(0==c.search("#if")){f=c;c=z(f,"preprocessor_if");if(k)g.push(new yd(0,!1,!1)),f=!1;else{var C=!1,A=!1;if("#ifdef"==c.B||"#ifndef"==c.B){var H=c.value.match(ud)[0];
if(!da(H))throw"Invalid "+c.B+": "+f;H=n[H];da(H)&&H.a?(C=!0,f=c.B+" "+(H.a.s||H.name)):A=da(H)==("#ifndef"==c.B)}else{A=rd(c.value,n);if(!A.ja)throw"Invalid "+c.B+": "+f;f="#if "+A.na;C=A.G;A=0==A.value}C?g.push(new yd(2,!1,!0)):g.push(new yd(A?0:1,!A,!1));C&&B.push(f);f=C}u+=f&&!k}else if(0==c.search("#else"))k=!1,0!=g.slice(-2,-1)[0].status&&(f.G&&!f.V?(k=!0,C=1,A=f.V,f=!0):0!=f.status||f.V?(C=0,A=!0,f=f.G):(C=1,A=!0,f=!1),g[g.length-1]=new yd(C,A,f)),k&&B.push(c);else if(0==c.search("#elif")){k=
c;c=!1;if(0!=g.slice(-2,-1)[0].status){A=z(k,"preprocessor_else_if");C=rd(A.value,n);if(!C.ja)throw"Invalid "+A.B+": "+k;k="#elif "+C.na;A=0==C.value;f.G&&!f.V?(f=!0,C.G?(C=2,A=!1):A?(C=0,A=!1):(k="#else",C=1,A=!0)):f.V?(C=0,A=f.V,f=f.G):C.G?(k=k.replace(/^#elif/,"#if"),C=2,A=!1,c=f=!0):(C=A?0:1,A=!A,f=f.G);g[g.length-1]=new yd(C,A,f);f&&0!=C&&B.push(k)}u+=c}else 0==c.search("#endif")?(g.pop(),f.G&&(u--,B.push(c))):k||(f=sd(c,n),B.push(f));else{if(0<u)throw"Definitions can not be changed inside of Modes: "+
c;f=z(c,"preprocessor_operator");delete n[f.value]}else{if(0<u)throw"Definitions can not be changed inside of Modes: "+c;f=z(c,"preprocessor_define");f=new vd(f);n[f.name]=f}});return z(B.join("\n"),k)}od.prototype.f=function(){return"Preprocessor"};od.prototype.g=function(){return["VariableMinifier"]};function Ad(c,f){var k="statements";for(k in c)if(c[k]===c.C)break;return P(new Rc(c,k,0,0,f.C),c)}
od.prototype.u=function(c,f){var k=this.a,n=new gd;if(this.h)for(var g in f.g){var u=id(n.f++);f.g[g].s=u}if(this.i)for(g in f.f)u=id(n.f++),k.push(f.f[g].a+" "+u),f.f[g].s=u;n=this.c.map(function(c){var f=new Sc;f.a=c;return f}).concat(f.g);k=z(k.map(function(c){return"#define "+c}).join("\n"));f.c=zd(Ad(f.c,k),n,"vertex_start");f.a=zd(Ad(f.a,k),n,"fragment_start");return[]};var Bd={};ka("glslprep.SyntaxError",la.SyntaxError);ka("glslprep.Shader",Bd);Bd.VERTEX=0;Bd.FRAGMENT=1;ka("glslprep.parseGlsl",function(c,f){return z(c,0===f?"vertex_start":"fragment_start")});
ka("glslprep.minifyGlsl",function(c,f){var k=new R;k.c=z(c[0],"vertex_start");k.a=z(c[1],"fragment_start");Vc(k);k=new bd(k);if(null!=f){var n=["GL_ES 1"],g=[],u;for(u in f){var B=f[u];null!=B?n.push(u+" "+B):g.push(u)}dd(k,new od(g,n,!1,!1))}dd(k,new V);dd(k,new W(!0));dd(k,new Y(!1));dd(k,new Z);dd(k,new U);dd(k,new T);k=ed(k);c[0]=I(k.c);c[1]=I(k.a);return c});})();


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom)
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    else
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
    if (!options) options = {};

    closeNotification(this, null);

    var dialog = dialogDiv(this, template, options.bottom);
    var closed = false, me = this;
    function close(newVal) {
      if (typeof newVal == 'string') {
        inp.value = newVal;
      } else {
        if (closed) return;
        closed = true;
        dialog.parentNode.removeChild(dialog);
        me.focus();

        if (options.onClose) options.onClose(dialog);
      }
    }

    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      if (options.value) {
        inp.value = options.value;
        if (options.selectValueOnOpen !== false) {
          inp.select();
        }
      }

      if (options.onInput)
        CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
      if (options.onKeyUp)
        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});

      CodeMirror.on(inp, "keydown", function(e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
        }
        if (e.keyCode == 13) callback(inp.value, e);
      });

      if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);

      inp.focus();
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function() {
        close();
        me.focus();
      });

      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

      button.focus();
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function(callback) {
        CodeMirror.on(b, "click", function(e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function() {
        --blurring;
        setTimeout(function() { if (blurring <= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function() { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function(template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, doneTimer;
    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function(e) {
      CodeMirror.e_preventDefault(e);
      close();
    });

    if (duration)
      doneTimer = setTimeout(close, duration);

    return close;
  });
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    // We want a single cursor position.
    if (this.listSelections().length > 1 || this.somethingSelected()) return;

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = this.buildOptions(options);
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor();
    this.startLen = this.cm.getLine(this.startPos.line).length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return;
      if (this.data) CodeMirror.signal(this.data, "update");
      if (!this.options.hint.async) {
        this.finishUpdate(this.options.hint(this.cm, this.options), first);
      } else {
        var myTick = ++this.tick, self = this;
        this.options.hint(this.cm, function(data) {
          if (self.tick == myTick) self.finishUpdate(data, first);
        }, this.options);
      }
    },

    finishUpdate: function(data, first) {
      this.data = data;

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    },

    buildOptions: function(options) {
      var editor = this.cm.options.hintOptions;
      var out = {};
      for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
      if (editor) for (var prop in editor)
        if (editor[prop] !== undefined) out[prop] = editor[prop];
      if (options) for (var prop in options)
        if (options[prop] !== undefined) out[prop] = options[prop];
      return out;
    }
  };

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;

    var hints = this.hints = document.createElement("ul");
    hints.className = "CodeMirror-hints";
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    var startScroll = cm.getScrollInfo();
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[0], hints.firstChild);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  CodeMirror.registerHelper("hint", "auto", function(cm, options) {
    var helpers = cm.getHelpers(cm.getCursor(), "hint"), words;
    if (helpers.length) {
      for (var i = 0; i < helpers.length; i++) {
        var cur = helpers[i](cm, options);
        if (cur && cur.list.length) return cur;
      }
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      if (words) return CodeMirror.hint.fromList(cm, {words: words});
    } else if (CodeMirror.hint.anyword) {
      return CodeMirror.hint.anyword(cm, options);
    }
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, token.string.length) == token.string)
        found.push(word);
    }

    if (found.length) return {
      list: found,
      from: CodeMirror.Pos(cur.line, token.start),
            to: CodeMirror.Pos(cur.line, token.end)
    };
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: false,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Glue code between CodeMirror and Tern.
//
// Create a CodeMirror.TernServer to wrap an actual Tern server,
// register open documents (CodeMirror.Doc instances) with it, and
// call its methods to activate the assisting functions that Tern
// provides.
//
// Options supported (all optional):
// * defs: An array of JSON definition data structures.
// * plugins: An object mapping plugin names to configuration
//   options.
// * getFile: A function(name, c) that can be used to access files in
//   the project that haven't been loaded yet. Simply do c(null) to
//   indicate that a file is not available.
// * fileFilter: A function(value, docName, doc) that will be applied
//   to documents before passing them on to Tern.
// * switchToDoc: A function(name, doc) that should, when providing a
//   multi-file view, switch the view or focus to the named file.
// * showError: A function(editor, message) that can be used to
//   override the way errors are displayed.
// * completionTip: Customize the content in tooltips for completions.
//   Is passed a single argumentthe completion's data as returned by
//   Ternand may return a string, DOM node, or null to indicate that
//   no tip should be shown. By default the docstring is shown.
// * typeTip: Like completionTip, but for the tooltips shown for type
//   queries.
// * responseFilter: A function(doc, query, request, error, data) that
//   will be applied to the Tern responses before treating them
// * caseInsensitive: boolean to send case insensitive querys to tern
//
//
// It is possible to run the Tern server in a web worker by specifying
// these additional options:
// * useWorker: Set to true to enable web worker mode. You'll probably
//   want to feature detect the actual value you use here, for example
//   !!window.Worker.
// * workerScript: The main script of the worker. Point this to
//   wherever you are hosting worker.js from this directory.
// * workerDeps: An array of paths pointing (relative to workerScript)
//   to the Acorn and Tern libraries and any Tern plugins you want to
//   load. Or, if you minified those into a single script and included
//   them in the workerScript, simply leave this undefined.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  // declare global: tern

  CodeMirror.TernServer = function(options) {
    var self = this;
    this.options = options || {};
    var plugins = this.options.plugins || (this.options.plugins = {});
    if (!plugins.doc_comment) plugins.doc_comment = true;
    if (this.options.useWorker) {
      this.server = new WorkerServer(this);
    } else {
      this.server = new tern.Server({
        getFile: function(name, c) { return getFile(self, name, c); },
        async: true,
        defs: this.options.defs || [],
        plugins: plugins
      });
    }
    this.docs = Object.create(null);
    this.trackChange = function(doc, change) { trackChange(self, doc, change); };

    this.cachedArgHints = null;
    this.activeArgHints = null;
    this.jumpStack = [];

    this.getHint = function(cm, c) { return hint(self, cm, c); };
    this.getHint.async = true;
  };

  CodeMirror.TernServer.prototype = {
    addDoc: function(name, doc) {
      var data = {doc: doc, name: name, changed: null};
      this.server.addFile(name, docValue(this, data));
      CodeMirror.on(doc, "change", this.trackChange);
      return this.docs[name] = data;
    },

    delDoc: function(id) {
      var found = resolveDoc(this, id);
      if (!found) return;
      CodeMirror.off(found.doc, "change", this.trackChange);
      delete this.docs[found.name];
      this.server.delFile(found.name);
    },

    hideDoc: function(id) {
      closeArgHints(this);
      var found = resolveDoc(this, id);
      if (found && found.changed) sendDoc(this, found);
    },

    complete: function(cm) {
      cm.showHint({hint: this.getHint});
    },

    showType: function(cm, pos, c) { showContextInfo(this, cm, pos, "type", c); },

    showDocs: function(cm, pos, c) { showContextInfo(this, cm, pos, "documentation", c); },

    updateArgHints: function(cm) { updateArgHints(this, cm); },

    jumpToDef: function(cm) { jumpToDef(this, cm); },

    jumpBack: function(cm) { jumpBack(this, cm); },

    rename: function(cm) { rename(this, cm); },

    selectName: function(cm) { selectName(this, cm); },

    request: function (cm, query, c, pos) {
      var self = this;
      var doc = findDoc(this, cm.getDoc());
      var request = buildRequest(this, doc, query, pos);

      this.server.request(request, function (error, data) {
        if (!error && self.options.responseFilter)
          data = self.options.responseFilter(doc, query, request, error, data);
        c(error, data);
      });
    },

    destroy: function () {
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
      }
    }
  };

  var Pos = CodeMirror.Pos;
  var cls = "CodeMirror-Tern-";
  var bigDoc = 250;

  function getFile(ts, name, c) {
    var buf = ts.docs[name];
    if (buf)
      c(docValue(ts, buf));
    else if (ts.options.getFile)
      ts.options.getFile(name, c);
    else
      c(null);
  }

  function findDoc(ts, doc, name) {
    for (var n in ts.docs) {
      var cur = ts.docs[n];
      if (cur.doc == doc) return cur;
    }
    if (!name) for (var i = 0;; ++i) {
      n = "[doc" + (i || "") + "]";
      if (!ts.docs[n]) { name = n; break; }
    }
    return ts.addDoc(name, doc);
  }

  function resolveDoc(ts, id) {
    if (typeof id == "string") return ts.docs[id];
    if (id instanceof CodeMirror) id = id.getDoc();
    if (id instanceof CodeMirror.Doc) return findDoc(ts, id);
  }

  function trackChange(ts, doc, change) {
    var data = findDoc(ts, doc);

    var argHints = ts.cachedArgHints;
    if (argHints && argHints.doc == doc && cmpPos(argHints.start, change.to) <= 0)
      ts.cachedArgHints = null;

    var changed = data.changed;
    if (changed == null)
      data.changed = changed = {from: change.from.line, to: change.from.line};
    var end = change.from.line + (change.text.length - 1);
    if (change.from.line < changed.to) changed.to = changed.to - (change.to.line - end);
    if (end >= changed.to) changed.to = end + 1;
    if (changed.from > change.from.line) changed.from = change.from.line;

    if (doc.lineCount() > bigDoc && change.to - changed.from > 100) setTimeout(function() {
      if (data.changed && data.changed.to - data.changed.from > 100) sendDoc(ts, data);
    }, 200);
  }

  function sendDoc(ts, doc) {
    ts.server.request({files: [{type: "full", name: doc.name, text: docValue(ts, doc)}]}, function(error) {
      if (error) window.console.error(error);
      else doc.changed = null;
    });
  }

  // Completion

  function hint(ts, cm, c) {
    ts.request(cm, {type: "completions", types: true, docs: true, urls: true, caseInsensitive: ts.options.caseInsensitive}, function(error, data) {
      if (error) return showError(ts, cm, error);
      var completions = [], after = "";
      var from = data.start, to = data.end;
      if (cm.getRange(Pos(from.line, from.ch - 2), from) == "[\"" &&
          cm.getRange(to, Pos(to.line, to.ch + 2)) != "\"]")
        after = "\"]";

      for (var i = 0; i < data.completions.length; ++i) {
        var completion = data.completions[i], className = typeToIcon(completion.type);
        if (data.guess) className += " " + cls + "guess";
        completions.push({text: completion.name + after,
                          displayText: completion.name,
                          className: className,
                          data: completion});
      }

      var obj = {from: from, to: to, list: completions};
      var tooltip = null;
      CodeMirror.on(obj, "close", function() { remove(tooltip); });
      CodeMirror.on(obj, "update", function() { remove(tooltip); });
      CodeMirror.on(obj, "select", function(cur, node) {
        remove(tooltip);
        var content = ts.options.completionTip ? ts.options.completionTip(cur.data) : cur.data.doc;
        if (content) {
          tooltip = makeTooltip(node.parentNode.getBoundingClientRect().right + window.pageXOffset,
                                node.getBoundingClientRect().top + window.pageYOffset, content);
          tooltip.className += " " + cls + "hint-doc";
        }
      });
      c(obj);
    });
  }

  function typeToIcon(type) {
    var suffix;
    if (type == "?") suffix = "unknown";
    else if (type == "number" || type == "string" || type == "bool") suffix = type;
    else if (/^fn\(/.test(type)) suffix = "fn";
    else if (/^\[/.test(type)) suffix = "array";
    else suffix = "object";
    return cls + "completion " + cls + "completion-" + suffix;
  }

  // Type queries

  function showContextInfo(ts, cm, pos, queryName, c) {
    ts.request(cm, queryName, function(error, data) {
      if (error) return showError(ts, cm, error);
      if (ts.options.typeTip) {
        var tip = ts.options.typeTip(data);
      } else {
        var tip = elt("span", null, elt("strong", null, data.type || "not found"));
        if (data.doc)
          tip.appendChild(document.createTextNode("  " + data.doc));
        if (data.url) {
          tip.appendChild(document.createTextNode(" "));
          var child = tip.appendChild(elt("a", null, "[docs]"));
          child.href = data.url;
          child.target = "_blank";
        }
      }
      tempTooltip(cm, tip);
      if (c) c();
    }, pos);
  }

  // Maintaining argument hints

  function updateArgHints(ts, cm) {
    closeArgHints(ts);

    if (cm.somethingSelected()) return;
    var state = cm.getTokenAt(cm.getCursor()).state;
    var inner = CodeMirror.innerMode(cm.getMode(), state);
    if (inner.mode.name != "javascript") return;
    var lex = inner.state.lexical;
    if (lex.info != "call") return;

    var ch, argPos = lex.pos || 0, tabSize = cm.getOption("tabSize");
    for (var line = cm.getCursor().line, e = Math.max(0, line - 9), found = false; line >= e; --line) {
      var str = cm.getLine(line), extra = 0;
      for (var pos = 0;;) {
        var tab = str.indexOf("\t", pos);
        if (tab == -1) break;
        extra += tabSize - (tab + extra) % tabSize - 1;
        pos = tab + 1;
      }
      ch = lex.column - extra;
      if (str.charAt(ch) == "(") {found = true; break;}
    }
    if (!found) return;

    var start = Pos(line, ch);
    var cache = ts.cachedArgHints;
    if (cache && cache.doc == cm.getDoc() && cmpPos(start, cache.start) == 0)
      return showArgHints(ts, cm, argPos);

    ts.request(cm, {type: "type", preferFunction: true, end: start}, function(error, data) {
      if (error || !data.type || !(/^fn\(/).test(data.type)) return;
      ts.cachedArgHints = {
        start: pos,
        type: parseFnType(data.type),
        name: data.exprName || data.name || "fn",
        guess: data.guess,
        doc: cm.getDoc()
      };
      showArgHints(ts, cm, argPos);
    });
  }

  function showArgHints(ts, cm, pos) {
    closeArgHints(ts);

    var cache = ts.cachedArgHints, tp = cache.type;
    var tip = elt("span", cache.guess ? cls + "fhint-guess" : null,
                  elt("span", cls + "fname", cache.name), "(");
    for (var i = 0; i < tp.args.length; ++i) {
      if (i) tip.appendChild(document.createTextNode(", "));
      var arg = tp.args[i];
      tip.appendChild(elt("span", cls + "farg" + (i == pos ? " " + cls + "farg-current" : ""), arg.name || "?"));
      if (arg.type != "?") {
        tip.appendChild(document.createTextNode(":\u00a0"));
        tip.appendChild(elt("span", cls + "type", arg.type));
      }
    }
    tip.appendChild(document.createTextNode(tp.rettype ? ") ->\u00a0" : ")"));
    if (tp.rettype) tip.appendChild(elt("span", cls + "type", tp.rettype));
    var place = cm.cursorCoords(null, "page");
    ts.activeArgHints = makeTooltip(place.right + 1, place.bottom, tip);
  }

  function parseFnType(text) {
    var args = [], pos = 3;

    function skipMatching(upto) {
      var depth = 0, start = pos;
      for (;;) {
        var next = text.charAt(pos);
        if (upto.test(next) && !depth) return text.slice(start, pos);
        if (/[{\[\(]/.test(next)) ++depth;
        else if (/[}\]\)]/.test(next)) --depth;
        ++pos;
      }
    }

    // Parse arguments
    if (text.charAt(pos) != ")") for (;;) {
      var name = text.slice(pos).match(/^([^, \(\[\{]+): /);
      if (name) {
        pos += name[0].length;
        name = name[1];
      }
      args.push({name: name, type: skipMatching(/[\),]/)});
      if (text.charAt(pos) == ")") break;
      pos += 2;
    }

    var rettype = text.slice(pos).match(/^\) -> (.*)$/);

    return {args: args, rettype: rettype && rettype[1]};
  }

  // Moving to the definition of something

  function jumpToDef(ts, cm) {
    function inner(varName) {
      var req = {type: "definition", variable: varName || null};
      var doc = findDoc(ts, cm.getDoc());
      ts.server.request(buildRequest(ts, doc, req), function(error, data) {
        if (error) return showError(ts, cm, error);
        if (!data.file && data.url) { window.open(data.url); return; }

        if (data.file) {
          var localDoc = ts.docs[data.file], found;
          if (localDoc && (found = findContext(localDoc.doc, data))) {
            ts.jumpStack.push({file: doc.name,
                               start: cm.getCursor("from"),
                               end: cm.getCursor("to")});
            moveTo(ts, doc, localDoc, found.start, found.end);
            return;
          }
        }
        showError(ts, cm, "Could not find a definition.");
      });
    }

    if (!atInterestingExpression(cm))
      dialog(cm, "Jump to variable", function(name) { if (name) inner(name); });
    else
      inner();
  }

  function jumpBack(ts, cm) {
    var pos = ts.jumpStack.pop(), doc = pos && ts.docs[pos.file];
    if (!doc) return;
    moveTo(ts, findDoc(ts, cm.getDoc()), doc, pos.start, pos.end);
  }

  function moveTo(ts, curDoc, doc, start, end) {
    doc.doc.setSelection(start, end);
    if (curDoc != doc && ts.options.switchToDoc) {
      closeArgHints(ts);
      ts.options.switchToDoc(doc.name, doc.doc);
    }
  }

  // The {line,ch} representation of positions makes this rather awkward.
  function findContext(doc, data) {
    var before = data.context.slice(0, data.contextOffset).split("\n");
    var startLine = data.start.line - (before.length - 1);
    var start = Pos(startLine, (before.length == 1 ? data.start.ch : doc.getLine(startLine).length) - before[0].length);

    var text = doc.getLine(startLine).slice(start.ch);
    for (var cur = startLine + 1; cur < doc.lineCount() && text.length < data.context.length; ++cur)
      text += "\n" + doc.getLine(cur);
    if (text.slice(0, data.context.length) == data.context) return data;

    var cursor = doc.getSearchCursor(data.context, 0, false);
    var nearest, nearestDist = Infinity;
    while (cursor.findNext()) {
      var from = cursor.from(), dist = Math.abs(from.line - start.line) * 10000;
      if (!dist) dist = Math.abs(from.ch - start.ch);
      if (dist < nearestDist) { nearest = from; nearestDist = dist; }
    }
    if (!nearest) return null;

    if (before.length == 1)
      nearest.ch += before[0].length;
    else
      nearest = Pos(nearest.line + (before.length - 1), before[before.length - 1].length);
    if (data.start.line == data.end.line)
      var end = Pos(nearest.line, nearest.ch + (data.end.ch - data.start.ch));
    else
      var end = Pos(nearest.line + (data.end.line - data.start.line), data.end.ch);
    return {start: nearest, end: end};
  }

  function atInterestingExpression(cm) {
    var pos = cm.getCursor("end"), tok = cm.getTokenAt(pos);
    if (tok.start < pos.ch && (tok.type == "comment" || tok.type == "string")) return false;
    return /[\w)\]]/.test(cm.getLine(pos.line).slice(Math.max(pos.ch - 1, 0), pos.ch + 1));
  }

  // Variable renaming

  function rename(ts, cm) {
    var token = cm.getTokenAt(cm.getCursor());
    if (!/\w/.test(token.string)) return showError(ts, cm, "Not at a variable");
    dialog(cm, "New name for " + token.string, function(newName) {
      ts.request(cm, {type: "rename", newName: newName, fullDocs: true}, function(error, data) {
        if (error) return showError(ts, cm, error);
        applyChanges(ts, data.changes);
      });
    });
  }

  function selectName(ts, cm) {
    var name = findDoc(ts, cm.doc).name;
    ts.request(cm, {type: "refs"}, function(error, data) {
      if (error) return showError(ts, cm, error);
      var ranges = [], cur = 0;
      for (var i = 0; i < data.refs.length; i++) {
        var ref = data.refs[i];
        if (ref.file == name) {
          ranges.push({anchor: ref.start, head: ref.end});
          if (cmpPos(cur, ref.start) >= 0 && cmpPos(cur, ref.end) <= 0)
            cur = ranges.length - 1;
        }
      }
      cm.setSelections(ranges, cur);
    });
  }

  var nextChangeOrig = 0;
  function applyChanges(ts, changes) {
    var perFile = Object.create(null);
    for (var i = 0; i < changes.length; ++i) {
      var ch = changes[i];
      (perFile[ch.file] || (perFile[ch.file] = [])).push(ch);
    }
    for (var file in perFile) {
      var known = ts.docs[file], chs = perFile[file];;
      if (!known) continue;
      chs.sort(function(a, b) { return cmpPos(b.start, a.start); });
      var origin = "*rename" + (++nextChangeOrig);
      for (var i = 0; i < chs.length; ++i) {
        var ch = chs[i];
        known.doc.replaceRange(ch.text, ch.start, ch.end, origin);
      }
    }
  }

  // Generic request-building helper

  function buildRequest(ts, doc, query, pos) {
    var files = [], offsetLines = 0, allowFragments = !query.fullDocs;
    if (!allowFragments) delete query.fullDocs;
    if (typeof query == "string") query = {type: query};
    query.lineCharPositions = true;
    if (query.end == null) {
      query.end = pos || doc.doc.getCursor("end");
      if (doc.doc.somethingSelected())
        query.start = doc.doc.getCursor("start");
    }
    var startPos = query.start || query.end;

    if (doc.changed) {
      if (doc.doc.lineCount() > bigDoc && allowFragments !== false &&
          doc.changed.to - doc.changed.from < 100 &&
          doc.changed.from <= startPos.line && doc.changed.to > query.end.line) {
        files.push(getFragmentAround(doc, startPos, query.end));
        query.file = "#0";
        var offsetLines = files[0].offsetLines;
        if (query.start != null) query.start = Pos(query.start.line - -offsetLines, query.start.ch);
        query.end = Pos(query.end.line - offsetLines, query.end.ch);
      } else {
        files.push({type: "full",
                    name: doc.name,
                    text: docValue(ts, doc)});
        query.file = doc.name;
        doc.changed = null;
      }
    } else {
      query.file = doc.name;
    }
    for (var name in ts.docs) {
      var cur = ts.docs[name];
      if (cur.changed && cur != doc) {
        files.push({type: "full", name: cur.name, text: docValue(ts, cur)});
        cur.changed = null;
      }
    }

    return {query: query, files: files};
  }

  function getFragmentAround(data, start, end) {
    var doc = data.doc;
    var minIndent = null, minLine = null, endLine, tabSize = 4;
    for (var p = start.line - 1, min = Math.max(0, p - 50); p >= min; --p) {
      var line = doc.getLine(p), fn = line.search(/\bfunction\b/);
      if (fn < 0) continue;
      var indent = CodeMirror.countColumn(line, null, tabSize);
      if (minIndent != null && minIndent <= indent) continue;
      minIndent = indent;
      minLine = p;
    }
    if (minLine == null) minLine = min;
    var max = Math.min(doc.lastLine(), end.line + 20);
    if (minIndent == null || minIndent == CodeMirror.countColumn(doc.getLine(start.line), null, tabSize))
      endLine = max;
    else for (endLine = end.line + 1; endLine < max; ++endLine) {
      var indent = CodeMirror.countColumn(doc.getLine(endLine), null, tabSize);
      if (indent <= minIndent) break;
    }
    var from = Pos(minLine, 0);

    return {type: "part",
            name: data.name,
            offsetLines: from.line,
            text: doc.getRange(from, Pos(endLine, 0))};
  }

  // Generic utilities

  var cmpPos = CodeMirror.cmpPos;

  function elt(tagname, cls /*, ... elts*/) {
    var e = document.createElement(tagname);
    if (cls) e.className = cls;
    for (var i = 2; i < arguments.length; ++i) {
      var elt = arguments[i];
      if (typeof elt == "string") elt = document.createTextNode(elt);
      e.appendChild(elt);
    }
    return e;
  }

  function dialog(cm, text, f) {
    if (cm.openDialog)
      cm.openDialog(text + ": <input type=text>", f);
    else
      f(prompt(text, ""));
  }

  // Tooltips

  function tempTooltip(cm, content) {
    if (cm.state.ternTooltip) remove(cm.state.ternTooltip);
    var where = cm.cursorCoords();
    var tip = cm.state.ternTooltip = makeTooltip(where.right + 1, where.bottom, content);
    function maybeClear() {
      old = true;
      if (!mouseOnTip) clear();
    }
    function clear() {
      cm.state.ternTooltip = null;
      if (!tip.parentNode) return;
      cm.off("cursorActivity", clear);
      cm.off('blur', clear);
      cm.off('scroll', clear);
      fadeOut(tip);
    }
    var mouseOnTip = false, old = false;
    CodeMirror.on(tip, "mousemove", function() { mouseOnTip = true; });
    CodeMirror.on(tip, "mouseout", function(e) {
      if (!CodeMirror.contains(tip, e.relatedTarget || e.toElement)) {
        if (old) clear();
        else mouseOnTip = false;
      }
    });
    setTimeout(maybeClear, 1700);
    cm.on("cursorActivity", clear);
    cm.on('blur', clear);
    cm.on('scroll', clear);
  }

  function makeTooltip(x, y, content) {
    var node = elt("div", cls + "tooltip", content);
    node.style.left = x + "px";
    node.style.top = y + "px";
    document.body.appendChild(node);
    return node;
  }

  function remove(node) {
    var p = node && node.parentNode;
    if (p) p.removeChild(node);
  }

  function fadeOut(tooltip) {
    tooltip.style.opacity = "0";
    setTimeout(function() { remove(tooltip); }, 1100);
  }

  function showError(ts, cm, msg) {
    if (ts.options.showError)
      ts.options.showError(cm, msg);
    else
      tempTooltip(cm, String(msg));
  }

  function closeArgHints(ts) {
    if (ts.activeArgHints) { remove(ts.activeArgHints); ts.activeArgHints = null; }
  }

  function docValue(ts, doc) {
    var val = doc.doc.getValue();
    if (ts.options.fileFilter) val = ts.options.fileFilter(val, doc.name, doc.doc);
    return val;
  }

  // Worker wrapper

  function WorkerServer(ts) {
    var worker = ts.worker = new Worker(ts.options.workerScript);
    worker.postMessage({type: "init",
                        defs: ts.options.defs,
                        plugins: ts.options.plugins,
                        scripts: ts.options.workerDeps});
    var msgId = 0, pending = {};

    function send(data, c) {
      if (c) {
        data.id = ++msgId;
        pending[msgId] = c;
      }
      worker.postMessage(data);
    }
    worker.onmessage = function(e) {
      var data = e.data;
      if (data.type == "getFile") {
        getFile(ts, data.name, function(err, text) {
          send({type: "getFile", err: String(err), text: text, id: data.id});
        });
      } else if (data.type == "debug") {
        window.console.log(data.message);
      } else if (data.id && pending[data.id]) {
        pending[data.id](data.err, data.body);
        delete pending[data.id];
      }
    };
    worker.onerror = function(e) {
      for (var id in pending) pending[id](e);
      pending = {};
    };

    this.addFile = function(name, text) { send({type: "add", name: name, text: text}); };
    this.delFile = function(name) { send({type: "del", name: name}); };
    this.request = function(body, c) { send({type: "req", body: body}, c); };
  }
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){


// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

"use strict";

exports.parse = parse;

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

exports.parseExpressionAt = parseExpressionAt;

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenize` export provides an interface to the tokenizer.

exports.tokenizer = tokenizer;
Object.defineProperty(exports, "__esModule", {
  value: true
});
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/marijnh/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

var _state = require("./state");

var Parser = _state.Parser;

var _options = require("./options");

var getOptions = _options.getOptions;

require("./parseutil");

require("./statement");

require("./lval");

require("./expression");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;
exports.defaultOptions = _options.defaultOptions;

var _location = require("./location");

exports.SourceLocation = _location.SourceLocation;
exports.getLineInfo = _location.getLineInfo;
exports.Node = require("./node").Node;

var _tokentype = require("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = require("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = require("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;
exports.Token = require("./tokenize").Token;

var _whitespace = require("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "1.0.1";exports.version = version;

function parse(input, options) {
  var p = parser(options, input);
  var startPos = p.options.locations ? [p.pos, p.curPosition()] : p.pos;
  p.nextToken();
  return p.parseTopLevel(p.options.program || p.startNodeAt(startPos));
}

function parseExpressionAt(input, pos, options) {
  var p = parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}

function tokenizer(input, options) {
  return parser(options, input);
}

function parser(options, input) {
  return new Parser(getOptions(options), String(input));
}

},{"./expression":2,"./identifier":3,"./location":4,"./lval":5,"./node":6,"./options":7,"./parseutil":8,"./state":9,"./statement":10,"./tokencontext":11,"./tokenize":12,"./tokentype":13,"./whitespace":15}],2:[function(require,module,exports){
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

"use strict";

var tt = require("./tokentype").types;

var Parser = require("./state").Parser;

var reservedWords = require("./identifier").reservedWords;

var has = require("./util").has;

var pp = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6) return;
  var key = prop.key,
      name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind || "init",
      other = undefined;
  if (has(propHash, name)) {
    other = propHash[name];
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp.parseExpression = function (noIn, refShorthandDefaultPos) {
  var start = this.markPosition();
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.type === tt.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos) {
  if (this.type == tt._yield && this.inGenerator) return this.parseYield();

  var failOnShorthandAssign = undefined;
  if (!refShorthandDefaultPos) {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  } else {
    failOnShorthandAssign = false;
  }
  var start = this.markPosition();
  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
  if (this.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.value;
    node.left = this.type === tt.eq ? this.toAssignable(left) : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
  var start = this.markPosition();
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(tt.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var start = this.markPosition();
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  return this.parseExprOp(expr, start, -1, noIn);
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp.parseExprOp = function (left, leftStart, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== tt._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStart);
      node.left = left;
      node.operator = this.value;
      var op = this.type;
      this.next();
      var start = this.markPosition();
      node.right = this.parseExprOp(this.parseMaybeUnary(), start, prec, noIn);
      this.finishNode(node, op === tt.logicalOR || op === tt.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStart, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === tt.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary();
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }
  var start = this.markPosition();
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.type.postfix && !this.canInsertSemicolon()) {
    var node = this.startNodeAt(start);
    node.operator = this.value;
    node.prefix = false;
    node.argument = expr;
    this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp.parseExprSubscripts = function (refShorthandDefaultPos) {
  var start = this.markPosition();
  var expr = this.parseExprAtom(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  return this.parseSubscripts(expr, start);
};

pp.parseSubscripts = function (base, start, noCalls) {
  if (this.eat(tt.dot)) {
    var node = this.startNodeAt(start);
    node.object = base;
    node.property = this.parseIdent(true);
    node.computed = false;
    return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
  } else if (this.eat(tt.bracketL)) {
    var node = this.startNodeAt(start);
    node.object = base;
    node.property = this.parseExpression();
    node.computed = true;
    this.expect(tt.bracketR);
    return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
  } else if (!noCalls && this.eat(tt.parenL)) {
    var node = this.startNodeAt(start);
    node.callee = base;
    node.arguments = this.parseExprList(tt.parenR, false);
    return this.parseSubscripts(this.finishNode(node, "CallExpression"), start, noCalls);
  } else if (this.type === tt.backQuote) {
    var node = this.startNodeAt(start);
    node.tag = base;
    node.quasi = this.parseTemplate();
    return this.parseSubscripts(this.finishNode(node, "TaggedTemplateExpression"), start, noCalls);
  }return base;
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp.parseExprAtom = function (refShorthandDefaultPos) {
  var node = undefined;
  switch (this.type) {
    case tt._this:
    case tt._super:
      var type = this.type === tt._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case tt._yield:
      if (this.inGenerator) unexpected();

    case tt.name:
      var start = this.markPosition();
      var id = this.parseIdent(this.type !== tt.name);
      if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(start), [id]);
      }
      return id;

    case tt.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case tt.num:case tt.string:
      return this.parseLiteral(this.value);

    case tt._null:case tt._true:case tt._false:
      node = this.startNode();
      node.value = this.type === tt._null ? null : this.type === tt._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case tt.parenL:
      return this.parseParenAndDistinguishExpression();

    case tt.bracketL:
      node = this.startNode();
      this.next();
      // check whether this is array comprehension or regular array
      if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
        return this.parseComprehension(node, false);
      }
      node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos);
      return this.finishNode(node, "ArrayExpression");

    case tt.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case tt._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case tt._class:
      return this.parseClass(this.startNode(), false);

    case tt._new:
      return this.parseNew();

    case tt.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(tt.parenL);
  var val = this.parseExpression();
  this.expect(tt.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function () {
  var start = this.markPosition(),
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
      return this.parseComprehension(this.startNodeAt(start), true);
    }

    var innerStart = this.markPosition(),
        exprList = [],
        first = true;
    var refShorthandDefaultPos = { start: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== tt.parenR) {
      first ? first = false : this.expect(tt.comma);
      if (this.type === tt.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseRest());
        break;
      } else {
        if (this.type === tt.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
      }
    }
    var innerEnd = this.markPosition();
    this.expect(tt.parenR);

    if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseArrowExpression(this.startNodeAt(start), exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStart);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEnd);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(start);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call  at
// least, not without wrapping it in parentheses. Thus, it uses the

var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.markPosition();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true);
  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === tt.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(tt.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(tt.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp.parseObj = function (isPattern, refShorthandDefaultPos) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this.expect(tt.comma);
      if (this.afterTrailingComma(tt.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refShorthandDefaultPos) start = this.markPosition();
      if (!isPattern) isGenerator = this.eat(tt.star);
    }
    this.parsePropertyName(prop);
    if (this.eat(tt.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault() : this.parseMaybeAssign(false, refShorthandDefaultPos);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
      if (isPattern) this.unexpected();
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != tt.comma && this.type != tt.braceR)) {
      if (isGenerator || isPattern) this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      prop.kind = "init";
      if (isPattern) {
        if (this.isKeyword(prop.key.name) || this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
        prop.value = this.parseMaybeDefault(start, prop.key);
      } else if (this.type === tt.eq && refShorthandDefaultPos) {
        if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
        prop.value = this.parseMaybeDefault(start, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else this.unexpected();

    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(tt.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(tt.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }
  prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
};

// Initialize empty function node.

pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

// Parse object or class method.

pp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  this.expect(tt.parenL);
  node.params = this.parseBindingList(tt.parenR, false, false);
  var allowExpressionBody = undefined;
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
    allowExpressionBody = true;
  } else {
    allowExpressionBody = false;
  }
  this.parseFunctionBody(node, allowExpressionBody);
  return this.finishNode(node, "FunctionExpression");
};

// Parse arrow function expression with given parameters.

pp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

// Parse function body and check parameters.

pp.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && this.type !== tt.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.inFunction,
        oldInGen = this.inGenerator,
        oldLabels = this.labels;
    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
  }

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var nameHash = {},
        oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    for (var i = 0; i < node.params.length; i++) {
      this.checkLVal(node.params[i], true, nameHash);
    }this.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(tt.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    if (allowEmpty && this.type === tt.comma) {
      elts.push(null);
    } else {
      if (this.type === tt.ellipsis) elts.push(this.parseSpread(refShorthandDefaultPos));else elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
    }
  }
  return elts;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === tt.name) {
    if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};

// Parses yield expression inside generator.

pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(tt.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Parses array and generator comprehensions.

pp.parseComprehension = function (node, isGenerator) {
  node.blocks = [];
  while (this.type === tt._for) {
    var block = this.startNode();
    this.next();
    this.expect(tt.parenL);
    block.left = this.parseBindingAtom();
    this.checkLVal(block.left, true);
    this.expectContextual("of");
    block.right = this.parseExpression();
    this.expect(tt.parenR);
    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
  }
  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null;
  node.body = this.parseExpression();
  this.expect(isGenerator ? tt.parenR : tt.bracketR);
  node.generator = isGenerator;
  return this.finishNode(node, "ComprehensionExpression");
};

},{"./identifier":3,"./state":9,"./tokentype":13,"./util":14}],3:[function(require,module,exports){


// Test whether a given character code starts an identifier.

"use strict";

exports.isIdentifierStart = isIdentifierStart;

// Test whether a given character is part of an identifier.

exports.isIdentifierChar = isIdentifierChar;
Object.defineProperty(exports, "__esModule", {
  value: true
});
// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function makePredicate(words) {
  words = words.split(" ");
  var f = "",
      cats = [];
  out: for (var i = 0; i < words.length; ++i) {
    for (var j = 0; j < cats.length; ++j) {
      if (cats[j][0].length == words[i].length) {
        cats[j].push(words[i]);
        continue out;
      }
    }cats.push([words[i]]);
  }
  function compareTo(arr) {
    if (arr.length == 1) {
      return f += "return str === " + JSON.stringify(arr[0]) + ";";
    }f += "switch(str){";
    for (var i = 0; i < arr.length; ++i) {
      f += "case " + JSON.stringify(arr[i]) + ":";
    }f += "return true}return false;";
  }

  // When there are more than three length categories, an outer
  // switch first dispatches on the lengths, to save on comparisons.

  if (cats.length > 3) {
    cats.sort(function (a, b) {
      return b.length - a.length;
    });
    f += "switch(str.length){";
    for (var i = 0; i < cats.length; ++i) {
      var cat = cats[i];
      f += "case " + cat[0].length + ":";
      compareTo(cat);
    }
    f += "}"

    // Otherwise, simply generate a flat `switch` statement.

    ;
  } else {
    compareTo(words);
  }
  return new Function("str", f);
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
  5: makePredicate("class enum extends super const export import"),
  6: makePredicate("enum await"),
  strict: makePredicate("implements interface let package private protected public static yield"),
  strictBind: makePredicate("eval arguments")
};

exports.reservedWords = reservedWords;
// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: makePredicate(ecma5AndLessKeywords),
  6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
};

exports.keywords = keywords;
// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `tools/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierChars = "-------------------------------------------------------------------------------------------------------------------------------------------------";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) {
      return false;
    }pos += set[i + 1];
    if (pos >= code) {
      return true;
    }
  }
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }if (code < 91) {
    return true;
  }if (code < 97) {
    return code === 95;
  }if (code < 123) {
    return true;
  }if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }if (astral === false) {
    return false;
  }return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }if (code < 58) {
    return true;
  }if (code < 65) {
    return false;
  }if (code < 91) {
    return true;
  }if (code < 97) {
    return code === 95;
  }if (code < 123) {
    return true;
  }if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }if (astral === false) {
    return false;
  }return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

},{}],4:[function(require,module,exports){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

exports.getLineInfo = getLineInfo;
Object.defineProperty(exports, "__esModule", {
  value: true
});

var Parser = require("./state").Parser;

var lineBreakG = require("./whitespace").lineBreakG;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = exports.Position = (function () {
  function Position(line, col) {
    _classCallCheck(this, Position);

    this.line = line;
    this.column = col;
  }

  _createClass(Position, {
    offset: {
      value: function offset(n) {
        return new Position(this.line, this.column + n);
      }
    }
  });

  return Position;
})();

var SourceLocation = exports.SourceLocation = function SourceLocation(p, start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

var pp = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.curPosition = function () {
  return new Position(this.curLine, this.pos - this.lineStart);
};

pp.markPosition = function () {
  return this.options.locations ? [this.start, this.startLoc] : this.start;
};

},{"./state":9,"./whitespace":15}],5:[function(require,module,exports){
"use strict";

var tt = require("./tokentype").types;

var Parser = require("./state").Parser;

var reservedWords = require("./identifier").reservedWords;

var has = require("./util").has;

var pp = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};

// Parses spread element.

pp.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();
  return this.finishNode(node, "RestElement");
};

// Parses lvalue (assignable) atom.

pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case tt.name:
      return this.parseIdent();

    case tt.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(tt.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case tt.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(tt.comma);
    if (allowEmpty && this.type === tt.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === tt.ellipsis) {
      elts.push(this.parseRest());
      this.expect(close);
      break;
    } else {
      elts.push(this.parseMaybeDefault());
    }
  }
  return elts;
};

// Parses assignment pattern around given atom if possible.

pp.parseMaybeDefault = function (startPos, left) {
  startPos = startPos || this.markPosition();
  left = left || this.parseBindingAtom();
  if (!this.eat(tt.eq)) return left;
  var node = this.startNodeAt(startPos);
  node.operator = "=";
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval  something that can be assigned
// to.

pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && (reservedWords.strictBind(expr.name) || reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./identifier":3,"./state":9,"./tokentype":13,"./util":14}],6:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Parser = require("./state").Parser;

var SourceLocation = require("./location").SourceLocation;

// Start an AST node, attaching a start offset.

var pp = Parser.prototype;

var Node = exports.Node = function Node() {
  _classCallCheck(this, Node);
};

pp.startNode = function () {
  var node = new Node();
  node.start = this.start;
  if (this.options.locations) node.loc = new SourceLocation(this, this.startLoc);
  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
  if (this.options.ranges) node.range = [this.start, 0];
  return node;
};

pp.startNodeAt = function (pos) {
  var node = new Node(),
      start = pos;
  if (this.options.locations) {
    node.loc = new SourceLocation(this, start[1]);
    start = pos[0];
  }
  node.start = start;
  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
  if (this.options.ranges) node.range = [start, 0];
  return node;
};

// Finish an AST node, adding `type` and `end` properties.

pp.finishNode = function (node, type) {
  node.type = type;
  node.end = this.lastTokEnd;
  if (this.options.locations) node.loc.end = this.lastTokEndLoc;
  if (this.options.ranges) node.range[1] = this.lastTokEnd;
  return node;
};

// Finish node at given position

pp.finishNodeAt = function (node, type, pos) {
  if (this.options.locations) {
    node.loc.end = pos[1];pos = pos[0];
  }
  node.type = type;
  node.end = pos;
  if (this.options.ranges) node.range[1] = pos;
  return node;
};

},{"./location":4,"./state":9}],7:[function(require,module,exports){


// Interpret and default an options object

"use strict";

exports.getOptions = getOptions;
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = require("./util");

var has = _util.has;
var isArray = _util.isArray;

var SourceLocation = require("./location").SourceLocation;

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, or 5, or 6. This influences support for strict
  // mode, the set of reserved words, support for getters and
  // setters and other features.
  ecmaVersion: 5,
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are not enforced. Disable
  // `allowReserved` to enforce them. When this option has the
  // value "never", reserved words and keywords can also not be
  // used as property names.
  allowReserved: true,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokenize() returns. Note that you are not
  // allowed to call the parser from the callbackthat will
  // corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};exports.defaultOptions = defaultOptions;

function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./location":4,"./util":14}],8:[function(require,module,exports){
"use strict";

var tt = require("./tokentype").types;

var Parser = require("./state").Parser;

var lineBreak = require("./whitespace").lineBreak;

var pp = Parser.prototype;

// ## Parser utilities

// Test whether a statement node is the string literal `"use strict"`.

pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.type === tt.name && this.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.value === name && this.eat(tt.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

},{"./state":9,"./tokentype":13,"./whitespace":15}],9:[function(require,module,exports){
"use strict";

exports.Parser = Parser;
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _identifier = require("./identifier");

var reservedWords = _identifier.reservedWords;
var keywords = _identifier.keywords;

var _tokentype = require("./tokentype");

var tt = _tokentype.types;
var lineBreak = _tokentype.lineBreak;

function Parser(options, input, startPos) {
  this.options = options;
  this.loadPlugins(this.options.plugins);
  this.sourceFile = this.options.sourceFile || null;
  this.isKeyword = keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
  this.isReservedWord = reservedWords[this.options.ecmaVersion];
  this.input = input;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = null;

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.strict = this.inModule = this.options.sourceType === "module";

  // Flags to track whether we are in a function, a generator.
  this.inFunction = this.inGenerator = false;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
}

Parser.prototype.extend = function (name, f) {
  this[name] = f(this[name]);
};

// Registered plugins

var plugins = {};

exports.plugins = plugins;
Parser.prototype.loadPlugins = function (plugins) {
  for (var _name in plugins) {
    var plugin = exports.plugins[_name];
    if (!plugin) throw new Error("Plugin '" + _name + "' not found");
    plugin(this, plugins[_name]);
  }
};

},{"./identifier":3,"./tokentype":13}],10:[function(require,module,exports){
"use strict";

var tt = require("./tokentype").types;

var Parser = require("./state").Parser;

var lineBreak = require("./whitespace").lineBreak;

var pp = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== tt.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first && this.isUseStrict(stmt)) this.setStrict(true);
    first = false;
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case tt._break:case tt._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case tt._debugger:
      return this.parseDebuggerStatement(node);
    case tt._do:
      return this.parseDoStatement(node);
    case tt._for:
      return this.parseForStatement(node);
    case tt._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case tt._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case tt._if:
      return this.parseIfStatement(node);
    case tt._return:
      return this.parseReturnStatement(node);
    case tt._switch:
      return this.parseSwitchStatement(node);
    case tt._throw:
      return this.parseThrowStatement(node);
    case tt._try:
      return this.parseTryStatement(node);
    case tt._let:case tt._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var
    case tt._var:
      return this.parseVarStatement(node, starttype);
    case tt._while:
      return this.parseWhileStatement(node);
    case tt._with:
      return this.parseWithStatement(node);
    case tt.braceL:
      return this.parseBlock();
    case tt.semi:
      return this.parseEmptyStatement(node);
    case tt._export:
    case tt._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(tt._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(tt.parenL);
  if (this.type === tt.semi) return this.parseFor(node, null);
  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {
    var _init = this.startNode(),
        varKind = this.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== tt._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(tt.braceL);
  this.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  for (var cur, sawDefault; this.type != tt.braceR;) {
    if (this.type === tt._case || this.type === tt._default) {
      var isCase = this.type === tt._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(tt.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === tt._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(tt.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(tt.parenR);
    clause.guard = null;
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.guardedHandlers = empty;
  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
  this.labels.push({ name: maybeName, kind: kind });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(tt.semi);
  node.test = this.type === tt.semi ? null : this.parseExpression();
  this.expect(tt.semi);
  node.update = this.type === tt.parenR ? null : this.parseExpression();
  this.expect(tt.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp.parseForIn = function (node, init) {
  var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(tt.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, true);
    if (this.eat(tt.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === tt._const && !(this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === tt._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(tt.comma)) break;
  }
  return node;
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);
  if (isStatement || this.type === tt.name) node.id = this.parseIdent();
  this.expect(tt.parenL);
  node.params = this.parseBindingList(tt.parenR, false, false);
  this.parseFunctionBody(node, allowExpressionBody);
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp.parseClass = function (node, isStatement) {
  this.next();
  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
  var classBody = this.startNode();
  classBody.body = [];
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (this.eat(tt.semi)) continue;
    var method = this.startNode();
    var isGenerator = this.eat(tt.star);
    this.parsePropertyName(method);
    if (this.type !== tt.parenL && !method.computed && method.key.type === "Identifier" && method.key.name === "static") {
      if (isGenerator) this.unexpected();
      method["static"] = true;
      isGenerator = this.eat(tt.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }
    method.kind = "method";
    if (!method.computed && !isGenerator) {
      if (method.key.type === "Identifier") {
        if (this.type !== tt.parenL && (method.key.name === "get" || method.key.name === "set")) {
          method.kind = method.key.name;
          this.parsePropertyName(method);
        } else if (!method["static"] && method.key.name === "constructor") {
          method.kind = "constructor";
        }
      } else if (!method["static"] && method.key.type === "Literal" && method.key.value === "constructor") {
        method.kind = "constructor";
      }
    }
    method.value = this.parseMethod(isGenerator);
    classBody.body.push(this.finishNode(method, "MethodDefinition"));
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

// Parses module export declaration.

pp.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.eat(tt.star)) {
    this.expectContextual("from");
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(tt._default)) {
    // export default ...
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  // export var|const|let|function|class ...
  if (this.type.keyword) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
    } else {
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

// Parses a comma-separated list of module exports.

pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  // export { x, y as z } [from '...']
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this.expect(tt.comma);
      if (this.afterTrailingComma(tt.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === tt._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};

// Parses import declaration.

pp.parseImport = function (node) {
  this.next();
  // import '...'
  if (this.type === tt.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
    node.kind = "";
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === tt.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(tt.comma)) return nodes;
  }
  if (this.type === tt.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this.expect(tt.comma);
      if (this.afterTrailingComma(tt.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./state":9,"./tokentype":13,"./whitespace":15}],11:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
  value: true
});
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var Parser = require("./state").Parser;

var tt = require("./tokentype").types;

var lineBreak = require("./whitespace").lineBreak;

var TokContext = exports.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = isExpr;
  this.preserveSpace = preserveSpace;
  this.override = override;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  var parent = undefined;
  if (prevType === tt.colon && (parent = this.curContext()).token == "{") return !parent.isExpr;
  if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof) return true;
  if (prevType == tt.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};

// Token-specific context update code

tt.parenR.updateContext = tt.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

tt.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

tt.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

tt.parenL.updateContext = function (prevType) {
  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

tt.incDec.updateContext = function () {};

tt._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

tt.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

// tokExprAllowed stays unchanged

},{"./state":9,"./tokentype":13,"./whitespace":15}],12:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _identifier = require("./identifier");

var isIdentifierStart = _identifier.isIdentifierStart;
var isIdentifierChar = _identifier.isIdentifierChar;

var _tokentype = require("./tokentype");

var tt = _tokentype.types;
var keywordTypes = _tokentype.keywords;

var Parser = require("./state").Parser;

var SourceLocation = require("./location").SourceLocation;

var _whitespace = require("./whitespace");

var lineBreak = _whitespace.lineBreak;
var lineBreakG = _whitespace.lineBreakG;
var isNewLine = _whitespace.isNewLine;
var nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = exports.Token = function Token(p) {
  _classCallCheck(this, Token);

  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

// ## Tokenizer

var pp = Parser.prototype;

// Move to the next token

pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === tt.eof,
        value: token
      };
    } };
};

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== tt.num && this.type !== tt.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(tt.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 57344) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 56613888;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.options.locations && this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.options.locations && this.curPosition());
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function () {
  while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 32) {
      // ' '
      ++this.pos;
    } else if (ch === 13) {
      ++this.pos;
      var next = this.input.charCodeAt(this.pos);
      if (next === 10) {
        ++this.pos;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
    } else if (ch === 10 || ch === 8232 || ch === 8233) {
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
    } else if (ch > 8 && ch < 14) {
      ++this.pos;
    } else if (ch === 47) {
      // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 42) {
        // '*'
        this.skipBlockComment();
      } else if (next === 47) {
        // '/'
        this.skipLineComment(2);
      } else break;
    } else if (ch === 160) {
      // '\xa0'
      ++this.pos;
    } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
      ++this.pos;
    } else {
      break;
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(tt.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(tt.dot);
  }
};

pp.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(tt.assign, 2);
  return this.finishOp(tt.slash, 1);
};

pp.readToken_mult_modulo = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(tt.assign, 2);
  return this.finishOp(code === 42 ? tt.star : tt.modulo, 1);
};

pp.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);
  if (next === 61) return this.finishOp(tt.assign, 2);
  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(tt.assign, 2);
  return this.finishOp(tt.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(tt.incDec, 2);
  }
  if (next === 61) return this.finishOp(tt.assign, 2);
  return this.finishOp(tt.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);
    return this.finishOp(tt.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) unexpected();
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
  return this.finishOp(tt.relational, size);
};

pp.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(tt.arrow);
  }
  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();

    // Punctuation tokens.
    case 40:
      ++this.pos;return this.finishToken(tt.parenL);
    case 41:
      ++this.pos;return this.finishToken(tt.parenR);
    case 59:
      ++this.pos;return this.finishToken(tt.semi);
    case 44:
      ++this.pos;return this.finishToken(tt.comma);
    case 91:
      ++this.pos;return this.finishToken(tt.bracketL);
    case 93:
      ++this.pos;return this.finishToken(tt.bracketR);
    case 123:
      ++this.pos;return this.finishToken(tt.braceL);
    case 125:
      ++this.pos;return this.finishToken(tt.braceR);
    case 58:
      ++this.pos;return this.finishToken(tt.colon);
    case 63:
      ++this.pos;return this.finishToken(tt.question);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(tt.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      // 1-9
      return this.readNumber(false);

    // Quotes produce strings.
    case 34:case 39:
      // '"', "'"
      return this.readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:case 42:
      // '%*'
      return this.readToken_mult_modulo(code);

    case 124:case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 126:
      // '~'
      return this.finishOp(tt.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

var regexpUnicodeSupport = false;
try {
  new RegExp("", "u");regexpUnicodeSupport = true;
} catch (e) {}

// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.

pp.readRegexp = function () {
  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gmsiy]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      // Replace each astral symbol and every Unicode escape sequence that
      // possibly represents an astral symbol or a paired surrogate with a
      // single ASCII symbol to avoid throwing on regular expressions that
      // are only valid in combination with the `/u` flag.
      // Note: replacing with the ASCII symbol `x` might cause false
      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
      // be replaced by `[x-b]` which throws an error.
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|\\u\{([0-9a-fA-F]+)\}|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  // Detect invalid regular expressions.
  try {
    new RegExp(tmp);
  } catch (e) {
    if (e instanceof SyntaxError) this.raise(start, "Error parsing regular expression: " + e.message);
    this.raise(e);
  }
  // Get a regular expression object for this pattern-flag pair, or `null` in
  // case the current environment doesn't support the flags it uses.
  var value = undefined;
  try {
    value = new RegExp(content, mods);
  } catch (err) {
    value = null;
  }
  return this.finishToken(tt.regexp, { pattern: content, flags: mods, value: value });
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10; // a
    else if (code >= 65) val = code - 65 + 10; // A
    else if (code >= 48 && code <= 57) val = code - 48; // 0-9
    else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(tt.num, val);
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  if (this.input.charCodeAt(this.pos) === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
  }
  var next = this.input.charCodeAt(this.pos);
  if (next === 69 || next === 101) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(tt.num, val);
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) this.unexpected();
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 65535) {
    return String.fromCharCode(code);
  }return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar();
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(tt.string, out);
};

// Reads template string tokens.

pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      // '`', '${'
      if (this.pos === this.start && this.type === tt.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(tt.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(tt.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(tt.template, out);
    }
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar();
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out += "\n";
      } else {
        out += String.fromCharCode(ch);
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Used to read escaped characters

pp.readEscapedChar = function () {
  var ch = this.input.charCodeAt(++this.pos);
  var octal = /^[0-7]+/.exec(this.input.slice(this.pos, this.pos + 3));
  if (octal) octal = octal[0];
  while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
  if (octal === "0") octal = null;
  ++this.pos;
  if (octal) {
    if (this.strict) this.raise(this.pos - 2, "Octal literal in strict mode");
    this.pos += octal.length - 1;
    return String.fromCharCode(parseInt(octal, 8));
  } else {
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2)); // 'x'
      case 117:
        return codePointToString(this.readCodePoint()); // 'u'
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\u000b"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 48:
        return "\u0000"; // 0 -> '\0'
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
      case 10:
        // ' \n'
        if (this.options.locations) {
          this.lineStart = this.pos;++this.curLine;
        }
        return "";
      default:
        return String.fromCharCode(ch);
    }
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function (len) {
  var n = this.readInt(16, len);
  if (n === null) this.raise(this.start, "Bad character escape sequence");
  return n;
};

// Used to signal to callers of `readWord1` whether the word
// contained any escape sequences. This is needed because words with
// escape sequences must not be interpreted as keywords.

var containsEsc;

// Read an identifier, and return it as a string. Sets `containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function () {
  containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function () {
  var word = this.readWord1();
  var type = tt.name;
  if ((this.options.ecmaVersion >= 6 || !containsEsc) && this.isKeyword(word)) type = keywordTypes[word];
  return this.finishToken(type, word);
};

},{"./identifier":3,"./location":4,"./state":9,"./tokentype":13,"./whitespace":15}],13:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
  value: true
});
// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = exports.TokenType = function TokenType(label) {
  var conf = arguments[1] === undefined ? {} : arguments[1];

  _classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10)
};

exports.types = types;
// Map keyword names to token types.

var keywords = {};

exports.keywords = keywords;
// Succinct definitions of keyword token types
function kw(name) {
  var options = arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default");
kw("do", { isLoop: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function");
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("let");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("yield", { beforeExpr: true, startsExpr: true });
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],14:[function(require,module,exports){
"use strict";

exports.isArray = isArray;

// Checks if an object has a property.

exports.has = has;
Object.defineProperty(exports, "__esModule", {
  value: true
});

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],15:[function(require,module,exports){
"use strict";

exports.isNewLine = isNewLine;
Object.defineProperty(exports, "__esModule", {
  value: true
});
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code == 8233;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;

},{}]},{},[1])(1)
});
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

exports.parse_dammit = parse_dammit;
Object.defineProperty(exports, "__esModule", {
  value: true
});
// Acorn: Loose parser
//
// This module provides an alternative parser (`parse_dammit`) that
// exposes that same interface as `parse`, but will try to parse
// anything as JavaScript, repairing syntax error the best it can.
// There are circumstances in which it will raise an error and give
// up, but they are very rare. The resulting AST will be a mostly
// valid JavaScript AST (as per the [Mozilla parser API][api], except
// that:
//
// - Return outside functions is allowed
//
// - Label consistency (no conflicts, break only to existing labels)
//   is not enforced.
//
// - Bogus Identifier nodes with a name of `""` are inserted whenever
//   the parser got too confused to return anything meaningful.
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
//
// The expected use for this is to *first* try `acorn.parse`, and only
// if that fails switch to `parse_dammit`. The loose parser might
// parse badly indented code incorrectly, so **don't** use it as
// your default parser.
//
// Quite a lot of acorn.js is duplicated here. The alternative was to
// add a *lot* of extra cruft to that file, making it less readable
// and slower. Copying and editing the code allowed me to make
// invasive changes and simplifications without creating a complicated
// tangle.

var acorn = _interopRequireWildcard(require(".."));

var _state = require("./state");

var LooseParser = _state.LooseParser;

require("./tokenize");

require("./parseutil");

require("./statement");

require("./expression");

exports.LooseParser = _state.LooseParser;

acorn.defaultOptions.tabSize = 4;

function parse_dammit(input, options) {
  var p = new LooseParser(input, options);
  p.next();
  return p.parseTopLevel();
}

acorn.parse_dammit = parse_dammit;
acorn.LooseParser = LooseParser;

},{"..":2,"./expression":3,"./parseutil":4,"./state":5,"./statement":6,"./tokenize":7}],2:[function(require,module,exports){
"use strict";

module.exports = typeof window != "undefined" ? window.acorn : require(("suppress", "./acorn"));

},{}],3:[function(require,module,exports){
"use strict";

var LooseParser = require("./state").LooseParser;

var isDummy = require("./parseutil").isDummy;

var tt = require("..").tokTypes;

var lp = LooseParser.prototype;

lp.checkLVal = function (expr) {
  if (!expr) return expr;
  switch (expr.type) {
    case "Identifier":
    case "MemberExpression":
    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
    case "AssignmentPattern":
      return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);
  if (this.tok.type === tt.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(tt.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(tt.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);
  if (this.tok.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.left = this.tok.type === tt.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  }
  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(tt.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(noIn), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;
  if (prec != null && (!noIn || this.tok.type !== tt._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();
      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
      }
      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }
  return left;
};

lp.parseMaybeUnary = function (noIn) {
  if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === tt.incDec;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(noIn);
    if (update) node.argument = this.checkLVal(node.argument);
    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === tt.ellipsis) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(noIn);
    return this.finishNode(node, "SpreadElement");
  }
  var start = this.storeCurrentPos();
  var expr = this.parseExprSubscripts();
  while (this.tok.type.postfix && !this.canInsertSemicolon()) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.prefix = false;
    node.argument = this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node, "UpdateExpression");
  }
  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
      if (this.tok.type == tt.dot && this.curIndent == startIndent) --startIndent;else return base;
    }

    if (this.eat(tt.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == tt.bracketL) {
      this.pushCx();
      this.next();
      var node = this.startNodeAt(start);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.popCx();
      this.expect(tt.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.tok.type == tt.parenL) {
      this.pushCx();
      var node = this.startNodeAt(start);
      node.callee = base;
      node.arguments = this.parseExprList(tt.parenR);
      base = this.finishNode(node, "CallExpression");
    } else if (this.tok.type == tt.backQuote) {
      var node = this.startNodeAt(start);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node = undefined;
  switch (this.tok.type) {
    case tt._this:
    case tt._super:
      var type = this.tok.type === tt._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case tt.name:
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      return this.eat(tt.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

    case tt.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = { pattern: val.pattern, flags: val.flags };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case tt.num:case tt.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case tt._null:case tt._true:case tt._false:
      node = this.startNode();
      node.value = this.tok.type === tt._null ? null : this.tok.type === tt._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case tt.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(tt.parenR);
      if (this.eat(tt.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (isDummy(inner) ? [] : [inner]));
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }
      return inner;

    case tt.bracketL:
      node = this.startNode();
      this.pushCx();
      node.elements = this.parseExprList(tt.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case tt.braceL:
      return this.parseObj();

    case tt._class:
      return this.parseClass();

    case tt._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case tt._new:
      return this.parseNew();

    case tt._yield:
      node = this.startNode();
      this.next();
      if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != tt.star && !this.tok.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(tt.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression");

    case tt.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
  if (this.tok.type == tt.parenL) {
    this.pushCx();
    node.arguments = this.parseExprList(tt.parenR);
  } else {
    node.arguments = [];
  }
  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === tt.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());
    if (this.expect(tt.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = { cooked: "", raw: "" };
      curElt.tail = true;
    }
    node.quasis.push(curElt);
  }
  this.expect(tt.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(tt.braceL);
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(tt.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(tt.star);
    }
    this.parsePropertyName(prop);
    if (isDummy(prop.key)) {
      if (isDummy(this.parseMaybeAssign())) this.next();this.eat(tt.comma);continue;
    }
    if (this.eat(tt.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === tt.parenL || this.tok.type === tt.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != tt.comma && this.tok.type != tt.braceR)) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(tt.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }
      prop.shorthand = true;
    }
    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(tt.comma);
  }
  this.popCx();
  if (!this.eat(tt.braceR)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return this.finishNode(node, "ObjectExpression");
};

lp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(tt.bracketL)) {
      prop.computed = true;
      prop.key = this.parseExpression();
      this.expect(tt.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }
  var key = this.tok.type === tt.num || this.tok.type === tt.string ? this.parseExprAtom() : this.parseIdent();
  prop.key = key || this.dummyIdent();
};

lp.parsePropertyAccessor = function () {
  if (this.tok.type === tt.name || this.tok.type.keyword) return this.parseIdent();
};

lp.parseIdent = function () {
  var name = this.tok.type === tt.name ? this.tok.value : this.tok.type.keyword;
  if (!name) return this.dummyIdent();
  var node = this.startNode();
  this.next();
  node.name = name;
  return this.finishNode(node, "Identifier");
};

lp.initFunction = function (node) {
  node.id = null;
  node.params = [];
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

// Convert existing expression atom to assignable pattern
// if possible.

lp.toAssignable = function (node) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "ObjectExpression":
        node.type = "ObjectPattern";
        var props = node.properties;
        for (var i = 0; i < props.length; i++) {
          this.toAssignable(props[i].value);
        }break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements);
        break;

      case "SpreadElement":
        node.type = "RestElement";
        node.argument = this.toAssignable(node.argument);
        break;

      case "AssignmentExpression":
        node.type = "AssignmentPattern";
        break;
    }
  }
  return this.checkLVal(node);
};

lp.toAssignableList = function (exprList) {
  for (var i = 0; i < exprList.length; i++) {
    this.toAssignable(exprList[i]);
  }return exprList;
};

lp.parseFunctionParams = function (params) {
  this.pushCx();
  params = this.parseExprList(tt.parenR);
  return this.toAssignableList(params);
};

lp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  node.params = this.parseFunctionParams();
  node.generator = isGenerator || false;
  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== tt.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "FunctionExpression");
};

lp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params);
  node.expression = this.tok.type !== tt.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "ArrowFunctionExpression");
};

lp.parseExprList = function (close, allowEmpty) {
  var indent = this.curIndent,
      line = this.curLineStart,
      elts = [];
  this.next(); // Opening bracket
  while (!this.closes(close, indent + 1, line)) {
    if (this.eat(tt.comma)) {
      elts.push(allowEmpty ? null : this.dummyIdent());
      continue;
    }
    var elt = this.parseMaybeAssign();
    if (isDummy(elt)) {
      if (this.closes(close, indent, line)) break;
      this.next();
    } else {
      elts.push(elt);
    }
    this.eat(tt.comma);
  }
  this.popCx();
  if (!this.eat(close)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return elts;
};

},{"..":2,"./parseutil":4,"./state":5}],4:[function(require,module,exports){
"use strict";

exports.isDummy = isDummy;
Object.defineProperty(exports, "__esModule", {
  value: true
});

var LooseParser = require("./state").LooseParser;

var _ = require("..");

var Node = _.Node;
var SourceLocation = _.SourceLocation;
var lineBreak = _.lineBreak;
var isNewLine = _.isNewLine;
var tt = _.tokTypes;

var lp = LooseParser.prototype;

lp.startNode = function () {
  var node = new Node();
  node.start = this.tok.start;
  if (this.options.locations) node.loc = new SourceLocation(this.toks, this.tok.loc.start);
  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
  if (this.options.ranges) node.range = [this.tok.start, 0];
  return node;
};

lp.storeCurrentPos = function () {
  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
};

lp.startNodeAt = function (pos) {
  var node = new Node();
  if (this.options.locations) {
    node.start = pos[0];
    node.loc = new SourceLocation(this.toks, pos[1]);
    pos = pos[0];
  } else {
    node.start = pos;
  }
  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
  if (this.options.ranges) node.range = [pos, 0];
  return node;
};

lp.finishNode = function (node, type) {
  node.type = type;
  node.end = this.last.end;
  if (this.options.locations) node.loc.end = this.last.loc.end;
  if (this.options.ranges) node.range[1] = this.last.end;
  return node;
};

lp.dummyIdent = function () {
  var dummy = this.startNode();
  dummy.name = "";
  return this.finishNode(dummy, "Identifier");
};

function isDummy(node) {
  return node.name == "";
}

lp.eat = function (type) {
  if (this.tok.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

lp.isContextual = function (name) {
  return this.tok.type === tt.name && this.tok.value === name;
};

lp.eatContextual = function (name) {
  return this.tok.value === name && this.eat(tt.name);
};

lp.canInsertSemicolon = function () {
  return this.tok.type === tt.eof || this.tok.type === tt.braceR || lineBreak.test(this.input.slice(this.last.end, this.tok.start));
};

lp.semicolon = function () {
  return this.eat(tt.semi);
};

lp.expect = function (type) {
  if (this.eat(type)) return true;
  for (var i = 1; i <= 2; i++) {
    if (this.lookAhead(i).type == type) {
      for (var j = 0; j < i; j++) {
        this.next();
      }return true;
    }
  }
};

lp.pushCx = function () {
  this.context.push(this.curIndent);
};
lp.popCx = function () {
  this.curIndent = this.context.pop();
};

lp.lineEnd = function (pos) {
  while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) ++pos;
  return pos;
};

lp.indentationAfter = function (pos) {
  for (var count = 0;; ++pos) {
    var ch = this.input.charCodeAt(pos);
    if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
  }
};

lp.closes = function (closeTok, indent, line, blockHeuristic) {
  if (this.tok.type === closeTok || this.tok.type === tt.eof) return true;
  return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
};

lp.tokenStartsLine = function () {
  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
    var ch = this.input.charCodeAt(p);
    if (ch !== 9 && ch !== 32) return false;
  }
  return true;
};

},{"..":2,"./state":5}],5:[function(require,module,exports){
"use strict";

exports.LooseParser = LooseParser;
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require("..");

var tokenizer = _.tokenizer;
var SourceLocation = _.SourceLocation;
var tt = _.tokTypes;

function LooseParser(input, options) {
  this.toks = tokenizer(input, options);
  this.options = this.toks.options;
  this.input = this.toks.input;
  this.tok = this.last = { type: tt.eof, start: 0, end: 0 };
  if (this.options.locations) {
    var here = this.toks.curPosition();
    this.tok.loc = new SourceLocation(this.toks, here, here);
  }
  this.ahead = []; // Tokens ahead
  this.context = []; // Indentation contexted
  this.curIndent = 0;
  this.curLineStart = 0;
  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
}

},{"..":2}],6:[function(require,module,exports){
"use strict";

var LooseParser = require("./state").LooseParser;

var isDummy = require("./parseutil").isDummy;

var _ = require("..");

var getLineInfo = _.getLineInfo;
var tt = _.tokTypes;

var lp = LooseParser.prototype;

lp.parseTopLevel = function () {
  var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);
  node.body = [];
  while (this.tok.type !== tt.eof) node.body.push(this.parseStatement());
  this.last = this.tok;
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

lp.parseStatement = function () {
  var starttype = this.tok.type,
      node = this.startNode();

  switch (starttype) {
    case tt._break:case tt._continue:
      this.next();
      var isBreak = starttype === tt._break;
      if (this.semicolon() || this.canInsertSemicolon()) {
        node.label = null;
      } else {
        node.label = this.tok.type === tt.name ? this.parseIdent() : null;
        this.semicolon();
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case tt._debugger:
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");

    case tt._do:
      this.next();
      node.body = this.parseStatement();
      node.test = this.eat(tt._while) ? this.parseParenExpression() : this.dummyIdent();
      this.semicolon();
      return this.finishNode(node, "DoWhileStatement");

    case tt._for:
      this.next();
      this.pushCx();
      this.expect(tt.parenL);
      if (this.tok.type === tt.semi) return this.parseFor(node, null);
      if (this.tok.type === tt._var || this.tok.type === tt._let || this.tok.type === tt._const) {
        var _init = this.parseVar(true);
        if (_init.declarations.length === 1 && (this.tok.type === tt._in || this.isContextual("of"))) {
          return this.parseForIn(node, _init);
        }
        return this.parseFor(node, _init);
      }
      var init = this.parseExpression(true);
      if (this.tok.type === tt._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
      return this.parseFor(node, init);

    case tt._function:
      this.next();
      return this.parseFunction(node, true);

    case tt._if:
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement();
      node.alternate = this.eat(tt._else) ? this.parseStatement() : null;
      return this.finishNode(node, "IfStatement");

    case tt._return:
      this.next();
      if (this.eat(tt.semi) || this.canInsertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");

    case tt._switch:
      var blockIndent = this.curIndent,
          line = this.curLineStart;
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.pushCx();
      this.expect(tt.braceL);

      var cur = undefined;
      while (!this.closes(tt.braceR, blockIndent, line, true)) {
        if (this.tok.type === tt._case || this.tok.type === tt._default) {
          var isCase = this.tok.type === tt._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) cur.test = this.parseExpression();else cur.test = null;
          this.expect(tt.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            cur.test = null;
          }
          cur.consequent.push(this.parseStatement());
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.popCx();
      this.eat(tt.braceR);
      return this.finishNode(node, "SwitchStatement");

    case tt._throw:
      this.next();
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");

    case tt._try:
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.tok.type === tt._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(tt.parenL);
        clause.param = this.toAssignable(this.parseExprAtom());
        this.expect(tt.parenR);
        clause.guard = null;
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return this.finishNode(node, "TryStatement");

    case tt._var:
    case tt._let:
    case tt._const:
      return this.parseVar();

    case tt._while:
      this.next();
      node.test = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WhileStatement");

    case tt._with:
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WithStatement");

    case tt.braceL:
      return this.parseBlock();

    case tt.semi:
      this.next();
      return this.finishNode(node, "EmptyStatement");

    case tt._class:
      return this.parseClass(true);

    case tt._import:
      return this.parseImport();

    case tt._export:
      return this.parseExport();

    default:
      var expr = this.parseExpression();
      if (isDummy(expr)) {
        this.next();
        if (this.tok.type === tt.eof) return this.finishNode(node, "EmptyStatement");
        return this.parseStatement();
      } else if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) {
        node.body = this.parseStatement();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
  }
};

lp.parseBlock = function () {
  var node = this.startNode();
  this.pushCx();
  this.expect(tt.braceL);
  var blockIndent = this.curIndent,
      line = this.curLineStart;
  node.body = [];
  while (!this.closes(tt.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
  this.popCx();
  this.eat(tt.braceR);
  return this.finishNode(node, "BlockStatement");
};

lp.parseFor = function (node, init) {
  node.init = init;
  node.test = node.update = null;
  if (this.eat(tt.semi) && this.tok.type !== tt.semi) node.test = this.parseExpression();
  if (this.eat(tt.semi) && this.tok.type !== tt.parenR) node.update = this.parseExpression();
  this.popCx();
  this.expect(tt.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, "ForStatement");
};

lp.parseForIn = function (node, init) {
  var type = this.tok.type === tt._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.popCx();
  this.expect(tt.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, type);
};

lp.parseVar = function (noIn) {
  var node = this.startNode();
  node.kind = this.tok.type.keyword;
  this.next();
  node.declarations = [];
  do {
    var decl = this.startNode();
    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom()) : this.parseIdent();
    decl.init = this.eat(tt.eq) ? this.parseMaybeAssign(noIn) : null;
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  } while (this.eat(tt.comma));
  if (!node.declarations.length) {
    var decl = this.startNode();
    decl.id = this.dummyIdent();
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  }
  if (!noIn) this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

lp.parseClass = function (isStatement) {
  var node = this.startNode();
  this.next();
  if (this.tok.type === tt.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
  node.superClass = this.eat(tt._extends) ? this.parseExpression() : null;
  node.body = this.startNode();
  node.body.body = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(tt.braceL);
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(tt.braceR, indent, line)) {
    if (this.semicolon()) continue;
    var method = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      method["static"] = false;
      isGenerator = this.eat(tt.star);
    }
    this.parsePropertyName(method);
    if (isDummy(method.key)) {
      if (isDummy(this.parseMaybeAssign())) this.next();this.eat(tt.comma);continue;
    }
    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != tt.parenL && this.tok.type != tt.braceL)) {
      method["static"] = true;
      isGenerator = this.eat(tt.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }
    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== tt.parenL && this.tok.type !== tt.braceL) {
      method.kind = method.key.name;
      this.parsePropertyName(method);
      method.value = this.parseMethod(false);
    } else {
      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
        method.kind = "constructor";
      } else {
        method.kind = "method";
      }
      method.value = this.parseMethod(isGenerator);
    }
    node.body.body.push(this.finishNode(method, "MethodDefinition"));
  }
  this.popCx();
  if (!this.eat(tt.braceR)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  this.semicolon();
  this.finishNode(node.body, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

lp.parseFunction = function (node, isStatement) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = this.eat(tt.star);
  }
  if (this.tok.type === tt.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
  node.params = this.parseFunctionParams();
  node.body = this.parseBlock();
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

lp.parseExport = function () {
  var node = this.startNode();
  this.next();
  if (this.eat(tt.star)) {
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(tt._default)) {
    var expr = this.parseMaybeAssign();
    if (expr.id) {
      switch (expr.type) {
        case "FunctionExpression":
          expr.type = "FunctionDeclaration";break;
        case "ClassExpression":
          expr.type = "ClassDeclaration";break;
      }
    }
    node.declaration = expr;
    this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.tok.type.keyword) {
    node.declaration = this.parseStatement();
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

lp.parseImport = function () {
  var node = this.startNode();
  this.next();
  if (this.tok.type === tt.string) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
    node.kind = "";
  } else {
    var elt = undefined;
    if (this.tok.type === tt.name && this.tok.value !== "from") {
      elt = this.startNode();
      elt.local = this.parseIdent();
      this.finishNode(elt, "ImportDefaultSpecifier");
      this.eat(tt.comma);
    }
    node.specifiers = this.parseImportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    if (elt) node.specifiers.unshift(elt);
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

lp.parseImportSpecifierList = function () {
  var elts = [];
  if (this.tok.type === tt.star) {
    var elt = this.startNode();
    this.next();
    if (this.eatContextual("as")) elt.local = this.parseIdent();
    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
  } else {
    var indent = this.curIndent,
        line = this.curLineStart,
        continuedLine = this.nextLineStart;
    this.pushCx();
    this.eat(tt.braceL);
    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
    while (!this.closes(tt.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
      var elt = this.startNode();
      if (this.eat(tt.star)) {
        if (this.eatContextual("as")) elt.local = this.parseIdent();
        this.finishNode(elt, "ImportNamespaceSpecifier");
      } else {
        if (this.isContextual("from")) break;
        elt.imported = this.parseIdent();
        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
        this.finishNode(elt, "ImportSpecifier");
      }
      elts.push(elt);
      this.eat(tt.comma);
    }
    this.eat(tt.braceR);
    this.popCx();
  }
  return elts;
};

lp.parseExportSpecifierList = function () {
  var elts = [];
  var indent = this.curIndent,
      line = this.curLineStart,
      continuedLine = this.nextLineStart;
  this.pushCx();
  this.eat(tt.braceL);
  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
  while (!this.closes(tt.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
    if (this.isContextual("from")) break;
    var elt = this.startNode();
    elt.local = this.parseIdent();
    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
    this.finishNode(elt, "ExportSpecifier");
    elts.push(elt);
    this.eat(tt.comma);
  }
  this.eat(tt.braceR);
  this.popCx();
  return elts;
};

},{"..":2,"./parseutil":4,"./state":5}],7:[function(require,module,exports){
"use strict";

var _ = require("..");

var tt = _.tokTypes;
var Token = _.Token;
var isNewLine = _.isNewLine;
var SourceLocation = _.SourceLocation;
var getLineInfo = _.getLineInfo;
var lineBreakG = _.lineBreakG;

var LooseParser = require("./state").LooseParser;

var lp = LooseParser.prototype;

function isSpace(ch) {
  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || isNewLine(ch);
}

lp.next = function () {
  this.last = this.tok;
  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

  if (this.tok.start >= this.nextLineStart) {
    while (this.tok.start >= this.nextLineStart) {
      this.curLineStart = this.nextLineStart;
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    }
    this.curIndent = this.indentationAfter(this.curLineStart);
  }
};

lp.readToken = function () {
  for (;;) {
    try {
      this.toks.next();
      if (this.toks.type === tt.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
        this.toks.end++;
        this.toks.type = tt.ellipsis;
      }
      return new Token(this.toks);
    } catch (e) {
      if (!(e instanceof SyntaxError)) throw e;

      // Try to skip some text, based on the error message, and then continue
      var msg = e.message,
          pos = e.raisedAt,
          replace = true;
      if (/unterminated/i.test(msg)) {
        pos = this.lineEnd(e.pos + 1);
        if (/string/.test(msg)) {
          replace = { start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos) };
        } else if (/regular expr/i.test(msg)) {
          var re = this.input.slice(e.pos, pos);
          try {
            re = new RegExp(re);
          } catch (e) {}
          replace = { start: e.pos, end: pos, type: tt.regexp, value: re };
        } else if (/template/.test(msg)) {
          replace = { start: e.pos, end: pos,
            type: tt.template,
            value: this.input.slice(e.pos, pos) };
        } else {
          replace = false;
        }
      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number/i.test(msg)) {
        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
      } else if (/character escape|expected hexadecimal/i.test(msg)) {
        while (pos < this.input.length) {
          var ch = this.input.charCodeAt(pos++);
          if (ch === 34 || ch === 39 || isNewLine(ch)) break;
        }
      } else if (/unexpected character/i.test(msg)) {
        pos++;
        replace = false;
      } else if (/regular expression/i.test(msg)) {
        replace = true;
      } else {
        throw e;
      }
      this.resetTo(pos);
      if (replace === true) replace = { start: pos, end: pos, type: tt.name, value: "" };
      if (replace) {
        if (this.options.locations) replace.loc = new SourceLocation(this.toks, getLineInfo(this.input, replace.start), getLineInfo(this.input, replace.end));
        return replace;
      }
    }
  }
};

lp.resetTo = function (pos) {
  this.toks.pos = pos;
  var ch = this.input.charAt(pos - 1);
  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

  if (this.options.locations) {
    this.toks.curLine = 1;
    this.toks.lineStart = lineBreakG.lastIndex = 0;
    var match = undefined;
    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {
      ++this.toks.curLine;
      this.toks.lineStart = match.index + match[0].length;
    }
  }
};

lp.lookAhead = function (n) {
  while (n > this.ahead.length) this.ahead.push(this.readToken());
  return this.ahead[n - 1];
};

},{"..":2,"./state":5}]},{},[1])(1)
});
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

// AST walker module for Mozilla Parser API compatible trees

// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.

exports.simple = simple;

// An ancestor walk builds up an array of ancestor nodes (including
// the current node) and passes them to the callback as the state parameter.
exports.ancestor = ancestor;

// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
exports.recursive = recursive;

// Find a node with a given start, end, and type (all are optional,
// null can be used as wildcard). Returns a {node, state} object, or
// undefined when it doesn't find a matching node.
exports.findNodeAt = findNodeAt;

// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
exports.findNodeAround = findNodeAround;

// Find the outermost matching node after a given position.
exports.findNodeAfter = findNodeAfter;

// Find the outermost matching node before a given position.
exports.findNodeBefore = findNodeBefore;

// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
exports.make = make;
Object.defineProperty(exports, "__esModule", {
  value: true
});

function simple(node, visitors, base, state) {
  if (!base) base = exports.base;(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}

function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base;
  if (!state) state = [];(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    if (node != st[st.length - 1]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}

function recursive(node, state, funcs, base) {
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state);
}

function makeTest(test) {
  if (typeof test == "string") {
    return function (type) {
      return type == test;
    };
  } else if (!test) {
    return function () {
      return true;
    };
  } else {
    return test;
  }
}

var Found = function Found(node, state) {
  _classCallCheck(this, Found);

  this.node = node;this.state = state;
};

function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
      if (test(type, node) && (start == null || node.start == start) && (end == null || node.end == end)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }throw e;
  }
}

function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) {
        return;
      }base[type](node, st, c);
      if (test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }throw e;
  }
}

function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      if (node.end < pos) {
        return;
      }var type = override || node.type;
      if (node.start >= pos && test(type, node)) throw new Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }throw e;
  }
}

function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  var max = undefined;(function c(node, st, override) {
    if (node.start > pos) {
      return;
    }var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
    base[type](node, st, c);
  })(node, state);
  return max;
}

function make(funcs, base) {
  if (!base) base = exports.base;
  var visitor = {};
  for (var type in base) visitor[type] = base[type];
  for (var type in funcs) visitor[type] = funcs[type];
  return visitor;
}

function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {}

// Node walkers.

var base = {};

exports.base = base;
base.Program = base.BlockStatement = function (node, st, c) {
  for (var i = 0; i < node.body.length; ++i) {
    c(node.body[i], st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) c(node.alternate, st, "Statement");
};
base.LabeledStatement = function (node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0; i < node.cases.length; ++i) {
    var cs = node.cases[i];
    if (cs.test) c(cs.test, st, "Expression");
    for (var j = 0; j < cs.consequent.length; ++j) {
      c(cs.consequent[j], st, "Statement");
    }
  }
};
base.ReturnStatement = base.YieldExpression = function (node, st, c) {
  if (node.argument) c(node.argument, st, "Expression");
};
base.ThrowStatement = base.SpreadElement = base.RestElement = function (node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) c(node.handler.body, st, "ScopeBody");
  if (node.finalizer) c(node.finalizer, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function (node, st, c) {
  if (node.init) c(node.init, st, "ForInit");
  if (node.test) c(node.test, st, "Expression");
  if (node.update) c(node.update, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function (node, st, c) {
  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0; i < node.declarations.length; ++i) {
    var decl = node.declarations[i];
    if (decl.init) c(decl.init, st, "Expression");
  }
};

base.Function = function (node, st, c) {
  return c(node.body, st, "ScopeBody");
};
base.ScopeBody = function (node, st, c) {
  return c(node, st, "Statement");
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = base.ArrayPattern = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Expression");
  }
};
base.ObjectExpression = base.ObjectPattern = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
  for (var i = 0; i < node.expressions.length; ++i) {
    c(node.expressions[i], st, "Expression");
  }
};
base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.AssignmentExpression = base.AssignmentPattern = base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
    c(node.arguments[i], st, "Expression");
  }
};
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) c(node.property, st, "Expression");
};
base.ExportDeclaration = function (node, st, c) {
  return c(node.declaration, st);
};
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0; i < node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }
};
base.ImportSpecifier = base.ImportBatchSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st);
};
base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
  if (node.superClass) c(node.superClass, st, "Expression");
  for (var i = 0; i < node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = base.Property = function (node, st, c) {
  if (node.computed) c(node.key, st, "Expression");
  c(node.value, st, "Expression");
};
base.ComprehensionExpression = function (node, st, c) {
  for (var i = 0; i < node.blocks.length; i++) {
    c(node.blocks[i].right, st, "Expression");
  }c(node.body, st, "Expression");
};

},{}]},{},[1])(1)
});
// Shims to fill in enough of ECMAScript 5 to make Tern run. Does not
// supply standard-compliant methods, in that some functionality is
// left out (such as second argument to Object.create, self args in
// array methods, etc). WILL clash with other ECMA5 polyfills in a
// probably disruptive way.

(function() {
  Object.create = Object.create || (function() {
    if (!({__proto__: null} instanceof Object))
      return function(base) { return {__proto__: base}; };
    function ctor() {}
    var frame = document.body.appendChild(document.createElement("iframe"));
    frame.src = "javascript:";
    var empty = frame.contentWindow.Object.prototype;
    delete empty.hasOwnProperty;
    delete empty.isPrototypeOf;
    delete empty.propertyIsEnumerable;
    delete empty.valueOf;
    delete empty.toString;
    delete empty.toLocaleString;
    delete empty.constructor;
    return function(base) { ctor.prototype = base || empty; return new ctor(); };
  })();

  // Array methods

  var AP = Array.prototype;

  AP.some = AP.some || function(pred) {
    for (var i = 0; i < this.length; ++i) if (pred(this[i], i)) return true;
  };

  AP.forEach = AP.forEach || function(f) {
    for (var i = 0; i < this.length; ++i) f(this[i], i);
  };

  AP.indexOf = AP.indexOf || function(x, start) {
    for (var i = start || 0; i < this.length; ++i) if (this[i] === x) return i;
    return -1;
  };

  AP.lastIndexOf = AP.lastIndexOf || function(x, start) {
    for (var i = start == null ? this.length - 1 : start; i >= 0; ++i) if (this[i] === x) return i;
    return -1;
  };

  AP.map = AP.map || function(f) {
    for (var r = [], i = 0; i < this.length; ++i) r.push(f(this[i], i));
    return r;
  };

  Array.isArray = Array.isArray || function(v) {
    return Object.prototype.toString.call(v) == "[object Array]";
  };

  String.prototype.trim = String.prototype.trim || function() {
    var from = 0, to = this.length;
    while (/\s/.test(this.charAt(from))) ++from;
    while (/\s/.test(this.charAt(to - 1))) --to;
    return this.slice(from, to);
  };

/*! JSON v3.2.4 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */
if (!window.JSON) (function(){var e=void 0,i=!0,k=null,l={}.toString,m,n,p="function"===typeof define&&define.c,q=!p&&"object"==typeof exports&&exports;q||p?"object"==typeof JSON&&JSON?p?q=JSON:(q.stringify=JSON.stringify,q.parse=JSON.parse):p&&(q=this.JSON={}):q=this.JSON||(this.JSON={});var r,t,u,x,z,B,C,D,E,F,G,H,I,J=new Date(-3509827334573292),K,O,P;try{J=-109252==J.getUTCFullYear()&&0===J.getUTCMonth()&&1==J.getUTCDate()&&10==J.getUTCHours()&&37==J.getUTCMinutes()&&6==J.getUTCSeconds()&&708==J.getUTCMilliseconds()}catch(Q){}
function R(b){var c,a,d,j=b=="json";if(j||b=="json-stringify"||b=="json-parse"){if(b=="json-stringify"||j){if(c=typeof q.stringify=="function"&&J){(d=function(){return 1}).toJSON=d;try{c=q.stringify(0)==="0"&&q.stringify(new Number)==="0"&&q.stringify(new String)=='""'&&q.stringify(l)===e&&q.stringify(e)===e&&q.stringify()===e&&q.stringify(d)==="1"&&q.stringify([d])=="[1]"&&q.stringify([e])=="[null]"&&q.stringify(k)=="null"&&q.stringify([e,l,k])=="[null,null,null]"&&q.stringify({A:[d,i,false,k,"\x00\u0008\n\u000c\r\t"]})==
'{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}'&&q.stringify(k,d)==="1"&&q.stringify([1,2],k,1)=="[\n 1,\n 2\n]"&&q.stringify(new Date(-864E13))=='"-271821-04-20T00:00:00.000Z"'&&q.stringify(new Date(864E13))=='"+275760-09-13T00:00:00.000Z"'&&q.stringify(new Date(-621987552E5))=='"-000001-01-01T00:00:00.000Z"'&&q.stringify(new Date(-1))=='"1969-12-31T23:59:59.999Z"'}catch(f){c=false}}if(!j)return c}if(b=="json-parse"||j){if(typeof q.parse=="function")try{if(q.parse("0")===0&&!q.parse(false)){d=
q.parse('{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}');if(a=d.a.length==5&&d.a[0]==1){try{a=!q.parse('"\t"')}catch(o){}if(a)try{a=q.parse("01")!=1}catch(g){}}}}catch(h){a=false}if(!j)return a}return c&&a}}
if(!R("json")){J||(K=Math.floor,O=[0,31,59,90,120,151,181,212,243,273,304,334],P=function(b,c){return O[c]+365*(b-1970)+K((b-1969+(c=+(c>1)))/4)-K((b-1901+c)/100)+K((b-1601+c)/400)});if(!(m={}.hasOwnProperty))m=function(b){var c={},a;if((c.__proto__=k,c.__proto__={toString:1},c).toString!=l)m=function(a){var b=this.__proto__,a=a in(this.__proto__=k,this);this.__proto__=b;return a};else{a=c.constructor;m=function(b){var c=(this.constructor||a).prototype;return b in this&&!(b in c&&this[b]===c[b])}}c=
k;return m.call(this,b)};n=function(b,c){var a=0,d,j,f;(d=function(){this.valueOf=0}).prototype.valueOf=0;j=new d;for(f in j)m.call(j,f)&&a++;d=j=k;if(a)a=a==2?function(a,b){var c={},d=l.call(a)=="[object Function]",f;for(f in a)!(d&&f=="prototype")&&!m.call(c,f)&&(c[f]=1)&&m.call(a,f)&&b(f)}:function(a,b){var c=l.call(a)=="[object Function]",d,f;for(d in a)!(c&&d=="prototype")&&m.call(a,d)&&!(f=d==="constructor")&&b(d);(f||m.call(a,d="constructor"))&&b(d)};else{j=["valueOf","toString","toLocaleString",
"propertyIsEnumerable","isPrototypeOf","hasOwnProperty","constructor"];a=function(a,b){var c=l.call(a)=="[object Function]",d;for(d in a)!(c&&d=="prototype")&&m.call(a,d)&&b(d);for(c=j.length;d=j[--c];m.call(a,d)&&b(d));}}a(b,c)};R("json-stringify")||(r={"\\":"\\\\",'"':'\\"',"\u0008":"\\b","\u000c":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},t=function(b,c){return("000000"+(c||0)).slice(-b)},u=function(b){for(var c='"',a=0,d;d=b.charAt(a);a++)c=c+('\\"\u0008\u000c\n\r\t'.indexOf(d)>-1?r[d]:r[d]=d<" "?
"\\u00"+t(2,d.charCodeAt(0).toString(16)):d);return c+'"'},x=function(b,c,a,d,j,f,o){var g=c[b],h,s,v,w,L,M,N,y,A;if(typeof g=="object"&&g){h=l.call(g);if(h=="[object Date]"&&!m.call(g,"toJSON"))if(g>-1/0&&g<1/0){if(P){v=K(g/864E5);for(h=K(v/365.2425)+1970-1;P(h+1,0)<=v;h++);for(s=K((v-P(h,0))/30.42);P(h,s+1)<=v;s++);v=1+v-P(h,s);w=(g%864E5+864E5)%864E5;L=K(w/36E5)%24;M=K(w/6E4)%60;N=K(w/1E3)%60;w=w%1E3}else{h=g.getUTCFullYear();s=g.getUTCMonth();v=g.getUTCDate();L=g.getUTCHours();M=g.getUTCMinutes();
N=g.getUTCSeconds();w=g.getUTCMilliseconds()}g=(h<=0||h>=1E4?(h<0?"-":"+")+t(6,h<0?-h:h):t(4,h))+"-"+t(2,s+1)+"-"+t(2,v)+"T"+t(2,L)+":"+t(2,M)+":"+t(2,N)+"."+t(3,w)+"Z"}else g=k;else if(typeof g.toJSON=="function"&&(h!="[object Number]"&&h!="[object String]"&&h!="[object Array]"||m.call(g,"toJSON")))g=g.toJSON(b)}a&&(g=a.call(c,b,g));if(g===k)return"null";h=l.call(g);if(h=="[object Boolean]")return""+g;if(h=="[object Number]")return g>-1/0&&g<1/0?""+g:"null";if(h=="[object String]")return u(g);if(typeof g==
"object"){for(b=o.length;b--;)if(o[b]===g)throw TypeError();o.push(g);y=[];c=f;f=f+j;if(h=="[object Array]"){s=0;for(b=g.length;s<b;A||(A=i),s++){h=x(s,g,a,d,j,f,o);y.push(h===e?"null":h)}b=A?j?"[\n"+f+y.join(",\n"+f)+"\n"+c+"]":"["+y.join(",")+"]":"[]"}else{n(d||g,function(b){var c=x(b,g,a,d,j,f,o);c!==e&&y.push(u(b)+":"+(j?" ":"")+c);A||(A=i)});b=A?j?"{\n"+f+y.join(",\n"+f)+"\n"+c+"}":"{"+y.join(",")+"}":"{}"}o.pop();return b}},q.stringify=function(b,c,a){var d,j,f,o,g,h;if(typeof c=="function"||
typeof c=="object"&&c)if(l.call(c)=="[object Function]")j=c;else if(l.call(c)=="[object Array]"){f={};o=0;for(g=c.length;o<g;h=c[o++],(l.call(h)=="[object String]"||l.call(h)=="[object Number]")&&(f[h]=1));}if(a)if(l.call(a)=="[object Number]"){if((a=a-a%1)>0){d="";for(a>10&&(a=10);d.length<a;d=d+" ");}}else l.call(a)=="[object String]"&&(d=a.length<=10?a:a.slice(0,10));return x("",(h={},h[""]=b,h),j,f,d,"",[])});R("json-parse")||(z=String.fromCharCode,B={"\\":"\\",'"':'"',"/":"/",b:"\u0008",t:"\t",
n:"\n",f:"\u000c",r:"\r"},C=function(){H=I=k;throw SyntaxError();},D=function(){for(var b=I,c=b.length,a,d,j,f,o;H<c;){a=b.charAt(H);if("\t\r\n ".indexOf(a)>-1)H++;else{if("{}[]:,".indexOf(a)>-1){H++;return a}if(a=='"'){d="@";for(H++;H<c;){a=b.charAt(H);if(a<" ")C();else if(a=="\\"){a=b.charAt(++H);if('\\"/btnfr'.indexOf(a)>-1){d=d+B[a];H++}else if(a=="u"){j=++H;for(f=H+4;H<f;H++){a=b.charAt(H);a>="0"&&a<="9"||a>="a"&&a<="f"||a>="A"&&a<="F"||C()}d=d+z("0x"+b.slice(j,H))}else C()}else{if(a=='"')break;
d=d+a;H++}}if(b.charAt(H)=='"'){H++;return d}}else{j=H;if(a=="-"){o=i;a=b.charAt(++H)}if(a>="0"&&a<="9"){for(a=="0"&&(a=b.charAt(H+1),a>="0"&&a<="9")&&C();H<c&&(a=b.charAt(H),a>="0"&&a<="9");H++);if(b.charAt(H)=="."){for(f=++H;f<c&&(a=b.charAt(f),a>="0"&&a<="9");f++);f==H&&C();H=f}a=b.charAt(H);if(a=="e"||a=="E"){a=b.charAt(++H);(a=="+"||a=="-")&&H++;for(f=H;f<c&&(a=b.charAt(f),a>="0"&&a<="9");f++);f==H&&C();H=f}return+b.slice(j,H)}o&&C();if(b.slice(H,H+4)=="true"){H=H+4;return i}if(b.slice(H,H+5)==
"false"){H=H+5;return false}if(b.slice(H,H+4)=="null"){H=H+4;return k}}C()}}return"$"},E=function(b){var c,a;b=="$"&&C();if(typeof b=="string"){if(b.charAt(0)=="@")return b.slice(1);if(b=="["){for(c=[];;a||(a=i)){b=D();if(b=="]")break;if(a)if(b==","){b=D();b=="]"&&C()}else C();b==","&&C();c.push(E(b))}return c}if(b=="{"){for(c={};;a||(a=i)){b=D();if(b=="}")break;if(a)if(b==","){b=D();b=="}"&&C()}else C();(b==","||typeof b!="string"||b.charAt(0)!="@"||D()!=":")&&C();c[b.slice(1)]=E(D())}return c}C()}return b},
G=function(b,c,a){a=F(b,c,a);a===e?delete b[c]:b[c]=a},F=function(b,c,a){var d=b[c],j;if(typeof d=="object"&&d)if(l.call(d)=="[object Array]")for(j=d.length;j--;)G(d,j,a);else n(d,function(b){G(d,b,a)});return a.call(b,c,d)},q.parse=function(b,c){var a,d;H=0;I=b;a=E(D());D()!="$"&&C();H=I=k;return c&&l.call(c)=="[object Function]"?F((d={},d[""]=a,d),"",c):a})}p&&define(function(){return q});
}());
})();

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
})(this, function(exports) {
  function on(type, f) {
    var handlers = this._handlers || (this._handlers = Object.create(null));
    (handlers[type] || (handlers[type] = [])).push(f);
  }
  function off(type, f) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i)
      if (arr[i] == f) { arr.splice(i, 1); break; }
  }
  function signal(type, a1, a2, a3, a4) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4);
  }

  exports.mixin = function(obj) {
    obj.on = on; obj.off = off; obj.signal = signal;
    return obj;
  };
});

// The Tern server object

// A server is a stateful object that manages the analysis for a
// project, and defines an interface for querying the code in the
// project.

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("./infer"), require("./signal"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "./infer", "./signal", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
})(this, function(exports, infer, signal, acorn, walk) {
  "use strict";

  var plugins = Object.create(null);
  exports.registerPlugin = function(name, init) { plugins[name] = init; };

  var defaultOptions = exports.defaultOptions = {
    debug: false,
    async: false,
    getFile: function(_f, c) { if (this.async) c(null, null); },
    defs: [],
    plugins: {},
    fetchTimeout: 1000,
    dependencyBudget: 20000,
    reuseInstances: true,
    stripCRs: false
  };

  var queryTypes = {
    completions: {
      takesFile: true,
      run: findCompletions
    },
    properties: {
      run: findProperties
    },
    type: {
      takesFile: true,
      run: findTypeAt
    },
    documentation: {
      takesFile: true,
      run: findDocs
    },
    definition: {
      takesFile: true,
      run: findDef
    },
    refs: {
      takesFile: true,
      fullFile: true,
      run: findRefs
    },
    rename: {
      takesFile: true,
      fullFile: true,
      run: buildRename
    },
    files: {
      run: listFiles
    }
  };

  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

  function File(name, parent) {
    this.name = name;
    this.parent = parent;
    this.scope = this.text = this.ast = this.lineOffsets = null;
  }
  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };

  function updateText(file, text, srv) {
    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
    infer.withContext(srv.cx, function() {
      file.ast = infer.parse(file.text, srv.passes, {directSourceFile: file, allowReturnOutsideFunction: true});
    });
    file.lineOffsets = null;
  }

  var Server = exports.Server = function(options) {
    this.cx = null;
    this.options = options || {};
    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
      options[o] = defaultOptions[o];

    this.handlers = Object.create(null);
    this.files = [];
    this.fileMap = Object.create(null);
    this.needsPurge = [];
    this.budgets = Object.create(null);
    this.uses = 0;
    this.pending = 0;
    this.asyncError = null;
    this.passes = Object.create(null);

    this.defs = options.defs.slice(0);
    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin) && plugin in plugins) {
      var init = plugins[plugin](this, options.plugins[plugin]);
      if (init && init.defs) {
        if (init.loadFirst) this.defs.unshift(init.defs);
        else this.defs.push(init.defs);
      }
      if (init && init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
        (this.passes[type] || (this.passes[type] = [])).push(init.passes[type]);
    }

    this.reset();
  };
  Server.prototype = signal.mixin({
    addFile: function(name, /*optional*/ text, parent) {
      // Don't crash when sloppy plugins pass non-existent parent ids
      if (parent && !(parent in this.fileMap)) parent = null;
      ensureFile(this, name, parent, text);
    },
    delFile: function(name) {
      var file = this.findFile(name);
      if (file) {
        this.needsPurge.push(file.name);
        this.files.splice(this.files.indexOf(file), 1);
        delete this.fileMap[name];
      }
    },
    reset: function() {
      this.signal("reset");
      this.cx = new infer.Context(this.defs, this);
      this.uses = 0;
      this.budgets = Object.create(null);
      for (var i = 0; i < this.files.length; ++i) {
        var file = this.files[i];
        file.scope = null;
      }
    },

    request: function(doc, c) {
      var inv = invalidDoc(doc);
      if (inv) return c(inv);

      var self = this;
      doRequest(this, doc, function(err, data) {
        c(err, data);
        if (self.uses > 40) {
          self.reset();
          analyzeAll(self, null, function(){});
        }
      });
    },

    findFile: function(name) {
      return this.fileMap[name];
    },

    flush: function(c) {
      var cx = this.cx;
      analyzeAll(this, null, function(err) {
        if (err) return c(err);
        infer.withContext(cx, c);
      });
    },

    startAsyncAction: function() {
      ++this.pending;
    },
    finishAsyncAction: function(err) {
      if (err) this.asyncError = err;
      if (--this.pending === 0) this.signal("everythingFetched");
    }
  });

  function doRequest(srv, doc, c) {
    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
      return c("No query type '" + doc.query.type + "' defined");

    var query = doc.query;
    // Respond as soon as possible when this just uploads files
    if (!query) c(null, {});

    var files = doc.files || [];
    if (files.length) ++srv.uses;
    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      if (file.type == "delete")
        srv.delFile(file.name);
      else
        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
    }

    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
    if (!query) {
      analyzeAll(srv, timeBudget, function(){});
      return;
    }

    var queryType = queryTypes[query.type];
    if (queryType.takesFile) {
      if (typeof query.file != "string") return c(".query.file must be a string");
      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
    }

    analyzeAll(srv, timeBudget, function(err) {
      if (err) return c(err);
      var file = queryType.takesFile && resolveFile(srv, files, query.file);
      if (queryType.fullFile && file.type == "part")
        return c("Can't run a " + query.type + " query on a file fragment");

      function run() {
        var result;
        try {
          result = queryType.run(srv, query, file);
        } catch (e) {
          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
          return c(e);
        }
        c(null, result);
      }
      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
    });
  }

  function analyzeFile(srv, file) {
    infer.withContext(srv.cx, function() {
      file.scope = srv.cx.topScope;
      srv.signal("beforeLoad", file);
      infer.analyze(file.ast, file.name, file.scope, srv.passes);
      srv.signal("afterLoad", file);
    });
    return file;
  }

  function ensureFile(srv, name, parent, text) {
    var known = srv.findFile(name);
    if (known) {
      if (text != null) {
        if (known.scope) {
          srv.needsPurge.push(name);
          known.scope = null;
        }
        updateText(known, text, srv);
      }
      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
        known.parent = parent;
        if (known.excluded) known.excluded = null;
      }
      return;
    }

    var file = new File(name, parent);
    srv.files.push(file);
    srv.fileMap[name] = file;
    if (text != null) {
      updateText(file, text, srv);
    } else if (srv.options.async) {
      srv.startAsyncAction();
      srv.options.getFile(name, function(err, text) {
        updateText(file, text || "", srv);
        srv.finishAsyncAction(err);
      });
    } else {
      updateText(file, srv.options.getFile(name) || "", srv);
    }
  }

  function fetchAll(srv, c) {
    var done = true, returned = false;
    srv.files.forEach(function(file) {
      if (file.text != null) return;
      if (srv.options.async) {
        done = false;
        srv.options.getFile(file.name, function(err, text) {
          if (err && !returned) { returned = true; return c(err); }
          updateText(file, text || "", srv);
          fetchAll(srv, c);
        });
      } else {
        try {
          updateText(file, srv.options.getFile(file.name) || "", srv);
        } catch (e) { return c(e); }
      }
    });
    if (done) c();
  }

  function waitOnFetch(srv, timeBudget, c) {
    var done = function() {
      srv.off("everythingFetched", done);
      clearTimeout(timeout);
      analyzeAll(srv, timeBudget, c);
    };
    srv.on("everythingFetched", done);
    var timeout = setTimeout(done, srv.options.fetchTimeout);
  }

  function analyzeAll(srv, timeBudget, c) {
    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

    var e = srv.fetchError;
    if (e) { srv.fetchError = null; return c(e); }

    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
      infer.purge(srv.needsPurge);
      srv.needsPurge.length = 0;
    });

    var done = true;
    // The second inner loop might add new files. The outer loop keeps
    // repeating both inner loops until all files have been looked at.
    for (var i = 0; i < srv.files.length;) {
      var toAnalyze = [];
      for (; i < srv.files.length; ++i) {
        var file = srv.files[i];
        if (file.text == null) done = false;
        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
      }
      toAnalyze.sort(function(a, b) {
        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
      });
      for (var j = 0; j < toAnalyze.length; j++) {
        var file = toAnalyze[j];
        if (file.parent && !chargeOnBudget(srv, file)) {
          file.excluded = true;
        } else if (timeBudget) {
          var startTime = +new Date;
          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
          timeBudget[0] -= +new Date - startTime;
        } else {
          analyzeFile(srv, file);
        }
      }
    }
    if (done) c();
    else waitOnFetch(srv, timeBudget, c);
  }

  function firstLine(str) {
    var end = str.indexOf("\n");
    if (end < 0) return str;
    return str.slice(0, end);
  }

  function findMatchingPosition(line, file, near) {
    var pos = Math.max(0, near - 500), closest = null;
    if (!/^\s*$/.test(line)) for (;;) {
      var found = file.indexOf(line, pos);
      if (found < 0 || found > near + 500) break;
      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
        closest = found;
      pos = found + line.length;
    }
    return closest;
  }

  function scopeDepth(s) {
    for (var i = 0; s; ++i, s = s.prev) {}
    return i;
  }

  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }

  function resolveFile(srv, localFiles, name) {
    var isRef = name.match(/^#(\d+)$/);
    if (!isRef) return srv.findFile(name);

    var file = localFiles[isRef[1]];
    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
    if (file.type == "full") return srv.findFile(file.name);

    // This is a partial file

    var realFile = file.backing = srv.findFile(file.name);
    var offset = file.offset;
    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
    var line = firstLine(file.text);
    var foundPos = findMatchingPosition(line, realFile.text, offset);
    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
    var inObject, atFunction;

    infer.withContext(srv.cx, function() {
      infer.purge(file.name, pos, pos + file.text.length);

      var text = file.text, m;
      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
        if (objNode && objNode.node.objType)
          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
      }
      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
        var cut = m[1].length, white = "";
        for (var i = 0; i < cut; ++i) white += " ";
        text = white + text.slice(cut);
        atFunction = true;
      }

      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
      file.ast = infer.parse(text, srv.passes, {directSourceFile: file, allowReturnOutsideFunction: true});
      infer.analyze(file.ast, file.name, scope, srv.passes);

      // This is a kludge to tie together the function types (if any)
      // outside and inside of the fragment, so that arguments and
      // return values have some information known about them.
      tieTogether: if (inObject || atFunction) {
        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
        if (!newInner.fnType) break tieTogether;
        if (inObject) {
          var prop = inObject.type.getProp(inObject.prop);
          prop.addType(newInner.fnType);
        } else if (atFunction) {
          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
          if (inner == scopeStart || !inner.fnType) break tieTogether;
          var fOld = inner.fnType, fNew = newInner.fnType;
          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
            fOld.args[i].propagate(fNew.args[i]);
          fOld.self.propagate(fNew.self);
          fNew.retval.propagate(fOld.retval);
        }
      }
    });
    return file;
  }

  // Budget management

  function astSize(node) {
    var size = 0;
    walk.simple(node, {Expression: function() { ++size; }});
    return size;
  }

  function parentDepth(srv, parent) {
    var depth = 0;
    while (parent) {
      parent = srv.findFile(parent).parent;
      ++depth;
    }
    return depth;
  }

  function budgetName(srv, file) {
    for (;;) {
      var parent = srv.findFile(file.parent);
      if (!parent.parent) break;
      file = parent;
    }
    return file.name;
  }

  function chargeOnBudget(srv, file) {
    var bName = budgetName(srv, file);
    var size = astSize(file.ast);
    var known = srv.budgets[bName];
    if (known == null)
      known = srv.budgets[bName] = srv.options.dependencyBudget;
    if (known < size) return false;
    srv.budgets[bName] = known - size;
    return true;
  }

  // Query helpers

  function isPosition(val) {
    return typeof val == "number" || typeof val == "object" &&
      typeof val.line == "number" && typeof val.ch == "number";
  }

  // Baseline query document validation
  function invalidDoc(doc) {
    if (doc.query) {
      if (typeof doc.query.type != "string") return ".query.type must be a string";
      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
    }
    if (doc.files) {
      if (!Array.isArray(doc.files)) return "Files property must be an array";
      for (var i = 0; i < doc.files.length; ++i) {
        var file = doc.files[i];
        if (typeof file != "object") return ".files[n] must be objects";
        else if (typeof file.name != "string") return ".files[n].name must be a string";
        else if (file.type == "delete") continue;
        else if (typeof file.text != "string") return ".files[n].text must be a string";
        else if (file.type == "part") {
          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
            return ".files[n].offset must be a position";
        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
      }
    }
  }

  var offsetSkipLines = 25;

  function findLineStart(file, line) {
    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var pos = 0, curLine = 0;
    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

    while (curLine < line) {
      ++curLine;
      pos = text.indexOf("\n", pos) + 1;
      if (pos === 0) return null;
      if (curLine % offsetSkipLines === 0) offsets.push(pos);
    }
    return pos;
  }

  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
    if (typeof pos != "number") {
      var lineStart = findLineStart(file, pos.line);
      if (lineStart == null) {
        if (tolerant) pos = file.text.length;
        else throw ternError("File doesn't contain a line " + pos.line);
      } else {
        pos = lineStart + pos.ch;
      }
    }
    if (pos > file.text.length) {
      if (tolerant) pos = file.text.length;
      else throw ternError("Position " + pos + " is outside of file.");
    }
    return pos;
  };

  function asLineChar(file, pos) {
    if (!file) return {line: 0, ch: 0};
    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var text = file.text, line, lineStart;
    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
      line = i * offsetSkipLines;
      lineStart = offsets[i];
    }
    for (;;) {
      var eol = text.indexOf("\n", lineStart);
      if (eol >= pos || eol < 0) break;
      lineStart = eol + 1;
      ++line;
    }
    return {line: line, ch: pos - lineStart};
  }

  var outputPos = exports.outputPos = function(query, file, pos) {
    if (query.lineCharPositions) {
      var out = asLineChar(file, pos);
      if (file.type == "part")
        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
      return out;
    } else {
      return pos + (file.type == "part" ? file.offset : 0);
    }
  };

  // Delete empty fields from result objects
  function clean(obj) {
    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
    return obj;
  }
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }

  // Built-in query types

  function compareCompletions(a, b) {
    if (typeof a != "string") { a = a.name; b = b.name; }
    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
    else return aUp ? 1 : -1;
  }

  function isStringAround(node, start, end) {
    return node.type == "Literal" && typeof node.value == "string" &&
      node.start == start - 1 && node.end <= end + 1;
  }

  function pointInProp(objNode, point) {
    for (var i = 0; i < objNode.properties.length; i++) {
      var curProp = objNode.properties[i];
      if (curProp.key.start <= point && curProp.key.end >= point)
        return curProp;
    }
  }

  var jsKeywords = ("break do instanceof typeof case else new var " +
    "catch finally return void continue for switch while debugger " +
    "function this with default if throw delete in try").split(" ");

  function findCompletions(srv, query, file) {
    if (query.end == null) throw ternError("missing .query.end field");
    if (srv.passes.completion) for (var i = 0; i < srv.passes.completion.length; i++) {
      var result = srv.passes.completion[i](file, query);
      if (result) return result;
    }

    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
    if (query.expandWordForward !== false)
      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
    if (query.caseInsensitive) word = word.toLowerCase();
    var wrapAsObjs = query.types || query.depths || query.docs || query.urls || query.origins;

    function gather(prop, obj, depth, addInfo) {
      // 'hasOwnProperty' and such are usually just noise, leave them
      // out when no prefix is provided.
      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
      if (ignoreObj && ignoreObj.props[prop]) return;
      for (var i = 0; i < completions.length; ++i) {
        var c = completions[i];
        if ((wrapAsObjs ? c.name : c) == prop) return;
      }
      var rec = wrapAsObjs ? {name: prop} : prop;
      completions.push(rec);

      if (obj && (query.types || query.docs || query.urls || query.origins)) {
        var val = obj.props[prop];
        infer.resetGuessing();
        var type = val.getType();
        rec.guess = infer.didGuess();
        if (query.types)
          rec.type = infer.toString(val);
        if (query.docs)
          maybeSet(rec, "doc", val.doc || type && type.doc);
        if (query.urls)
          maybeSet(rec, "url", val.url || type && type.url);
        if (query.origins)
          maybeSet(rec, "origin", val.origin || type && type.origin);
      }
      if (query.depths) rec.depth = depth;
      if (wrapAsObjs && addInfo) addInfo(rec);
    }

    var hookname, prop, objType, isKey;

    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
    var memberExpr, objLit;
    // Decide whether this is an object property, either in a member
    // expression or an object literal.
    if (exprAt) {
      if (exprAt.node.type == "MemberExpression" && exprAt.node.object.end < wordStart) {
        memberExpr = exprAt;
      } else if (isStringAround(exprAt.node, wordStart, wordEnd)) {
        var parent = infer.parentNode(exprAt.node, file.ast);
        if (parent.type == "MemberExpression" && parent.property == exprAt.node)
          memberExpr = {node: parent, state: exprAt.state};
      } else if (exprAt.node.type == "ObjectExpression") {
        var objProp = pointInProp(exprAt.node, wordEnd);
        if (objProp) {
          objLit = exprAt;
          prop = isKey = objProp.key.name;
        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
          objLit = exprAt;
          prop = isKey = true;
        }
      }
    }

    if (objLit) {
      // Since we can't use the type of the literal itself to complete
      // its properties (it doesn't contain the information we need),
      // we have to try asking the surrounding expression for type info.
      objType = infer.typeFromContext(file.ast, objLit);
      ignoreObj = objLit.node.objType;
    } else if (memberExpr) {
      prop = memberExpr.node.property;
      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
      memberExpr.node = memberExpr.node.object;
      objType = infer.expressionType(memberExpr);
    } else if (text.charAt(wordStart - 1) == ".") {
      var pathStart = wordStart - 1;
      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
      var path = text.slice(pathStart, wordStart - 1);
      if (path) {
        objType = infer.def.parsePath(path, file.scope).getObjType();
        prop = word;
      }
    }

    if (prop != null) {
      srv.cx.completingProperty = prop;

      if (objType) infer.forAllPropertiesOf(objType, gather);

      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
        objType.guessProperties(function(p, o, d) {if (p != prop && p != "") gather(p, o, d);});
      if (!completions.length && word.length >= 2 && query.guess !== false)
        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
      hookname = "memberCompletion";
    } else {
      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
      });
      hookname = "variableCompletion";
    }
    if (srv.passes[hookname])
      srv.passes[hookname].forEach(function(hook) {hook(file, wordStart, wordEnd, gather);});

    if (query.sort !== false) completions.sort(compareCompletions);
    srv.cx.completingProperty = null;

    return {start: outputPos(query, file, wordStart),
            end: outputPos(query, file, wordEnd),
            isProperty: !!prop,
            isObjectKey: !!isKey,
            completions: completions};
  }

  function findProperties(srv, query) {
    var prefix = query.prefix, found = [];
    for (var prop in srv.cx.props)
      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
    if (query.sort !== false) found.sort(compareCompletions);
    return {completions: found};
  }

  var findExpr = exports.findQueryExpr = function(file, query, wide) {
    if (query.end == null) throw ternError("missing .query.end field");

    if (query.variable) {
      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
              state: scope};
    } else {
      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
      if (expr) return expr;
      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (expr && (expr.node.type == "ObjectExpression" || wide ||
                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
        return expr;
      return null;
    }
  };

  function findExprOrThrow(file, query, wide) {
    var expr = findExpr(file, query, wide);
    if (expr) return expr;
    throw ternError("No expression at the given position.");
  }

  function ensureObj(tp) {
    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
    return tp;
  }

  function findExprType(srv, query, file, expr) {
    var type;
    if (expr) {
      infer.resetGuessing();
      type = infer.expressionType(expr);
    }
    if (srv.passes["typeAt"]) {
      var pos = resolvePos(file, query.end);
      srv.passes["typeAt"].forEach(function(hook) {
        type = hook(file, pos, expr, type);
      });
    }
    if (!type) throw ternError("No type found at the given position.");

    var objProp;
    if (expr.node.type == "ObjectExpression" && query.end != null &&
        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
      var name = objProp.key.name;
      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
      if (fromCx && fromCx.hasProp(name)) {
        type = fromCx.hasProp(name);
      } else {
        var fromLocal = ensureObj(type);
        if (fromLocal && fromLocal.hasProp(name))
          type = fromLocal.hasProp(name);
      }
    }
    return type;
  };

  function findTypeAt(srv, query, file) {
    var expr = findExpr(file, query), exprName;
    var type = findExprType(srv, query, file, expr), exprType = type;
    if (query.preferFunction)
      type = type.getFunctionType() || type.getType();
    else
      type = type.getType();

    if (expr) {
      if (expr.node.type == "Identifier")
        exprName = expr.node.name;
      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
        exprName = expr.node.property.name;
    }

    if (query.depth != null && typeof query.depth != "number")
      throw ternError(".query.depth must be a number");

    var result = {guess: infer.didGuess(),
                  type: infer.toString(exprType, query.depth),
                  name: type && type.name,
                  exprName: exprName};
    if (type) storeTypeDocs(type, result);
    if (!result.doc && exprType.doc) result.doc = exprType.doc;

    return clean(result);
  }

  function findDocs(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    var result = {url: type.url, doc: type.doc, type: infer.toString(type)};
    var inner = type.getType();
    if (inner) storeTypeDocs(inner, result);
    return clean(result);
  }

  function storeTypeDocs(type, out) {
    if (!out.url) out.url = type.url;
    if (!out.doc) out.doc = type.doc;
    if (!out.origin) out.origin = type.origin;
    var ctor, boring = infer.cx().protos;
    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
      out.url = ctor.url;
      out.doc = ctor.doc;
    }
  }

  var getSpan = exports.getSpan = function(obj) {
    if (!obj.origin) return;
    if (obj.originNode) {
      var node = obj.originNode;
      if (/^Function/.test(node.type) && node.id) node = node.id;
      return {origin: obj.origin, node: node};
    }
    if (obj.span) return {origin: obj.origin, span: obj.span};
  };

  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
    target.origin = span.origin;
    if (span.span) {
      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
    } else {
      var file = srv.findFile(span.origin);
      target.start = outputPos(query, file, span.node.start);
      target.end = outputPos(query, file, span.node.end);
    }
  };

  function findDef(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    if (infer.didGuess()) return {};

    var span = getSpan(type);
    var result = {url: type.url, doc: type.doc, origin: type.origin};

    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
      var tp = type.types[i];
      storeTypeDocs(tp, result);
      if (!span) span = getSpan(tp);
    }

    if (span && span.node) { // refers to a loaded file
      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
      result.start = start; result.end = end;
      result.file = span.origin;
      var cxStart = Math.max(0, span.node.start - 50);
      result.contextOffset = span.node.start - cxStart;
      result.context = spanFile.text.slice(cxStart, cxStart + 50);
    } else if (span) { // external
      result.file = span.origin;
      storeSpan(srv, query, span, result);
    }
    return clean(result);
  }

  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
    var name = expr.node.name;

    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
    if (!scope) throw ternError("Could not find a definition for " + name + " " + !!srv.cx.topScope.props.x);

    var type, refs = [];
    function storeRef(file) {
      return function(node, scopeHere) {
        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
          var exists = s.hasProp(checkShadowing);
          if (exists)
            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
                            (asLineChar(file, exists.name.start).line + 1));
        }
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }

    if (scope.originNode) {
      type = "local";
      if (checkShadowing) {
        for (var prev = scope.prev; prev; prev = prev.prev)
          if (checkShadowing in prev.props) break;
        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
                          (asLineChar(file, node.start).line + 1));
        });
      }
      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
    } else {
      type = "global";
      for (var i = 0; i < srv.files.length; ++i) {
        var cur = srv.files[i];
        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
      }
    }

    return {refs: refs, type: type, name: name};
  }

  function findRefsToProperty(srv, query, expr, prop) {
    var objType = infer.expressionType(expr).getObjType();
    if (!objType) throw ternError("Couldn't determine type of base object.");

    var refs = [];
    function storeRef(file) {
      return function(node) {
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }
    for (var i = 0; i < srv.files.length; ++i) {
      var cur = srv.files[i];
      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
    }

    return {refs: refs, name: prop.name};
  }

  function findRefs(srv, query, file) {
    var expr = findExprOrThrow(file, query, true);
    if (expr && expr.node.type == "Identifier") {
      return findRefsToVariable(srv, query, file, expr);
    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
      var p = expr.node.property;
      expr.node = expr.node.object;
      return findRefsToProperty(srv, query, expr, p);
    } else if (expr && expr.node.type == "ObjectExpression") {
      var pos = resolvePos(file, query.end);
      for (var i = 0; i < expr.node.properties.length; ++i) {
        var k = expr.node.properties[i].key;
        if (k.start <= pos && k.end >= pos)
          return findRefsToProperty(srv, query, expr, k);
      }
    }
    throw ternError("Not at a variable or property name.");
  }

  function buildRename(srv, query, file) {
    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
    var expr = findExprOrThrow(file, query);
    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
    delete data.refs;
    data.files = srv.files.map(function(f){return f.name;});

    var changes = data.changes = [];
    for (var i = 0; i < refs.length; ++i) {
      var use = refs[i];
      use.text = query.newName;
      changes.push(use);
    }

    return data;
  }

  function listFiles(srv) {
    return {files: srv.files.map(function(f){return f.name;})};
  }

  exports.version = "0.11.1";
});

// Type description parser
//
// Type description JSON files (such as ecma5.json and browser.json)
// are used to
//
// A) describe types that come from native code
//
// B) to cheaply load the types for big libraries, or libraries that
//    can't be inferred well

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return exports.init = mod;
  if (typeof define == "function" && define.amd) // AMD
    return define({init: mod});
  tern.def = {init: mod};
})(function(exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(args, retType) {
    return function(self, cArgs) {
      var realArgs = [];
      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs));
    };
  }
  function computedUnion(types) {
    return function(self, args) {
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
      return union;
    };
  }
  function computedArray(inner) {
    return function(self, args) {
      return new infer.Arr(inner(self, args));
    };
  }

  TypeParser.prototype = {
    eat: function(str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function(re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function() {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function(comp, name, top) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -> ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call) {
          if (top) {
            computeRet = retType;
            retType = infer.ANull;
            computeRetStart = retStart;
          } else {
            computed = true;
          }
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(args, retType);

      if (top && (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function(comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (;;) {
        var next = this.parseTypeMaybeProp(comp, name, top);
        types.push(next);
        if (next.call) computed = true;
        if (!this.eat("|")) break;
      }
      if (computed) return computedUnion(types);
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) types[i].propagate(union);
      return union;
    },
    parseTypeMaybeProp: function(comp, name, top) {
      var result = this.parseTypeInner(comp, name, top);
      while (comp && this.eat(".")) result = this.extendWithProp(result);
      return result;
    },
    extendWithProp: function(base) {
      var propName = this.word(/[\w<>$!]/) || this.error();
      if (base.apply) return function(self, args) {
        return extractProp(base(self, args), propName);
      };
      return extractProp(base, propName);
    },
    parseTypeInner: function(comp, name, top) {
      if (this.eat("fn(")) {
        return this.parseFnType(comp, name, top);
      } else if (this.eat("[")) {
        var inner = this.parseType(comp);
        this.eat("]") || this.error();
        if (inner.call) return computedArray(inner);
        if (top && this.base) {
          infer.Arr.call(this.base, inner);
          return this.base;
        }
        return new infer.Arr(inner);
      } else if (this.eat("+")) {
        var path = this.word(/[\w$<>\.!]/);
        var base = parsePath(path + ".prototype");
        var type;
        if (!(base instanceof infer.Obj)) base = parsePath(path);
        if (!(base instanceof infer.Obj)) return base;
        if (comp && this.eat("[")) return this.parsePoly(base);
        if (top && this.forceNew) return new infer.Obj(base);
        return infer.getInstance(base);
      } else if (comp && this.eat("!")) {
        var arg = this.word(/\d/);
        if (arg) {
          arg = Number(arg);
          return function(_self, args) {return args[arg] || infer.ANull;};
        } else if (this.eat("this")) {
          return function(self) {return self;};
        } else if (this.eat("custom:")) {
          var fname = this.word(/[\w$]/);
          return customFunctions[fname] || function() { return infer.ANull; };
        } else {
          return this.fromWord("!" + this.word(/[\w$<>\.!]/));
        }
      } else if (this.eat("?")) {
        return infer.ANull;
      } else {
        return this.fromWord(this.word(/[\w$<>\.!`]/));
      }
    },
    fromWord: function(spec) {
      var cx = infer.cx();
      switch (spec) {
      case "number": return cx.num;
      case "string": return cx.str;
      case "bool": return cx.bool;
      case "<top>": return cx.topScope;
      }
      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
      return parsePath(spec);
    },
    parsePoly: function(base) {
      var propName = "<i>", match;
      if (match = this.spec.slice(this.pos).match(/^\s*(\w+)\s*=\s*/)) {
        propName = match[1];
        this.pos += match[0].length;
      }
      var value = this.parseType(true);
      if (!this.eat("]")) this.error();
      if (value.call) return function(self, args) {
        var instance = infer.getInstance(base);
        value(self, args).propagate(instance.defProp(propName));
        return instance;
      };
      var instance = infer.getInstance(base);
      value.propagate(instance.defProp(propName));
      return instance;
    }
  };

  function parseType(spec, name, base, forceNew) {
    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
      var arg = type.args[i];
      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
        var fArg = fArgs[i];
        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
      });
    })(i);
    return type;
  }

  function addEffect(fn, handler, replaceRet) {
    var oldCmp = fn.computeRet, rv = fn.retval;
    fn.computeRet = function(self, args, argNodes) {
      var handled = handler(self, args, argNodes);
      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
      return replaceRet ? handled : old;
    };
  }

  var parseEffect = exports.parseEffect = function(effect, fn) {
    var m;
    if (effect.indexOf("propagate ") == 0) {
      var p = new TypeParser(effect, 10);
      var origin = p.parseType(true);
      if (!p.eat(" ")) p.error();
      var target = p.parseType(true);
      addEffect(fn, function(self, args) {
        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
      });
    } else if (effect.indexOf("call ") == 0) {
      var andRet = effect.indexOf("and return ", 5) == 5;
      var p = new TypeParser(effect, andRet ? 16 : 5);
      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
      if (p.eat(" this=")) getSelf = p.parseType(true);
      while (p.eat(" ")) getArgs.push(p.parseType(true));
      addEffect(fn, function(self, args) {
        var callee = unwrapType(getCallee, self, args);
        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
        var result = andRet ? new infer.AVal : infer.ANull;
        callee.propagate(new infer.IsCallee(slf, as, null, result));
        return result;
      }, andRet);
    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
      var customFunc = customFunctions[m[1]];
      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
    } else if (effect.indexOf("copy ") == 0) {
      var p = new TypeParser(effect, 5);
      var getFrom = p.parseType(true);
      p.eat(" ");
      var getTo = p.parseType(true);
      addEffect(fn, function(self, args) {
        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
        from.forAllProps(function(prop, val, local) {
          if (local && prop != "<i>")
            to.propagate(new infer.PropHasSubset(prop, val));
        });
      });
    } else {
      throw new Error("Unknown effect type: " + effect);
    }
  };

  var currentTopScope;

  var parsePath = exports.parsePath = function(path, scope) {
    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
    if (cached != null) return cached;
    cx.paths[path] = infer.ANull;

    var base = scope || currentTopScope || cx.topScope;

    if (cx.localDefs) for (var name in cx.localDefs) {
      if (path.indexOf(name) == 0) {
        if (path == name) return cx.paths[path] = cx.localDefs[path];
        if (path.charAt(name.length) == ".") {
          base = cx.localDefs[name];
          path = path.slice(name.length + 1);
          break;
        }
      }
    }

    var parts = path.split(".");
    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
      var prop = parts[i];
      if (prop.charAt(0) == "!") {
        if (prop == "!proto") {
          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
        } else {
          var fn = base.getFunctionType();
          if (!fn) {
            base = infer.ANull;
          } else if (prop == "!ret") {
            base = fn.retval && fn.retval.getType(false) || infer.ANull;
          } else {
            var arg = fn.args && fn.args[Number(prop.slice(1))];
            base = (arg && arg.getType(false)) || infer.ANull;
          }
        }
      } else if (base instanceof infer.Obj) {
        var propVal = (prop == "prototype" && base instanceof infer.Fn) ? base.getProp(prop) : base.props[prop];
        if (!propVal || propVal.isEmpty())
          base = infer.ANull;
        else
          base = propVal.types[0];
      }
    }
    // Uncomment this to get feedback on your poorly written .json files
    // if (base == infer.ANull) console.error("bad path: " + origPath + " (" + cx.curOrigin + ")");
    cx.paths[origPath] = base == infer.ANull ? null : base;
    return base;
  };

  function emptyObj(ctor) {
    var empty = Object.create(ctor.prototype);
    empty.props = Object.create(null);
    empty.isShell = true;
    return empty;
  }

  function isSimpleAnnotation(spec) {
    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
    for (var prop in spec)
      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
        return false;
    return true;
  }

  function passOne(base, spec, path) {
    if (!base) {
      var tp = spec["!type"];
      if (tp) {
        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
        else throw new Error("Invalid !type spec: " + tp);
      } else if (spec["!stdProto"]) {
        base = infer.cx().protos[spec["!stdProto"]];
      } else {
        base = emptyObj(infer.Obj);
      }
      base.name = path;
    }

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name];
      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
      var prop = base.defProp(name);
      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
    }
    return base;
  }

  function passTwo(base, spec, path) {
    if (base.isShell) {
      delete base.isShell;
      var tp = spec["!type"];
      if (tp) {
        parseType(tp, path, base);
      } else {
        var proto = spec["!proto"] && parseType(spec["!proto"]);
        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
      }
    }

    var effects = spec["!effects"];
    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
      parseEffect(effects[i], base);
    copyInfo(spec, base);

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
      if (typeof inner == "string") {
        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
      } else {
        if (!isSimpleAnnotation(inner))
          passTwo(known.getObjType(), inner, innerPath);
        else if (known.isEmpty())
          parseType(inner["!type"], innerPath, null, true).propagate(known);
        else
          continue;
        if (inner["!doc"]) known.doc = inner["!doc"];
        if (inner["!url"]) known.url = inner["!url"];
        if (inner["!span"]) known.span = inner["!span"];
      }
    }
    return base;
  }

  function copyInfo(spec, type) {
    if (spec["!doc"]) type.doc = spec["!doc"];
    if (spec["!url"]) type.url = spec["!url"];
    if (spec["!span"]) type.span = spec["!span"];
    if (spec["!data"]) type.metaData = spec["!data"];
  }

  function runPasses(type, arg) {
    var parent = infer.cx().parent, pass = parent && parent.passes && parent.passes[type];
    if (pass) for (var i = 0; i < pass.length; i++) pass[i](arg);
  }

  function doLoadEnvironment(data, scope) {
    var cx = infer.cx();

    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

    runPasses("preLoadDef", data);

    passOne(scope, data);

    var def = data["!define"];
    if (def) {
      for (var name in def) {
        var spec = def[name];
        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
      }
      for (var name in def) {
        var spec = def[name];
        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
      }
    }

    passTwo(scope, data);

    runPasses("postLoadDef", data);

    cx.curOrigin = cx.localDefs = null;
  }

  exports.load = function(data, scope) {
    if (!scope) scope = infer.cx().topScope;
    var oldScope = currentTopScope;
    currentTopScope = scope;
    try {
      doLoadEnvironment(data, scope);
    } finally {
      currentTopScope = oldScope;
    }
  };

  exports.parse = function(data, origin, path) {
    var cx = infer.cx();
    if (origin) {
      cx.origin = origin;
      cx.localDefs = cx.definitions[origin];
    }

    try {
      if (typeof data == "string")
        return parseType(data, path);
      else
        return passTwo(passOne(null, data, path), data, path);
    } finally {
      if (origin) cx.origin = cx.localDefs = null;
    }
  };

  // Used to register custom logic for more involved effect or type
  // computation.
  var customFunctions = Object.create(null);
  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

  var IsCreated = infer.constraint("created, target, spec", {
    addType: function(tp) {
      if (tp instanceof infer.Obj && this.created++ < 5) {
        var derived = new infer.Obj(tp), spec = this.spec;
        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
        if (spec instanceof infer.Obj) for (var prop in spec.props) {
          var cur = spec.props[prop].types[0];
          var p = derived.defProp(prop);
          if (cur && cur instanceof infer.Obj && cur.props.value) {
            var vtp = cur.props.value.getType(false);
            if (vtp) p.addType(vtp);
          }
        }
        this.target.addType(derived);
      }
    }
  });

  infer.registerFunction("Object_create", function(_self, args, argNodes) {
    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
      return new infer.Obj();

    var result = new infer.AVal;
    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
    return result;
  });

  var PropSpec = infer.constraint("target", {
    addType: function(tp) {
      if (!(tp instanceof infer.Obj)) return;
      if (tp.hasProp("value"))
        tp.getProp("value").propagate(this.target);
      else if (tp.hasProp("get"))
        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
    }
  });

  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
        typeof argNodes[1].value == "string") {
      var obj = args[0], connect = new infer.AVal;
      obj.propagate(new infer.PropHasSubset(argNodes[1].value, connect, argNodes[1]));
      args[2].propagate(new PropSpec(connect));
    }
    return infer.ANull;
  });

  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
    if (args.length >= 2) {
      var obj = args[0];
      args[1].forAllProps(function(prop, val, local) {
        if (!local) return;
        var connect = new infer.AVal;
        obj.propagate(new infer.PropHasSubset(prop, connect, argNodes && argNodes[1]));
        val.propagate(new PropSpec(connect));
      });
    }
    return infer.ANull;
  });

  var IsBound = infer.constraint("self, args, target", {
    addType: function(tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
                                       tp.argNames.slice(this.args.length), tp.retval));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("Function_bind", function(self, args) {
    if (!args.length) return infer.ANull;
    var result = new infer.AVal;
    self.propagate(new IsBound(args[0], args.slice(1), result));
    return result;
  });

  infer.registerFunction("Array_ctor", function(_self, args) {
    var arr = new infer.Arr;
    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
      var content = arr.getProp("<i>");
      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
    }
    return arr;
  });

  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
    if (args.length < 1) return infer.ANull;
    var self = new infer.Obj(infer.cx().definitions.ecma6["Promise.prototype"]);
    var valProp = self.defProp("value", argNodes && argNodes[0]);
    var valArg = new infer.AVal;
    valArg.propagate(valProp);
    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
    var reject = infer.cx().definitions.ecma6.promiseReject;
    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
    return self;
  });

  return exports;
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod(tern.comment || (tern.comment = {}));
})(function(exports) {
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;
  }

  function onOwnLine(text, pos) {
    for (; pos > 0; --pos) {
      var ch = text.charCodeAt(pos - 1);
      if (ch == 10) break;
      if (!isSpace(ch)) return false;
    }
    return true;
  }

  // Gather comments directly before a function
  exports.commentsBefore = function(text, pos) {
    var found = null, emptyLines = 0, topIsLineComment;
    out: while (pos > 0) {
      var prev = text.charCodeAt(pos - 1);
      if (prev == 10) {
        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {
          prev = text.charCodeAt(scan - 1);
          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            var content = text.slice(scan, pos);
            if (!emptyLines && topIsLineComment) found[0] = content + "\n" + found[0];
            else (found || (found = [])).unshift(content);
            topIsLineComment = true;
            emptyLines = 0;
            pos = scan - 2;
            break;
          } else if (prev == 10) {
            if (!sawNonWS && ++emptyLines > 1) break out;
            break;
          } else if (!sawNonWS && !isSpace(prev)) {
            sawNonWS = true;
          }
        }
      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {
        for (var scan = pos - 2; scan > 1; --scan) {
          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            (found || (found = [])).unshift(text.slice(scan, pos - 2));
            topIsLineComment = false;
            emptyLines = 0;
            break;
          }
        }
        pos = scan - 2;
      } else if (isSpace(prev)) {
        --pos;
      } else {
        break;
      }
    }
    return found;
  };

  exports.commentAfter = function(text, pos) {
    while (pos < text.length) {
      var next = text.charCodeAt(pos);
      if (next == 47) {
        var after = text.charCodeAt(pos + 1), end;
        if (after == 47) // line comment
          end = text.indexOf("\n", pos + 2);
        else if (after == 42) // block comment
          end = text.indexOf("*/", pos + 2);
        else
          return;
        return text.slice(pos + 2, end < 0 ? text.length : end);
      } else if (isSpace(next)) {
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function(text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.commentsBefore(text, node.start);
  };
});

// Main type inference engine

// Walks an AST, building up a graph of abstract values and constraints
// that cause types to flow from one node to another. Also defines a
// number of utilities for accessing ASTs and scopes.

// Analysis is done in a context, which is tracked by the dynamically
// bound cx variable. Use withContext to set the current context.

// For memory-saving reasons, individual types export an interface
// similar to abstract values (which can hold multiple types), and can
// thus be used in place abstract values that only ever contain a
// single type.

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("acorn"), require("acorn/dist/acorn_loose"), require("acorn/dist/walk"),
               require("./def"), require("./signal"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "acorn/dist/acorn", "acorn/dist/acorn_loose", "acorn/dist/walk", "./def", "./signal"], mod);
  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
  "use strict";

  var toString = exports.toString = function(type, maxDepth, parent) {
    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
    return type.toString(maxDepth, parent);
  };

  // A variant of AVal used for unknown, dead-end values. Also serves
  // as prototype for AVals, Types, and Constraints because it
  // implements 'empty' versions of all the methods that the code
  // expects.
  var ANull = exports.ANull = signal.mixin({
    addType: function() {},
    propagate: function() {},
    getProp: function() { return ANull; },
    forAllProps: function() {},
    hasType: function() { return false; },
    isEmpty: function() { return true; },
    getFunctionType: function() {},
    getObjType: function() {},
    getType: function() {},
    gatherProperties: function() {},
    propagatesTo: function() {},
    typeHint: function() {},
    propHint: function() {},
    toString: function() { return "?"; }
  });

  function extend(proto, props) {
    var obj = Object.create(proto);
    if (props) for (var prop in props) obj[prop] = props[prop];
    return obj;
  }

  // ABSTRACT VALUES

  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10, WG_MULTI_MEMBER = 5,
      WG_CATCH_ERROR = 5, WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2;

  var AVal = exports.AVal = function() {
    this.types = [];
    this.forward = null;
    this.maxWeight = 0;
  };
  AVal.prototype = extend(ANull, {
    addType: function(type, weight) {
      weight = weight || WG_DEFAULT;
      if (this.maxWeight < weight) {
        this.maxWeight = weight;
        if (this.types.length == 1 && this.types[0] == type) return;
        this.types.length = 0;
      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
        return;
      }

      this.signal("addType", type);
      this.types.push(type);
      var forward = this.forward;
      if (forward) withWorklist(function(add) {
        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
      });
    },

    propagate: function(target, weight) {
      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
      (this.forward || (this.forward = [])).push(target);
      var types = this.types;
      if (types.length) withWorklist(function(add) {
        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
      });
    },

    getProp: function(prop) {
      if (prop == "__proto__" || prop == "") return ANull;
      var found = (this.props || (this.props = Object.create(null)))[prop];
      if (!found) {
        found = this.props[prop] = new AVal;
        this.propagate(new PropIsSubset(prop, found));
      }
      return found;
    },

    forAllProps: function(c) {
      this.propagate(new ForAllProps(c));
    },

    hasType: function(type) {
      return this.types.indexOf(type) > -1;
    },
    isEmpty: function() { return this.types.length === 0; },
    getFunctionType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Fn) return this.types[i];
    },
    getObjType: function() {
      var seen = null;
      for (var i = this.types.length - 1; i >= 0; --i) {
        var type = this.types[i];
        if (!(type instanceof Obj)) continue;
        if (type.name) return type;
        if (!seen) seen = type;
      }
      return seen;
    },

    getType: function(guess) {
      if (this.types.length === 0 && guess !== false) return this.makeupType();
      if (this.types.length === 1) return this.types[0];
      return canonicalType(this.types);
    },

    toString: function(maxDepth, parent) {
      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);
      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
      var simplified = simplifyTypes(this.types);
      if (simplified.length > 2) return "?";
      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
    },

    computedPropType: function() {
      if (!this.propertyOf) return null;
      if (this.propertyOf.hasProp("<i>")) {
        var computedProp = this.propertyOf.getProp("<i>");
        if (computedProp == this) return null;
        return computedProp.getType();
      } else if (this.propertyOf.maybeProps && this.propertyOf.maybeProps["<i>"] == this) {
        for (var prop in this.propertyOf.props) {
          var val = this.propertyOf.props[prop];
          if (!val.isEmpty()) return val;
        }
        return null;
      }
    },

    makeupType: function() {
      var computed = this.computedPropType();
      if (computed) return computed;

      if (!this.forward) return null;
      for (var i = this.forward.length - 1; i >= 0; --i) {
        var hint = this.forward[i].typeHint();
        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
      }

      var props = Object.create(null), foundProp = null;
      for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop && prop != "length" && prop != "<i>" && prop != "" && prop != cx.completingProperty) {
          props[prop] = true;
          foundProp = prop;
        }
      }
      if (!foundProp) return null;

      var objs = objsWithProp(foundProp);
      if (objs) {
        var matches = [];
        search: for (var i = 0; i < objs.length; ++i) {
          var obj = objs[i];
          for (var prop in props) if (!obj.hasProp(prop)) continue search;
          if (obj.hasCtor) obj = getInstance(obj);
          matches.push(obj);
        }
        var canon = canonicalType(matches);
        if (canon) {guessing = true; return canon;}
      }
    },

    typeHint: function() { return this.types.length ? this.getType() : null; },
    propagatesTo: function() { return this; },

    gatherProperties: function(f, depth) {
      for (var i = 0; i < this.types.length; ++i)
        this.types[i].gatherProperties(f, depth);
    },

    guessProperties: function(f) {
      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop) f(prop, null, 0);
      }
      var guessed = this.makeupType();
      if (guessed) guessed.gatherProperties(f);
    }
  });

  function similarAVal(a, b, depth) {
    var typeA = a.getType(false), typeB = b.getType(false);
    if (!typeA || !typeB) return true;
    return similarType(typeA, typeB, depth);
  }

  function similarType(a, b, depth) {
    if (!a || depth >= 5) return b;
    if (!a || a == b) return a;
    if (!b) return a;
    if (a.constructor != b.constructor) return false;
    if (a.constructor == Arr) {
      var innerA = a.getProp("<i>").getType(false);
      if (!innerA) return b;
      var innerB = b.getProp("<i>").getType(false);
      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
    } else if (a.constructor == Obj) {
      var propsA = 0, propsB = 0, same = 0;
      for (var prop in a.props) {
        propsA++;
        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
          same++;
      }
      for (var prop in b.props) propsB++;
      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
      return propsA > propsB ? a : b;
    } else if (a.constructor == Fn) {
      if (a.args.length != b.args.length ||
          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
        return false;
      return a;
    } else {
      return false;
    }
  }

  var simplifyTypes = exports.simplifyTypes = function(types) {
    var found = [];
    outer: for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      for (var j = 0; j < found.length; j++) {
        var similar = similarType(tp, found[j], 0);
        if (similar) {
          found[j] = similar;
          continue outer;
        }
      }
      found.push(tp);
    }
    return found;
  };

  function canonicalType(types) {
    var arrays = 0, fns = 0, objs = 0, prim = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      if (tp instanceof Arr) ++arrays;
      else if (tp instanceof Fn) ++fns;
      else if (tp instanceof Obj) ++objs;
      else if (tp instanceof Prim) {
        if (prim && tp.name != prim.name) return null;
        prim = tp;
      }
    }
    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
    if (kinds > 1) return null;
    if (prim) return prim;

    var maxScore = 0, maxTp = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i], score = 0;
      if (arrays) {
        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
      } else if (fns) {
        score = 1;
        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
        if (!tp.retval.isEmpty()) ++score;
      } else if (objs) {
        score = tp.name ? 100 : 2;
      }
      if (score >= maxScore) { maxScore = score; maxTp = tp; }
    }
    return maxTp;
  }

  // PROPAGATION STRATEGIES

  function Constraint() {}
  Constraint.prototype = extend(ANull, {
    init: function() { this.origin = cx.curOrigin; }
  });

  var constraint = exports.constraint = function(props, methods) {
    var body = "this.init();";
    props = props ? props.split(", ") : [];
    for (var i = 0; i < props.length; ++i)
      body += "this." + props[i] + " = " + props[i] + ";";
    var ctor = Function.apply(null, props.concat([body]));
    ctor.prototype = Object.create(Constraint.prototype);
    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
    return ctor;
  };

  var PropIsSubset = constraint("prop, target", {
    addType: function(type, weight) {
      if (type.getProp)
        type.getProp(this.prop).propagate(this.target, weight);
    },
    propHint: function() { return this.prop; },
    propagatesTo: function() {
      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
        return {target: this.target, pathExt: "." + this.prop};
    }
  });

  var PropHasSubset = exports.PropHasSubset = constraint("prop, type, originNode", {
    addType: function(type, weight) {
      if (!(type instanceof Obj)) return;
      var prop = type.defProp(this.prop, this.originNode);
      if (!prop.origin) prop.origin = this.origin;
      this.type.propagate(prop, weight);
    },
    propHint: function() { return this.prop; }
  });

  var ForAllProps = constraint("c", {
    addType: function(type) {
      if (!(type instanceof Obj)) return;
      type.forAllProps(this.c);
    }
  });

  function withDisabledComputing(fn, body) {
    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
    try {
      return body();
    } finally {
      cx.disabledComputing = cx.disabledComputing.prev;
    }
  }
  var IsCallee = exports.IsCallee = constraint("self, args, argNodes, retval", {
    init: function() {
      Constraint.prototype.init.call(this);
      this.disabled = cx.disabledComputing;
    },
    addType: function(fn, weight) {
      if (!(fn instanceof Fn)) return;
      for (var i = 0; i < this.args.length; ++i) {
        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
      }
      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
      var compute = fn.computeRet;
      if (compute) for (var d = this.disabled; d; d = d.prev)
        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
      if (compute)
        compute(this.self, this.args, this.argNodes).propagate(this.retval, weight);
      else
        fn.retval.propagate(this.retval, weight);
    },
    typeHint: function() {
      var names = [];
      for (var i = 0; i < this.args.length; ++i) names.push("?");
      return new Fn(null, this.self, this.args, names, ANull);
    },
    propagatesTo: function() {
      return {target: this.retval, pathExt: ".!ret"};
    }
  });

  var HasMethodCall = constraint("propName, args, argNodes, retval", {
    init: function() {
      Constraint.prototype.init.call(this);
      this.disabled = cx.disabledComputing;
    },
    addType: function(obj, weight) {
      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
      callee.disabled = this.disabled;
      obj.getProp(this.propName).propagate(callee, weight);
    },
    propHint: function() { return this.propName; }
  });

  var IsCtor = exports.IsCtor = constraint("target, noReuse", {
    addType: function(f, weight) {
      if (!(f instanceof Fn)) return;
      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
    }
  });

  var getInstance = exports.getInstance = function(obj, ctor) {
    if (ctor === false) return new Obj(obj);

    if (!ctor) ctor = obj.hasCtor;
    if (!obj.instances) obj.instances = [];
    for (var i = 0; i < obj.instances.length; ++i) {
      var cur = obj.instances[i];
      if (cur.ctor == ctor) return cur.instance;
    }
    var instance = new Obj(obj, ctor && ctor.name);
    instance.origin = obj.origin;
    obj.instances.push({ctor: ctor, instance: instance});
    return instance;
  };

  var IsProto = exports.IsProto = constraint("ctor, target", {
    addType: function(o, _weight) {
      if (!(o instanceof Obj)) return;
      if ((this.count = (this.count || 0) + 1) > 8) return;
      if (o == cx.protos.Array)
        this.target.addType(new Arr);
      else
        this.target.addType(getInstance(o, this.ctor));
    }
  });

  var FnPrototype = constraint("fn", {
    addType: function(o, _weight) {
      if (o instanceof Obj && !o.hasCtor) {
        o.hasCtor = this.fn;
        var adder = new SpeculativeThis(o, this.fn);
        adder.addType(this.fn);
        o.forAllProps(function(_prop, val, local) {
          if (local) val.propagate(adder);
        });
      }
    }
  });

  var IsAdded = constraint("other, target", {
    addType: function(type, weight) {
      if (type == cx.str)
        this.target.addType(cx.str, weight);
      else if (type == cx.num && this.other.hasType(cx.num))
        this.target.addType(cx.num, weight);
    },
    typeHint: function() { return this.other; }
  });

  var IfObj = exports.IfObj = constraint("target", {
    addType: function(t, weight) {
      if (t instanceof Obj) this.target.addType(t, weight);
    },
    propagatesTo: function() { return this.target; }
  });

  var SpeculativeThis = constraint("obj, ctor", {
    addType: function(tp) {
      if (tp instanceof Fn && tp.self && tp.self.isEmpty())
        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_THIS);
    }
  });

  var Muffle = constraint("inner, weight", {
    addType: function(tp, weight) {
      this.inner.addType(tp, Math.min(weight, this.weight));
    },
    propagatesTo: function() { return this.inner.propagatesTo(); },
    typeHint: function() { return this.inner.typeHint(); },
    propHint: function() { return this.inner.propHint(); }
  });

  // TYPE OBJECTS

  var Type = exports.Type = function() {};
  Type.prototype = extend(ANull, {
    constructor: Type,
    propagate: function(c, w) { c.addType(this, w); },
    hasType: function(other) { return other == this; },
    isEmpty: function() { return false; },
    typeHint: function() { return this; },
    getType: function() { return this; }
  });

  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
  Prim.prototype = extend(Type.prototype, {
    constructor: Prim,
    toString: function() { return this.name; },
    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
    gatherProperties: function(f, depth) {
      if (this.proto) this.proto.gatherProperties(f, depth);
    }
  });

  var Obj = exports.Obj = function(proto, name) {
    if (!this.props) this.props = Object.create(null);
    this.proto = proto === true ? cx.protos.Object : proto;
    if (proto && !name && proto.name && !(this instanceof Fn)) {
      var match = /^(.*)\.prototype$/.exec(this.proto.name);
      if (match) name = match[1];
    }
    this.name = name;
    this.maybeProps = null;
    this.origin = cx.curOrigin;
  };
  Obj.prototype = extend(Type.prototype, {
    constructor: Obj,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      if (maxDepth <= 0 && this.name) return this.name;
      var props = [], etc = false;
      for (var prop in this.props) if (prop != "<i>") {
        if (props.length > 5) { etc = true; break; }
        if (maxDepth)
          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
        else
          props.push(prop);
      }
      props.sort();
      if (etc) props.push("...");
      return "{" + props.join(", ") + "}";
    },
    hasProp: function(prop, searchProto) {
      var found = this.props[prop];
      if (searchProto !== false)
        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
      return found;
    },
    defProp: function(prop, originNode) {
      var found = this.hasProp(prop, false);
      if (found) {
        if (originNode && !found.originNode) found.originNode = originNode;
        return found;
      }
      if (prop == "__proto__" || prop == "") return ANull;

      var av = this.maybeProps && this.maybeProps[prop];
      if (av) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
      } else {
        av = new AVal;
        av.propertyOf = this;
      }

      this.props[prop] = av;
      av.originNode = originNode;
      av.origin = cx.curOrigin;
      this.broadcastProp(prop, av, true);
      return av;
    },
    getProp: function(prop) {
      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
      if (found) return found;
      if (prop == "__proto__" || prop == "") return ANull;
      var av = this.ensureMaybeProps()[prop] = new AVal;
      av.propertyOf = this;
      return av;
    },
    broadcastProp: function(prop, val, local) {
      if (local) {
        this.signal("addProp", prop, val);
        // If this is a scope, it shouldn't be registered
        if (!(this instanceof Scope)) registerProp(prop, this);
      }

      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
        var h = this.onNewProp[i];
        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
      }
    },
    onProtoProp: function(prop, val, _local) {
      var maybe = this.maybeProps && this.maybeProps[prop];
      if (maybe) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
        this.proto.getProp(prop).propagate(maybe);
      }
      this.broadcastProp(prop, val, false);
    },
    ensureMaybeProps: function() {
      if (!this.maybeProps) {
        if (this.proto) this.proto.forAllProps(this);
        this.maybeProps = Object.create(null);
      }
      return this.maybeProps;
    },
    removeProp: function(prop) {
      var av = this.props[prop];
      delete this.props[prop];
      this.ensureMaybeProps()[prop] = av;
      av.types.length = 0;
    },
    forAllProps: function(c) {
      if (!this.onNewProp) {
        this.onNewProp = [];
        if (this.proto) this.proto.forAllProps(this);
      }
      this.onNewProp.push(c);
      for (var o = this; o; o = o.proto) for (var prop in o.props) {
        if (c.onProtoProp)
          c.onProtoProp(prop, o.props[prop], o == this);
        else
          c(prop, o.props[prop], o == this);
      }
    },
    maybeUnregProtoPropHandler: function() {
      if (this.maybeProps) {
        for (var _n in this.maybeProps) return;
        this.maybeProps = null;
      }
      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
      this.proto.unregPropHandler(this);
    },
    unregPropHandler: function(handler) {
      for (var i = 0; i < this.onNewProp.length; ++i)
        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
      this.maybeUnregProtoPropHandler();
    },
    gatherProperties: function(f, depth) {
      for (var prop in this.props) if (prop != "<i>")
        f(prop, this, depth);
      if (this.proto) this.proto.gatherProperties(f, depth + 1);
    },
    getObjType: function() { return this; }
  });

  var Fn = exports.Fn = function(name, self, args, argNames, retval) {
    Obj.call(this, cx.protos.Function, name);
    this.self = self;
    this.args = args;
    this.argNames = argNames;
    this.retval = retval;
  };
  Fn.prototype = extend(Obj.prototype, {
    constructor: Fn,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      var str = "fn(";
      for (var i = 0; i < this.args.length; ++i) {
        if (i) str += ", ";
        var name = this.argNames[i];
        if (name && name != "?") str += name + ": ";
        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
      }
      str += ")";
      if (!this.retval.isEmpty())
        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
      return str;
    },
    getProp: function(prop) {
      if (prop == "prototype") {
        var known = this.hasProp(prop, false);
        if (!known) {
          known = this.defProp(prop);
          var proto = new Obj(true, this.name && this.name + ".prototype");
          proto.origin = this.origin;
          known.addType(proto, WG_MADEUP_PROTO);
        }
        return known;
      }
      return Obj.prototype.getProp.call(this, prop);
    },
    defProp: function(prop, originNode) {
      if (prop == "prototype") {
        var found = this.hasProp(prop, false);
        if (found) return found;
        found = Obj.prototype.defProp.call(this, prop, originNode);
        found.origin = this.origin;
        found.propagate(new FnPrototype(this));
        return found;
      }
      return Obj.prototype.defProp.call(this, prop, originNode);
    },
    getFunctionType: function() { return this; }
  });

  var Arr = exports.Arr = function(contentType) {
    Obj.call(this, cx.protos.Array);
    var content = this.defProp("<i>");
    if (contentType) contentType.propagate(content);
  };
  Arr.prototype = extend(Obj.prototype, {
    constructor: Arr,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      return "[" + (maxDepth > -3 ? toString(this.getProp("<i>"), maxDepth - 1, this) : "?") + "]";
    }
  });

  // THE PROPERTY REGISTRY

  function registerProp(prop, obj) {
    var data = cx.props[prop] || (cx.props[prop] = []);
    data.push(obj);
  }

  function objsWithProp(prop) {
    return cx.props[prop];
  }

  // INFERENCE CONTEXT

  exports.Context = function(defs, parent) {
    this.parent = parent;
    this.props = Object.create(null);
    this.protos = Object.create(null);
    this.origins = [];
    this.curOrigin = "ecma5";
    this.paths = Object.create(null);
    this.definitions = Object.create(null);
    this.purgeGen = 0;
    this.workList = null;
    this.disabledComputing = null;

    exports.withContext(this, function() {
      cx.protos.Object = new Obj(null, "Object.prototype");
      cx.topScope = new Scope();
      cx.topScope.name = "<top>";
      cx.protos.Array = new Obj(true, "Array.prototype");
      cx.protos.Function = new Obj(true, "Function.prototype");
      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
      cx.protos.String = new Obj(true, "String.prototype");
      cx.protos.Number = new Obj(true, "Number.prototype");
      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
      cx.str = new Prim(cx.protos.String, "string");
      cx.bool = new Prim(cx.protos.Boolean, "bool");
      cx.num = new Prim(cx.protos.Number, "number");
      cx.curOrigin = null;

      if (defs) for (var i = 0; i < defs.length; ++i)
        def.load(defs[i]);
    });
  };

  var cx = null;
  exports.cx = function() { return cx; };

  exports.withContext = function(context, f) {
    var old = cx;
    cx = context;
    try { return f(); }
    finally { cx = old; }
  };

  exports.TimedOut = function() {
    this.message = "Timed out";
    this.stack = (new Error()).stack;
  };
  exports.TimedOut.prototype = Object.create(Error.prototype);
  exports.TimedOut.prototype.name = "infer.TimedOut";

  var timeout;
  exports.withTimeout = function(ms, f) {
    var end = +new Date + ms;
    var oldEnd = timeout;
    if (oldEnd && oldEnd < end) return f();
    timeout = end;
    try { return f(); }
    finally { timeout = oldEnd; }
  };

  exports.addOrigin = function(origin) {
    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
  };

  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
  function withWorklist(f) {
    if (cx.workList) return f(cx.workList);

    var list = [], depth = 0;
    var add = cx.workList = function(type, target, weight) {
      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
        list.push(type, target, weight, depth);
    };
    try {
      var ret = f(add);
      for (var i = 0; i < list.length; i += 4) {
        if (timeout && +new Date >= timeout)
          throw new exports.TimedOut();
        depth = list[i + 3] + 1;
        list[i + 1].addType(list[i], list[i + 2]);
      }
      return ret;
    } finally {
      cx.workList = null;
    }
  }

  // SCOPES

  var Scope = exports.Scope = function(prev) {
    Obj.call(this, prev || true);
    this.prev = prev;
  };
  Scope.prototype = extend(Obj.prototype, {
    constructor: Scope,
    defVar: function(name, originNode) {
      for (var s = this; ; s = s.proto) {
        var found = s.props[name];
        if (found) return found;
        if (!s.prev) return s.defProp(name, originNode);
      }
    }
  });

  // RETVAL COMPUTATION HEURISTICS

  function maybeInstantiate(scope, score) {
    if (scope.fnType)
      scope.fnType.instantiateScore = (scope.fnType.instantiateScore || 0) + score;
  }

  var NotSmaller = {};
  function nodeSmallerThan(node, n) {
    try {
      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
      return true;
    } catch(e) {
      if (e == NotSmaller) return false;
      throw e;
    }
  }

  function maybeTagAsInstantiated(node, scope) {
    var score = scope.fnType.instantiateScore;
    if (!cx.disabledComputing && score && scope.fnType.args.length && nodeSmallerThan(node, score * 5)) {
      maybeInstantiate(scope.prev, score / 2);
      setFunctionInstantiated(node, scope);
      return true;
    } else {
      scope.fnType.instantiateScore = null;
    }
  }

  function setFunctionInstantiated(node, scope) {
    var fn = scope.fnType;
    // Disconnect the arg avals, so that we can add info to them without side effects
    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
    fn.self = new AVal;
    fn.computeRet = function(self, args) {
      // Prevent recursion
      return withDisabledComputing(fn, function() {
        var oldOrigin = cx.curOrigin;
        cx.curOrigin = fn.origin;
        var scopeCopy = new Scope(scope.prev);
        scopeCopy.originNode = scope.originNode;
        for (var v in scope.props) {
          var local = scopeCopy.defProp(v, scope.props[v].originNode);
          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
            args[i].propagate(local);
        }
        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
        while (argNames.length < args.length) argNames.push("?");
        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull);
        scopeCopy.fnType.originNode = fn.originNode;
        if (fn.arguments) {
          var argset = scopeCopy.fnType.arguments = new AVal;
          scopeCopy.defProp("arguments").addType(new Arr(argset));
          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
        }
        node.body.scope = scopeCopy;
        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
        walk.recursive(node.body, scopeCopy, null, inferWrapper);
        cx.curOrigin = oldOrigin;
        return scopeCopy.fnType.retval;
      });
    };
  }

  function maybeTagAsGeneric(scope) {
    var fn = scope.fnType, target = fn.retval;
    if (target == ANull) return;
    var targetInner, asArray;
    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
      target = asArray = targetInner.getProp("<i>");

    function explore(aval, path, depth) {
      if (depth > 3 || !aval.forward) return;
      for (var i = 0; i < aval.forward.length; ++i) {
        var prop = aval.forward[i].propagatesTo();
        if (!prop) continue;
        var newPath = path, dest;
        if (prop instanceof AVal) {
          dest = prop;
        } else if (prop.target instanceof AVal) {
          newPath += prop.pathExt;
          dest = prop.target;
        } else continue;
        if (dest == target) return newPath;
        var found = explore(dest, newPath, depth + 1);
        if (found) return found;
      }
    }

    var foundPath = explore(fn.self, "!this", 0);
    for (var i = 0; !foundPath && i < fn.args.length; ++i)
      foundPath = explore(fn.args[i], "!" + i, 0);

    if (foundPath) {
      if (asArray) foundPath = "[" + foundPath + "]";
      var p = new def.TypeParser(foundPath);
      var parsed = p.parseType(true);
      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
      fn.computeRetSource = foundPath;
      return true;
    }
  }

  // SCOPE GATHERING PASS

  function addVar(scope, nameNode) {
    return scope.defProp(nameNode.name, nameNode);
  }

  var scopeGatherer = walk.make({
    Function: function(node, scope, c) {
      var inner = node.body.scope = new Scope(scope);
      inner.originNode = node;
      var argVals = [], argNames = [];
      for (var i = 0; i < node.params.length; ++i) {
        var param = node.params[i];
        argNames.push(param.name);
        argVals.push(addVar(inner, param));
      }
      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull);
      inner.fnType.originNode = node;
      if (node.id) {
        var decl = node.type == "FunctionDeclaration";
        addVar(decl ? scope : inner, node.id);
      }
      c(node.body, inner, "ScopeBody");
    },
    TryStatement: function(node, scope, c) {
      c(node.block, scope, "Statement");
      if (node.handler) {
        var v = addVar(scope, node.handler.param);
        c(node.handler.body, scope, "ScopeBody");
        var e5 = cx.definitions.ecma5;
        if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
      }
      if (node.finalizer) c(node.finalizer, scope, "Statement");
    },
    VariableDeclaration: function(node, scope, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        addVar(scope, decl.id);
        if (decl.init) c(decl.init, scope, "Expression");
      }
    }
  });

  // CONSTRAINT GATHERING PASS

  function propName(node, scope, c) {
    var prop = node.property;
    if (!node.computed) return prop.name;
    if (prop.type == "Literal" && typeof prop.value == "string") return prop.value;
    if (c) infer(prop, scope, c, ANull);
    return "<i>";
  }

  function unopResultType(op) {
    switch (op) {
    case "+": case "-": case "~": return cx.num;
    case "!": return cx.bool;
    case "typeof": return cx.str;
    case "void": case "delete": return ANull;
    }
  }
  function binopIsBoolean(op) {
    switch (op) {
    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
    case "in": case "instanceof": return true;
    }
  }
  function literalType(node) {
    if (node.regex) return getInstance(cx.protos.RegExp);
    switch (typeof node.value) {
    case "boolean": return cx.bool;
    case "number": return cx.num;
    case "string": return cx.str;
    case "object":
    case "function":
      if (!node.value) return ANull;
      return getInstance(cx.protos.RegExp);
    }
  }

  function ret(f) {
    return function(node, scope, c, out, name) {
      var r = f(node, scope, c, name);
      if (out) r.propagate(out);
      return r;
    };
  }
  function fill(f) {
    return function(node, scope, c, out, name) {
      if (!out) out = new AVal;
      f(node, scope, c, out, name);
      return out;
    };
  }

  var inferExprVisitor = {
    ArrayExpression: ret(function(node, scope, c) {
      var eltval = new AVal;
      for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt) infer(elt, scope, c, eltval);
      }
      return new Arr(eltval);
    }),
    ObjectExpression: ret(function(node, scope, c, name) {
      var obj = node.objType = new Obj(true, name);
      obj.originNode = node;

      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i], key = prop.key, name;
        if (prop.value.name == "") continue;

        if (key.type == "Identifier") {
          name = key.name;
        } else if (typeof key.value == "string") {
          name = key.value;
        }
        if (!name || prop.kind == "set") {
          infer(prop.value, scope, c, ANull);
          continue;
        }

        var val = obj.defProp(name, key), out = val;
        val.initializer = true;
        if (prop.kind == "get")
          out = new IsCallee(obj, [], null, val);
        infer(prop.value, scope, c, out, name);
      }
      return obj;
    }),
    FunctionExpression: ret(function(node, scope, c, name) {
      var inner = node.body.scope, fn = inner.fnType;
      if (name && !fn.name) fn.name = name;
      c(node.body, scope, "ScopeBody");
      maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
      if (node.id) inner.getProp(node.id.name).addType(fn);
      return fn;
    }),
    SequenceExpression: ret(function(node, scope, c) {
      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
        infer(node.expressions[i], scope, c, ANull);
      return infer(node.expressions[l], scope, c);
    }),
    UnaryExpression: ret(function(node, scope, c) {
      infer(node.argument, scope, c, ANull);
      return unopResultType(node.operator);
    }),
    UpdateExpression: ret(function(node, scope, c) {
      infer(node.argument, scope, c, ANull);
      return cx.num;
    }),
    BinaryExpression: ret(function(node, scope, c) {
      if (node.operator == "+") {
        var lhs = infer(node.left, scope, c);
        var rhs = infer(node.right, scope, c);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
        var result = new AVal;
        lhs.propagate(new IsAdded(rhs, result));
        rhs.propagate(new IsAdded(lhs, result));
        return result;
      } else {
        infer(node.left, scope, c, ANull);
        infer(node.right, scope, c, ANull);
        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
      }
    }),
    AssignmentExpression: ret(function(node, scope, c) {
      var rhs, name, pName;
      if (node.left.type == "MemberExpression") {
        pName = propName(node.left, scope, c);
        if (node.left.object.type == "Identifier")
          name = node.left.object.name + "." + pName;
      } else {
        name = node.left.name;
      }

      if (node.operator != "=" && node.operator != "+=") {
        infer(node.right, scope, c, ANull);
        rhs = cx.num;
      } else {
        rhs = infer(node.right, scope, c, null, name);
      }

      if (node.left.type == "MemberExpression") {
        var obj = infer(node.left.object, scope, c);
        if (pName == "prototype") maybeInstantiate(scope, 20);
        if (pName == "<i>") {
          // This is a hack to recognize for/in loops that copy
          // properties, and do the copying ourselves, insofar as we
          // manage, because such loops tend to be relevant for type
          // information.
          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
          if (over) {
            maybeInstantiate(scope, 20);
            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
            over.forAllProps(function(prop, val, local) {
              if (local && prop != "prototype" && prop != "<i>")
                obj.propagate(new PropHasSubset(prop, fromRight ? val : ANull));
            });
            return rhs;
          }
        }
        obj.propagate(new PropHasSubset(pName, rhs, node.left.property));
      } else { // Identifier
        rhs.propagate(scope.defVar(node.left.name, node.left));
      }
      return rhs;
    }),
    LogicalExpression: fill(function(node, scope, c, out) {
      infer(node.left, scope, c, out);
      infer(node.right, scope, c, out);
    }),
    ConditionalExpression: fill(function(node, scope, c, out) {
      infer(node.test, scope, c, ANull);
      infer(node.consequent, scope, c, out);
      infer(node.alternate, scope, c, out);
    }),
    NewExpression: fill(function(node, scope, c, out, name) {
      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
        maybeInstantiate(scope, 20);

      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope, c));
      var callee = infer(node.callee, scope, c);
      var self = new AVal;
      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
      self.propagate(out, WG_NEW_INSTANCE);
      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
    }),
    CallExpression: fill(function(node, scope, c, out) {
      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope, c));
      if (node.callee.type == "MemberExpression") {
        var self = infer(node.callee.object, scope, c);
        var pName = propName(node.callee, scope, c);
        if ((pName == "call" || pName == "apply") &&
            scope.fnType && scope.fnType.args.indexOf(self) > -1)
          maybeInstantiate(scope, 30);
        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
      } else {
        var callee = infer(node.callee, scope, c);
        if (scope.fnType && scope.fnType.args.indexOf(callee) > -1)
          maybeInstantiate(scope, 30);
        var knownFn = callee.getFunctionType();
        if (knownFn && knownFn.instantiateScore && scope.fnType)
          maybeInstantiate(scope, knownFn.instantiateScore / 5);
        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
      }
    }),
    MemberExpression: fill(function(node, scope, c, out) {
      var name = propName(node, scope);
      var obj = infer(node.object, scope, c);
      var prop = obj.getProp(name);
      if (name == "<i>") {
        var propType = infer(node.property, scope, c);
        if (!propType.hasType(cx.num))
          return prop.propagate(out, WG_MULTI_MEMBER);
      }
      prop.propagate(out);
    }),
    Identifier: ret(function(node, scope) {
      if (node.name == "arguments" && scope.fnType && !(node.name in scope.props))
        scope.defProp(node.name, scope.fnType.originNode)
          .addType(new Arr(scope.fnType.arguments = new AVal));
      return scope.getProp(node.name);
    }),
    ThisExpression: ret(function(_node, scope) {
      return scope.fnType ? scope.fnType.self : cx.topScope;
    }),
    Literal: ret(function(node) {
      return literalType(node);
    })
  };

  function infer(node, scope, c, out, name) {
    return inferExprVisitor[node.type](node, scope, c, out, name);
  }

  var inferWrapper = walk.make({
    Expression: function(node, scope, c) {
      infer(node, scope, c, ANull);
    },

    FunctionDeclaration: function(node, scope, c) {
      var inner = node.body.scope, fn = inner.fnType;
      c(node.body, scope, "ScopeBody");
      maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
      var prop = scope.getProp(node.id.name);
      prop.addType(fn);
    },

    VariableDeclaration: function(node, scope, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i], prop = scope.getProp(decl.id.name);
        if (decl.init)
          infer(decl.init, scope, c, prop, decl.id.name);
      }
    },

    ReturnStatement: function(node, scope, c) {
      if (!node.argument) return;
      var output = ANull;
      if (scope.fnType) {
        if (scope.fnType.retval == ANull) scope.fnType.retval = new AVal;
        output = scope.fnType.retval;
      }
      infer(node.argument, scope, c, output);
    },

    ForInStatement: function(node, scope, c) {
      var source = infer(node.right, scope, c);
      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
        maybeInstantiate(scope, 5);
        var varName;
        if (node.left.type == "Identifier") {
          varName = node.left.name;
        } else if (node.left.type == "VariableDeclaration") {
          varName = node.left.declarations[0].id.name;
        }
        if (varName && varName in scope.props)
          scope.getProp(varName).iteratesOver = source;
      }
      c(node.body, scope, "Statement");
    },

    ScopeBody: function(node, scope, c) { c(node, node.scope || scope); }
  });

  // PARSING

  function runPasses(passes, pass) {
    var arr = passes && passes[pass];
    var args = Array.prototype.slice.call(arguments, 2);
    if (arr) for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var parse = exports.parse = function(text, passes, options) {
    var ast;
    try { ast = acorn.parse(text, options); }
    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
    runPasses(passes, "postParse", ast, text);
    return ast;
  };

  // ANALYSIS INTERFACE

  exports.analyze = function(ast, name, scope, passes) {
    if (typeof ast == "string") ast = parse(ast);

    if (!name) name = "file#" + cx.origins.length;
    exports.addOrigin(cx.curOrigin = name);

    if (!scope) scope = cx.topScope;
    walk.recursive(ast, scope, null, scopeGatherer);
    runPasses(passes, "preInfer", ast, scope);
    walk.recursive(ast, scope, null, inferWrapper);
    runPasses(passes, "postInfer", ast, scope);

    cx.curOrigin = null;
  };

  // PURGING

  exports.purge = function(origins, start, end) {
    var test = makePredicate(origins, start, end);
    ++cx.purgeGen;
    cx.topScope.purge(test);
    for (var prop in cx.props) {
      var list = cx.props[prop];
      for (var i = 0; i < list.length; ++i) {
        var obj = list[i], av = obj.props[prop];
        if (!av || test(av, av.originNode)) list.splice(i--, 1);
      }
      if (!list.length) delete cx.props[prop];
    }
  };

  function makePredicate(origins, start, end) {
    var arr = Array.isArray(origins);
    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
    if (arr) {
      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
    } else {
      if (end == null) return function(n) { return n.origin == origins; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
    }
  }

  AVal.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return;
    this.purgeGen = cx.purgeGen;
    for (var i = 0; i < this.types.length; ++i) {
      var type = this.types[i];
      if (test(type, type.originNode))
        this.types.splice(i--, 1);
      else
        type.purge(test);
    }
    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
      var f = this.forward[i];
      if (test(f)) {
        this.forward.splice(i--, 1);
        if (this.props) this.props = null;
      } else if (f.purge) {
        f.purge(test);
      }
    }
  };
  ANull.purge = function() {};
  Obj.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return true;
    this.purgeGen = cx.purgeGen;
    for (var p in this.props) {
      var av = this.props[p];
      if (test(av, av.originNode))
        this.removeProp(p);
      av.purge(test);
    }
  };
  Fn.prototype.purge = function(test) {
    if (Obj.prototype.purge.call(this, test)) return;
    this.self.purge(test);
    this.retval.purge(test);
    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
  };

  // EXPRESSION TYPE DETERMINATION

  function findByPropertyName(name) {
    guessing = true;
    var found = objsWithProp(name);
    if (found) for (var i = 0; i < found.length; ++i) {
      var val = found[i].getProp(name);
      if (!val.isEmpty()) return val;
    }
    return ANull;
  }

  var typeFinder = {
    ArrayExpression: function(node, scope) {
      var eltval = new AVal;
      for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt) findType(elt, scope).propagate(eltval);
      }
      return new Arr(eltval);
    },
    ObjectExpression: function(node) {
      return node.objType;
    },
    FunctionExpression: function(node) {
      return node.body.scope.fnType;
    },
    SequenceExpression: function(node, scope) {
      return findType(node.expressions[node.expressions.length-1], scope);
    },
    UnaryExpression: function(node) {
      return unopResultType(node.operator);
    },
    UpdateExpression: function() {
      return cx.num;
    },
    BinaryExpression: function(node, scope) {
      if (binopIsBoolean(node.operator)) return cx.bool;
      if (node.operator == "+") {
        var lhs = findType(node.left, scope);
        var rhs = findType(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
      }
      return cx.num;
    },
    AssignmentExpression: function(node, scope) {
      return findType(node.right, scope);
    },
    LogicalExpression: function(node, scope) {
      var lhs = findType(node.left, scope);
      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
    },
    ConditionalExpression: function(node, scope) {
      var lhs = findType(node.consequent, scope);
      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
    },
    NewExpression: function(node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      var proto = f && f.getProp("prototype").getObjType();
      if (!proto) return ANull;
      return getInstance(proto, f);
    },
    CallExpression: function(node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      if (!f) return ANull;
      if (f.computeRet) {
        for (var i = 0, args = []; i < node.arguments.length; ++i)
          args.push(findType(node.arguments[i], scope));
        var self = ANull;
        if (node.callee.type == "MemberExpression")
          self = findType(node.callee.object, scope);
        return f.computeRet(self, args, node.arguments);
      } else {
        return f.retval;
      }
    },
    MemberExpression: function(node, scope) {
      var propN = propName(node, scope), obj = findType(node.object, scope).getType();
      if (obj) return obj.getProp(propN);
      if (propN == "<i>") return ANull;
      return findByPropertyName(propN);
    },
    Identifier: function(node, scope) {
      return scope.hasProp(node.name) || ANull;
    },
    ThisExpression: function(_node, scope) {
      return scope.fnType ? scope.fnType.self : cx.topScope;
    },
    Literal: function(node) {
      return literalType(node);
    }
  };

  function findType(node, scope) {
    return typeFinder[node.type](node, scope);
  }

  var searchVisitor = exports.searchVisitor = walk.make({
    Function: function(node, _st, c) {
      var scope = node.body.scope;
      if (node.id) c(node.id, scope);
      for (var i = 0; i < node.params.length; ++i)
        c(node.params[i], scope);
      c(node.body, scope, "ScopeBody");
    },
    TryStatement: function(node, st, c) {
      if (node.handler)
        c(node.handler.param, st);
      walk.base.TryStatement(node, st, c);
    },
    VariableDeclaration: function(node, st, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        c(decl.id, st);
        if (decl.init) c(decl.init, st, "Expression");
      }
    }
  });
  exports.fullVisitor = walk.make({
    MemberExpression: function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, node.computed ? "Expression" : null);
    },
    ObjectExpression: function(node, st, c) {
      for (var i = 0; i < node.properties.length; ++i) {
        c(node.properties[i].value, st, "Expression");
        c(node.properties[i].key, st);
      }
    }
  }, searchVisitor);

  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (node.type == "Identifier" && node.name == "") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (start != null && node.start > start) return false;
      if (node.type == "Identifier" && node.name == "") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.expressionType = function(found) {
    return findType(found.node, found.state);
  };

  // Finding the expected type of something, from context

  exports.parentNode = function(child, ast) {
    var stack = [];
    function c(node, st, override) {
      if (node.start <= child.start && node.end >= child.end) {
        var top = stack[stack.length - 1];
        if (node == child) throw {found: top};
        if (top != node) stack.push(node);
        walk.base[override || node.type](node, st, c);
        if (top != node) stack.pop();
      }
    }
    try {
      c(ast, null);
    } catch (e) {
      if (e.found) return e.found;
      throw e;
    }
  };

  var findTypeFromContext = {
    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
    ObjectExpression: function(parent, node, get) {
      for (var i = 0; i < parent.properties.length; ++i) {
        var prop = node.properties[i];
        if (prop.value == node)
          return get(parent, true).getProp(prop.key.name);
      }
    },
    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
    UpdateExpression: function() { return cx.num; },
    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
    LogicalExpression: function(parent, _, get) { return get(parent, true); },
    ConditionalExpression: function(parent, node, get) {
      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
    },
    NewExpression: function(parent, node, get) {
      return this.CallExpression(parent, node, get);
    },
    CallExpression: function(parent, node, get) {
      for (var i = 0; i < parent.arguments.length; i++) {
        var arg = parent.arguments[i];
        if (arg == node) {
          var calleeType = get(parent.callee).getFunctionType();
          if (calleeType instanceof Fn)
            return calleeType.args[i];
          break;
        }
      }
    },
    ReturnStatement: function(_parent, node, get) {
      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
      if (fnNode) {
        var fnType = fnNode.node.type == "FunctionExpression"
          ? get(fnNode.node, true).getFunctionType()
          : fnNode.node.body.scope.fnType;
        if (fnType) return fnType.retval.getType();
      }
    },
    VariableDeclaration: function(parent, node, get) {
      for (var i = 0; i < parent.declarations.length; i++) {
        var decl = parent.declarations[i];
        if (decl.init == node) return get(decl.id);
      }
    }
  };

  exports.typeFromContext = function(ast, found) {
    var parent = exports.parentNode(found.node, ast);
    var type = null;
    if (findTypeFromContext.hasOwnProperty(parent.type)) {
      type = findTypeFromContext[parent.type](parent, found.node, function(node, fromContext) {
        var obj = {node: node, state: found.state};
        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
        return tp || ANull;
      });
    }
    return type || exports.expressionType(found);
  };

  // Flag used to indicate that some wild guessing was used to produce
  // a type or set of completions.
  var guessing = false;

  exports.resetGuessing = function(val) { guessing = val; };
  exports.didGuess = function() { return guessing; };

  exports.forAllPropertiesOf = function(type, f) {
    type.gatherProperties(f, 0);
  };

  var refFindWalker = walk.make({}, searchVisitor);

  exports.findRefs = function(ast, baseScope, name, refScope, f) {
    refFindWalker.Identifier = function(node, scope) {
      if (node.name != name) return;
      for (var s = scope; s; s = s.prev) {
        if (s == refScope) f(node, scope);
        if (name in s.props) return;
      }
    };
    walk.recursive(ast, baseScope, null, refFindWalker);
  };

  var simpleWalker = walk.make({
    Function: function(node, _st, c) { c(node.body, node.body.scope, "ScopeBody"); }
  });

  exports.findPropRefs = function(ast, scope, objType, propName, f) {
    walk.simple(ast, {
      MemberExpression: function(node, scope) {
        if (node.computed || node.property.name != propName) return;
        if (findType(node.object, scope).getType() == objType) f(node.property);
      },
      ObjectExpression: function(node, scope) {
        if (findType(node, scope).getType() != objType) return;
        for (var i = 0; i < node.properties.length; ++i)
          if (node.properties[i].key.name == propName) f(node.properties[i].key);
      }
    }, simpleWalker, scope);
  };

  // LOCAL-VARIABLE QUERIES

  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
    var found = walk.findNodeAround(ast, pos, function(tp, node) {
      return tp == "ScopeBody" && node.scope;
    });
    if (found) return found.node.scope;
    else return defaultScope || cx.topScope;
  };

  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };

  // INIT DEF MODULE

  // Delayed initialization because of cyclic dependencies.
  def = exports.def = def.init({}, exports);
});

// Parses comments above variable declarations, function declarations,
// and object properties as docstrings and JSDoc-style type
// annotations.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(tern, tern, tern.comment, acorn, acorn.walk);
})(function(infer, tern, comment, acorn, walk) {
  "use strict";

  var WG_MADEUP = 1, WG_STRONG = 101;

  tern.registerPlugin("doc_comment", function(server, options) {
    server.jsdocTypedefs = Object.create(null);
    server.on("reset", function() {
      server.jsdocTypedefs = Object.create(null);
    });
    server._docComment = {
      weight: options && options.strong ? WG_STRONG : undefined,
      fullDocs: options && options.fullDocs
    };

    return {
      passes: {
        postParse: postParse,
        postInfer: postInfer,
        postLoadDef: postLoadDef
      }
    };
  });

  function postParse(ast, text) {
    function attachComments(node) { comment.ensureCommentsBefore(text, node); }

    walk.simple(ast, {
      VariableDeclaration: attachComments,
      FunctionDeclaration: attachComments,
      AssignmentExpression: function(node) {
        if (node.operator == "=") attachComments(node);
      },
      ObjectExpression: function(node) {
        for (var i = 0; i < node.properties.length; ++i)
          attachComments(node.properties[i]);
      },
      CallExpression: function(node) {
        if (isDefinePropertyCall(node)) attachComments(node);
      }
    });
  }

  function isDefinePropertyCall(node) {
    return node.callee.type == "MemberExpression" &&
      node.callee.object.name == "Object" &&
      node.callee.property.name == "defineProperty" &&
      node.arguments.length >= 3 &&
      typeof node.arguments[1].value == "string";
  }

  function postInfer(ast, scope) {
    jsdocParseTypedefs(ast.sourceFile.text, scope);

    walk.simple(ast, {
      VariableDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.declarations[0].id.name));
      },
      FunctionDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.body.scope.fnType);
      },
      AssignmentExpression: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            infer.expressionType({node: node.left, state: scope}));
      },
      ObjectExpression: function(node, scope) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i];
          if (prop.commentsBefore)
            interpretComments(prop, prop.commentsBefore, scope,
                              node.objType.getProp(prop.key.name));
        }
      },
      CallExpression: function(node, scope) {
        if (node.commentsBefore && isDefinePropertyCall(node)) {
          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();
          if (type && type instanceof infer.Obj) {
            var prop = type.props[node.arguments[1].value];
            if (prop) interpretComments(node, node.commentsBefore, scope, prop);
          }
        }
      }
    }, infer.searchVisitor, scope);
  }

  function postLoadDef(data) {
    var defs = data["!typedef"];
    var cx = infer.cx(), orig = data["!name"];
    if (defs) for (var name in defs)
      cx.parent.jsdocTypedefs[name] =
        maybeInstance(infer.def.parse(defs[name], orig, name), name);
  }

  // COMMENT INTERPRETATION

  function interpretComments(node, comments, scope, aval, type) {
    jsdocInterpretComments(node, scope, aval, comments);
    var cx = infer.cx();

    if (!type && aval instanceof infer.AVal && aval.types.length) {
      type = aval.types[aval.types.length - 1];
      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)
        type = null;
    }

    var result = comments[comments.length - 1];
    if (cx.parent._docComment.fullDocs) {
      result = result.trim().replace(/\n[ \t]*\* ?/g, "\n");
    } else {
      var dot = result.search(/\.\s/);
      if (dot > 5) result = result.slice(0, dot + 1);
      result = result.trim().replace(/\s*\n\s*\*\s*|\s{1,}/g, " ");
    }
    result = result.replace(/^\s*\*+\s*/, "");

    if (aval instanceof infer.AVal) aval.doc = result;
    if (type) type.doc = result;
  }

  // Parses a subset of JSDoc-style comments in order to include the
  // explicitly defined types in the analysis.

  function skipSpace(str, pos) {
    while (/\s/.test(str.charAt(pos))) ++pos;
    return pos;
  }

  function isIdentifier(string) {
    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;
    for (var i = 1; i < string.length; i++)
      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;
    return true;
  }

  function parseLabelList(scope, str, pos, close) {
    var labels = [], types = [], madeUp = false;
    for (var first = true; ; first = false) {
      pos = skipSpace(str, pos);
      if (first && str.charAt(pos) == close) break;
      var colon = str.indexOf(":", pos);
      if (colon < 0) return null;
      var label = str.slice(pos, colon);
      if (!isIdentifier(label)) return null;
      labels.push(label);
      pos = colon + 1;
      var type = parseType(scope, str, pos);
      if (!type) return null;
      pos = type.end;
      madeUp = madeUp || type.madeUp;
      types.push(type.type);
      pos = skipSpace(str, pos);
      var next = str.charAt(pos);
      ++pos;
      if (next == close) break;
      if (next != ",") return null;
    }
    return {labels: labels, types: types, end: pos, madeUp: madeUp};
  }

  function parseType(scope, str, pos) {
    var type, union = false, madeUp = false;
    for (;;) {
      var inner = parseTypeInner(scope, str, pos);
      if (!inner) return null;
      madeUp = madeUp || inner.madeUp;
      if (union) inner.type.propagate(union);
      else type = inner.type;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != "|") break;
      pos++;
      if (!union) {
        union = new infer.AVal;
        type.propagate(union);
        type = union;
      }
    }
    var isOptional = false;
    if (str.charAt(pos) == "=") {
      ++pos;
      isOptional = true;
    }
    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};
  }

  function parseTypeInner(scope, str, pos) {
    pos = skipSpace(str, pos);
    var type, madeUp = false;

    if (str.indexOf("function(", pos) == pos) {
      var args = parseLabelList(scope, str, pos + 9, ")"), ret = infer.ANull;
      if (!args) return null;
      pos = skipSpace(str, args.end);
      if (str.charAt(pos) == ":") {
        ++pos;
        var retType = parseType(scope, str, pos + 1);
        if (!retType) return null;
        pos = retType.end;
        ret = retType.type;
        madeUp = retType.madeUp;
      }
      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);
    } else if (str.charAt(pos) == "[") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      madeUp = inner.madeUp;
      if (str.charAt(pos) != "]") return null;
      ++pos;
      type = new infer.Arr(inner.type);
    } else if (str.charAt(pos) == "{") {
      var fields = parseLabelList(scope, str, pos + 1, "}");
      if (!fields) return null;
      type = new infer.Obj(true);
      for (var i = 0; i < fields.types.length; ++i) {
        var field = type.defProp(fields.labels[i]);
        field.initializer = true;
        fields.types[i].propagate(field);
      }
      pos = fields.end;
      madeUp = fields.madeUp;
    } else if (str.charAt(pos) == "(") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != ")") return null;
      ++pos;
      type = inner.type;
    } else {
      var start = pos;
      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;
      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
      if (start == pos) return null;
      var word = str.slice(start, pos);
      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;
      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;
      else if (/^string$/i.test(word)) type = infer.cx().str;
      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;
      else if (/^array$/i.test(word)) {
        var inner = null;
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var inAngles = parseType(scope, str, pos + 2);
          if (!inAngles) return null;
          pos = skipSpace(str, inAngles.end);
          madeUp = inAngles.madeUp;
          if (str.charAt(pos++) != ">") return null;
          inner = inAngles.type;
        }
        type = new infer.Arr(inner);
      } else if (/^object$/i.test(word)) {
        type = new infer.Obj(true);
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var key = parseType(scope, str, pos + 2);
          if (!key) return null;
          pos = skipSpace(str, key.end);
          madeUp = madeUp || key.madeUp;
          if (str.charAt(pos++) != ",") return null;
          var val = parseType(scope, str, pos);
          if (!val) return null;
          pos = skipSpace(str, val.end);
          madeUp = key.madeUp || val.madeUp;
          if (str.charAt(pos++) != ">") return null;
          val.type.propagate(type.defProp("<i>"));
        }
      } else {
        while (str.charCodeAt(pos) == 46 ||
               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
        var path = str.slice(start, pos);
        var cx = infer.cx(), defs = cx.parent && cx.parent.jsdocTypedefs, found;
        if (defs && (path in defs)) {
          type = defs[path];
        } else if (found = infer.def.parsePath(path, scope).getObjType()) {
          type = maybeInstance(found, path);
        } else {
          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);
          if (!(path in cx.jsdocPlaceholders))
            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);
          else
            type = cx.jsdocPlaceholders[path];
          madeUp = true;
        }
      }
    }

    return {type: type, end: pos, madeUp: madeUp};
  }

  function maybeInstance(type, path) {
    if (type instanceof infer.Fn && /^[A-Z]/.test(path)) {
      var proto = type.getProp("prototype").getObjType();
      if (proto instanceof infer.Obj) return infer.getInstance(proto);
    }
    return type;
  }

  function parseTypeOuter(scope, str, pos) {
    pos = skipSpace(str, pos || 0);
    if (str.charAt(pos) != "{") return null;
    var result = parseType(scope, str, pos + 1);
    if (!result) return null;
    var end = skipSpace(str, result.end);
    if (str.charAt(end) != "}") return null;
    result.end = end + 1;
    return result;
  }

  function jsdocInterpretComments(node, scope, aval, comments) {
    var type, args, ret, foundOne, self, parsed;

    for (var i = 0; i < comments.length; ++i) {
      var comment = comments[i];
      var decl = /(?:\n|$|\*)\s*@(type|param|arg(?:ument)?|returns?|this)\s+(.*)/g, m;
      while (m = decl.exec(comment)) {
        if (m[1] == "this" && (parsed = parseType(scope, m[2], 0))) {
          self = parsed;
          foundOne = true;
          continue;
        }

        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;
        foundOne = true;

        switch(m[1]) {
        case "returns": case "return":
          ret = parsed; break;
        case "type":
          type = parsed; break;
        case "param": case "arg": case "argument":
            var name = m[2].slice(parsed.end).match(/^\s*(\[?)\s*([^\]\s=]+)\s*(?:=[^\]]+\s*)?(\]?).*/);
            if (!name) continue;
            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[3] === ']') ? "?" : "");
          (args || (args = Object.create(null)))[argname] = parsed;
          break;
        }
      }
    }

    if (foundOne) applyType(type, self, args, ret, node, aval);
  };

  function jsdocParseTypedefs(text, scope) {
    var cx = infer.cx();

    var re = /\s@typedef\s+(.*)/g, m;
    while (m = re.exec(text)) {
      var parsed = parseTypeOuter(scope, m[1]);
      var name = parsed && m[1].slice(parsed.end).match(/^\s*(\S+)/);
      if (name)
        cx.parent.jsdocTypedefs[name[1]] = parsed.type;
    }
  }

  function propagateWithWeight(type, target) {
    var weight = infer.cx().parent._docComment.weight;
    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));
  }

  function applyType(type, self, args, ret, node, aval) {
    var fn;
    if (node.type == "VariableDeclaration") {
      var decl = node.declarations[0];
      if (decl.init && decl.init.type == "FunctionExpression") fn = decl.init.body.scope.fnType;
    } else if (node.type == "FunctionDeclaration") {
      fn = node.body.scope.fnType;
    } else if (node.type == "AssignmentExpression") {
      if (node.right.type == "FunctionExpression")
        fn = node.right.body.scope.fnType;
    } else if (node.type == "CallExpression") {
    } else { // An object property
      if (node.value.type == "FunctionExpression") fn = node.value.body.scope.fnType;
    }

    if (fn && (args || ret || self)) {
      if (args) for (var i = 0; i < fn.argNames.length; ++i) {
        var name = fn.argNames[i], known = args[name];
        if (!known && (known = args[name + "?"]))
          fn.argNames[i] += "?";
        if (known) propagateWithWeight(known, fn.args[i]);
      }
      if (ret) propagateWithWeight(ret, fn.retval);
      if (self) propagateWithWeight(self, fn.self);
    } else if (type) {
      propagateWithWeight(type, aval);
    }
  };
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("tern/lib/infer"), require("tern/lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define([ "tern/lib/infer", "tern/lib/tern" ], mod);
  mod(tern, tern);
})(function(infer, tern) {
  "use strict";

  tern.registerPlugin("threejs", function(server, options) {
    return {
      defs : {
  "!name": "threejs",
  "THREE": {
    "Original": {
      "!url": "http://threejs.org/docs/#Reference/Original",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "todo"
    },
    "Camera": {
      "!url": "http://threejs.org/docs/#Reference/cameras/Camera",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "matrixWorldInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera."
        },
        "projectionMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "This is the matrix which contains the projection."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3)",
          "!doc": "vector  point to look at<br>\n\t\t<br>\n\t\tThis makes the camera look at the vector position in the global space as long as the parent of this camera is the scene or at position (0,0,0)."
        }
      },
      "!doc": "Abstract base class for cameras. This class should always be inherited when you build a new camera.",
      "!type": "fn()"
    },
    "CubeCamera": {
      "!url": "http://threejs.org/docs/#Reference/cameras/CubeCamera",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "renderTarget": {
          "!type": "+THREE.WebGLRenderTargetCube",
          "!doc": "The cube texture that gets generated."
        },
        "updateCubeMap": {
          "!type": "fn(renderer: todo, scene: todo) -> todo",
          "!doc": "Call this to update the renderTarget."
        }
      },
      "!doc": "Creates 6 cameras that render to a [page:WebGLRenderTargetCube].",
      "!type": "fn(near: number, far: number, cubeResolution: number)"
    },
    "OrthographicCamera": {
      "!url": "http://threejs.org/docs/#Reference/cameras/OrthographicCamera",
      "prototype": {
        "!proto": "THREE.Camera.prototype",
        "left": {
          "!type": "number",
          "!doc": "Camera frustum left plane."
        },
        "right": {
          "!type": "number",
          "!doc": "Camera frustum right plane."
        },
        "top": {
          "!type": "number",
          "!doc": "Camera frustum top plane."
        },
        "bottom": {
          "!type": "number",
          "!doc": "Camera frustum bottom plane."
        },
        "near": {
          "!type": "number",
          "!doc": "Camera frustum near plane."
        },
        "far": {
          "!type": "number",
          "!doc": "Camera frustum far plane."
        },
        "updateProjectionMatrix": {
          "!type": "fn()",
          "!doc": "Updates the camera projection matrix. Must be called after change of parameters."
        }
      },
      "!doc": "Camera with orthographic projection.",
      "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number)"
    },
    "PerspectiveCamera": {
      "!url": "http://threejs.org/docs/#Reference/cameras/PerspectiveCamera",
      "prototype": {
        "!proto": "THREE.Camera.prototype",
        "fov": {
          "!type": "number",
          "!doc": "Camera frustum vertical field of view, from bottom to top of view, in degrees."
        },
        "aspect": {
          "!type": "number",
          "!doc": "Camera frustum aspect ratio, window width divided by window height."
        },
        "near": {
          "!type": "number",
          "!doc": "Camera frustum near plane."
        },
        "far": {
          "!type": "number",
          "!doc": "Camera frustum far plane."
        },
        "setLens": {
          "!type": "fn(focalLength: number, frameSize: number)",
          "!doc": "Uses focal length (in mm) to estimate and set FOV 35mm (fullframe) camera is used if frame size is not specified.<br>\n\t\tFormula based on [link:http://www.bobatkins.com/photography/technical/field_of_view.html]"
        },
        "setViewOffset": {
          "!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
          "!doc": "For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br>\n\n\t\t<pre>+---+---+---+\n| A | B | C |\n+---+---+---+\n| D | E | F |\n+---+---+---+</pre>\n\n\t\tthen for each monitor you would call it like this:<br>\n\n\t\t<code>var w = 1920;\nvar h = 1080;\nvar fullWidth = w * 3;\nvar fullHeight = h * 2;\n\n// A\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n// B\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n// C\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n// D\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n// E\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n// F\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n</code>\n\n\t\tNote there is no reason monitors have to be the same size or in a grid."
        },
        "updateProjectionMatrix": {
          "!type": "fn()",
          "!doc": "Updates the camera projection matrix. Must be called after change of parameters."
        }
      },
      "!doc": "Camera with perspective projection.",
      "!type": "fn(fov: number, aspect: number, near: number, far: number)"
    },
    "CustomBlendingEquations": {
      "!url": "http://threejs.org/docs/#Reference/constants/CustomBlendingEquations",
      "prototype": {}
    },
    "GLState": {
      "!url": "http://threejs.org/docs/#Reference/constants/GLState",
      "prototype": {}
    },
    "Materials": {
      "!url": "http://threejs.org/docs/#Reference/constants/Materials",
      "prototype": {}
    },
    "ShadowingTypes": {
      "!url": "http://threejs.org/docs/#Reference/constants/ShadowingTypes",
      "prototype": {}
    },
    "Textures": {
      "!url": "http://threejs.org/docs/#Reference/constants/Textures",
      "prototype": {}
    },
    "BufferAttribute": {
      "!url": "http://threejs.org/docs/#Reference/core/BufferAttribute",
      "prototype": {
        "array": {
          "!type": "[]",
          "!doc": "Stores the data associated with this attribute; can be an Array or a Typed Array. This element should have <code>itemSize * numVertices</code> elements, where numVertices is the number of vertices in the associated [page:BufferGeometry geometry]."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "Records how many items of the array are associated with a particular vertex. For instance, if this\n\t\tattribute is storing a 3-component vector (such as a position, normal, or color), then itemSize should be 3."
        },
        "length": {
          "!type": "number",
          "!doc": "Gives the total number of elements in the array."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Flag to indicate that this attribute has changed and should be re-send to the GPU. Set this to true when you modify the value of the array."
        },
        "setX": {
          "!type": "fn(index, x)",
          "!doc": "Sets the value of the array at <code>index * itemSize</code> to x"
        },
        "setY": {
          "!type": "fn(index, y)",
          "!doc": "Sets the value of the array at <code>index * itemSize + 1</code> to y"
        },
        "setZ": {
          "!type": "fn(index, z)",
          "!doc": "Sets the value of the array at <code>index * itemSize + 2</code> to z"
        },
        "setXY": {
          "!type": "fn(index, x, y)",
          "!doc": "Sets the value of the array at <code>index * itemSize</code> to x and \n\t\tsets the value of the array at <code>index * itemSize + 1</code> to y"
        },
        "setXYZ": {
          "!type": "fn(index, x, y, z)",
          "!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, and\n\t\tthe value of the array at <code>index * itemSize + 2</code> to z."
        },
        "setXYZW": {
          "!type": "fn(index, x, y, z, w)",
          "!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, \n\t\tthe value of the array at <code>index * itemSize + 2</code> to z, and\n\t\tthe value of the array at <code>index * itemSize + 3</code> to w."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Copies this attribute."
        }
      },
      "!doc": "This class stores data for an attribute associated with a [page:BufferGeometry]. See that page for details and a usage example. This class is used to store builtin attributes such as vertex position, normals, color, etc., but can also be used in your code to store custom attributes in a [page:BufferGeometry].",
      "!type": "fn(array: [], itemSize: number)"
    },
    "BufferGeometry": {
      "!url": "http://threejs.org/docs/#Reference/core/BufferGeometry",
      "prototype": {
        "id": {
          "!type": "number",
          "!doc": "Unique number for this buffergeometry instance."
        },
        "attributes": {
          "!type": "Hashmap",
          "!doc": "This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.\n\t\tRather than accessing this property directly, use addAttribute and getAttribute to access attributes of this geometry."
        },
        "drawCalls": {
          "!type": "[]",
          "!doc": "For geometries that use indexed triangles, this Array can be used to split the object into multiple WebGL draw calls. Each draw call will draw some subset of the vertices in this geometry using the configured [page:Material shader]. This may be necessary if, for instance, you have more than 65535 vertices in your object. \n\t\tEach element is an object of the form:\n\t\t<code>{ start: Integer, count: Integer, index: Integer }</code>\n\t\twhere start specifies the index of the first vertex in this draw call, count specifies how many vertices are included, and index specifies an optional offset.\n\n\t\tUse addDrawCall to add draw calls, rather than modifying this array directly."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box.\n\t\t<code>{ min: new THREE.Vector3(), max: new THREE.Vector3() }</code>"
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
        },
        "morphTargets": {
          "!type": "[]",
          "!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new THREE.Vertex(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
        },
        "addAttribute": {
          "!type": "null",
          "!doc": "Adds an attribute to this geometry. Use this rather than the attributes property, \n\t\tbecause an internal array of attributes is maintained to speed up iterating over\n\t\tattributes."
        },
        "addDrawCall": {
          "!type": "fn(start: number, count: number, indexOffset: number)",
          "!doc": "Adds a draw call to this geometry; see the drawcalls property for details."
        },
        "applyMatrix": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Bakes matrix transform directly into vertex coordinates."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals by averaging face normals.<br>"
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute.<br>\n\t\tBounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes bounding sphere of the geometry, updating [page:Geometry Geometry.boundingSphere] attribute.<br>\n\t\tBounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Disposes the object from memory. <br>\n\t\tYou need to call this when you want the bufferGeometry removed while the application is running."
        },
        "fromGeometry": {
          "!type": "fn()",
          "!doc": "Populates this BufferGeometry with data from a [page:Geometry] object."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the [page:BufferAttribute attribute] with the specified name."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Every normal vector in a geometry will have a magnitude of 1.\n\t\tThis will correct lighting on the geometry surfaces."
        }
      },
      "!doc": "<p>\n\t\tThis class is an efficient alternative to [page:Geometry], because it stores all data, including\n\t\tvertex positions, face indices, normals, colors, UVs, and custom attributes within buffers; this\n\t\treduces the cost of passing all this data to the GPU. \n\t\tThis also makes BufferGeometry harder to work with than [page:Geometry]; rather than accessing \n\t\tposition data as [page:Vector3] objects, color data as [page:Color] objects, and so on, you have to \n\t\taccess the raw data from the appropriate [page:BufferAttribute attribute] buffer. This makes \n\t\tBufferGeometry best-suited for static objects where you don't need to manipulate the geometry much\n\t\tafter instantiating it.\n\t\t</p>\n\n\t\t<h3>Example</h3>\n\t\t<code>\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\t// create a simple square shape. We duplicate the top left and bottom right\n\t\t// vertices because each vertex needs to appear once per triangle. \n\t\tvar vertexPositions = [ \n\t\t\t[-1.0, -1.0,  1.0],\n\t\t\t[ 1.0, -1.0,  1.0],\n\t\t\t[ 1.0,  1.0,  1.0],\n\n\t\t\t[ 1.0,  1.0,  1.0],\n\t\t\t[-1.0,  1.0,  1.0],\n\t\t\t[-1.0, -1.0,  1.0]\n\t\t];\n\t\tvar vertices = new Float32Array( vertexPositions.length * 3 ); // three components per vertex\n\n\t\t// components of the position vector for each vertex are stored\n\t\t// contiguously in the buffer.\n\t\tfor ( var i = 0; i &lt; vertexPositions.length; i++ )\n\t\t{\n\t\t\tvertices[ i*3 + 0 ] = vertexPositions[i][0];\n\t\t\tvertices[ i*3 + 1 ] = vertexPositions[i][1];\n\t\t\tvertices[ i*3 + 2 ] = vertexPositions[i][2];\n\t\t}\n\n\t\t// itemSize = 3 because there are 3 values (components) per vertex\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tvar material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t</code>\n\t\t<p>More examples: [example:webgl_buffergeometry Complex mesh with non-indexed faces], [example:webgl_buffergeometry_uint Complex mesh with indexed faces], [example:webgl_buffergeometry_lines Lines], [example:webgl_buffergeometry_lines_indexed Indexed Lines], [example:webgl_buffergeometry_particles Particles], and [example:webgl_buffergeometry_rawshader Raw Shaders].</p>\n\n\t\t\n\t\t<h3>Accessing attributes</h3>\n\t\t<p>\n\t\tWebGL stores data associated with individual vertices of a geometry in <emph>attributes</emph>. \n\t\tExamples include the position of the vertex, the normal vector for the vertex, the vertex color,\n\t\tand so on. When using [page:Geometry], the [page:WebGLRenderer renderer] takes care of wrapping\n\t\tup this information into typed array buffers and sending this data to the shader. With \n\t\tBufferGeometry, all of this data is stored in buffers associated with an individual attributes.\n\t\tThis means that to get the position data associated with a vertex (for instance), you must call\n\t\t[page:.getAttribute] to access the 'position' [page:BufferAttribute attribute], then access the individual \n\t\tx, y, and z coordinates of the position.  \n\t\t</p>\n\t\t<p>\n\t\tThe following attributes are set by various members of this class:\n\t\t</p>\n\t\t<h4>[page:BufferAttribute position] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z coordinates of each vertex in this geometry. Set by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute normal] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the face or vertex normal vector of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute color] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the red, green, and blue channels of vertex color of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute tangent] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the tangent vector of each vertex in this geometry. Set by [page:.computeTangents]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute index] (itemSize: 3)</h4>\n\t\tAllows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles,\" and works much the same as it does in [page:Geometry]: each triangle is associated with the index of three vertices. This attribute therefore stores the index of each vertex for each triangular face.\n\n\t\tIf this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.",
      "!type": "fn()"
    },
    "Clock": {
      "!url": "http://threejs.org/docs/#Reference/core/Clock",
      "prototype": {
        "autoStart": {
          "!type": "bool",
          "!doc": "If set, starts the clock automatically when the first update is called."
        },
        "startTime": {
          "!type": "number",
          "!doc": "When the clock is running, It holds the start time of the clock. <br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
        },
        "oldTime": {
          "!type": "number",
          "!doc": "When the clock is running, It holds the previous time from a update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
        },
        "elapsedTime": {
          "!type": "number",
          "!doc": "When the clock is running, It holds the time elapsed between the start of the clock to the previous update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
        },
        "running": {
          "!type": "bool",
          "!doc": "This property keeps track whether the clock is running or not."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts clock."
        },
        "stop": {
          "!type": "fn()",
          "!doc": "Stops clock."
        },
        "getElapsedTime": {
          "!type": "fn() -> number",
          "!doc": "Get the seconds passed since the clock started."
        },
        "getDelta": {
          "!type": "fn() -> number",
          "!doc": "Get the seconds passed since the last call to this method."
        }
      },
      "!doc": "Object for keeping track of time.",
      "!type": "fn(autoStart: bool)"
    },
    "EventDispatcher": {
      "!url": "http://threejs.org/docs/#Reference/core/EventDispatcher",
      "prototype": {
        "addEventListener": {
          "!type": "fn(type: string, listener: function)",
          "!doc": "Adds a listener to an event type."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: function) -> bool",
          "!doc": "Checks if listener is added to an event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: function)",
          "!doc": "Removes a listener from an event type."
        },
        "dispatchEvent": {
          "!type": "fn(type: string)",
          "!doc": "Fire an event type."
        }
      },
      "!doc": "JavaScript events for custom objects.<br>\n\t\t<a href=\"https://github.com/mrdoob/eventdispatcher.js\">https://github.com/mrdoob/eventdispatcher.js</a>",
      "!type": "fn()"
    },
    "Face3": {
      "!url": "http://threejs.org/docs/#Reference/core/Face3",
      "prototype": {
        "a": {
          "!type": "number",
          "!doc": "Vertex A index."
        },
        "b": {
          "!type": "number",
          "!doc": "Vertex B index."
        },
        "c": {
          "!type": "number",
          "!doc": "Vertex C index."
        },
        "normal": {
          "!type": "+THREE.Vector3",
          "!doc": "Face normal."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Face color."
        },
        "vertexNormals": {
          "!type": "[]",
          "!doc": "Array of 3 vertex normals."
        },
        "vertexColors": {
          "!type": "[]",
          "!doc": "Array of 3 vertex colors."
        },
        "materialIndex": {
          "!type": "number",
          "!doc": "Material index (points to [page:MultiMaterial MultiMaterial.materials])."
        },
        "clone": {
          "!type": "fn() -> +THREE.Face3",
          "!doc": "Creates a new clone of the Face3 object."
        }
      },
      "!doc": "Triangle face.",
      "!type": "fn(a: number, b: number, c: number, normal: +THREE.Vector3, color: +THREE.Color, materialIndex: number)"
    },
    "Geometry": {
      "!url": "http://threejs.org/docs/#Reference/core/Geometry",
      "prototype": {
        "id": {
          "!type": "number",
          "!doc": "Unique number for this geometry instance."
        },
        "name": {
          "!type": "string",
          "!doc": "Name for this geometry. Default is an empty string."
        },
        "vertices": {
          "!type": "[]",
          "!doc": "Array of [page:Vector3 vertices].<br>\n\t\tThe array of vertices holds every position of points in the model.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.verticesNeedUpdate] needs to be set to true."
        },
        "colors": {
          "!type": "[]",
          "!doc": "Array of vertex [page:Color colors], matching number and order of vertices.<br>\n\t\tUsed in [page:PointCloud] and [page:Line].<br>\n\t\t[page:Mesh Meshes] use per-face-use-of-vertex colors embedded directly in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.colorsNeedUpdate] needs to be set to true."
        },
        "faces": {
          "!type": "[]",
          "!doc": "Array of [page:Face3 triangles].<br>\n\t\tThe array of faces describe how each vertex in the model is connected with each other.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.elementsNeedUpdate] needs to be set to true."
        },
        "faceVertexUvs": {
          "!type": "[]",
          "!doc": "Array of face [page:UV] layers.<br>\n\t\tEach UV layer is an array of [page:UV]s matching the order and number of vertices in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.uvsNeedUpdate] needs to be set to true."
        },
        "morphTargets": {
          "!type": "[]",
          "!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new THREE.Vector3(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
        },
        "morphNormals": {
          "!type": "[]",
          "!doc": "Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:\n\t\t<code>morphNormal = { name: \"NormalName\", normals: [ new THREE.Vector3(), ... ] }</code>"
        },
        "skinWeights": {
          "!type": "[]",
          "!doc": "Array of skinning weights, matching number and order of vertices."
        },
        "skinIndices": {
          "!type": "[]",
          "!doc": "Array of skinning indices, matching number and order of vertices."
        },
        "boundingBox": {
          "!type": "object",
          "!doc": "Bounding box.\n\t\t<code>{ min: new THREE.Vector3(), max: new THREE.Vector3() }</code>"
        },
        "boundingSphere": {
          "!type": "object",
          "!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
        },
        "dynamic": {
          "!type": "bool",
          "!doc": "Set to *true* if attribute buffers will need to change in runtime (using \"dirty\" flags).<br>\n\t\tUnless set to true internal typed arrays corresponding to buffers will be deleted once sent to GPU.<br>\n\t\tDefaults to true."
        },
        "verticesNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the vertices array has been updated."
        },
        "elementsNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the faces array has been updated."
        },
        "uvsNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the uvs array has been updated."
        },
        "normalsNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the normals array has been updated."
        },
        "colorsNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the colors array has been updated."
        },
        "lineDistancesNeedUpdate": {
          "!type": "bool",
          "!doc": "Set to *true* if the linedistances array has been updated."
        },
        "lineDistances": {
          "!type": "array",
          "!doc": "An array containing distances between vertices for Line geometries.\n\t\tThis is required for LinePieces/LineDashedMaterial to render correctly.\n\t\tLine distances can also be generated with computeLineDistances."
        },
        "applyMatrix": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Bakes matrix transform directly into vertex coordinates."
        },
        "computeFaceNormals": {
          "!type": "fn()",
          "!doc": "Computes face normals."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals by averaging face normals.<br>\n\t\tFace normals must be existing / computed beforehand."
        },
        "computeMorphNormals": {
          "!type": "fn()",
          "!doc": "Computes morph normals."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are *null*."
        },
        "merge": {
          "!type": "fn(geometry: +THREE.Geometry, matrix: +THREE.Matrix4, materialIndexOffset: number)",
          "!doc": "Merge two geometries or geometry and geometry from object (using object's transform)"
        },
        "mergeVertices": {
          "!type": "fn()",
          "!doc": "Checks for duplicate vertices using hashmap.<br>\n\t\tDuplicated vertices are removed and faces' vertices are updated."
        },
        "clone": {
          "!type": "fn() -> +THREE.Geometry",
          "!doc": "Creates a new clone of the Geometry."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Removes The object from memory. <br>\n\t\tDon't forget to call this method when you remove a geometry because it can cause memory leaks."
        },
        "computeLineDistances": {
          "!type": "fn()",
          "!doc": "Compute distances between vertices for Line geometries."
        }
      },
      "!doc": "Base class for geometries.<br>\n\t\tA geometry holds all data necessary to describe a 3D model.",
      "!type": "fn()"
    },
    "Object3D": {
      "!url": "http://threejs.org/docs/#Reference/core/Object3D",
      "prototype": {
        "id": {
          "!type": "number",
          "!doc": "readonly  Unique number for this object instance."
        },
        "uuid": {
          "!type": "string",
          "!doc": "[link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.\n\t\tThis gets automatically assigned, so this shouldn't be edited."
        },
        "name": {
          "!type": "string",
          "!doc": "Optional name of the object (doesn't need to be unique)."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "Object's parent in the scene graph."
        },
        "children": {
          "!type": "+THREE.Object3D",
          "!doc": "Array with object's children."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Object's local position."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Object's local rotation (<a href=\"https://en.wikipedia.org/wiki/Euler_angles\" target=\"_blank\">Euler angles</a>), in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Object's local scale."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Up direction."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Local transform."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Object's local rotation as [page:Quaternion Quaternion]."
        },
        "visible": {
          "!type": "bool",
          "!doc": "default  true"
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "default  false"
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "default  false"
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "default  true"
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "default  true"
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "default  false"
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "The global transform of the object. If the Object3d has no parent, then it's identical to the local transform."
        },
        "applyMatrix": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "This updates the position, rotation and scale with the matrix."
        },
        "translateX": {
          "!type": "fn(distance: number)",
          "!doc": "Translates object along x axis by distance."
        },
        "translateY": {
          "!type": "fn(distance: number)",
          "!doc": "Translates object along y axis by distance."
        },
        "translateZ": {
          "!type": "fn(distance: number)",
          "!doc": "Translates object along z axis by distance."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Updates the vector from local space to world space."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Updates the vector from world space to local space."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3)",
          "!doc": "Rotates object to face point in space."
        },
        "traverse": {
          "!type": "fn(callback: function)",
          "!doc": "Executes the callback on this object and all descendants."
        },
        "traverseVisible": {
          "!type": "fn(callback: function)",
          "!doc": "Like traverse, but the callback will only be executed for visible objects.\n\t\tDescendants of invisible objects are not traversed."
        },
        "traverseAncestors": {
          "!type": "fn(callback: function)",
          "!doc": "Executes the callback on this object and all ancestors."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates local transform."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates global transform of the object and its children."
        },
        "clone": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Creates a new clone of this object and all descendants."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the object's children and returns the first with a matching name."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the object's children and returns the first with a matching id."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate an object by distance along an axis in object space. The axis is assumed to be normalized."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotate an object along an axis in object space. The axis is assumed to be normalized."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
          "!doc": "Abstract method to get intersections between a casted ray and this object. Subclasses such as [page:Mesh], [page:Line], and [page:PointCloud] implement this method in order to participate in raycasting."
        }
      },
      "!doc": "Base class for scene graph objects.",
      "!type": "fn()"
    },
    "Raycaster": {
      "!url": "http://threejs.org/docs/#Reference/core/Raycaster",
      "prototype": {
        "ray": {
          "!type": "+THREE.Ray",
          "!doc": "The Ray used for the raycasting."
        },
        "near": {
          "!type": "float",
          "!doc": "The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be smaller than the far property."
        },
        "far": {
          "!type": "float",
          "!doc": "The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be larger than the near property."
        },
        "precision": {
          "!type": "float",
          "!doc": "The precision factor of the raycaster when intersecting [page:Mesh] objects."
        },
        "set": {
          "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)",
          "!doc": "Updates the ray with a new origin and direction."
        },
        "setFromCamera": {
          "!type": "fn(coords: +THREE.Vector2, camera: +THREE.Camera)",
          "!doc": "Updates the ray with a new origin and direction."
        },
        "intersectObject": {
          "!type": "fn(object: +THREE.Object3D, recursive: bool) -> []",
          "!doc": "Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first. An array of intersections is returned...\n        <code>\n            [ { distance, point, face, faceIndex, indices, object }, ... ]\n        </code>\n        <p>\n        [page:Float distance]  distance between the origin of the ray and the intersection<br>\n        [page:Vector3 point]  point of intersection, in world coordinates<br>\n        [page:Face3 face]  intersected face<br>\n        [page:Integer faceIndex]  index of the intersected face<br>\n        [page:Array indices]  indices of vertices comprising the intersected face<br>\n        [page:Object3D object]  the intersected object\n    \t</p>\n        <p>\n        When intersecting a [page:Mesh] with a [page:BufferGeometry], the *faceIndex* will be *undefined*, and *indices* will be set; when intersecting a [page:Mesh] with a [page:Geometry], *indices* will be *undefined*. \n        </p>\n\t\t<p>\n\t\t*Raycaster* delegates to the [page:Object3D.raycast raycast] method of the passed object, when evaluating whether the ray intersects the object or not. This allows [page:Mesh meshes] to respond differently to ray casting than [page:Line lines] and [page:PointCloud pointclouds].\n\t\t</p>\n\t\t<p>\n\t\t*Note* that for meshes, faces must be pointed towards the origin of the [page:.ray ray] in order to be detected; intersections of the ray passing through the back of a face will not be detected. To raycast against both faces of an object, you'll want to set the [page:Mesh.material material]'s [page:Material.side side] property to *THREE.DoubleSide*.  \n\t\t</p>"
        },
        "intersectObjects": {
          "!type": "fn(objects: [], recursive: bool) -> []",
          "!doc": "Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by [page:.intersectObject]."
        }
      },
      "!doc": "This class makes raycasting easier. Raycasting is used for picking and more.",
      "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3, near: number, far: number)"
    },
    "Lut": {
      "!url": "http://threejs.org/docs/#Reference/examples/Lut",
      "prototype": {
        "minV": {
          "!type": "number",
          "!doc": "The minimum value to be represented with the lookup table. Default is 0."
        },
        "maxV": {
          "!type": "number",
          "!doc": "The maximum value to be represented with the lookup table. Default is 1."
        },
        "copy": {
          "!type": "fn(lut: +THREE.Lut)",
          "!doc": "Copies given lut."
        },
        "setminV": {
          "!type": "fn(minV: number) -> +THREE.Lut",
          "!doc": "Sets this Lut with the minimum value to be represented."
        },
        "setmaxV": {
          "!type": "fn(maxV: number) -> +THREE.Lut",
          "!doc": "Sets this Lut with the maximum value to be represented."
        },
        "changeNumberOfColors": {
          "!type": "fn(numberOfColors: number) -> +THREE.Lut",
          "!doc": "Sets this Lut with the number of colors to be used."
        },
        "changeColorMap": {
          "!type": "fn(colorMap: number) -> +THREE.Lut",
          "!doc": "Sets this Lut with the colormap to be used."
        },
        "addColorMap": {
          "!type": "fn(colorMapName, arrayOfColors) -> +THREE.Lut",
          "!doc": "Insert a new color map into the set of available color maps."
        },
        "getColor": {
          "!type": "fn(value) -> +THREE.Lut",
          "!doc": "Returns a Three.Color."
        }
      },
      "!doc": "Represents a lookup table for colormaps. It is used to determine the color values from a range of data values.",
      "!type": "fn(colormap, numberOfColors)"
    },
    "FontUtils": {
      "!url": "http://threejs.org/docs/#Reference/extras/FontUtils",
      "prototype": {
        "divisions": {
          "!type": "number",
          "!doc": "The amount of segments in a curve. Default is 10."
        },
        "style": {
          "!type": "string",
          "!doc": "The style of the used font. Default is \"normal\"."
        },
        "weight": {
          "!type": "string",
          "!doc": "The weight of the used font. Default is \"normal\"."
        },
        "face": {
          "!type": "string",
          "!doc": "The name of the font. Default is \"helvetiker\"."
        },
        "faces": {
          "!type": "object",
          "!doc": "All Fonts which are already loaded in."
        },
        "size": {
          "!type": "number",
          "!doc": "The size of the used Font. Default is 150."
        },
        "drawText": {
          "!type": "fn(text: string) -> object",
          "!doc": "Calculates the path and offset of the text in the used font. It returns an  object like { paths : fontPaths, offset : width }."
        },
        "Triangulate": {
          "!type": "fn(contour: [], indices: bool) -> []",
          "!doc": "Triangulates a contour into an array of faces."
        },
        "extractGlyphPoints": {
          "!type": "fn(c: string, face: string, scale: number, offset: number, path: +THREE.Path) -> object",
          "!doc": "This ectracts the glyphPoints of the character of the face and returns an object containing the path and the new offset."
        },
        "generateShapes": {
          "!type": "fn(text: string, parameters: object) -> []",
          "!doc": "Generates shapes from the text and return them as an Array of [page:Shape]."
        },
        "loadFace": {
          "!type": "fn(data: object) -> object",
          "!doc": "This loads and saves the data of the face and return the data. When you add the font Data as javascriptfile, then this automatically get called. So there is no need to do this yourself."
        },
        "getFace": {
          "!type": "fn() -> object",
          "!doc": "Returns the used font its data based on its style and weight."
        }
      },
      "!doc": "A class for text operations in three.js (See [page:TextGeometry])"
    },
    "GeometryUtils": {
      "!url": "http://threejs.org/docs/#Reference/extras/GeometryUtils",
      "prototype": {},
      "!doc": "Contains handy functions geometry manipulations."
    },
    "ImageUtils": {
      "!url": "http://threejs.org/docs/#Reference/extras/ImageUtils",
      "prototype": {
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the image from a different domain that allows CORS."
        },
        "generateDataTexture": {
          "!type": "fn(width: number, height: number, color: number) -> +THREE.DataTexture",
          "!doc": "Generates a texture of a single color. It is a DataTexture with format, RGBFormat."
        },
        "parseDDS": {
          "!type": "fn(buffer: string, loadMipmaps: boolean) -> +THREE.CompressedTexture",
          "!doc": "Parses a DDS Image from the string into a CompressedTexture."
        },
        "loadCompressedTexture": {
          "!type": "fn(url: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
          "!doc": "todo"
        },
        "loadTexture": {
          "!type": "fn(url: string, mapping: UVMapping, onLoad: function, onError: function) -> todo",
          "!doc": "todo"
        },
        "getNormalMap": {
          "!type": "fn(image: todo, depth: todo) -> todo",
          "!doc": "todo"
        },
        "loadCompressedTextureCube": {
          "!type": "fn(array: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
          "!doc": "todo"
        },
        "loadTextureCube": {
          "!type": "fn(array: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "A Helper class to ease the loading of images of different types."
    },
    "SceneUtils": {
      "!url": "http://threejs.org/docs/#Reference/extras/SceneUtils",
      "prototype": {
        "createMultiMaterialObject": {
          "!type": "fn(geometry: +THREE.Geometry, materials: []) -> +THREE.Object3D",
          "!doc": "Creates an new Object3D an new mesh for each material defined in materials. Beware that this is not the same as MultiMaterial which defines multiple material for 1 mesh.<br>\n\t\tThis is mostly useful for object that need a material and a wireframe implementation."
        },
        "attach": {
          "!type": "fn(child: +THREE.Object3D, scene: +THREE.Object3D, parent: +THREE.Object3D)",
          "!doc": "Attaches the object to the parent without the moving the object in the worldspace."
        },
        "detach": {
          "!type": "fn(child: +THREE.Object3D, parent: +THREE.Object3D, scene: +THREE.Object3D)",
          "!doc": "Detaches the object from the parent and adds it back to the scene without moving in worldspace."
        }
      },
      "!doc": "A class containing useful utility functions for scene manipulation."
    },
    "Curve": {
      "!url": "http://threejs.org/docs/#Reference/extras/core/Curve",
      "prototype": {
        "getPoint": {
          "!type": "fn(t) -> Vector",
          "!doc": "Returns a vector for point t of the curve where t is between 0 and 1"
        },
        "getPointAt": {
          "!type": "fn(u) -> Vector",
          "!doc": "Returns a vector for point at relative position in curve according to arc length"
        },
        "getPoints": {
          "!type": "fn(divisions) -> []",
          "!doc": "Get sequence of points using getPoint( t )"
        },
        "getSpacedPoints": {
          "!type": "fn(divisions) -> []",
          "!doc": "Get sequence of equi-spaced points using getPointAt( u )"
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Get total curve arc length"
        },
        "getLengths": {
          "!type": "fn(divisions) -> []",
          "!doc": "Get list of cumulative segment lengths"
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumlative segment distance cache"
        },
        "getUtoTmapping": {
          "!type": "fn(u, distance) -> number",
          "!doc": "Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant"
        },
        "getTangent": {
          "!type": "fn(t) -> Vector",
          "!doc": "Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation"
        },
        "getTangentAt": {
          "!type": "fn(u) -> Vector",
          "!doc": "Returns tangent at equidistant point u on the curve"
        }
      },
      "!doc": "An extensible curve object which contains methods for interpolation.",
      "!type": "fn()"
    },
    "CurvePath": {
      "!url": "http://threejs.org/docs/#Reference/extras/core/CurvePath",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "curves": {
          "!type": "array",
          "!doc": "todo"
        },
        "bends": {
          "!type": "array",
          "!doc": "todo"
        },
        "autoClose": {
          "!type": "boolean",
          "!doc": "todo"
        },
        "getWrapPoints": {
          "!type": "fn(oldPts: todo, path: todo) -> todo",
          "!doc": "todo"
        },
        "createPointsGeometry": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "todo"
        },
        "addWrapPath": {
          "!type": "fn(bendpath: todo) -> todo",
          "!doc": "todo"
        },
        "createGeometry": {
          "!type": "fn(points: todo) -> todo",
          "!doc": "todo"
        },
        "add": {
          "!type": "fn(curve: todo) -> todo",
          "!doc": "todo"
        },
        "getTransformedSpacedPoints": {
          "!type": "fn(segments: todo, bends: todo) -> todo",
          "!doc": "todo"
        },
        "createSpacedPointsGeometry": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "todo"
        },
        "closePath": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "getBoundingBox": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "getCurveLengths": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "getTransformedPoints": {
          "!type": "fn(segments: todo, bends: todo) -> todo",
          "!doc": "todo"
        },
        "checkConnection": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "todo",
      "!type": "fn()"
    },
    "Gyroscope": {
      "!url": "http://threejs.org/docs/#Reference/extras/core/Gyroscope",
      "prototype": {
        "!proto": "THREE.Object3D.prototype"
      },
      "!doc": "todo",
      "!type": "fn()"
    },
    "Path": {
      "!url": "http://threejs.org/docs/#Reference/extras/core/Path",
      "prototype": {
        "!proto": "THREE.CurvePath.prototype",
        "actions": {
          "!type": "array",
          "!doc": "The possible actions that define the path."
        },
        "fromPoints": {
          "!type": "fn(vectors) -> todo",
          "!doc": "Adds to the Path from the points. The first vector defines the offset. After that the lines get defined."
        },
        "moveTo": {
          "!type": "fn(x, y) -> todo",
          "!doc": "This moves the offset to x and y"
        },
        "lineTo": {
          "!type": "fn(x, y) -> todo",
          "!doc": "This creates a line from the offset to X and Y and updates the offset to X and Y."
        },
        "quadraticCurveTo": {
          "!type": "fn(aCPx, aCPy, aX, aY) -> todo",
          "!doc": "This creates a quadratic curve from the offset to aX and aY with aCPx and aCPy as control point and updates the offset to aX and aY."
        },
        "bezierCurveTo": {
          "!type": "fn(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) -> todo",
          "!doc": "This creates a bezier curve from the offset to aX and aY with aCP1x, aCP1y and aCP1x, aCP1y  as control points and updates the offset to aX and aY."
        },
        "arc": {
          "!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
          "!doc": "todo"
        },
        "absarc": {
          "!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
          "!doc": "todo"
        },
        "ellipse": {
          "!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
          "!doc": "todo"
        },
        "absellipse": {
          "!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
          "!doc": "todo"
        },
        "toShapes": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "A 2d path representation, comprising of points, lines, and cubes,  similar to the html5 2d canvas api. It extends CurvePath.",
      "!type": "fn(points: todo)"
    },
    "Shape": {
      "!url": "http://threejs.org/docs/#Reference/extras/core/Shape",
      "prototype": {
        "!proto": "THREE.Path.prototype",
        "holes": {
          "!type": "array",
          "!doc": "todo"
        },
        "makeGeometry": {
          "!type": "fn(options: todo) -> todo",
          "!doc": "Convenience method to return ShapeGeometry"
        },
        "extractAllPoints": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "Get points of shape and holes (keypoints based on segments parameter)"
        },
        "extrude": {
          "!type": "fn(options: todo) -> todo",
          "!doc": "Convenience method to return ExtrudeGeometry"
        },
        "extractPoints": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "todo"
        },
        "extractAllSpacedPoints": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "todo"
        },
        "getPointsHoles": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "Get points of holes"
        },
        "getSpacedPointsHoles": {
          "!type": "fn(divisions: todo) -> todo",
          "!doc": "Get points of holes (spaced by regular distance)"
        }
      },
      "!doc": "Defines a 2d shape plane using paths.",
      "!type": "fn()"
    },
    "ArcCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/ArcCurve",
      "prototype": {
        "!proto": "THREE.EllipseCurve.prototype"
      },
      "!doc": "Alias for [page:EllipseCurve]"
    },
    "CubicBezierCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/CubicBezierCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v0": "+THREE.Vector2",
        "v1": "+THREE.Vector2",
        "v2": "+THREE.Vector2",
        "v3": "+THREE.Vector2"
      },
      "!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>."
    },
    "CubicBezierCurve3": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/CubicBezierCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v0": "+THREE.Vector3",
        "v1": "+THREE.Vector3",
        "v2": "+THREE.Vector3",
        "v3": "+THREE.Vector3"
      },
      "!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>.",
      "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3, v3: +THREE.Vector3)"
    },
    "EllipseCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/EllipseCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "aX": "number",
        "aY": "number",
        "xRadius": "Radians",
        "yRadius": "Radians",
        "aStartAngle": "number",
        "aEndAngle": "number",
        "aClockwise": "bool"
      },
      "!doc": "Creates a 2d curve in the shape of an ellipse.",
      "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: Radians, aEndAngle: Radians, aClockwise: bool)"
    },
    "LineCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/LineCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v1": "+THREE.Vector2",
        "v2": "+THREE.Vector2"
      },
      "!doc": "A curve representing a 2d line segment",
      "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2)"
    },
    "LineCurve3": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/LineCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v1": "+THREE.Vector3",
        "v2": "+THREE.Vector3"
      },
      "!doc": "A curve representing a 3d line segment",
      "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3)"
    },
    "QuadraticBezierCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/QuadraticBezierCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v0": "+THREE.Vector2",
        "v1": "+THREE.Vector2",
        "v2": "+THREE.Vector2"
      },
      "!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
      "!type": "fn(v0: +THREE.Vector2, v1: +THREE.Vector2, v2: +THREE.Vector2)"
    },
    "QuadraticBezierCurve3": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/QuadraticBezierCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "v0": "+THREE.Vector3",
        "v1": "+THREE.Vector3",
        "v2": "+THREE.Vector3"
      },
      "!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
      "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3)"
    },
    "SplineCurve": {
      "!url": "http://threejs.org/docs/#Reference/extras/curves/SplineCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "points": "[]"
      },
      "!doc": "Create a smooth 2d spline curve from a series of points",
      "!type": "fn(points: [])"
    },
    "BoxGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/BoxGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided with the 'width', 'height', and 'depth' constructor arguments.",
      "!type": "fn(width: number, height: number, depth: number, widthSegments: number, heightSegments: number, depthSegments: number)"
    },
    "CircleGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/CircleGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "CircleGeometry is a simple shape of Euclidean geometry.  It is contructed from a number of triangular segments that are oriented around a central point and extend as far out as a given radius.  It is built counter-clockwise from a start angle and a given central angle.  It can also be used to create regular polygons, where the number of segments determines the number of sides.",
      "!type": "fn(radius: number, segments: number, thetaStart: number, thetaLength: number)"
    },
    "CubeGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/CubeGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "Renamed CubeGeometry to BoxGeometry. see [page:BoxGeometry]."
    },
    "CylinderGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/CylinderGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "A class for generating cylinder geometries",
      "!type": "fn(radiusTop: number, radiusBottom: number, height: number, radiusSegments: number, heightSegments: number, openEnded: bool, thetaStart: number, thetaLength: number)"
    },
    "DodecahedronGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/DodecahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        }
      },
      "!doc": "A class for generating a dodecahedron geometries.",
      "!type": "fn(radius: number, detail: number)"
    },
    "ExtrudeGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/ExtrudeGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype",
        "addShapeList": {
          "!type": "fn(shapes: [], options: object)",
          "!doc": "Adds the shapes to the list to extrude."
        },
        "addShape": {
          "!type": "fn(shape: +THREE.Shape, options: object)",
          "!doc": "Add the shape to the list to extrude."
        }
      },
      "!doc": "Creates extruded geometry from a path shape",
      "!type": "fn(shapes: [], options: object)"
    },
    "IcosahedronGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/IcosahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        }
      },
      "!doc": "A class for generating an icosahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "LatheGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/LatheGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "Class for generating meshes with axial symmetry. Possible uses include donuts, pipes, vases etc. The lathe rotate around the Y axis.",
      "!type": "fn(points: [], segments: number, phiStart: number, phiLength: number)"
    },
    "OctahedronGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/OctahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        }
      },
      "!doc": "A class for generating an octahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "ParametricGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/ParametricGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "Generate geometry representing a parametric surface.",
      "!type": "fn(func: function, slices: number, stacks: number)"
    },
    "PlaneGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/PlaneGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "A class for generating plane geometries",
      "!type": "fn(width: number, height: number, widthSegments: number, heightSegments: number)"
    },
    "PolyhedronGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/PolyhedronGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        }
      },
      "!doc": "A polyhedron is a solid in three dimensions with flat faces. This class will take an array of vertices,\n\t\t\tproject them onto a sphere, and then divide them up to the desired level of detail. This class is used\n\t\t\tby [page:DodecahedronGeometry], [page:IcosahedronGeometry], [page:OctahedronGeometry],\n\t\t\tand [page:TetrahedronGeometry] to generate their respective geometries.",
      "!type": "fn(vertices: [], faces: [], radius: number, detail: number)"
    },
    "RingGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/RingGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "A class for generating a two-dimensional ring geometry.",
      "!type": "fn(innerRadius: number, outerRadius: number, thetaSegments: number, phiSegments: number, thetaStart: number, thetaLength: number)"
    },
    "ShapeGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/ShapeGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype",
        "addShape": {
          "!type": "fn(shape: +THREE.Shape, options: object)",
          "!doc": "Adds a single shape to the geometry"
        }
      },
      "!doc": "Creates a one-sided polygonal geometry from one or more path shapes. Similar to [page:ExtrudeGeometry]",
      "!type": "fn(shapes: [], options: object)"
    },
    "SphereGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/SphereGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "A class for generating sphere geometries",
      "!type": "fn(radius: number, widthSegments: number, heightSegments: number, phiStart: number, phiLength: number, thetaStart: number, thetaLength: number)"
    },
    "TetrahedronGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/TetrahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        }
      },
      "!doc": "A class for generating a tetrahedron geometries.",
      "!type": "fn(radius: number, detail: number)"
    },
    "TextGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/TextGeometry",
      "prototype": {
        "!proto": "THREE.ExtrudeGeometry.prototype"
      },
      "!doc": "This object creates an 3D object of text as a single object.",
      "!type": "fn(text: string, parameters: object)"
    },
    "TorusGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/TorusGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "A class for generating torus geometries",
      "!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, arc: number)"
    },
    "TorusKnotGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/TorusKnotGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype"
      },
      "!doc": "Creates a torus knot, the particular shape of which is defined by a pair of coprime integers, p and q.  If p and q are not coprime, the result will be a torus link.",
      "!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, heightScale: number)"
    },
    "TubeGeometry": {
      "!url": "http://threejs.org/docs/#Reference/geometries/TubeGeometry",
      "prototype": {
        "!proto": "THREE.Geometry.prototype",
        "parameters": {
          "!type": "object",
          "!doc": "An object with all of the parameters that were used to generate the geometry."
        },
        "tangents": {
          "!type": "[]",
          "!doc": "An array of [page:Vector3] tangents"
        },
        "normals": {
          "!type": "[]",
          "!doc": "An array of [page:Vector3] normals"
        },
        "binormals": {
          "!type": "[]",
          "!doc": "An array of [page:Vector3] binormals"
        }
      },
      "!doc": "Creates a tube that extrudes along a 3d curve",
      "!type": "fn(path: +THREE.Curve, segments: number, radius: number, radiusSegments: number, closed: bool)"
    },
    "ArrowHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/ArrowHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "line": {
          "!type": "+THREE.Line",
          "!doc": "Contains the line part of the arrowHelper."
        },
        "cone": {
          "!type": "+THREE.Mesh",
          "!doc": "Contains the cone part of the arrowHelper."
        },
        "setColor": {
          "!type": "fn(hex: number)",
          "!doc": "Sets the color of the arrowHelper."
        },
        "setLength": {
          "!type": "fn(length: number, headLength: number, headWidth: number)",
          "!doc": "Sets the length of the arrowhelper."
        },
        "setDirection": {
          "!type": "fn(dir: +THREE.Vector3)",
          "!doc": "Sets the direction of the arrowhelper."
        }
      },
      "!doc": "An 3D arrow Object.",
      "!type": "fn(dir: +THREE.Vector3, origin: +THREE.Vector3, length: number, hex: number, headLength: number, headWidth: number)"
    },
    "AxisHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/AxisHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype"
      },
      "!doc": "An axis object to visualize the the 3 axes in a simple way. <br>\n\t\t\tThe X axis is red. The Y axis is green. The Z axis is blue.",
      "!type": "fn(size: number)"
    },
    "BoundingBoxHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/BoundingBoxHelper",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "object": {
          "!type": "+THREE.Object3D",
          "!doc": "Contains the object3D to show the world-axis-aligned boundingbox."
        },
        "box": {
          "!type": "+THREE.Box3",
          "!doc": "Contains the bounding box of the object."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the BoundingBoxHelper based on the object property."
        }
      },
      "!doc": "A helper object to show the world-axis-aligned bounding box for an object.",
      "!type": "fn(object: +THREE.Object3D, hex: number)"
    },
    "BoxHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/BoxHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "update": {
          "!type": "fn(object: +THREE.Object3D)",
          "!doc": "Updates the helper's geometry to match the dimensions of the [page:Geometry.boundingBox bounding box] of the passed object's geometry.\n\n\t\t<h2>Source</h2>\n\n\t\t[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]"
        }
      },
      "!doc": "Helper object to show a wireframe box (with no face diagonals) around an object",
      "!type": "fn(object: +THREE.Object3D)"
    },
    "CameraHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/CameraHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "pointMap": {
          "!type": "object",
          "!doc": "This contains the points to viualize the cameraHelper"
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The camera to visualize."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper based on the projectionMatrix of the camera."
        }
      },
      "!doc": "The camera Helper is an Object3D which helps visualizing what a camera contains in its frustum.<br>\n\t\tIt visualizes the frustum with an line Geometry.",
      "!type": "fn(camera: +THREE.Camera)"
    },
    "DirectionalLightHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/DirectionalLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "lightPlane": {
          "!type": "+THREE.Line",
          "!doc": "Contains the line mesh showing the location of the directional light."
        },
        "light": {
          "!type": "+THREE.DirectionalLight",
          "!doc": "Contains the directionalLight."
        },
        "targetLine": {
          "!type": "+THREE.Line",
          "!doc": "Contains the line mesh that shows the direction of the light."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the [page:.light]."
        }
      },
      "!doc": "Visualize a [page:DirectionalLight]'s effect on the scene",
      "!type": "fn(light: +THREE.DirectionalLight, size: number)"
    },
    "EdgesHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/EdgesHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype"
      },
      "!doc": "Creates a wireframe object that shows the \"hard\" edges of another object's geometry. To draw a full wireframe image of an object, see [page:WireframeHelper].",
      "!type": "fn(object: +THREE.Object3D, color: +THREE.Color, thresholdAngle: number)"
    },
    "FaceNormalsHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/FaceNormalsHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "object": {
          "!type": "+THREE.Object3D",
          "!doc": "The attached object"
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the face normal preview based on movement of the object."
        }
      },
      "!doc": "Renders [page:ArrowHelper arrows] to visualize an object's [page:Face3 face] normals. Requires that the object's geometry be an instance of [page:Geometry] (does not work with [page:BufferGeometry]), and that face normals have been specified on all [page:Face3 faces] or calculated with [page:Geometry.computeFaceNormals computeFaceNormals].",
      "!type": "fn(object: +THREE.Object3D, size: number, color: +THREE.Color, linewidth: number)"
    },
    "GridHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/GridHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype"
      },
      "!doc": "The GridHelper is an object to define grids. Grids are two-dimensional arrays of lines.",
      "!type": "fn(size: number, step: number)"
    },
    "HemisphereLightHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/HemisphereLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "lightSphere": {
          "!type": "+THREE.Mesh",
          "!doc": "The sphere mesh that shows the location of the hemispherelight."
        },
        "light": {
          "!type": "+THREE.HemisphereLight",
          "!doc": "Contains the HemisphereLight."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the [page:.light]."
        }
      },
      "!doc": "Creates a visual aid for a [page:HemisphereLight HemisphereLight].",
      "!type": "fn(light: +THREE.HemisphereLight, sphereSize: number)"
    },
    "PointLightHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/PointLightHelper",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "lightSphere": {
          "!type": "+THREE.Mesh",
          "!doc": "todo"
        },
        "light": {
          "!type": "+THREE.PointLight",
          "!doc": "todo"
        },
        "update": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "This display a helper for a pointLight",
      "!type": "fn(light: todo, sphereSize: todo)"
    },
    "SpotLightHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/SpotLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "lightSphere": {
          "!type": "+THREE.Mesh",
          "!doc": "todo"
        },
        "light": {
          "!type": "+THREE.SpotLight",
          "!doc": "todo"
        },
        "lightCone": {
          "!type": "+THREE.Mesh",
          "!doc": "todo"
        },
        "update": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "todo",
      "!type": "fn(light: todo, sphereSize: todo)"
    },
    "VertexNormalsHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/VertexNormalsHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "object": {
          "!type": "+THREE.Object3D",
          "!doc": "The attached object"
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the vertex normal preview based on movement of the object."
        }
      },
      "!doc": "Renders [page:ArrowHelper arrows] to visualize an object's vertex normal vectors. Requires that normals have been specified in a [page:BufferAttribute custom attribute] or have been calculated using [page:Geometry.computeVertexNormals computeVertexNormals].",
      "!type": "fn(object: +THREE.Object3D, size: number, color: +THREE.Color, linewidth: number)"
    },
    "WireframeHelper": {
      "!url": "http://threejs.org/docs/#Reference/extras/helpers/WireframeHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype"
      },
      "!doc": "Creates a wireframe object that shows the edges of another object's geometry. To draw a  wireframe image showing only \"hard\" edges (edges between non-coplanar faces), see [page:EdgesHelper].",
      "!type": "fn(object: +THREE.Object3D, color: +THREE.Color)"
    },
    "ImmediateRenderObject": {
      "!url": "http://threejs.org/docs/#Reference/extras/objects/ImmediateRenderObject",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "render": {
          "!type": "fn(renderCallback: function)",
          "!doc": "This function needs to be overridden to start the creation of the object and should call renderCallback when finished."
        }
      },
      "!doc": "base class for immediate rendering objects.",
      "!type": "fn()"
    },
    "AmbientLight": {
      "!url": "http://threejs.org/docs/#Reference/lights/AmbientLight",
      "prototype": {
        "!proto": "THREE.Light.prototype"
      },
      "!doc": "This light's color gets applied to all the objects in the scene globally.",
      "!type": "fn(hex: number)"
    },
    "DirectionalLight": {
      "!url": "http://threejs.org/docs/#Reference/lights/DirectionalLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "Target used for shadow camera orientation."
        },
        "intensity": {
          "!type": "number",
          "!doc": "Light's intensity.<br>\n\t\t\tDefault  *1.0*."
        }
      },
      "!doc": "Affects objects using [page:MeshLambertMaterial] or [page:MeshPhongMaterial].",
      "!type": "fn(hex: number, intensity: number)"
    },
    "HemisphereLight": {
      "!url": "http://threejs.org/docs/#Reference/lights/HemisphereLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "groundColor": {
          "!type": "number",
          "!doc": "Light's ground color.<br>"
        },
        "intensity": {
          "!type": "number",
          "!doc": "Light's intensity.<br>\n\t\t\tDefault  *1.0*."
        }
      },
      "!doc": "A light source positioned directly above the scene.",
      "!type": "fn(skyColorHex: number, groundColorHex: number, intensity: number)"
    },
    "Light": {
      "!url": "http://threejs.org/docs/#Reference/lights/Light",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the light.<br>"
        }
      },
      "!doc": "Abstract base class for lights.",
      "!type": "fn(hex: number)"
    },
    "PointLight": {
      "!url": "http://threejs.org/docs/#Reference/lights/PointLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "intensity": {
          "!type": "number",
          "!doc": "Light's intensity.<br>\n\t\t\tDefault - *1.0*."
        },
        "distance": {
          "!type": "number",
          "!doc": "If non-zero, light will attenuate linearly from maximum intensity at light *position* down to zero at *distance*.<br>\n\t\t\tDefault  *0.0*."
        }
      },
      "!doc": "Affects objects using [page:MeshLambertMaterial] or [page:MeshPhongMaterial].",
      "!type": "fn(hex: number, intensity: number, distance: number)"
    },
    "SpotLight": {
      "!url": "http://threejs.org/docs/#Reference/lights/SpotLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "Spotlight focus points at target.position.<br>\n\t\t\tDefault position  *(0,0,0)*."
        },
        "intensity": {
          "!type": "number",
          "!doc": "Light's intensity.<br>\n\t\t\tDefault  *1.0*."
        },
        "distance": {
          "!type": "number",
          "!doc": "If non-zero, light will attenuate linearly from maximum intensity at light *position* down to zero at *distance*.<br>\n\t\t\tDefault  *0.0*."
        },
        "angle": {
          "!type": "number",
          "!doc": "Maximum extent of the spotlight, in radians, from its direction. Should be no more than *Math.PI/2*.<br>\n\t\t\tDefault  *Math.PI/3*."
        },
        "exponent": {
          "!type": "number",
          "!doc": "Rapidity of the falloff of light from its target direction.<br>\n\t\t\tDefault  *10.0*."
        }
      },
      "!doc": "A point light that can cast shadow in one direction.",
      "!type": "fn(hex: number, intensity: number, distance: todo, angle: todo, exponent: todo)"
    },
    "BabylonLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/BabylonLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.Object3D",
          "!doc": "Parse a <em>JSON</em> structure and return an [page:Object3D object] or a [page:Scene scene].<br>\n\t\tFound objects are converted to [page:Mesh] with a [page:BufferGeometry] and a default [page:MeshPhongMaterial].<br>\n\t\tLights are parsed accordingly."
        }
      },
      "!doc": "A loader for loading a <em>.babylon</em> resource.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "BufferGeometryLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/BufferGeometryLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.BufferGeometry",
          "!doc": "Parse a <em>JSON</em> structure and return a [page:BufferGeometry]."
        }
      },
      "!doc": "A loader for loading a [page:BufferGeometry].",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "Cache": {
      "!url": "http://threejs.org/docs/#Reference/loaders/Cache",
      "prototype": {
        "files": {
          "!type": "object",
          "!doc": "An [page:Object object] that hold cached values."
        },
        "add": {
          "!type": "fn(key: string, value)",
          "!doc": "Adds a cache entry with that key to hold the value. If this key already holds a value, it is overwritten."
        },
        "get": {
          "!type": "fn(key: string)",
          "!doc": "Get the value of key. If the key does not exist the null value is returned."
        },
        "remove": {
          "!type": "fn(key: string)",
          "!doc": "Remove the cached value associated with the key."
        },
        "clear": {
          "!type": "fn()",
          "!doc": "Remove all values from the cache."
        }
      },
      "!doc": "A simple caching classe, used internaly by [page:FileLoader].",
      "!type": "fn()"
    },
    "ColladaLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/ColladaLoader",
      "prototype": {
        "options": {
          "!type": "[]",
          "!doc": "&nbsp;.[page:Boolean centerGeometry]  Force [page:Geometry] to always be centered at the local origin of the containing [page: Mesh].<br>\n\t\t&nbsp;.[page:Boolean convertUpAxis]  Axis conversion is done for geometries, animations, and controllers.<br>\n\t\t&nbsp;.[page:Boolean subdivideFaces]  Force subdivision into multiple [page: Face3].<br>\n\t\t&nbsp;.[page:String upAxis]  X, Y or Z<br>\n\t\t&nbsp;.[page:Boolean defaultEnvMap]  Cubemap to use for reflective or refractive materials.<br>"
        },
        "geometries": {
          "!type": "object",
          "!doc": "Parsed <em>.dae</em> geometries."
        },
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(doc: Document, callBack: function, url: string) -> object",
          "!doc": "Parse an <em>XML Document</em> and return an [page:Object object] that contain loaded parts: .[page:Scene scene], .[page:Array morphs], .[page:Array skins], .[page:Array animations], .[page:Object dae]"
        },
        "setPreferredShading": {
          "!type": "fn(shading: number)",
          "!doc": "Set the .[page:Integer shading] property on the resource's materials.<br>\n\t\tOptions are [page:Materials THREE.SmoothShading], [page:Materials THREE.FlatShading]."
        },
        "applySkin": {
          "!type": "fn(geometry: +THREE.Geometry, instanceCtrl: object, frame: number)",
          "!doc": "Apply a skin (vertices, animation, bones) from a <em>collada skin controller</em>, on the given [page:Geometry]."
        }
      },
      "!doc": "A loader for <em>Collada</em> files.",
      "!type": "fn()"
    },
    "ImageLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/ImageLoader",
      "prototype": {
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and return the [page:Image image] object that will contain the data."
        },
        "setCrossOrigin": {
          "!type": "fn(value: string)",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        }
      },
      "!doc": "A loader for loading an [page:Image].",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "JSONLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/JSONLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "withCredentials": {
          "!type": "boolean",
          "!doc": "If true, the ajax request will use cookies."
        },
        "onLoadStart": {
          "!type": "function",
          "!doc": "The default is a function with empty body."
        },
        "onLoadComplete": {
          "!type": "function",
          "!doc": "The default is a function with empty body."
        },
        "load": {
          "!type": "fn(url: string, callback: function, texturePath: string)",
          "!doc": "[page:String url]  required<br>\n\t\t[page:Function callback]  required. Will be called when load completes. The arguments will be the loaded [page:Object3D] and the loaded [page:Array materials].<br>\n\t\t[page:String texturePath]  optional. If not specified, textures will be assumed to be in the same folder as the Javascript model file."
        },
        "loadAjaxJSON": {
          "!type": "fn(context: +THREE.JSONLoader, url: string, callback: function, texturePath: string, callbackProgress: function)",
          "!doc": "Begin loading from url and call <em>callback</em> with the parsed response content."
        },
        "parse": {
          "!type": "fn(json: object, texturePath: string) -> +THREE.Object3D",
          "!doc": "Parse a <em>JSON</em> structure and return an [page:Object] containing the parsed .[page:Geometry] and .[page:Array materials]."
        },
        "updateProgress": {
          "!type": "fn(progress: object)",
          "!doc": "Updates the DOM object with the progress made."
        },
        "createMaterial": {
          "!type": "fn(m: object, texturePath: string) -> +THREE.Material",
          "!doc": "Creates the Material based on the parameters m."
        },
        "initMaterials": {
          "!type": "fn(materials: [], texturePath: string) -> []",
          "!doc": "Creates an array of [page:Material] based on the array of parameters m. The index of the parameters decide the correct index of the materials."
        },
        "extractUrlBase": {
          "!type": "fn(url: string) -> string",
          "!doc": "Extract the base from the URL."
        }
      },
      "!doc": "A loader for loading objects in JSON format.",
      "!type": "fn()"
    },
    "Loader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/Loader",
      "prototype": {
        "onLoadStart": {
          "!type": "function",
          "!doc": "The default is a function with empty body."
        },
        "onLoadProgress": {
          "!type": "function",
          "!doc": "The default is a function with empty body."
        },
        "onLoadComplete": {
          "!type": "function",
          "!doc": "The default is a function with empty body."
        },
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "updateProgress": {
          "!type": "fn(progress: object)",
          "!doc": "Updates the DOM object with the progress made."
        },
        "createMaterial": {
          "!type": "fn(m: object, texturePath: string) -> +THREE.Material",
          "!doc": "Creates the Material based on the parameters m."
        },
        "initMaterials": {
          "!type": "fn(materials: [], texturePath: string) -> []",
          "!doc": "Creates an array of [page:Material] based on the array of parameters m. The index of the parameters decide the correct index of the materials."
        },
        "extractUrlBase": {
          "!type": "fn(url: string) -> string",
          "!doc": "Extract the base from the URL."
        }
      },
      "!doc": "Base class for implementing loaders.",
      "!type": "fn()"
    },
    "LoadingManager": {
      "!url": "http://threejs.org/docs/#Reference/loaders/LoadingManager",
      "prototype": {
        "onLoad": {
          "!type": "function",
          "!doc": "The function that needs to be called when all loaders are done."
        },
        "onProgress": {
          "!type": "function",
          "!doc": "The function that needs to be called when an item is complete. The arguments are url(The url of the item just loaded),<br>\n\t\tloaded(the amount of items already loaded), total( The total amount of items to be loaded.)"
        },
        "onError": {
          "!type": "function",
          "!doc": "The function that needs to be called when an item errors."
        },
        "itemStart": {
          "!type": "fn(url: string)",
          "!doc": "This should be called by any loader used by the manager when the loader starts loading an url. These shouldn't be called outside a loader."
        },
        "itemEnd": {
          "!type": "fn(url: string)",
          "!doc": "This should be called by any loader used by the manager when the loader ended loading an url.  These shouldn't be called outside a loader."
        }
      },
      "!doc": "Handles and keeps track of loaded and pending data.",
      "!type": "fn(onLoad: function, onProgress: function, onError: function)"
    },
    "MTLLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/MTLLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and return the loaded material."
        },
        "parse": {
          "!type": "fn(text: string) -> MTLLoaderMaterialCreator",
          "!doc": "Parse a <em>mtl</em> text structure and return a [page:MTLLoaderMaterialCreator] instance.<br>"
        }
      },
      "!doc": "A loader for loading an <em>.mtl</em> resource, used internaly by [page:OBJMTLLoader] and [page:UTF8Loader].",
      "!type": "fn(baseUrl: string, options: object, crossOrigin: string)"
    },
    "MaterialLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/MaterialLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and return the [page:Material] object that will contain the data."
        },
        "setCrossOrigin": {
          "!type": "fn(value: string)",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.Material",
          "!doc": "Parse a <em>JSON</em> structure and create a new [page:Material] of the type [page:String json.type] with parameters defined in the json object."
        }
      },
      "!doc": "A loader for loading a [page:Material] in JSON format.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "OBJLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/OBJLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(text: string) -> +THREE.Object3D",
          "!doc": "Parse an <em>obj</em> text structure and return an [page:Object3D].<br>\n\t\tFound objects are converted to [page:Mesh] with a [page:BufferGeometry] and a default [page:MeshLambertMaterial]."
        }
      },
      "!doc": "A loader for loading an <em>.obj</em> resource.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "OBJMTLLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/OBJMTLLoader",
      "prototype": {
        "load": {
          "!type": "fn(objUrl: string, mtlUrl: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from urls and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(text: string, mtllibCallback: function) -> +THREE.Object3D",
          "!doc": "Parse an <em>obj</em> text structure and return an [page:Object3D].<br>\n\t\tFound objects are converted to a [page:Mesh] and materials are converted to [page:MeshLambertMaterial]."
        }
      },
      "!doc": "A loader for loading a <em>.obj</em> and its <em>.mtl</em> together.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "ObjectLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/ObjectLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.Object3D",
          "!doc": "Parse a <em>JSON</em> content and return a threejs object."
        },
        "setCrossOrigin": {
          "!type": "fn(value: string)",
          "!doc": "[page:String value]  The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        }
      },
      "!doc": "A loader for loading a JSON resource. Unlike the [page:JSONLoader], this one make use of the <em>.type</em> attributes of objects to map them to their original classes.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "PDBLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/PDBLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the parsed response content."
        },
        "parsePDB": {
          "!type": "fn(text: string) -> object",
          "!doc": "Parse a <em>pdb</em> text and return a <em>JSON</em> structure.<br>"
        },
        "createModel": {
          "!type": "fn(json: object, callback: function)",
          "!doc": "Parse a <em>(JSON) pdb</em> structure and return two [page:Geometry]: one for atoms, one for bonds.<br>"
        }
      },
      "!doc": "A loader for loading a <em>.pdb</em> resource.\n\t\t<br><br>\n\t\tThe <a href=\"http://en.wikipedia.org/wiki/Protein_Data_Bank_(file_format)\">Protein Data Bank file format</a> is a textual file format describing the three-dimensional structures of molecules.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "SVGLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/SVGLoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and call onLoad with the response content."
        }
      },
      "!doc": "A loader for loading an <em>.svg</em> resource.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "TGALoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/TGALoader",
      "prototype": {
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function) -> +THREE.DataTexture",
          "!doc": "Begin loading from url and pass the loaded [page:DataTexture texture] to onLoad. The [page:DataTexture texture] is also directly returned for immediate use (but may not be fully loaded)."
        }
      },
      "!doc": "Class for loading a <em>.tga</em> [page:DataTexture texture].",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "TextureLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/TextureLoader",
      "prototype": {
        "crossOrigin": {
          "!type": "string",
          "!doc": "default  *null*.<br>\n\t\tIf set, assigns the *crossOrigin* attribute of the image to the value of *crossOrigin*, prior to starting the load."
        },
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and pass the loaded [page:Texture texture] to onLoad."
        }
      },
      "!doc": "Class for loading a [page:Texture texture].",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "FileLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/FileLoader",
      "prototype": {
        "cache": {
          "!type": "+THREE.Cache",
          "!doc": "A [page:Cache cache] instance that hold the response from each request made through this loader, so each file is requested once."
        },
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "responseType": {
          "!type": "string",
          "!doc": "Can be set to change the response type."
        },
        "load": {
          "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
          "!doc": "Begin loading from url and return the [page:String text] response that will contain the data."
        },
        "setCrossOrigin": {
          "!type": "fn(value: string)",
          "!doc": "[page:String value]  The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "setResponseType": {
          "!type": "fn(value: string)",
          "!doc": "[page:String value]  the empty string (default), \"arraybuffer\", \"blob\", \"document\", \"json\", or \"text\"."
        }
      },
      "!doc": "A low level class for loading resources with XMLHttpRequest, used internaly by most loaders.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "GLTFLoader": {
      "!url": "http://threejs.org/docs/#Reference/loaders/GLTFLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "load": {
          "!type": "fn(url: string, callback: function) -> +THREE.Object3D",
          "!doc": "Begin loading from url and call the callback function with the parsed response content."
        }
      },
      "!doc": "A loader for loading a <em>.gltf</em> resource in <em>JSON</em> format.\n\t\t<br><br>\n\t\tThe <a href=\"https://www.khronos.org/gltf\">glTF file format</a> is a JSON file format to enable rapid delivery and loading of 3D content.",
      "!type": "fn()"
    },
    "LineBasicMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/LineBasicMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "number",
          "!doc": "Sets the color of the line. Default is 0xffffff."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "linecap": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "linejoin": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "vertexColors": {
          "!type": "number",
          "!doc": "This setting might not have any effect when used with certain renderers."
        },
        "fog": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        }
      },
      "!doc": "A material for drawing wireframe-style geometries.",
      "!type": "fn(parameters: object)"
    },
    "LineDashedMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/LineDashedMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Sets the color of the line. Default is 0xffffff."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "scale": {
          "!type": "number",
          "!doc": "The scale of the dashed part of a line."
        },
        "dashSize": {
          "!type": "number",
          "!doc": "The size of the dash. This is both the gap with the stroke. Default is 3."
        },
        "gapSize": {
          "!type": "number",
          "!doc": "The size of the gap. Default is 1."
        },
        "vertexColors": {
          "!type": "boolean",
          "!doc": "This setting might not have any effect when used with certain renderers."
        },
        "fog": {
          "!type": "boolean",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        }
      },
      "!doc": "A material for drawing wireframe-style geometries with dashed lines.",
      "!type": "fn(parameters: object)"
    },
    "Material": {
      "!url": "http://threejs.org/docs/#Reference/materials/Material",
      "prototype": {
        "id": {
          "!type": "number",
          "!doc": "Unique number for this material instance."
        },
        "name": {
          "!type": "string",
          "!doc": "Material name. Default is an empty string."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Default is *1.0*."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Default is *false*."
        },
        "blendDst": {
          "!type": "number",
          "!doc": "Blending destination. It's one of the blending mode constants defined in [page:Three Three.js]. Default is [page:CustomBlendingEquation OneMinusSrcAlphaFactor]."
        },
        "blendEquation": {
          "!type": "number",
          "!doc": "Blending equation to use when applying blending. It's one of the constants defined in [page:Three Three.js]. Default is [page:CustomBlendingEquation AddEquation.]"
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. Default is *true*."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset. Default is *false*. This corresponds to the *POLYGON_OFFSET_FILL* WebGL feature."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Sets the polygon offset factor. Default is *0*."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Sets the polygon offset units. Default is *0*."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. Default is *0*."
        },
        "overdraw": {
          "!type": "number",
          "!doc": "Amount of triangle expansion at draw time. This is a workaround for cases when gaps appear between triangles when using [page:CanvasRenderer]. *0.5* tends to give good results across browsers. Default is *0*."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether this material is visible. Default is *true*."
        },
        "side": {
          "!type": "Enum",
          "!doc": "Default is [page:Materials THREE.FrontSide]. Other options are [page:Materials THREE.BackSide] and [page:Materials THREE.DoubleSide]."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "This property is automatically set to *true* when instancing a new material."
        },
        "clone": {
          "!type": "fn(material: material) -> +THREE.Material",
          "!doc": "This clones the material in the optional parameter and returns it."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "This disposes the material."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets the properties based on the *values*."
        }
      },
      "!doc": "Materials describe the appearance of [page:Object objects]. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.",
      "!type": "fn()"
    },
    "MeshBasicMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MeshBasicMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "number",
          "!doc": "Sets the color of the geometry. Default is 0xffffff."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set light map. Default is null."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set specular map. Default is null."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "envMap": {
          "!type": "TextureCube",
          "!doc": "Set env map. Default is null."
        },
        "fog": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "shading": {
          "!type": "string",
          "!doc": "Define shading type. Default is THREE.SmoothShading."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Render geometry as wireframe. Default is false (i.e. render as flat polygons)."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "wireframeLinecap": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "wireframeLinejoin": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "vertexColors": {
          "!type": "number",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "skinning": {
          "!type": "bool",
          "!doc": "Define whether the material uses skinning. Default is false."
        },
        "morphTargets": {
          "!type": "bool",
          "!doc": "Define whether the material uses morphTargets. Default is false."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Sets the texture map. Default is  null."
        },
        "combine": {
          "!type": "number",
          "!doc": "How to combine the result of the surface's color with the environment map, if any."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface; also see \"combine\"."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
        }
      },
      "!doc": "A material for drawing geometries in a simple shaded (flat or wireframe) way.",
      "!type": "fn(parameters: object)"
    },
    "MeshDepthMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MeshDepthMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "morphTargets": {
          "!type": "boolean",
          "!doc": "Define whether the material uses morphTargets. Default is false."
        },
        "wireframe": {
          "!type": "boolean",
          "!doc": "Render geometry as wireframe. Default is false (i.e. render as smooth shaded)."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls wireframe thickness. Default is 1.<br><br>\n\t\t\tDue to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value."
        }
      },
      "!doc": "A material for drawing geometry by depth. Depth is based off of the camera near and far plane. White is nearest, black is farthest.",
      "!type": "fn(parameters: object)"
    },
    "MultiMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MultiMaterial",
      "prototype": {
        "materials": {
          "!type": "[]",
          "!doc": "Get or set the materials for the geometry."
        }
      },
      "!doc": "A Material to define multiple materials for the same geometry. \n\t\tThe geometry decides which material is used for which faces by the [page:Face3 faces materialindex].\n\t\tThe materialindex corresponds with the index of the material in the materials array.",
      "!type": "fn(materials: [])"
    },
    "MeshLambertMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MeshLambertMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Diffuse color of the material. Default is white.<br>"
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting. Default is black.<br>"
        },
        "wrapAround": {
          "!type": "boolean",
          "!doc": "Define whether the diffuse lighting wraps around the model or not. This option adds a little more (tintable) light\n\t\t\tonto the side of the object in relation to a light."
        },
        "wrapRGB": {
          "!type": "+THREE.Vector3",
          "!doc": "Decide how much of the wrap around values get used if the wrapAround option is set. The x, y, z values correspond\n\t\t\tto the r, g, b values respectively. The typical range is of each is from 0 to 1. For example setting all of the\n\t\t\tvector values to 0.5 will add a moderate amount of light to the side of the model. Changing *b* to 1 will\n\t\t\ttint the light on the side to be more blue. Defaults to *(1,1,1)*."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Set color texture map. Default is null."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set light map. Default is null."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "Since this material does not have a specular component, the specular value affects only how much of the environment map affects the surface. Default is null."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "envMap": {
          "!type": "TextureCube",
          "!doc": "Set env map. Default is null."
        },
        "combine": {
          "!type": "number",
          "!doc": "Options are [page:Textures THREE.Multiply] (default), [page:Textures THREE.MixOperation], [page:Textures THREE.AddOperation]. If mix is chosen, the reflectivity is used to blend between the two colors."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface; also see \"combine\"."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
        },
        "fog": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "shading": {
          "!type": "number",
          "!doc": "Options are [page:Materials THREE.SmoothShading] (default), [page:Materials THREE.FlatShading]."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Whether the triangles' edges are displayed instead of surfaces. Default is *false*."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "wireframeLinecap": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "wireframeLinejoin": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "vertexColors": {
          "!type": "number",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "skinning": {
          "!type": "bool",
          "!doc": "Define whether the material uses skinning. Default is *false*."
        },
        "morphTargets": {
          "!type": "bool",
          "!doc": "Define whether the material uses morphTargets. Default is *false*."
        },
        "morphNormals": {
          "!type": "boolean",
          "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
        }
      },
      "!doc": "A material for non-shiny (Lambertian) surfaces, evaluated per vertex.",
      "!type": "fn(parameters: object)"
    },
    "MeshNormalMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MeshNormalMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "wireframe": {
          "!type": "boolean",
          "!doc": "Render geometry as wireframe. Default is false (i.e. render as smooth shaded)."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls wireframe thickness. Default is 1.<br><br>\n\t\t\tDue to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "morphTargets": {
          "!type": "boolean",
          "!doc": "Define whether the material uses morphTargets. Default is false."
        }
      },
      "!doc": "A material that maps the normal vectors to RGB colors.",
      "!type": "fn(parameters: object)"
    },
    "MeshPhongMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/MeshPhongMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Diffuse color of the material. Default is white.<br>"
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting. Default is black.<br>"
        },
        "specular": {
          "!type": "+THREE.Color",
          "!doc": "Specular color of the material, i.e., how shiny the material is and the color of its shine. Setting this the same color as the diffuse value (times some intensity) makes the material more metallic-looking; setting this to some gray makes the material look more plastic. Default is dark gray.<br>"
        },
        "shininess": {
          "!type": "number",
          "!doc": "How shiny the specular highlight is; a higher value gives a sharper highlight. Default is *30*. It should not be set to 0."
        },
        "metal": {
          "!type": "boolean",
          "!doc": "If set to true the shader multiplies the specular highlight by the underlying color of the object, making\n\t\t\tit appear to be more metal-like and darker. If set to false the specular highlight is added ontop of the\n\t\t\tunderlying colors."
        },
        "wrapAround": {
          "!type": "boolean",
          "!doc": "Define whether the diffuse lighting wraps around the model or not. This option adds a little more (tintable) light\n\t\t\tonto the side of the object in relation to a light."
        },
        "wrapRGB": {
          "!type": "+THREE.Vector3",
          "!doc": "Decide how much of the wrap around values get used if the wrapAround option is set. The x, y, z values correspond\n\t\t\tto the r, g, b values respectively. The typical range is of each is from 0 to 1. For example setting all of the\n\t\t\tvector values to 0.5 will add a moderate amount of light to the side of the model. Changing *b* to 1 will\n\t\t\ttint the light on the side to be more blue. Defaults to (1,1,1)."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Set color texture map. Default is null."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set light map. Default is null."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights.\n\t\t\tBump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will\n\t\t\tbe ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical ranges are 0-1. Default is 1."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change\n\t\t\tthe way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical ranges are 0-1. Default is (1,1)."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "The specular map value affects both how much the specular surface highlight contributes and how much of the environment map affects the surface. Default is null."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "envMap": {
          "!type": "TextureCube",
          "!doc": "Set env map. Default is null."
        },
        "combine": {
          "!type": "number",
          "!doc": "Options are [page:Textures THREE.MultiplyOperation] (default), [page:Textures THREE.MixOperation], [page:Textures THREE.AddOperation]. If mix is chosen, the reflectivity is used to blend between the two colors."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface; also see \"combine\"."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
        },
        "fog": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "shading": {
          "!type": "number",
          "!doc": "Options are [page:Materials THREE.SmoothShading] (default), [page:Materials THREE.FlatShading]."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Whether the triangles' edges are displayed instead of surfaces. Default is *false*."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "wireframeLinecap": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "wireframeLinejoin": {
          "!type": "string",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
        },
        "vertexColors": {
          "!type": "number",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "skinning": {
          "!type": "bool",
          "!doc": "Define whether the material uses skinning. Default is *false*."
        },
        "morphTargets": {
          "!type": "bool",
          "!doc": "Define whether the material uses morphTargets. Default is *false*."
        },
        "morphNormals": {
          "!type": "boolean",
          "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
        }
      },
      "!doc": "A material for shiny surfaces, evaluated per pixel.",
      "!type": "fn(parameters: object)"
    },
    "PointCloudMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/PointCloudMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "number",
          "!doc": "Sets the color of the particles. Default is 0xffffff."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Sets the color of the particles using data from a texture."
        },
        "size": {
          "!type": "number",
          "!doc": "Sets the size of the particles. Default is 1.0."
        },
        "sizeAttenuation": {
          "!type": "bool",
          "!doc": "Specify whether particles' size will get smaller with the distance. Default is true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        },
        "fog": {
          "!type": "bool",
          "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
        }
      },
      "!doc": "The default material used by [page:PointCloud particle] systems.",
      "!type": "fn(parameters: object)"
    },
    "RawShaderMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/RawShaderMaterial",
      "prototype": {
        "!proto": "THREE.ShaderMaterial.prototype"
      },
      "!doc": "This class works just like [page:ShaderMaterial], except that definitions of built-in uniforms and attributes are not automatically prepended to the GLSL shader code."
    },
    "ShaderMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/ShaderMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "uniforms": {
          "!type": "object",
          "!doc": "Object specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form\n\t\t<code>\n\t\t{ type: 'f', value: 1.0 }\n\t\t</code>\n\t\twhere *type* is a <a href=\"#uniform-types\">uniform type string</a>, and *value* is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code."
        },
        "attributes": {
          "!type": "object",
          "!doc": "<p>\n\t\tObject specifying the custom attributes to be passed to the shader code; keys are attribute names, values are definitions of the form\n\t\t<code>\n\t\t{ type: 'f', value: [1.0, 0.5, 2.0, ...] }\n\t\t</code>\n\t\twhere *type* is an <a href=\"#attribute-types\">attribute type string</a>, and *value* is an array containing an attribute value for each vertex in the geometry (or *undefined* if using [page:BufferGeometry]). Names must match the name of the attribute, as defined in the GLSL code.\n\t\t</p>\n\t\t<p>\n\t\tNote that attribute buffers are <emph>not</emph> refreshed automatically when their values change; if using [page:Geometry], set <code>needsUpdate = true</code> on the attribute definition. If using [page:BufferGeometry], set <code>needsUpdate = true</code> on the [page:BufferAttribute].\n\t\t</p>"
        },
        "defines": {
          "!type": "object",
          "!doc": "Defines custom constants using *#define* directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive:\n\t\t<code>\n\t\tdefines: {\n\t\t\tFOO: 15,\n\t\t\tBAR: true\n\t\t}\n\t\t</code>\n\t\tyields the lines\n\t\t<code>\n\t\t#define FOO 15\n\t\t#define BAR true\n\t\t</code>\n\t\tin the GLSL code."
        },
        "vertexShader": {
          "!type": "string",
          "!doc": "Vertex shader GLSL code.  This is the actual code for the shader. In the example above, the *vertexShader* and *fragmentShader* code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead."
        },
        "fragmentShader": {
          "!type": "string",
          "!doc": "Fragment shader GLSL code.  This is the actual code for the shader. In the example above, the *vertexShader* and *fragmentShader* code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead."
        },
        "shading": {
          "!type": "number",
          "!doc": "Define shading type, which determines whether normals are smoothed between vertices; possible values are [page:Materials THREE.SmoothShading] or [page:Materials THREE.FlatShading]. Default is THREE.SmoothShading."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Render geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false (i.e. render as flat polygons)."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Define whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Default is false."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader"
        },
        "vertexColors": {
          "!type": "number",
          "!doc": "Define how the vertices are colored, by defining how the *colors* attribute gets populated. Possible values are [page:Materials THREE.NoColors], [page:Materials THREE.FaceColors] and [page:Materials THREE.VertexColors]. Default is THREE.NoColors."
        },
        "skinning": {
          "!type": "bool",
          "!doc": "Define whether the material uses skinning; true to pass skinning attributes to the shader. Default is false."
        },
        "morphTargets": {
          "!type": "bool",
          "!doc": "Defines whether the material uses morphTargets; true morphTarget attributes to this shader"
        },
        "morphNormals": {
          "!type": "boolean",
          "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
        },
        "program": {
          "!type": "+THREE.WebGLProgram",
          "!doc": "The compiled shader program associated with this material, generated by [page:WebGLRenderer]. You should not need to access this property."
        },
        "clone": {
          "!type": "fn() -> +THREE.ShaderMaterial",
          "!doc": "Generates a shallow copy of this material. Note that the vertexShader and fragmentShader are copied <emph>by reference</emph>, as are the definitions of the *attributes*; this means that clones of the material will share the same compiled [page:WebGLProgram]. However, the *uniforms* are copied <emph>by value</emph>, which allows you to have different sets of uniforms for different copies of the material."
        }
      },
      "!doc": "Material rendered with custom shaders. A shader is a small program written in [link:https://www.opengl.org/documentation/glsl/ GLSL] to run on the GPU. You may want to use a custom shader if you need to:\n\t\t<ul>\n\t\t\t<li>implement an effect not included with any of the built-in [page:Material materials]</li>\n\t\t\t<li>combine many objects into a single [page:Geometry] or [page:BufferGeometry] in order to improve performance</li>\n\t\t\t<li>associate custom data with individual vertices (\"custom attributes\")</li>\n\t\t</ul>\n\t\tNote that a ShaderMaterial will only be rendered properly by [page:WebGLRenderer], since the GLSL code in the vertexShader and fragmentShader properties must be compiled and run on the GPU using WebGL.",
      "!type": "fn(parameters: object)"
    },
    "SpriteCanvasMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/SpriteCanvasMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The color of the sprite. The material will set up the color for the context before calling the material's program."
        },
        "program": {
          "!type": "fn(context: CanvasRenderingContext2D, color: +THREE.Color)",
          "!doc": "Define a program that will use the context to draw the sprite."
        }
      },
      "!doc": "Create a material that can draw custom sprites using a 2d canvas.",
      "!type": "fn(parameters: object)"
    },
    "SpriteMaterial": {
      "!url": "http://threejs.org/docs/#Reference/materials/SpriteMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The texture is multiplied by this color. The default is 0xffffff"
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The texture map. Default is null."
        },
        "rotation": {
          "!type": "Radians",
          "!doc": "The rotation of the sprite in radians. Default is 0."
        },
        "fog": {
          "!type": "boolean",
          "!doc": "Whether or not this material affected by the scene's fog. Default is false"
        }
      },
      "!doc": "A material for a [page:Sprite].",
      "!type": "fn(parameters: object)"
    },
    "Box2": {
      "!url": "http://threejs.org/docs/#Reference/math/Box2",
      "prototype": {
        "min": {
          "!type": "+THREE.Vector2",
          "!doc": "Lower (x, y) boundary of this box."
        },
        "max": {
          "!type": "+THREE.Vector2",
          "!doc": "Upper (x, y) boundary of this box."
        },
        "set": {
          "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Sets the lower and upper (x, y) boundaries of this box."
        },
        "expandByPoint": {
          "!type": "fn(point: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Expands the boundaries of this box to include *point*."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector2, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Clamps *point* within the bounds of this box."
        },
        "isIntersectionBox": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Determines whether or not this box intersects *box*."
        },
        "setFromPoints": {
          "!type": "fn(points: []) -> +THREE.Box2",
          "!doc": "Sets the upper and lower bounds of this box to include all of the points in *points*."
        },
        "size": {
          "!type": "fn(optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns the width and height of this box."
        },
        "union": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Unions this box with *box* setting the upper bound of this box to the greater of the \n\t\ttwo boxes' upper bounds and the lower bound of this box to the lesser of the two boxes'\n\t\tlower bounds."
        },
        "getParameter": {
          "!type": "fn(point: +THREE.Vector2, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point as a proportion of this box's width and height."
        },
        "expandByScalar": {
          "!type": "fn(scalar: float) -> +THREE.Box2",
          "!doc": "Expands each dimension of the box by *scalar*. If negative, the dimensions of the box <br>\n\t\twill be contracted."
        },
        "intersect": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Returns the intersection of this and *box*, setting the upper bound of this box to the lesser <br>\n\t\tof the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' <br>\n\t\tlower bounds."
        },
        "containsBox": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Returns true if this box includes the entirety of *box*. If this and *box* overlap exactly,<br>\n\t\tthis function also returns true."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Adds *offset* to both the upper and lower bounds of this box, effectively moving this box <br>\n\t\t*offset* units in 2D space."
        },
        "empty": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if this box includes zero points within its bounds.<br>\n\t\tNote that a box with equal lower and upper bounds still includes one point, the\n\t\tone both bounds share."
        },
        "clone": {
          "!type": "fn() -> +THREE.Box2",
          "!doc": "Returns a copy of this box."
        },
        "equals": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Returns true if this box and *box* share the same lower and upper bounds."
        },
        "expandByVector": {
          "!type": "fn(vector: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Expands this box equilaterally by *vector*. The width of this box will be\n\t\texpanded by the x component of *vector* in both directions. The height of \n\t\tthis box will be expanded by the y component of *vector* in both directions."
        },
        "copy": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Copies the values of *box* to this box."
        },
        "makeEmpty": {
          "!type": "fn() -> +THREE.Box2",
          "!doc": "Makes this box empty."
        },
        "center": {
          "!type": "fn(optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns the center point of this box."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector2) -> number",
          "!doc": "Returns the distance from any edge of this box to the specified point. <br>\n\t\tIf the point lies inside of this box, the distance will be 0."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector2) -> bool",
          "!doc": "Returns true if the specified point lies within the boundaries of this box."
        },
        "setFromCenterAndSize": {
          "!type": "fn(center: +THREE.Vector2, size: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Centers this box on *center* and sets this box's width and height to the values specified\n\t\tin *size*."
        }
      },
      "!doc": "Represents a boundary box in 2D space.",
      "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2)"
    },
    "Box3": {
      "!url": "http://threejs.org/docs/#Reference/math/Box3",
      "prototype": {
        "min": {
          "!type": "+THREE.Vector3",
          "!doc": "Lower (x, y, z) boundary of this box."
        },
        "max": {
          "!type": "+THREE.Vector3",
          "!doc": "Upper (x, y, z) boundary of this box."
        },
        "set": {
          "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Sets the lower and upper (x, y, z) boundaries of this box."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Box3",
          "!doc": "Transforms this Box3 with the supplied matrix."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Clamps *point* within the bounds of this box."
        },
        "isIntersectionBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Determines whether or not this box intersects *box*."
        },
        "setFromPoints": {
          "!type": "fn(points: []) -> +THREE.Box3",
          "!doc": "Sets the upper and lower bounds of this box to include all of the points in *points*."
        },
        "setFromObject": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Box3",
          "!doc": "Computes the world-axis-aligned bounding box of an object (including its children),\n\t\taccounting for both the object's, and childrens', world transforms"
        },
        "size": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the width, height, and depth of this box."
        },
        "union": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Unions this box with *box* setting the upper bound of this box to the greater of the \n\t\ttwo boxes' upper bounds and the lower bound of this box to the lesser of the two boxes'\n\t\tlower bounds."
        },
        "getParameter": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns point as a proportion of this box's width and height."
        },
        "intersect": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Returns the intersection of this and *box*, setting the upper bound of this box to the lesser <br>\n\t\tof the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' <br>\n\t\tlower bounds."
        },
        "containsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this box includes the entirety of *box*. If this and *box* overlap exactly,<br>\n\t\tthis function also returns true."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Returns true if the specified point lies within the boundaries of this box."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Adds *offset* to both the upper and lower bounds of this box, effectively moving this box <br>\n\t\t*offset* units in 3D space."
        },
        "empty": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if this box includes zero points within its bounds.<br>\n\t\tNote that a box with equal lower and upper bounds still includes one point, the\n\t\tone both bounds share."
        },
        "clone": {
          "!type": "fn() -> +THREE.Box3",
          "!doc": "Returns a copy of this box."
        },
        "equals": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this box and *box* share the same lower and upper bounds."
        },
        "expandByPoint": {
          "!type": "fn(point: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Expands the boundaries of this box to include *point*."
        },
        "expandByScalar": {
          "!type": "fn(scalar: float) -> +THREE.Box3",
          "!doc": "Expands each dimension of the box by *scalar*. If negative, the dimensions of the box <br>\n\t\twill be contracted."
        },
        "expandByVector": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Expands this box equilaterally by *vector*. The width of this box will be\n\t\texpanded by the x component of *vector* in both directions. The height of \n\t\tthis box will be expanded by the y component of *vector* in both directions.\n\t\tThe depth of this box will be expanded by the z component of *vector* in\n\t\tboth directions."
        },
        "copy": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Copies the values of *box* to this box."
        },
        "makeEmpty": {
          "!type": "fn() -> +THREE.Box3",
          "!doc": "Makes this box empty."
        },
        "center": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the center point of this box."
        },
        "getBoundingSphere": {
          "!type": "fn(optionalTarget: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Gets a sphere that bounds the box."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the distance from any edge of this box to the specified point. <br>\n\t\tIf the point lies inside of this box, the distance will be 0."
        },
        "setFromCenterAndSize": {
          "!type": "fn(center: +THREE.Vector3, size: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Centers this box on *center* and sets this box's width and height to the values specified\n\t\tin *size*."
        }
      },
      "!doc": "Represents a boundary box in 3d space.",
      "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3)"
    },
    "Color": {
      "!url": "http://threejs.org/docs/#Reference/math/Color",
      "prototype": {
        "r": {
          "!type": "number",
          "!doc": "Red channel value between 0 and 1. Default is 1."
        },
        "g": {
          "!type": "number",
          "!doc": "Green channel value between 0 and 1. Default is 1."
        },
        "b": {
          "!type": "number",
          "!doc": "Blue channel value between 0 and 1. Default is 1."
        },
        "copy": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies given color."
        },
        "copyGammaToLinear": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies given color making conversion from gamma to linear space."
        },
        "copyLinearToGamma": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies given color making conversion from linear to gamma space."
        },
        "convertGammaToLinear": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Converts this color from gamma to linear space."
        },
        "convertLinearToGamma": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Converts this color from linear to gamma space."
        },
        "setRGB": {
          "!type": "fn(r: number, g: number, b: number) -> +THREE.Color",
          "!doc": "Sets this color from RGB values."
        },
        "getHex": {
          "!type": "fn() -> number",
          "!doc": "Returns the hexadecimal value of this color."
        },
        "getHexString": {
          "!type": "fn() -> string",
          "!doc": "Returns the string formated hexadecimal value of this color."
        },
        "setHex": {
          "!type": "fn(hex: number) -> +THREE.Color",
          "!doc": "Sets this color from a hexadecimal value."
        },
        "setStyle": {
          "!type": "fn(style: string) -> +THREE.Color",
          "!doc": "Sets this color\tfrom a CSS-style string."
        },
        "getStyle": {
          "!type": "fn() -> string",
          "!doc": "Returns the value of this color as a CSS-style string. Example: rgb(255,0,0)"
        },
        "setHSL": {
          "!type": "fn(h: number, s: number, l: number) -> +THREE.Color",
          "!doc": "Sets color from hsl"
        },
        "offsetHSL": {
          "!type": "fn(h: number, s: number, l: number) -> +THREE.Color",
          "!doc": "Adds given h, s, and l to this color's existing h, s, and l values."
        },
        "add": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Adds rgb values of given color to rgb values of this color"
        },
        "addColors": {
          "!type": "fn(color1: +THREE.Color, color2: +THREE.Color) -> +THREE.Color",
          "!doc": "Sets this color to the sum of color1 and color2"
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Color",
          "!doc": "Adds s to the rgb values of this color"
        },
        "multiply": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Multiplies this color's rgb values by given color's rgb values"
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Color",
          "!doc": "Multiplies this color's rgb values by s"
        },
        "lerp": {
          "!type": "fn(color: +THREE.Color, alpha) -> +THREE.Color",
          "!doc": "Linear interpolation of this colors rgb values and the rgb values of the first argument. The alpha argument can be thought of as the percent between the two colors, where 0 is this color and 1 is the first argument."
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Returns an array [r,g,b]"
        },
        "equals": {
          "!type": "fn(c: +THREE.Color) -> +THREE.Color",
          "!doc": "Compares this color and c and returns true if they are the same, false otherwise."
        },
        "clone": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Clones this color."
        },
        "set": {
          "!type": "fn(value) -> +THREE.Color",
          "!doc": "Delegates to .copy, .setStyle, or .setHex depending on input type."
        }
      },
      "!doc": "Represents a color.",
      "!type": "fn(value)"
    },
    "Euler": {
      "!url": "http://threejs.org/docs/#Reference/math/Euler",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "order": "string",
        "set": {
          "!type": "fn(x: number, y: number, z: number, order: string) -> +THREE.Euler",
          "!doc": "Sets the angles of this euler transform."
        },
        "copy": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Euler",
          "!doc": "Copies value of *euler* to this euler."
        },
        "setFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4, order: string) -> +THREE.Euler",
          "!doc": "Sets the angles of this euler transform from a pure rotation matrix based on the orientation specified by order."
        },
        "setFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion, order: string) -> +THREE.Euler",
          "!doc": "Sets the angles of this euler transform from a normalized quaternion based on the orientation specified by order."
        },
        "reorder": {
          "!type": "fn(newOrder: string) -> +THREE.Euler",
          "!doc": "Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order. <br>\n\t\tWARNING: this discards revolution information."
        },
        "setFromVector3": {
          "!type": "fn(vector: +THREE.Vector3, order: string) -> +THREE.Euler",
          "!doc": "Optionally Vector3 to the XYZ parameters of Euler, and order to the Euler's order property."
        },
        "toVector3": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Returns the Euler's XYZ properties as a Vector3."
        },
        "fromArray": {
          "!type": "fn(array: []) -> +THREE.Euler",
          "!doc": "Assigns this euler's x angle to array[0]. <br>\n\t\tAssigns this euler's y angle to array[1]. <br>\n\t\tAssigns this euler's z angle to array[2]. <br>\n\t\tOptionally assigns this euler's order to array[3]."
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Returns an array [x, y, z, order]"
        },
        "equals": {
          "!type": "fn(euler: +THREE.Euler) -> bool",
          "!doc": "Checks for strict equality of this euler and *euler*."
        },
        "clone": {
          "!type": "fn() -> +THREE.Euler",
          "!doc": "Returns a new euler created from this euler."
        }
      },
      "!doc": "Euler Angles. <br><br>\n\n\t\tEuler angles describe a rotation transformation by rotating an object on its various axes in specified amounts per axis, and a specified axis order.\n\t\t(More information on <a href=\"http://en.wikipedia.org/wiki/Euler_angles\" target=\"blank\">Wikipedia</a>)",
      "!type": "fn(x: number, y: number, z: number, order: string)"
    },
    "Frustum": {
      "!url": "http://threejs.org/docs/#Reference/math/Frustum",
      "prototype": {
        "planes": {
          "!type": "[]",
          "!doc": "Array of 6 [page:Plane planes]."
        },
        "setFromMatrix": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Frustum",
          "!doc": "Array of 6 [page:Plane planes]."
        },
        "intersectsObject": {
          "!type": "fn(object: +THREE.Object3D) -> bool",
          "!doc": "Checks whether the object's bounding sphere is intersecting the Frustum."
        },
        "clone": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Return a copy of this Frustum"
        },
        "set": {
          "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane) -> bool",
          "!doc": "Sets the current frustum from the passed planes. No plane order is implicitely implied."
        },
        "copy": {
          "!type": "fn(frustum: +THREE.Frustum) -> +THREE.Frustum",
          "!doc": "Copies the values of the passed frustum."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Checks to see if the frustum contains the point."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Check to see if the sphere intersects with the frustum."
        }
      },
      "!doc": "<a href=\"http://en.wikipedia.org/wiki/Frustum\">Frustums</a> are used to determine what is inside the camera's field of view. They help speed up the rendering process.",
      "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane)"
    },
    "Line3": {
      "!url": "http://threejs.org/docs/#Reference/math/Line3",
      "prototype": {
        "start": "+THREE.Vector3",
        "end": "+THREE.Vector3",
        "set": {
          "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3) -> +THREE.Line3",
          "!doc": "Sets the start and end values by copying the provided vectors."
        },
        "copy": {
          "!type": "fn(line: +THREE.Line3) -> +THREE.Line3",
          "!doc": "Copies the passed line's start and end vectors to this line."
        },
        "clone": {
          "!type": "fn() -> +THREE.Line3",
          "!doc": "Return a new copy of this [page:Line3]."
        },
        "equals": {
          "!type": "fn(line: +THREE.Line3) -> bool",
          "!doc": "<h3>[method:Float distance]()</h3>\n\t\t<div>\n\t\tReturns the length of the line segment.\n\t\t</div>\n\t\tReturns true if both line's start and end points are equal."
        },
        "distance": {
          "!type": "fn() -> number",
          "!doc": "Returns the length of the line segment."
        },
        "distanceSq": {
          "!type": "fn() -> number",
          "!doc": "Returns the line segment's length squared."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Line3",
          "!doc": "Apply a matrix transform to the line segment."
        },
        "at": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> Vector",
          "!doc": "Return a vector at a certain position along the line. When t = 0, it returns the start vector, and when t=1 it returns the end vector."
        },
        "center": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Return the center of the line segment."
        },
        "delta": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the delta vector of the line segment, or the end vector minus the start vector."
        },
        "closestPointToPoint": {
          "!type": "fn(point: +THREE.Vector3, clampToLine: bool, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the closets point on the line. If clamp to line is true, then the returned value will be clamped to the line segment."
        },
        "closestPointToPointParameter": {
          "!type": "fn(point: +THREE.Vector3, clampToLine: bool) -> number",
          "!doc": "Returns a point parameter based on the closest point as projected on the line segement. If clamp to line is true, then the returned value will be between 0 and 1."
        }
      },
      "!doc": "A geometric line segment represented by a start and end point.",
      "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3)"
    },
    "Math": {
      "!url": "http://threejs.org/docs/#Reference/math/Math",
      "prototype": {
        "clamp": {
          "!type": "fn(x: number, a: number, b: number) -> number",
          "!doc": "Clamps the *x* to be between *a* and *b*."
        },
        "clampBottom": {
          "!type": "fn(x: number, a: number) -> number",
          "!doc": "Clamps the *x* to be larger than *a*."
        },
        "mapLinear": {
          "!type": "fn(x: number, a1: number, a2: number, b1: number, b2: number) -> number",
          "!doc": "Linear mapping of *x* from range [*a1*, *a2*] to range [*b1*, *b2*]."
        },
        "random16": {
          "!type": "fn() -> number",
          "!doc": "Random float from 0 to 1 with 16 bits of randomness.<br>\n\t\tStandard Math.random() creates repetitive patterns when applied over larger space."
        },
        "randInt": {
          "!type": "fn(low: number, high: number) -> number",
          "!doc": "Random integer from *low* to *high* interval."
        },
        "randFloat": {
          "!type": "fn(low: number, high: number) -> number",
          "!doc": "Random float from *low* to *high* interval."
        },
        "randFloatSpread": {
          "!type": "fn(range: number) -> number",
          "!doc": "Random float from *- range / 2* to *range / 2* interval."
        },
        "sign": {
          "!type": "fn(x: number) -> number",
          "!doc": "Returns -1 if *x* is less than 0, 1 if *x* is greater than 0, and 0 if *x* is zero."
        },
        "degToRad": {
          "!type": "fn(degrees: number) -> number",
          "!doc": "Converts degrees to radians."
        },
        "radToDeg": {
          "!type": "fn(radians: number) -> number",
          "!doc": "Converts radians to degrees"
        },
        "smoothstep": {
          "!type": "fn(x: number, min: number, max: number) -> number",
          "!doc": "Returns a value between 0-1 that represents the percentage that x has moved between min and max, but smoothed or slowed down the closer X is to the min and max.<br><br>\n\t\t\n\t\t[link:http://en.wikipedia.org/wiki/Smoothstep Wikipedia]"
        },
        "smootherstep": {
          "!type": "fn(x: number, min: number, max: number) -> number",
          "!doc": "Returns a value between 0-1. It works the same as smoothstep, but more smooth."
        }
      },
      "!doc": "Math utility functions"
    },
    "Matrix3": {
      "!url": "http://threejs.org/docs/#Reference/math/Matrix3",
      "prototype": {
        "elements": {
          "!type": "Float32Array",
          "!doc": "Float32Array with column-major matrix values."
        },
        "transpose": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Transposes this matrix in place."
        },
        "transposeIntoArray": {
          "!type": "fn(array: []) -> +THREE.Matrix3",
          "!doc": "Transposes this matrix into the supplied array, and returns itself."
        },
        "determinant": {
          "!type": "fn() -> number",
          "!doc": "Returns the matrix's determinant."
        },
        "set": {
          "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) -> +THREE.Matrix3",
          "!doc": "Set the 3x3 matrix values to the given row-major sequence of values."
        },
        "multiplyScalar": {
          "!type": "fn(scalar: number) -> +THREE.Matrix3",
          "!doc": "Multiply every component of the matrix by a scalar value."
        },
        "applyToBufferAttribute": {
          "!type": "fn(attribute: []) -> +THREE.BufferAttribute",
          "!doc": "Multiply (apply) this matrix to every vector3 in the attribute."
        },
        "getNormalMatrix": {
          "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Matrix3",
          "!doc": "Set this matrix as the normal matrix of the passed [page:Matrix4 matrix4]. The normal matrix is the inverse transpose of the matrix."
        },
        "getInverse": {
          "!type": "fn(matrix4: +THREE.Matrix4, throwOnInvertible: bool) -> +THREE.Matrix3",
          "!doc": "Set this matrix to the inverse of the passed matrix."
        },
        "copy": {
          "!type": "fn(matrix: +THREE.Matrix3) -> +THREE.Matrix3",
          "!doc": "Copy the values of the passed matrix."
        },
        "clone": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Create a copy of the matrix."
        },
        "identity": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Set as an identity matrix.<br><br>\n\t\t\n\t\t1, 0, 0<br>\n\t\t0, 1, 0<br>\n\t\t0, 0, 1<br>"
        }
      },
      "!doc": "A 3x3 matrix.",
      "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number)"
    },
    "Matrix4": {
      "!url": "http://threejs.org/docs/#Reference/math/Matrix4",
      "prototype": {
        "elements": {
          "!type": "Float32Array",
          "!doc": "A column-major list of matrix values."
        },
        "set": {
          "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) -> +THREE.Matrix4",
          "!doc": "Sets all fields of this matrix to the supplied row-major values n11..n44."
        },
        "identity": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Resets this matrix to identity."
        },
        "copy": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Copies a matrix *m* into this matrix."
        },
        "copyPosition": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Copies the translation component of the supplied matrix *m* into this matrix translation component."
        },
        "makeBasis": {
          "!type": "fn(xAxis: +THREE.Vector3, zAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Creates the basis matrix consisting of the three provided axis vectors.  Returns the current matrix."
        },
        "extractBasis": {
          "!type": "fn(xAxis: +THREE.Vector3, zAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Extracts basis of into the three axis vectors provided.  Returns the current matrix."
        },
        "extractRotation": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Extracts the rotation of the supplied matrix *m* into this matrix rotation component."
        },
        "lookAt": {
          "!type": "fn(eye: +THREE.Vector3, center: +THREE.Vector3, up: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Constructs a rotation matrix, looking from *eye* towards *center* with defined *up* vector."
        },
        "multiply": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Multiplies this matrix by *m*."
        },
        "multiplyMatrices": {
          "!type": "fn(a: +THREE.Matrix4, b: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Sets this matrix to *a x b*."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Matrix4",
          "!doc": "Multiplies this matrix by *s*."
        },
        "determinant": {
          "!type": "fn() -> number",
          "!doc": "Computes determinant of this matrix.<br>\n\t\tBased on [link:http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm]"
        },
        "transpose": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Transposes this matrix."
        },
        "flattenToArrayOffset": {
          "!type": "fn(flat: [], offset: number) -> []",
          "!doc": "Flattens this matrix into supplied *flat* array starting from *offset* position in the array."
        },
        "setPosition": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Sets the position component for this matrix from vector *v*."
        },
        "getInverse": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Sets this matrix to the inverse of matrix *m*.<br>\n\t\tBased on [link:http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm]."
        },
        "makeRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Matrix4",
          "!doc": "Sets the rotation submatrix of this matrix to the rotation specified by Euler angles, the rest of the matrix is identity.<br>\n\t\tDefault order is *\"XYZ\"*."
        },
        "makeRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Matrix4",
          "!doc": "Sets the rotation submatrix of this matrix to the rotation specified by *q*. The rest of the matrix is identity."
        },
        "scale": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Multiplies the columns of this matrix by vector *v*."
        },
        "compose": {
          "!type": "fn(translation: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Sets this matrix to the transformation composed of *translation*, *quaternion* and *scale*."
        },
        "decompose": {
          "!type": "fn(translation: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> []",
          "!doc": "Decomposes this matrix into the *translation*, *quaternion* and *scale* components."
        },
        "makeTranslation": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as translation transform."
        },
        "makeRotationX": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as rotation transform around x axis by *theta* radians."
        },
        "makeRotationY": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as rotation transform around y axis by *theta* radians."
        },
        "makeRotationZ": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as rotation transform around z axis by *theta* radians."
        },
        "makeRotationAxis": {
          "!type": "fn(axis: +THREE.Vector3, theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as rotation transform around *axis* by *angle* radians.<br>\n\t\tBased on [link:http://www.gamedev.net/reference/articles/article1199.asp]."
        },
        "makeScale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as scale transform."
        },
        "makePerspective": {
          "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number) -> +THREE.Matrix4",
          "!doc": "Creates a perspective projection matrix."
        },
        "makeOrthographic": {
          "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number) -> +THREE.Matrix4",
          "!doc": "Creates an orthographic projection matrix."
        },
        "clone": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Clones this matrix."
        },
        "applyToBufferAttribute": {
          "!type": "fn(attribute: []) -> +THREE.BufferAttribute",
          "!doc": "Multiply (apply) this matrix to every vector3 in the attribute."
        },
        "getMaxScaleOnAxis": {
          "!type": "fn() -> number",
          "!doc": "Gets the max scale value of the 3 axes."
        }
      },
      "!doc": "A 4x4 Matrix.",
      "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number)"
    },
    "Plane": {
      "!url": "http://threejs.org/docs/#Reference/math/Plane",
      "prototype": {
        "normal": "+THREE.Vector3",
        "constant": "number",
        "normalize": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Normalizes the normal vector, and adjusts the constant value accordingly."
        },
        "set": {
          "!type": "fn(normal: +THREE.Vector3, constant: number) -> +THREE.Plane",
          "!doc": "Sets the plane's values."
        },
        "copy": {
          "!type": "fn(plane: +THREE.Plane) -> +THREE.Plane",
          "!doc": "Copies the values of the passed plane to this plane."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4, optionalNormalMatrix: +THREE.Matrix3) -> +THREE.Plane",
          "!doc": "Apply a Matrix4 to the plane. The second parameter is optional.\n\t\t\n\t\t<code>\n\t\tvar optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix ) \n\t\t</code>"
        },
        "orthoPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector in the same direction as the Plane's normal, but the magnitude is passed point's original distance to the plane."
        },
        "isIntersectionLine": {
          "!type": "fn(line: +THREE.Line3) -> bool",
          "!doc": "Tests whether a line segment intersects with the plane. (Do not mistake this for a collinear check.)"
        },
        "intersectLine": {
          "!type": "fn(line: +THREE.Line3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the intersection point of the passed line and the plane. Returns undefined if the line does not intersect. Returns the line's starting point if the line is coplanar with the plane."
        },
        "setFromNormalAndCoplanarPoint": {
          "!type": "fn(normal: +THREE.Vector3, point: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets the plane's values as defined by a normal and arbitrary coplanar point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Returns a new copy of this plane."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the smallest distance from the point to the plane."
        },
        "equals": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Checks to see if two planes are equal (their normals and constants match)"
        },
        "setComponents": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Plane",
          "!doc": "Set the individual components that make up the plane."
        },
        "distanceToSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> number",
          "!doc": "Returns the smallest distance from an edge of the sphere to the plane."
        },
        "setFromCoplanarPoints": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Plane",
          "!doc": "Defines the plane based on the 3 provided points. The winding order is counter clockwise, and determines which direction the normal will point."
        },
        "projectPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Projects a point onto the plane. The projected point is the closest point on the plane to the passed point, so a line drawn from the projected point and the passed point would be orthogonal to the plane."
        },
        "negate": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Negates both the normal vector and constant, effectively mirroring the plane across the origin."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Plane",
          "!doc": "Translates the plane the distance defined by the vector. Note that this only affects the constant (distance from origin) and will not affect the normal vector."
        },
        "coplanarPoint": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a coplanar point. (The projection of the normal vector at the origin onto the plane.)"
        }
      },
      "!doc": "A two dimensional surface that extends infinitely in 3d space.",
      "!type": "fn(normal: +THREE.Vector3, constant: number)"
    },
    "Quaternion": {
      "!url": "http://threejs.org/docs/#Reference/math/Quaternion",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "w": "number",
        "set": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Quaternion",
          "!doc": "Sets values of this quaternion."
        },
        "copy": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Copies values of *q* to this quaternion."
        },
        "setFromEuler": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from rotation specified by Euler angle."
        },
        "setFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from rotation specified by axis and angle.<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm].<br>\n\t\t*Axis* is asumed to be normalized, *angle* is in radians."
        },
        "setFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from rotation component of *m*.<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm]."
        },
        "setFromUnitVectors": {
          "!type": "fn(vFrom: +THREE.Vector3, vTo: +THREE.Vector3) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion to the rotation required to rotate direction vector *vFrom* to direction vector *vTo*.<br>\n\t\tAdapted from [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors].<br>\n\t\t*vFrom* and *vTo* are assumed to be normalized."
        },
        "inverse": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Inverts this quaternion."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes length of this quaternion."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Normalizes this quaternion."
        },
        "multiply": {
          "!type": "fn(b: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Multiplies this quaternion by *b*."
        },
        "multiplyQuaternions": {
          "!type": "fn(a: +THREE.Quaternion, b: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion to *a x b*<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm]."
        },
        "multiplyVector3": {
          "!type": "fn(vector: +THREE.Vector3, dest: +THREE.Vector3) -> +THREE.Quaternion",
          "!doc": "Rotates *vector* by this quaternion into *dest*.<br>\n\t\tIf *dest* is not specified, result goes to *vec*."
        },
        "clone": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Clones this quaternion."
        },
        "slerp": {
          "!type": "fn(qb: +THREE.Quaternion, t: float) -> +THREE.Quaternion",
          "!doc": "Handles the spherical linear interpolation between this quaternion's configuration\n\t\tand that of *qb*. *t* represents how close to the current (0) or target (1) rotation the\n\t\tresult should be."
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Returns the numerical elements of this quaternion in an array of format (x, y, z, w)."
        },
        "equals": {
          "!type": "fn(v: +THREE.Quaternion) -> bool",
          "!doc": "Compares each component of *v* to each component of this quaternion to determine if they\n\t\trepresent the same rotation."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Calculates the squared length of the quaternion."
        },
        "fromArray": {
          "!type": "fn(array: []) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion's component values from an array."
        },
        "conjugate": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Returns the rotational conjugate of this quaternion. The conjugate of a quaternion\n\t\trepresents the same rotation in the opposite direction about the rotational axis."
        }
      },
      "!doc": "Implementation of a <a href=\"http://en.wikipedia.org/wiki/Quaternion\">quaternion</a>. This is used for rotating things without encountering the dreaded <a href=\"http://en.wikipedia.org/wiki/Gimbal_lock\">gimbal lock</a> issue, amongst other advantages.",
      "!type": "fn(x: number, y: number, z: number, w: number)"
    },
    "Ray": {
      "!url": "http://threejs.org/docs/#Reference/math/Ray",
      "prototype": {
        "origin": {
          "!type": "+THREE.Vector3",
          "!doc": "The origin of the [page:Ray]."
        },
        "direction": {
          "!type": "+THREE.Vector3",
          "!doc": "The direction of the [page:Ray]. This must be normalized (with [page:Vector3].normalize) for the methods to operate properly."
        },
        "applyMatrix4": {
          "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Ray",
          "!doc": "Transform this [page:Ray] by the [page:Matrix4]."
        },
        "clone": {
          "!type": "fn() -> +THREE.Ray",
          "!doc": "Create a clone of this [page:Ray]."
        },
        "closestPointToPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Get the point along this [page:Ray] that is closest to the [page:Vector3] provided."
        },
        "copy": {
          "!type": "fn(ray: +THREE.Ray) -> +THREE.Ray",
          "!doc": "Copy the properties of the provided [page:Ray], then return this [page:Ray]."
        },
        "distanceToPlane": {
          "!type": "fn(plane: +THREE.Plane) -> number",
          "!doc": "Get the distance from the origin to the [page:Plane], or *null* if the [page:Ray] doesn't intersect the [page:Plane]."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Get the distance of the closest approach between the [page:Ray] and the [page:Vector3]."
        },
        "equals": {
          "!type": "fn(ray: +THREE.Ray) -> bool",
          "!doc": "Return whether this and the other [page:Ray] have equal offsets and directions."
        },
        "isIntersectionBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Return whether or not this [page:Ray] intersects with the [page:Box3]."
        },
        "isIntersectionPlane": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Return whether or not this [page:Ray] intersects with the [page:Plane]."
        },
        "isIntersectionSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Return whether or not this [page:Ray] intersects with the [page:Sphere]."
        },
        "recast": {
          "!type": "fn(t: number) -> +THREE.Ray",
          "!doc": "Shift the origin of this [page:Ray] along its direction by the distance given."
        },
        "set": {
          "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3) -> +THREE.Ray",
          "!doc": "Copy the parameters to the origin and direction properties."
        }
      },
      "!doc": "A ray that emits from an origin in a certain direction.",
      "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)"
    },
    "Sphere": {
      "!url": "http://threejs.org/docs/#Reference/math/Sphere",
      "prototype": {
        "center": "+THREE.Vector3",
        "radius": "number",
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Sphere",
          "!doc": "Transforms this sphere with the provided [page:Matrix4]."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Clamps a point within the sphere. If the point is is outside the sphere, it will clamp it to the closets point on the edge of the sphere."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Sphere",
          "!doc": "Translate the sphere's center by the provided offset vector."
        },
        "clone": {
          "!type": "fn() -> +THREE.Sphere",
          "!doc": "Provides a new copy of the sphere."
        },
        "equals": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Checks to see if the two spheres' centers and radii are equal."
        },
        "setFromPoints": {
          "!type": "fn(points: [], optionalCenter: +THREE.Vector3) -> +THREE.Sphere",
          "!doc": "Computes the minimum bounding sphere for *points*. If *optionalCenter* is given, it is used as the sphere's center. Otherwise, the center of the axis-aligned bounding box encompassing *points* is calculated."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the closest distance from the boundary of the sphere to the point. If the sphere contains the point, the distance will be negative."
        },
        "getBoundingBox": {
          "!type": "fn(optionalTarget: Box) -> Box",
          "!doc": "Returns a bounding box for the sphere, optionally setting a provided box target."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Checks to see if the sphere contains the provided point inclusive of the edge of the sphere."
        },
        "copy": {
          "!type": "fn(sphere: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Copies the values of the passed sphere to this sphere."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Checks to see if two spheres intersect."
        },
        "empty": {
          "!type": "fn() -> bool",
          "!doc": "Checks to see if the sphere is empty (the radius set to 0)."
        }
      },
      "!doc": "A geometric sphere defined by a center position and radius.",
      "!type": "fn(center: +THREE.Vector3, radius: number)"
    },
    "Triangle": {
      "!url": "http://threejs.org/docs/#Reference/math/Triangle",
      "prototype": {
        "a": {
          "!type": "+THREE.Vector3",
          "!doc": "The first [page:Vector3] of the triangle."
        },
        "b": {
          "!type": "+THREE.Vector3",
          "!doc": "The second [page:Vector3] of the triangle."
        },
        "c": {
          "!type": "+THREE.Vector3",
          "!doc": "The third [page:Vector3] of the triangle."
        },
        "setFromPointsAndIndices": {
          "!type": "fn(points: [], i0: number, i1: number, i2: number) -> +THREE.Triangle",
          "!doc": "Sets the triangle's vectors to the vectors in the array."
        },
        "set": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Triangle",
          "!doc": "Sets the triangle's vectors to the passed vectors."
        },
        "normal": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Return the calculated normal of the triangle."
        },
        "barycoordFromPoint": {
          "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Return a barycentric coordinate from the given vector. <br><br>\n\t\t[link:http://commons.wikimedia.org/wiki/File:Barycentric_coordinates_1.png](Picture of barycentric coordinates)"
        },
        "clone": {
          "!type": "fn() -> +THREE.Triangle",
          "!doc": "Return a new copy of this triangle."
        },
        "area": {
          "!type": "fn() -> number",
          "!doc": "Return the area of the triangle."
        },
        "midpoint": {
          "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Return the midpoint of the triangle. Optionally sets a target vector."
        },
        "equals": {
          "!type": "fn(triangle: +THREE.Triangle) -> bool",
          "!doc": "Checks to see if two triangles are equal (share the same vectors)."
        },
        "plane": {
          "!type": "fn(optionalTarget: +THREE.Plane) -> +THREE.Plane",
          "!doc": "Return a [page:Plane plane] based on the triangle. Optionally sets a target plane."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Checks to see if the passed vector is within the triangle."
        },
        "copy": {
          "!type": "fn(triangle: +THREE.Triangle) -> +THREE.Triangle",
          "!doc": "Copies the values of the vertices of the passed triangle to this triangle."
        }
      },
      "!doc": "A geometric triangle as defined by three vectors.",
      "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3)"
    },
    "Vector2": {
      "!url": "http://threejs.org/docs/#Reference/math/Vector2",
      "prototype": {
        "x": "number",
        "y": "number",
        "set": {
          "!type": "fn(x: number, y: number) -> +THREE.Vector2",
          "!doc": "Sets value of this vector."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Copies value of *v* to this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Adds *v* to this vector."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Sets this vector to *a + b*."
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Subtracts *v* from this vector."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Sets this vector to *a - b*."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Vector2",
          "!doc": "Multiplies this vector by scalar *s*."
        },
        "divideScalar": {
          "!type": "fn(s: number) -> +THREE.Vector2",
          "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0 )* if *s == 0*."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Inverts this vector."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes dot product of this vector and *v*."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes squared length of this vector."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes length of this vector."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Normalizes this vector."
        },
        "distanceTo": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes distance of this vector to *v*."
        },
        "distanceToSquared": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes squared distance of this vector to *v*."
        },
        "setLength": {
          "!type": "fn(l: number) -> +THREE.Vector2",
          "!doc": "Normalizes this vector and multiplies it by *l*."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector2) -> bool",
          "!doc": "Checks for strict equality of this vector and *v*."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Clones this vector."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value. <br>\tIf this vector's x or y value is less than the min vector's x or y value, it is replace by the corresponding value."
        },
        "clampScalar": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector2",
          "!doc": "If this vector's x or y values are greater than the max value, they are replaced by the max value. <br>  If this vector's x or y values are less than the min value, they are replace by the min value."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of the vector are rounded towards the nearest integer value."
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
          "!doc": "Linear interpolation between this vector and v, where alpha is the percent along the line."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
          "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
        },
        "setComponent": {
          "!type": "fn(index: number, value: number) -> undefined",
          "!doc": "if index equals 0 method replaces this.x with value. <br>\n\t\tif index equals 1 method replaces this.y with value."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Vector2",
          "!doc": "Add the scalar value s to this vector's x and y values."
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "if index equals 0 returns the x value. <br>\n\t\tif index equals 1 returns the y value."
        },
        "fromArray": {
          "!type": "fn(array: []) -> +THREE.Vector2",
          "!doc": "Sets this vector's x value to be array[0] and y value to be array[1]."
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Returns an array [x, y]."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is less than v's x or y value, replace that value with the corresponding min value."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding max value."
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector2",
          "!doc": "replace this vector's x value with x."
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector2",
          "!doc": "replace this vector's y value with y."
        }
      },
      "!doc": "2D vector.",
      "!type": "fn(x: number, y: number)"
    },
    "Vector3": {
      "!url": "http://threejs.org/docs/#Reference/math/Vector3",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "set": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Vector3",
          "!doc": "Sets value of this vector."
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector3",
          "!doc": "Sets x value of this vector."
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector3",
          "!doc": "Sets y value of this vector."
        },
        "setZ": {
          "!type": "fn(z: number) -> +THREE.Vector3",
          "!doc": "Sets z value of this vector."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Copies value of *v* to this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Adds *v* to this vector."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets this vector to *a + b*."
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Subtracts *v* from this vector."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets this vector to *a - b*."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Vector3",
          "!doc": "Multiplies this vector by scalar *s*."
        },
        "divideScalar": {
          "!type": "fn(s: number) -> +THREE.Vector3",
          "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0, 0 )* if *s == 0*."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Inverts this vector."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes dot product of this vector and *v*."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes squared length of this vector."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes length of this vector."
        },
        "lengthManhattan": {
          "!type": "fn() -> number",
          "!doc": "Computes Manhattan length of this vector.<br>\n\t\t[link:http://en.wikipedia.org/wiki/Taxicab_geometry]"
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Normalizes this vector. Transforms this Vector into a Unit vector by dividing the vector by it's length."
        },
        "distanceTo": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes distance of this vector to *v*."
        },
        "distanceToSquared": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes squared distance of this vector to *v*."
        },
        "setLength": {
          "!type": "fn(l: number) -> +THREE.Vector3",
          "!doc": "Normalizes this vector and multiplies it by *l*."
        },
        "cross": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets this vector to cross product of itself and *v*."
        },
        "crossVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets this vector to cross product of *a* and *b*."
        },
        "setFromMatrixPosition": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Sets this vector extracting position from matrix transform."
        },
        "setFromMatrixScale": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Sets this vector extracting scale from matrix transform."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector3) -> bool",
          "!doc": "Checks for strict equality of this vector and *v*."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Clones this vector."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z value is greater than the max vector's x, y or z value, it is replaced by the corresponding value. <br><br>\n\t\tIf this vector's x, y or z value is less than the min vector's x, y or z value, it is replace by the corresponding value."
        },
        "clampScalar": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z values are greater than the max value, they are replaced by the max value. <br>  If this vector's x, y or z values are less than the min value, they are replace by the min value."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of the vector are rounded towards the nearest integer value."
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
          "!doc": "Multiplies this vector times a 3 x 3 matrix."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
          "!doc": "Multiplies this vector by 4 x 3 subset of a Matrix4."
        },
        "projectOnPlane": {
          "!type": "fn(planeNormal: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Projects this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector."
        },
        "projectOnVector": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Projects this vector onto another vector."
        },
        "addScalar": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Adds a s to this vector."
        },
        "divide": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Divides this vector by vector v."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y, or z value is less than vector v's x, y, or z value, that value is replaced by the corresponding vector v value."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y, or z value is greater than vector v's x, y, or z value, that value is replaced by the corresponding vector v value."
        },
        "setComponent": {
          "!type": "fn(index: number, value: number) -> +THREE.Vector3",
          "!doc": "If index equals 0 the method sets this vector's x value to value <br>\n\t\tIf index equals 1 the method sets this vector's y value to value <br>\n\t\tIf index equals 2 the method sets this vector's z value to value"
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Transforms the direction of this vector by a matrix (a 3 x 3 subset of a Matrix4) and then normalizes the result."
        },
        "multiplyVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Sets this vector equal to the result of multiplying vector a by vector b."
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the value of the vector component x, y, or z by an index. <br><br>\n\n\t\tIndex 0: x <br>\n\t\tIndex 1: y <br>\n\t\tIndex 2: z <br>"
        },
        "applyAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Vector3",
          "!doc": "Applies a rotation specified by an axis and an angle to this vector."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
          "!doc": "Linear Interpolation between this vector and vector v, where alpha is the percent along the line."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
          "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
        },
        "angleTo": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Returns the angle between this vector and vector v in radians."
        },
        "setFromMatrixColumn": {
          "!type": "fn(index: number, matrix: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Sets this vector's x, y, and z equal to the column of the matrix specified by the index."
        },
        "reflect": {
          "!type": "fn(normal: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Reflect incident vector off of plane orthogonal to normal. Normal is assumed to have unit length."
        },
        "fromArray": {
          "!type": "fn(array: []) -> +THREE.Vector3",
          "!doc": "Sets the vector's components based on an array formatted like [x, y, z]"
        },
        "multiply": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Multiplies this vector by vector v."
        },
        "applyProjection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Multiplies this vector and m, and divides by perspective."
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Assigns this vector's x value to array[0]. <br>\n\t\tAssigns this vector's y value to array[1]. <br>\n\t\tAssigns this vector's z value to array[2]. <br>\n\t\tReturns the created array."
        },
        "applyEuler": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Vector3",
          "!doc": "Applies euler transform to this vector by converting the [page:Euler] object to a [page:Quaternion] and applying."
        },
        "applyQuaternion": {
          "!type": "fn(quaternion: +THREE.Quaternion) -> +THREE.Vector3",
          "!doc": "Applies a [page:Quaternion] transform to this vector."
        },
        "project": {
          "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
          "!doc": "Projects the vector with the camera."
        },
        "unproject": {
          "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
          "!doc": "Unprojects the vector with the camera."
        }
      },
      "!doc": "3D vector.",
      "!type": "fn(x: number, y: number, z: number)"
    },
    "Vector4": {
      "!url": "http://threejs.org/docs/#Reference/math/Vector4",
      "prototype": {
        "x": "number",
        "y": "number",
        "z": "number",
        "w": "number",
        "set": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Vector4",
          "!doc": "Sets value of this vector."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Copies value of *v* to this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Adds *v* to this vector."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Sets this vector to *a + b*."
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Subtracts *v* from this vector."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Sets this vector to *a - b*."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Vector4",
          "!doc": "Multiplies this vector by scalar *s*."
        },
        "divideScalar": {
          "!type": "fn(s: number) -> +THREE.Vector4",
          "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0, 0 )* if *s == 0*."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Inverts this vector."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector4) -> number",
          "!doc": "Computes dot product of this vector and *v*."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes squared length of this vector."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes length of this vector."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Normalizes this vector."
        },
        "setLength": {
          "!type": "fn(l: number) -> +THREE.Vector4",
          "!doc": "Normalizes this vector and multiplies it by *l*."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
          "!doc": "Linearly interpolate between this vector and *v* with *alpha* factor."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector4, v2: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
          "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Clones this vector."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector4, max: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z, or w value is greater than the max vector's x, y, z, or w value, it is replaced by the corresponding value.<br><br>\n\n\t\tIf this vector's x, y, z, or w value is less than the min vector's x, y, z, or w value, it is replace by the corresponding value."
        },
        "clampScalar": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z or w values are greater than the max value, they are replaced by the max value. <br>\n\t\tIf this vector's x, y, z or w values are less than the min value, they are replace by the min value."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of the vector are rounded towards the nearest integer value."
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
          "!doc": "Transforms the vector by the matrix."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z, or w value is less than vector v's x, y, z, or w value, that value is replaced by the corresponding vector v value."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z, or w value is greater than vector v's x, y, z, or w value, that value is replaced by the corresponding vector v value."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Vector4",
          "!doc": "Adds a scalar value to all of the vector's components."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector4) -> bool",
          "!doc": "Checks to see if this vector matches vector v."
        },
        "setAxisAngleFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
          "!doc": "Sets this Vector4 to the computed <a href=\"http://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation\" target=\"_blank\">axis-angle representation</a> of the rotation defined by Matrix4 m. Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br><br>\n\n\t\tThe axis is stored in components (x, y, z) of the vector, and the rotation in radians is stored in component w"
        },
        "setAxisAngleFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Vector4",
          "!doc": "Sets this Vector4 to the computed <a href=\"http://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation\" target=\"_blank\">axis-angle representation</a> of the rotation defined by Quaternion q.<br><br>\n\n\t\tThe axis is stored in components (x, y, z) of the vector, and the rotation in radians is stored in component w"
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the value of the vector component x, y, or z by an index.<br><br>\n\n\t\tIndex 0: x<br>\n\t\tIndex 1: y<br>\n\t\tIndex 2: z<br>\n\t\tIndex 3: w<br>"
        },
        "setComponent": {
          "!type": "fn(index: number, value: number)",
          "!doc": "Sets the value of the vector component\tx, y, or z by an index.<br><br>\n\n\t\tIndex 0: x<br>\n\t\tIndex 1: y<br>\n\t\tIndex 2: z<br>\n\t\tIndex 3: w<br>"
        },
        "fromArray": {
          "!type": "fn(array: []) -> +THREE.Vector4",
          "!doc": "Sets the vector's components based on an array formatted like [x, y, z, w]"
        },
        "toArray": {
          "!type": "fn(array: []) -> []",
          "!doc": "Returns an array in the format [x, y, z, w]"
        },
        "lengthManhattan": {
          "!type": "fn() -> number",
          "!doc": "Computes Manhattan length of this vector.<br>\n\t\t[link:http://en.wikipedia.org/wiki/Taxicab_geometry]"
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector4",
          "!doc": "Sets the x component of the vector."
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector4",
          "!doc": "Sets the y component of the vector."
        },
        "setZ": {
          "!type": "fn(z: number) -> +THREE.Vector4",
          "!doc": "Sets the z component of the vector."
        },
        "setW": {
          "!type": "fn(w: number) -> +THREE.Vector4",
          "!doc": "Sets the w component of the vector."
        }
      },
      "!doc": "4D vector.",
      "!type": "fn(x: number, y: number, z: number, w: number)"
    },
    "Bone": {
      "!url": "http://threejs.org/docs/#Reference/objects/Bone",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "skinMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The matrix of the bone."
        },
        "skin": {
          "!type": "+THREE.SkinnedMesh",
          "!doc": "The skin that contains this bone."
        },
        "update": {
          "!type": "fn(parentSkinMatrix: +THREE.Matrix4, forceUpdate: boolean) -> todo",
          "!doc": "This updates the matrix of the bone and the matrices of its children."
        }
      },
      "!doc": "A bone which is part of a SkinnedMesh.",
      "!type": "fn(belongsToSkin: +THREE.SkinnedMesh)"
    },
    "LOD": {
      "!url": "http://threejs.org/docs/#Reference/objects/LOD",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "objects": {
          "!type": "array",
          "!doc": "todo"
        },
        "addLevel": {
          "!type": "fn(object: todo, distance: todo) -> todo",
          "!doc": "todo"
        },
        "getObjectForDistance": {
          "!type": "fn(distance: todo) -> todo",
          "!doc": "todo"
        },
        "update": {
          "!type": "fn(camera: todo) -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "todo",
      "!type": "fn()"
    },
    "LensFlare": {
      "!url": "http://threejs.org/docs/#Reference/objects/LensFlare",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "lensFlares": {
          "!type": "array",
          "!doc": "todo"
        },
        "positionScreen": {
          "!type": "+THREE.Vector3",
          "!doc": "todo"
        },
        "customUpdateCallback": {
          "!type": "todo",
          "!doc": "todo"
        },
        "updateLensFlares": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "todo",
      "!type": "fn(texture: todo, size: todo, distance: todo, blending: todo, color: todo)"
    },
    "Line": {
      "!url": "http://threejs.org/docs/#Reference/objects/Line",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "geometry": {
          "!type": "+THREE.Geometry",
          "!doc": "Vertices representing the line segment(s)."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "Material for the line."
        },
        "type": {
          "!type": "number",
          "!doc": "In OpenGL terms, LineStrip is the classic GL_LINE_STRIP and LinePieces is the equivalent to GL_LINES."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
          "!doc": "Get intersections between a casted ray and this Line. [page:Raycaster.intersectObject] will call this method."
        }
      },
      "!doc": "A line or a series of lines.",
      "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material, type: number)"
    },
    "Mesh": {
      "!url": "http://threejs.org/docs/#Reference/objects/Mesh",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "geometry": {
          "!type": "+THREE.Geometry",
          "!doc": "An instance of [page:Geometry], defining the object's structure."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:MeshBasicMaterial] with wireframe mode enabled and randomised colour."
        },
        "getMorphTargetIndexByName": {
          "!type": "fn(name: string) -> number",
          "!doc": "Returns the index of a morph target defined by name."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Updates the morphtargets to have no influence on the object."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
          "!doc": "Get intersections between a casted ray and this mesh. [page:Raycaster.intersectObject] will call this method."
        }
      },
      "!doc": "Base class for Mesh objects, such as [page:MorphAnimMesh] and [page:SkinnedMesh].",
      "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material)"
    },
    "MorphAnimMesh": {
      "!url": "http://threejs.org/docs/#Reference/objects/MorphAnimMesh",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "directionBackwards": {
          "!type": "boolean",
          "!doc": "todo"
        },
        "direction": {
          "!type": "number",
          "!doc": "todo"
        },
        "endKeyframe": {
          "!type": "number",
          "!doc": "todo"
        },
        "mirroredLoop": {
          "!type": "boolean",
          "!doc": "todo"
        },
        "startKeyframe": {
          "!type": "number",
          "!doc": "todo"
        },
        "lastKeyframe": {
          "!type": "number",
          "!doc": "todo"
        },
        "length": {
          "!type": "number",
          "!doc": "todo"
        },
        "time": {
          "!type": "number",
          "!doc": "todo"
        },
        "duration": {
          "!type": "number",
          "!doc": "todo"
        },
        "currentKeyframe": {
          "!type": "number",
          "!doc": "todo"
        },
        "setDirectionForward": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "playAnimation": {
          "!type": "fn(label: todo, fps: todo) -> todo",
          "!doc": "todo"
        },
        "setFrameRange": {
          "!type": "fn(start: todo, end: todo) -> todo",
          "!doc": "todo"
        },
        "setDirectionBackward": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "parseAnimations": {
          "!type": "fn() -> todo",
          "!doc": "todo"
        },
        "updateAnimation": {
          "!type": "fn(delta: todo) -> todo",
          "!doc": "todo"
        },
        "setAnimationLabel": {
          "!type": "fn(label: todo, start: todo, end: todo) -> todo",
          "!doc": "todo"
        }
      },
      "!doc": "todo",
      "!type": "fn(geometry: todo, material: todo)"
    },
    "PointCloud": {
      "!url": "http://threejs.org/docs/#Reference/objects/PointCloud",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "geometry": {
          "!type": "+THREE.Geometry",
          "!doc": "An instance of [page:Geometry], where each vertex designates the position of a particle in the system."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:PointCloudMaterial] with randomised colour."
        },
        "clone": {
          "!type": "fn() -> +THREE.PointCloud",
          "!doc": "This creates a clone of the particle system."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
          "!doc": "Get intersections between a casted ray and this PointCloud. [page:Raycaster.intersectObject] will call this method."
        }
      },
      "!doc": "A class for displaying particles in the form of variable size points. For example, if using the [page:WebGLRenderer], the particles are displayed using GL_POINTS.",
      "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material)"
    },
    "SkinnedMesh": {
      "!url": "http://threejs.org/docs/#Reference/objects/SkinnedMesh",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "bones": {
          "!type": "array",
          "!doc": "This contains the array of bones for this mesh. These should be set in the constructor."
        },
        "identityMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "This is an identityMatrix to calculate the bones matrices from."
        },
        "useVertexTexture": {
          "!type": "boolean",
          "!doc": "The boolean defines whether a vertex texture is used to calculate the bones. This boolean shouldn't be changed after constructor."
        },
        "boneMatrices": {
          "!type": "array",
          "!doc": "This array of matrices contains the matrices of the bones. These get calculated in the constructor."
        },
        "pose": {
          "!type": "fn()",
          "!doc": "This method sets the skinnedmesh in the rest pose."
        },
        "addBone": {
          "!type": "fn(bone: +THREE.Bone) -> +THREE.Bone",
          "!doc": "This method adds the bone to the skinnedmesh when it is provided. It creates a new bone and adds that when no bone is given."
        }
      },
      "!doc": "An 3d object that has bones data. These Bones can then be used to animate the vertices of the object.",
      "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material, useVertexTexture: boolean)"
    },
    "Sprite": {
      "!url": "http://threejs.org/docs/#Reference/objects/Sprite",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "material": {
          "!type": "+THREE.SpriteMaterial",
          "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:SpriteMaterial] which is a white plane."
        },
        "clone": {
          "!type": "fn() -> +THREE.Sprite",
          "!doc": "This creates a new clone of the sprite."
        }
      },
      "!doc": "A sprite is a plane in an 3d scene which faces always towards the camera.",
      "!type": "fn(material: +THREE.Material)"
    },
    "CanvasRenderer": {
      "!url": "http://threejs.org/docs/#Reference/renderers/CanvasRenderer",
      "prototype": {
        "info": {
          "!type": "object",
          "!doc": "An object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:"
        },
        "domElement": {
          "!type": "DOMElement",
          "!doc": "A [page:Canvas] where the renderer draws its output.<br>\n\t\t\tThis is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page."
        },
        "autoClear": {
          "!type": "bool",
          "!doc": "Defines whether the renderer should automatically clear its output before rendering."
        },
        "sortObjects": {
          "!type": "bool",
          "!doc": "Defines whether the renderer should sort objects. Default is true.<br>\n      Note: Sorting is used to attempt to properly render objects that have some degree of transparency.  By definition, sorting objects may not work in all cases.  Depending on the needs of application, it may be neccessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining the object rendering order."
        },
        "sortElements": {
          "!type": "boolean",
          "!doc": "Defines whether the renderer should sort the face of each object. Default is true."
        },
        "render": {
          "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
          "!doc": "Render a scene using a camera."
        },
        "clear": {
          "!type": "fn()",
          "!doc": "Tells the renderer to clear its color drawing buffer with the clearcolor."
        },
        "setClearColor": {
          "!type": "fn(color: +THREE.Color, alpha: number)",
          "!doc": "This set the clearColor and the clearAlpha."
        },
        "setSize": {
          "!type": "fn(width: number, height: number)",
          "!doc": "This set the size of the drawing canvas and if updateStyle is set, then the css of the canvas is updated too."
        },
        "setClearColorHex": {
          "!type": "fn(hex: number, alpha: number)",
          "!doc": "This set the clearColor and the clearAlpha."
        },
        "getClearColorHex": {
          "!type": "fn() -> number",
          "!doc": "Returns the [page:number hex] color."
        },
        "getClearAlpha": {
          "!type": "fn() -> number",
          "!doc": "Returns the alpha value."
        }
      },
      "!doc": "The Canvas renderer displays your beautifully crafted scenes <em>not</em> using WebGL, but draws it using the (slower) <a href=\"http://www.w3.org/html/wg/drafts/2dcontext/html5_canvas/\">Canvas 2D Context</a> API.<br><br>\n\t\t\tThis renderer can be a nice fallback from [page:WebGLRenderer] for simple scenes:\n\n\t\t\t<code>\n\t\t\tfunction webglAvailable() {\n\t\t\t\ttry {\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\n\t\t\t\t\treturn !!( window.WebGLRenderingContext &amp;&amp; (\n\t\t\t\t\t\tcanvas.getContext( 'webgl' ) ||\n\t\t\t\t\t\tcanvas.getContext( 'experimental-webgl' ) )\n\t\t\t\t\t);\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( webglAvailable() ) {\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t} else {\n\t\t\t\trenderer = new THREE.CanvasRenderer();\n\t\t\t}\n\t\t\t</code>\n\n\t\t\tNote: both WebGLRenderer and CanvasRenderer are embedded in the web page using an HTML5 &lt;canvas&gt; tag.\n\t\t\tThe \"Canvas\" in CanvasRenderer means it uses Canvas 2D instead of WebGL.<br><br>\n\n\t\t\tDon't confuse either CanvasRenderer with the SoftwareRenderer example, which simulates a screen buffer in a Javascript array.",
      "!type": "fn(parameters: object)"
    },
    "WebGLRenderTarget": {
      "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderTarget",
      "prototype": {
        "wrapS": {
          "!type": "number",
          "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
        },
        "wrapT": {
          "!type": "number",
          "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
        },
        "magFilter": {
          "!type": "number",
          "!doc": "How the texture is sampled when a texel covers more than one pixel. The default is THREE.LinearFilter, which takes the four closest texels and bilinearly interpolates among them. The other option is THREE.NearestFilter, which uses the value of the closest texel."
        },
        "minFilter": {
          "!type": "number",
          "!doc": "How the texture is sampled when a texel covers less than one pixel. The default is THREE.LinearMipMapLinearFilter, which uses mipmapping and a trilinear filter. Other choices are THREE.NearestFilter, THREE.NearestMipMapNearestFilter, THREE.NearestMipMapLinearFilter, THREE.LinearFilter, and THREE.LinearMipMapNearestFilter. These vary whether the nearest texel or nearest four texels are retrieved on the nearest mipmap or nearest two mipmaps. Interpolation occurs among the samples retrieved."
        },
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used. Use renderer.getMaxAnisotropy() to find the maximum valid anisotropy value for the GPU; this value is usually a power of 2."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "format": {
          "!type": "number",
          "!doc": "The default is THREE.RGBAFormat for the texture. Other formats are: THREE.AlphaFormat, THREE.RGBFormat, THREE.LuminanceFormat, and THREE.LuminanceAlphaFormat. There are also compressed texture formats, if the S3TC extension is supported: THREE.RGB_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT3_Format, and THREE.RGBA_S3TC_DXT5_Format."
        },
        "type": {
          "!type": "number",
          "!doc": "The default is THREE.UnsignedByteType. Other valid types (as WebGL allows) are THREE.ByteType, THREE.ShortType, THREE.UnsignedShortType, THREE.IntType, THREE.UnsignedIntType, THREE.HalfFloatType, THREE.FloatType, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type, and THREE.UnsignedShort565Type."
        },
        "depthBuffer": {
          "!type": "boolean",
          "!doc": "Renders to the depth buffer. Default is true."
        },
        "stencilBuffer": {
          "!type": "boolean",
          "!doc": "Renders to the stencil buffer. Default is true."
        },
        "generateMipmaps": {
          "!type": "boolean",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. True by default."
        },
        "setSize": {
          "!type": "fn(width: number, height: number)",
          "!doc": "Sets the size of the renderTarget."
        },
        "clone": {
          "!type": "fn() -> RenderTarget",
          "!doc": "Creates a copy of the render target."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Dispatches a dispose event."
        }
      },
      "!doc": "A render target is a buffer where the video card draws pixels for a scene that is being rendered in the background. It is used in different effects.",
      "!type": "fn(width: number, height: number, options: object)"
    },
    "WebGLRenderTargetCube": {
      "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderTargetCube",
      "prototype": {
        "!proto": "THREE.WebGLRenderTarget.prototype",
        "activeCubeFace": {
          "!type": "integer",
          "!doc": "The activeCubeFace property corresponds to a cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) and is\n\t\tused and set internally by the [page:CubeCamera]."
        }
      },
      "!doc": "[page:CubeCamera] uses this as its [page:WebGLRenderTarget]",
      "!type": "fn(width: number, height: number, options: object)"
    },
    "WebGLRenderer": {
      "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderer",
      "prototype": {
        "domElement": {
          "!type": "DOMElement",
          "!doc": "A [page:Canvas] where the renderer draws its output.<br>\n\t\tThis is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page."
        },
        "context": {
          "!type": "WebGLRenderingContext",
          "!doc": "The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw."
        },
        "autoClear": {
          "!type": "bool",
          "!doc": "Defines whether the renderer should automatically clear its output before rendering."
        },
        "autoClearColor": {
          "!type": "bool",
          "!doc": "If autoClear is true, defines whether the renderer should clear the color buffer. Default is true."
        },
        "autoClearDepth": {
          "!type": "bool",
          "!doc": "If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true."
        },
        "autoClearStencil": {
          "!type": "bool",
          "!doc": "If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true."
        },
        "sortObjects": {
          "!type": "bool",
          "!doc": "Note: Sorting is used to attempt to properly render objects that have some degree of transparency.  By definition, sorting objects may not work in all cases.  Depending on the needs of application, it may be neccessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining the object rendering order."
        },
        "autoUpdateObjects": {
          "!type": "bool",
          "!doc": "Defines whether the renderer should auto update objects. Default is true."
        },
        "gammaInput": {
          "!type": "bool",
          "!doc": "Default is false. If set, then it expects that all textures and colors are premultiplied gamma."
        },
        "gammaOutput": {
          "!type": "bool",
          "!doc": "Default is false.  If set, then it expects that all textures and colors need to be outputted in premultiplied gamma."
        },
        "shadowMapEnabled": {
          "!type": "bool",
          "!doc": "Default is false. If set, use shadow maps in the scene."
        },
        "shadowMapType": {
          "!type": "number",
          "!doc": "Options are THREE.BasicShadowMap, THREE.PCFShadowMap, THREE.PCFSoftShadowMap. Default is THREE.PCFShadowMap."
        },
        "shadowMapCullFace": {
          "!type": "number",
          "!doc": "Default is THREE.CullFaceFront. The faces that needed to be culled. Possible values: THREE.CullFaceFront and THREE.CullFaceBack"
        },
        "shadowMapCascade": {
          "!type": "bool",
          "!doc": "Default is false. If Set, use cascaded shadowmaps. See [link:http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf cascaded shadowmaps] for more information."
        },
        "maxMorphTargets": {
          "!type": "number",
          "!doc": "Default is 8. The maximum number of MorphTargets allowed in a shader. Keep in mind that the standard materials only allow 8 MorphTargets."
        },
        "maxMorphNormals": {
          "!type": "number",
          "!doc": "Default is 4. The maximum number of MorphNormals allowed in a shader. Keep in mind that the standard materials only allow 4 MorphNormals."
        },
        "autoScaleCubemaps": {
          "!type": "bool",
          "!doc": "Default is true. If set, then Cubemaps are scaled, when they are bigger than the maximum size, to make sure that they aren't bigger than the maximum size."
        },
        "info": {
          "!type": "object",
          "!doc": "<ul>\n\t\t\t<li>memory:\n\t\t\t\t<ul>\n\t\t\t\t\t<li>programs</li>\n\t\t\t\t\t<li>geometries</li>\n\t\t\t\t\t<li>textures</li>\n\t\t\t\t</ul>\n\t\t\t</li>\n\t\t\t<li>render:\n\t\t\t\t<ul>\n\t\t\t\t\t<li>calls</li>\n\t\t\t\t\t<li>vertices</li>\n\t\t\t\t\t<li>faces</li>\n\t\t\t\t\t<li>points</li>\n\t\t\t\t</ul>\n\t\t\t</li>\n\t\t</ul>"
        },
        "shadowMapPlugin": {
          "!type": "+THREE.ShadowMapPlugin",
          "!doc": "This contains the reference to the shadowMapPlugin."
        },
        "getContext": {
          "!type": "fn() -> WebGLRenderingContext",
          "!doc": "Return the WebGL context."
        },
        "supportsVertexTextures": {
          "!type": "fn() -> bool",
          "!doc": "Return a [page:Boolean] true if the context supports vertex textures."
        },
        "setSize": {
          "!type": "fn(width: number, height: number)",
          "!doc": "Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0)."
        },
        "setViewport": {
          "!type": "fn(x: number, y: number, width: number, height: number)",
          "!doc": "Sets the viewport to render from (x, y) to (x + width, y + height)."
        },
        "setScissor": {
          "!type": "fn(x: number, y: number, width: number, height: number)",
          "!doc": "Sets the scissor area from (x, y) to (x + width, y + height)."
        },
        "enableScissorTest": {
          "!type": "fn(enable: bool)",
          "!doc": "Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions."
        },
        "setClearColor": {
          "!type": "fn(color: +THREE.Color, alpha: number)",
          "!doc": "Sets the clear color and opacity."
        },
        "getClearColor": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Returns a [page:Color THREE.Color] instance with the current clear color."
        },
        "getClearAlpha": {
          "!type": "fn() -> number",
          "!doc": "Returns a [page:Float float] with the current clear alpha. Ranges from 0 to 1."
        },
        "clear": {
          "!type": "fn(color: bool, depth: bool, stencil: bool)",
          "!doc": "Arguments default to true."
        },
        "renderBufferImmediate": {
          "!type": "fn(object: +THREE.Object3D, program: shaderprogram, shading: +THREE.Material)",
          "!doc": "Render an immediate buffer. Gets called by renderImmediateObject."
        },
        "renderBufferDirect": {
          "!type": "fn(camera: +THREE.Camera, lights: [], fog: +THREE.Fog, material: +THREE.Material, geometryGroup: object, object: +THREE.Object3D)",
          "!doc": "Render a buffer geometry group using the camera and with the correct material."
        },
        "renderBuffer": {
          "!type": "fn(camera: +THREE.Camera, lights: [], fog: +THREE.Fog, material: +THREE.Material, geometryGroup: object, object: +THREE.Object3D)",
          "!doc": "Render a geometry group using the camera and with the correct material."
        },
        "render": {
          "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera, renderTarget: +THREE.WebGLRenderTarget, forceClear: bool)",
          "!doc": "Even with forceClear set to true you can prevent certain buffers being cleared by setting either the .autoClearColor, .autoClearStencil or .autoClearDepth properties to false."
        },
        "renderImmediateObject": {
          "!type": "fn(camera, lights, fog, material, object)",
          "!doc": "Renders an immediate Object using a camera."
        },
        "setFaceCulling": {
          "!type": "fn(cullFace, frontFace)",
          "!doc": "If cullFace is false, culling will be disabled."
        },
        "setDepthTest": {
          "!type": "fn(depthTest: boolean)",
          "!doc": "This sets, based on depthTest, whether or not the depth data needs to be tested against the depth buffer."
        },
        "setDepthWrite": {
          "!type": "fn(depthWrite: boolean)",
          "!doc": "This sets, based on depthWrite, whether or not the depth data needs to be written in the depth buffer."
        },
        "setBlending": {
          "!type": "fn(blending: number, blendEquation: number, blendSrc: number, blendDst: number)",
          "!doc": "This method sets the correct blending."
        },
        "setTexture": {
          "!type": "fn(texture: +THREE.Texture, slot: number)",
          "!doc": "This method sets the correct texture to the correct slot for the wegl shader. The slot number can be found as a value of the uniform of the sampler."
        },
        "setRenderTarget": {
          "!type": "fn(renderTarget: +THREE.WebGLRenderTarget)",
          "!doc": "This method sets the active rendertarget."
        },
        "supportsCompressedTextureS3TC": {
          "!type": "fn() -> boolean",
          "!doc": "This method returns true if the webgl implementation supports compressed textures of the format S3TC."
        },
        "getMaxAnisotropy": {
          "!type": "fn() -> number",
          "!doc": "This returns the anisotropy level of the textures."
        },
        "getPrecision": {
          "!type": "fn() -> string",
          "!doc": "This gets the precision used by the shaders. It returns \"highp\",\"mediump\" or \"lowp\"."
        },
        "setMaterialFaces": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "This sets which side needs to be culled in the webgl renderer."
        },
        "supportsStandardDerivatives": {
          "!type": "fn() -> boolean",
          "!doc": "This method returns true if the webgl implementation supports standard derivatives."
        },
        "supportsFloatTextures": {
          "!type": "fn() -> boolean",
          "!doc": "This method returns true if the webgl implementation supports float textures."
        },
        "clearTarget": {
          "!type": "fn(renderTarget: +THREE.WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean)",
          "!doc": "This method clears a rendertarget. To do this, it activates the rendertarget."
        }
      },
      "!doc": "The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.",
      "!type": "fn(parameters: object)"
    },
    "ShaderChunk": {
      "!url": "http://threejs.org/docs/#Reference/renderers/shaders/ShaderChunk",
      "prototype": {},
      "!doc": "Shader chunks for WebLG Shader library"
    },
    "ShaderLib": {
      "!url": "http://threejs.org/docs/#Reference/renderers/shaders/ShaderLib",
      "prototype": {},
      "!doc": "Webgl Shader Library for three.js"
    },
    "UniformsLib": {
      "!url": "http://threejs.org/docs/#Reference/renderers/shaders/UniformsLib",
      "prototype": {},
      "!doc": "Uniforms library for shared webgl shaders"
    },
    "UniformsUtils": {
      "!url": "http://threejs.org/docs/#Reference/renderers/shaders/UniformsUtils",
      "prototype": {},
      "!doc": "Uniform Utilities. Support merging and cloning of uniform variables"
    },
    "WebGLProgram": {
      "!url": "http://threejs.org/docs/#Reference/renderers/webgl/WebGLProgram",
      "prototype": {
        "uniforms": "object",
        "attributes": "object",
        "id": "string",
        "code": "string",
        "usedTimes": "number",
        "program": "object",
        "vertexShader": "+THREE.WebGLShader",
        "fragmentShader": "+THREE.WebGLShader"
      },
      "!doc": "Constructor for the GLSL program sent to vertex and fragment shaders, including default uniforms and attributes.",
      "!type": "fn(renderer: +THREE.WebGLRenderer, code: object, material: +THREE.Material, parameters: object)"
    },
    "WebGLShader": {
      "!url": "http://threejs.org/docs/#Reference/renderers/webgl/WebGLShader",
      "prototype": {},
      "!doc": "todo"
    },
    "LensFlarePlugin": {
      "!url": "http://threejs.org/docs/#Reference/renderers/webgl/plugins/LensFlarePlugin",
      "prototype": {
        "render": {
          "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera, viewportWidth: number, viewportHeight: number)",
          "!doc": "Renders the lensflares defined in the scene. This gets automatically called as post render function to draw the lensflares."
        }
      },
      "!doc": "The Webglrenderer plugin class that allows lensflares to be rendered in the WebglRenderer. This plugin is automatically loaded in the Webglrenderer.",
      "!type": "fn()"
    },
    "ShadowMapPlugin": {
      "!url": "http://threejs.org/docs/#Reference/renderers/webgl/plugins/ShadowMapPlugin",
      "prototype": {
        "render": {
          "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
          "!doc": "Prepares the shadowmaps to be rendered defined in the scene. This gets automatically called as pre render function to draw the lensflares."
        }
      },
      "!doc": "The Webglrenderer plugin class that allows shadowmaps to be rendered in the WebglRenderer. This plugin is automatically loaded in the Webglrenderer.",
      "!type": "fn()"
    },
    "SpritePlugin": {
      "!url": "http://threejs.org/docs/#Reference/renderers/webgl/plugins/SpritePlugin",
      "prototype": {
        "render": {
          "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
          "!doc": "Renders the sprites defined in the scene. This gets automatically called as post-render function to draw the lensflares."
        }
      },
      "!doc": "The Webglrenderer plugin class that allows Sprites to be rendered in the WebglRenderer. This plugin is automatically loaded in the Webglrenderer.",
      "!type": "fn()"
    },
    "Fog": {
      "!url": "http://threejs.org/docs/#Reference/scenes/Fog",
      "prototype": {
        "name": {
          "!type": "string",
          "!doc": "Default is the empty string."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Fog color.  Example: If set to black, far away objects will be rendered black."
        },
        "near": {
          "!type": "number",
          "!doc": "Default is 1."
        },
        "far": {
          "!type": "number",
          "!doc": "Default is 1000."
        },
        "clone": {
          "!type": "fn() -> +THREE.Fog",
          "!doc": "Returns a copy of this."
        }
      },
      "!doc": "This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.",
      "!type": "fn(hex: number, near: number, far: number)"
    },
    "FogExp2": {
      "!url": "http://threejs.org/docs/#Reference/scenes/FogExp2",
      "prototype": {
        "name": {
          "!type": "string",
          "!doc": "Default is the empty string."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Fog color. Example: If set to black, far away objects will be rendered black."
        },
        "density": {
          "!type": "number",
          "!doc": "Default is 0.00025."
        },
        "clone": {
          "!type": "fn() -> +THREE.FogExp2",
          "!doc": "Returns a copy of this."
        }
      },
      "!doc": "This class contains the parameters that define exponential fog, i.e., that grows exponentially denser with the distance.",
      "!type": "fn(hex: number, density: number)"
    },
    "Scene": {
      "!url": "http://threejs.org/docs/#Reference/scenes/Scene",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "fog": {
          "!type": "+THREE.Fog",
          "!doc": "A [page:Fog fog] instance defining the type of fog that affects everything rendered in the scene. Default is null."
        },
        "overrideMaterial": {
          "!type": "+THREE.Material",
          "!doc": "If not null, it will force everything in the scene to be rendered with that material. Default is null."
        },
        "autoUpdate": {
          "!type": "boolean",
          "!doc": "Default is true. If set, then the renderer checks every frame if the scene and its objects needs matrix updates. \n\t\tWhen it isn't, then you have to maintain all matrices in the scene yourself."
        }
      },
      "!doc": "Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.",
      "!type": "fn()"
    },
    "CompressedTexture": {
      "!url": "http://threejs.org/docs/#Reference/textures/CompressedTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "flipY": {
          "!type": "boolean",
          "!doc": "False by default. Flipping textures does not work for compressed textures."
        },
        "generateMipmaps": {
          "!type": "boolean",
          "!doc": "False by default. Mipmaps can't be generated for compressed textures"
        }
      },
      "!doc": "Creates a texture based on data in compressed form.",
      "!type": "fn(mipmaps: [], width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number)"
    },
    "DataTexture": {
      "!url": "http://threejs.org/docs/#Reference/textures/DataTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype"
      },
      "!doc": "Creates a texture directly from bitmapdata, width and height.",
      "!type": "fn(data: ArraybufferView, width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number)"
    },
    "Texture": {
      "!url": "http://threejs.org/docs/#Reference/textures/Texture",
      "prototype": {
        "id": {
          "!type": "number",
          "!doc": "Unique number for this texture instance."
        },
        "image": {
          "!type": "Image",
          "!doc": "An Image object, typically created using the ImageUtils or [page:ImageLoader ImageLoader] classes. The Image object can include an image (e.g., PNG, JPG, GIF, DDS), video (e.g., MP4, OGG/OGV), or set of six images for a cube map. To use video as a texture you need to have a playing HTML5 video element as a source for your texture image and continuously update this texture as long as video is playing."
        },
        "mapping": {
          "!type": "object",
          "!doc": "How the image is applied to the object. An object type of THREE.UVMapping is the default, where the U,V coordinates are used to apply the map, and a single texture is expected. The other types are THREE.CubeReflectionMapping, for cube maps used as a reflection map; THREE.CubeRefractionMapping, refraction mapping; and THREE.SphericalReflectionMapping, a spherical reflection map projection."
        },
        "wrapS": {
          "!type": "number",
          "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
        },
        "wrapT": {
          "!type": "number",
          "!doc": "NOTE: tiling of images in textures only functions if image dimensions are powers of two (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels. Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL, not Three.js."
        },
        "magFilter": {
          "!type": "number",
          "!doc": "How the texture is sampled when a texel covers more than one pixel. The default is THREE.LinearFilter, which takes the four closest texels and bilinearly interpolates among them. The other option is THREE.NearestFilter, which uses the value of the closest texel."
        },
        "minFilter": {
          "!type": "number",
          "!doc": "How the texture is sampled when a texel covers less than one pixel. The default is THREE.LinearMipMapLinearFilter, which uses mipmapping and a trilinear filter. Other choices are THREE.NearestFilter, THREE.NearestMipMapNearestFilter, THREE.NearestMipMapLinearFilter, THREE.LinearFilter, and THREE.LinearMipMapNearestFilter. These vary whether the nearest texel or nearest four texels are retrieved on the nearest mipmap or nearest two mipmaps. Interpolation occurs among the samples retrieved."
        },
        "format": {
          "!type": "number",
          "!doc": "The default is THREE.RGBAFormat for the texture. Other formats are: THREE.AlphaFormat, THREE.RGBFormat, THREE.LuminanceFormat, and THREE.LuminanceAlphaFormat. There are also compressed texture formats, if the S3TC extension is supported: THREE.RGB_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT3_Format, and THREE.RGBA_S3TC_DXT5_Format."
        },
        "type": {
          "!type": "number",
          "!doc": "The default is THREE.UnsignedByteType. Other valid types (as WebGL allows) are THREE.ByteType, THREE.ShortType, THREE.UnsignedShortType, THREE.IntType, THREE.UnsignedIntType, THREE.FloatType, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type, and THREE.UnsignedShort565Type."
        },
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used. Use renderer.getMaxAnisotropy() to find the maximum valid anisotropy value for the GPU; this value is usually a power of 2."
        },
        "needsUpdate": {
          "!type": "boolean",
          "!doc": "If a texture is changed after creation, set this flag to true so that the texture is properly set up. Particularly important for setting the wrap mode."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "name": {
          "!type": "string",
          "!doc": "Given name of the texture, empty string by default."
        },
        "generateMipmaps": {
          "!type": "boolean",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. True by default."
        },
        "flipY": {
          "!type": "boolean",
          "!doc": "True by default. Flips the image's Y axis to match the WebGL texture coordinate space."
        },
        "mipmaps": {
          "!type": "array",
          "!doc": "Array of mipmaps generated."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "4 by default. Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See <a href=\"http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml\">glPixelStorei</a> for more information."
        },
        "premultiplyAlpha": {
          "!type": "boolean",
          "!doc": "False by default, which is the norm for PNG images. Set to true if the RGB values have been stored premultiplied by alpha."
        },
        "onUpdate": {
          "!type": "object",
          "!doc": "A callback function, called when the texture is updated (e.g., when needsUpdate has been set to true and then the texture is used)."
        }
      },
      "!doc": "Create a texture to apply to a surface or as a reflection or refraction map.",
      "!type": "fn(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)"
    }
  }
}
    };
  });
});

/*

 JS Signals <http://millermedeiros.github.com/js-signals/>
 Released under the MIT license
 Author: Miller Medeiros
 Version: 0.7.4 - Build: 252 (2012/02/24 10:30 PM)
*/
(function(h){function g(a,b,c,d,e){this._listener=b;this._isOnce=c;this.context=d;this._signal=a;this._priority=e||0}function f(a,b){if(typeof a!=="function")throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}",b));}var e={VERSION:"0.7.4"};g.prototype={active:!0,params:null,execute:function(a){var b;this.active&&this._listener&&(a=this.params?this.params.concat(a):a,b=this._listener.apply(this.context,a),this._isOnce&&this.detach());return b},detach:function(){return this.isBound()?
this._signal.remove(this._listener,this.context):null},isBound:function(){return!!this._signal&&!!this._listener},getListener:function(){return this._listener},_destroy:function(){delete this._signal;delete this._listener;delete this.context},isOnce:function(){return this._isOnce},toString:function(){return"[SignalBinding isOnce:"+this._isOnce+", isBound:"+this.isBound()+", active:"+this.active+"]"}};e.Signal=function(){this._bindings=[];this._prevParams=null};e.Signal.prototype={memorize:!1,_shouldPropagate:!0,
active:!0,_registerListener:function(a,b,c,d){var e=this._indexOfListener(a,c);if(e!==-1){if(a=this._bindings[e],a.isOnce()!==b)throw Error("You cannot add"+(b?"":"Once")+"() then add"+(!b?"":"Once")+"() the same listener without removing the relationship first.");}else a=new g(this,a,b,c,d),this._addBinding(a);this.memorize&&this._prevParams&&a.execute(this._prevParams);return a},_addBinding:function(a){var b=this._bindings.length;do--b;while(this._bindings[b]&&a._priority<=this._bindings[b]._priority);
this._bindings.splice(b+1,0,a)},_indexOfListener:function(a,b){for(var c=this._bindings.length,d;c--;)if(d=this._bindings[c],d._listener===a&&d.context===b)return c;return-1},has:function(a,b){return this._indexOfListener(a,b)!==-1},add:function(a,b,c){f(a,"add");return this._registerListener(a,!1,b,c)},addOnce:function(a,b,c){f(a,"addOnce");return this._registerListener(a,!0,b,c)},remove:function(a,b){f(a,"remove");var c=this._indexOfListener(a,b);c!==-1&&(this._bindings[c]._destroy(),this._bindings.splice(c,
1));return a},removeAll:function(){for(var a=this._bindings.length;a--;)this._bindings[a]._destroy();this._bindings.length=0},getNumListeners:function(){return this._bindings.length},halt:function(){this._shouldPropagate=!1},dispatch:function(a){if(this.active){var b=Array.prototype.slice.call(arguments),c=this._bindings.length,d;if(this.memorize)this._prevParams=b;if(c){d=this._bindings.slice();this._shouldPropagate=!0;do c--;while(d[c]&&this._shouldPropagate&&d[c].execute(b)!==!1)}}},forget:function(){this._prevParams=
null},dispose:function(){this.removeAll();delete this._bindings;delete this._prevParams},toString:function(){return"[Signal active:"+this.active+" numListeners:"+this.getNumListeners()+"]"}};typeof define==="function"&&define.amd?define(e):typeof module!=="undefined"&&module.exports?module.exports=e:h.signals=e})(this);
/**
 * @author mrdoob / http://mrdoob.com/
 */

var UI = {};

UI.Element = function ( dom ) {

  this.dom = dom;

};

UI.Element.prototype = {

  add: function () {

    for ( var i = 0; i < arguments.length; i ++ ) {

      var argument = arguments[ i ];

      if ( argument instanceof UI.Element ) {

        this.dom.appendChild( argument.dom );

      } else {

        console.error( 'UI.Element:', argument, 'is not an instance of UI.Element.' );

      }

    }

    return this;

  },

  remove: function () {

    for ( var i = 0; i < arguments.length; i ++ ) {

      var argument = arguments[ i ];

      if ( argument instanceof UI.Element ) {

        this.dom.removeChild( argument.dom );

      } else {

        console.error( 'UI.Element:', argument, 'is not an instance of UI.Element.' );

      }

    }

    return this;

  },

  clear: function () {

    while ( this.dom.children.length ) {

      this.dom.removeChild( this.dom.lastChild );

    }

  },

  setId: function ( id ) {

    this.dom.id = id;

    return this;

  },

  setClass: function ( name ) {

    this.dom.className = name;

    return this;

  },

  setStyle: function ( style, array ) {

    for ( var i = 0; i < array.length; i ++ ) {

      this.dom.style[ style ] = array[ i ];

    }

    return this;

  },

  setDisabled: function ( value ) {

    this.dom.disabled = value;

    return this;

  },

  setTextContent: function ( value ) {

    this.dom.textContent = value;

    return this;

  }

};

// properties

var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

properties.forEach( function ( property ) {

  var method = 'set' + property.substr( 0, 1 ).toUpperCase() + property.substr( 1, property.length );

  UI.Element.prototype[ method ] = function () {

    this.setStyle( property, arguments );

    return this;

  };

} );

// events

var events = [ 'KeyUp', 'KeyDown', 'MouseOver', 'MouseOut', 'Click', 'DblClick', 'Change' ];

events.forEach( function ( event ) {

  var method = 'on' + event;

  UI.Element.prototype[ method ] = function ( callback ) {

    this.dom.addEventListener( event.toLowerCase(), callback.bind( this ), false );

    return this;

  };

} );

// Span

UI.Span = function () {

  UI.Element.call( this );

  this.dom = document.createElement( 'span' );

  return this;

};

UI.Span.prototype = Object.create( UI.Element.prototype );
UI.Span.prototype.constructor = UI.Span;

// Div

UI.Div = function () {

  UI.Element.call( this );

  this.dom = document.createElement( 'div' );

  return this;

};

UI.Div.prototype = Object.create( UI.Element.prototype );
UI.Div.prototype.constructor = UI.Div;

// Row

UI.Row = function () {

  UI.Element.call( this );

  var dom = document.createElement( 'div' );
  dom.className = 'Row';

  this.dom = dom;

  return this;

};

UI.Row.prototype = Object.create( UI.Element.prototype );
UI.Row.prototype.constructor = UI.Row;

// Panel

UI.Panel = function () {

  UI.Element.call( this );

  var dom = document.createElement( 'div' );
  dom.className = 'Panel';

  this.dom = dom;

  return this;

};

UI.Panel.prototype = Object.create( UI.Element.prototype );
UI.Panel.prototype.constructor = UI.Panel;

// Text

UI.Text = function ( text ) {

  UI.Element.call( this );

  var dom = document.createElement( 'span' );
  dom.className = 'Text';
  dom.style.cursor = 'default';
  dom.style.display = 'inline-block';
  dom.style.verticalAlign = 'middle';

  this.dom = dom;
  this.setValue( text );

  return this;

};

UI.Text.prototype = Object.create( UI.Element.prototype );
UI.Text.prototype.constructor = UI.Text;

UI.Text.prototype.getValue = function () {

  return this.dom.textContent;

};

UI.Text.prototype.setValue = function ( value ) {

  if ( value !== undefined ) {

    this.dom.textContent = value;

  }

  return this;

};


// Input

UI.Input = function ( text ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'input' );
  dom.className = 'Input';
  dom.style.padding = '2px';
  dom.style.border = '1px solid transparent';

  dom.addEventListener( 'keydown', function ( event ) {

    event.stopPropagation();

  }, false );

  this.dom = dom;
  this.setValue( text );

  return this;

};

UI.Input.prototype = Object.create( UI.Element.prototype );
UI.Input.prototype.constructor = UI.Input;

UI.Input.prototype.getValue = function () {

  return this.dom.value;

};

UI.Input.prototype.setValue = function ( value ) {

  this.dom.value = value;

  return this;

};


// TextArea

UI.TextArea = function () {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'textarea' );
  dom.className = 'TextArea';
  dom.style.padding = '2px';
  dom.spellcheck = false;

  dom.addEventListener( 'keydown', function ( event ) {

    event.stopPropagation();

    if ( event.keyCode === 9 ) {

      event.preventDefault();

      var cursor = dom.selectionStart;

      dom.value = dom.value.substring( 0, cursor ) + '\t' + dom.value.substring( cursor );
      dom.selectionStart = cursor + 1;
      dom.selectionEnd = dom.selectionStart;

    }

  }, false );

  this.dom = dom;

  return this;

};

UI.TextArea.prototype = Object.create( UI.Element.prototype );
UI.TextArea.prototype.constructor = UI.TextArea;

UI.TextArea.prototype.getValue = function () {

  return this.dom.value;

};

UI.TextArea.prototype.setValue = function ( value ) {

  this.dom.value = value;

  return this;

};


// Select

UI.Select = function () {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'select' );
  dom.className = 'Select';
  dom.style.padding = '2px';

  this.dom = dom;

  return this;

};

UI.Select.prototype = Object.create( UI.Element.prototype );
UI.Select.prototype.constructor = UI.Select;

UI.Select.prototype.setMultiple = function ( boolean ) {

  this.dom.multiple = boolean;

  return this;

};

UI.Select.prototype.setOptions = function ( options ) {

  var selected = this.dom.value;

  while ( this.dom.children.length > 0 ) {

    this.dom.removeChild( this.dom.firstChild );

  }

  for ( var key in options ) {

    var option = document.createElement( 'option' );
    option.value = key;
    option.innerHTML = options[ key ];
    this.dom.appendChild( option );

  }

  this.dom.value = selected;

  return this;

};

UI.Select.prototype.getValue = function () {

  return this.dom.value;

};

UI.Select.prototype.setValue = function ( value ) {

  value = String( value );

  if ( this.dom.value !== value ) {

    this.dom.value = value;

  }

  return this;

};

// Checkbox

UI.Checkbox = function ( boolean ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'input' );
  dom.className = 'Checkbox';
  dom.type = 'checkbox';

  this.dom = dom;
  this.setValue( boolean );

  return this;

};

UI.Checkbox.prototype = Object.create( UI.Element.prototype );
UI.Checkbox.prototype.constructor = UI.Checkbox;

UI.Checkbox.prototype.getValue = function () {

  return this.dom.checked;

};

UI.Checkbox.prototype.setValue = function ( value ) {

  if ( value !== undefined ) {

    this.dom.checked = value;

  }

  return this;

};


// Color

UI.Color = function () {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'input' );
  dom.className = 'Color';
  dom.style.width = '64px';
  dom.style.height = '17px';
  dom.style.border = '0px';
  dom.style.padding = '2px';
  dom.style.backgroundColor = 'transparent';

  try {

    dom.type = 'color';
    dom.value = '#ffffff';

  } catch ( exception ) {}

  this.dom = dom;

  return this;

};

UI.Color.prototype = Object.create( UI.Element.prototype );
UI.Color.prototype.constructor = UI.Color;

UI.Color.prototype.getValue = function () {

  return this.dom.value;

};

UI.Color.prototype.getHexValue = function () {

  return parseInt( this.dom.value.substr( 1 ), 16 );

};

UI.Color.prototype.setValue = function ( value ) {

  this.dom.value = value;

  return this;

};

UI.Color.prototype.setHexValue = function ( hex ) {

  this.dom.value = '#' + ( '000000' + hex.toString( 16 ) ).slice( - 6 );

  return this;

};


// Number

UI.Number = function ( number ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'input' );
  dom.className = 'Number';
  dom.value = '0.00';

  dom.addEventListener( 'keydown', function ( event ) {

    event.stopPropagation();

    if ( event.keyCode === 13 ) dom.blur();

  }, false );

  this.value = 0;

  this.min = - Infinity;
  this.max = Infinity;

  this.precision = 2;
  this.step = 1;
  this.unit = '';

  this.dom = dom;

  this.setValue( number );

  var changeEvent = document.createEvent( 'HTMLEvents' );
  changeEvent.initEvent( 'change', true, true );

  var distance = 0;
  var onMouseDownValue = 0;

  var pointer = [ 0, 0 ];
  var prevPointer = [ 0, 0 ];

  function onMouseDown( event ) {

    event.preventDefault();

    distance = 0;

    onMouseDownValue = scope.value;

    prevPointer = [ event.clientX, event.clientY ];

    document.addEventListener( 'mousemove', onMouseMove, false );
    document.addEventListener( 'mouseup', onMouseUp, false );

  }

  function onMouseMove( event ) {

    var currentValue = scope.value;

    pointer = [ event.clientX, event.clientY ];

    distance += ( pointer[ 0 ] - prevPointer[ 0 ] ) - ( pointer[ 1 ] - prevPointer[ 1 ] );

    var value = onMouseDownValue + ( distance / ( event.shiftKey ? 5 : 50 ) ) * scope.step;
    value = Math.min( scope.max, Math.max( scope.min, value ) );

    if ( currentValue !== value ) {

      scope.setValue( value );
      dom.dispatchEvent( changeEvent );

    }

    prevPointer = [ event.clientX, event.clientY ];

  }

  function onMouseUp( event ) {

    document.removeEventListener( 'mousemove', onMouseMove, false );
    document.removeEventListener( 'mouseup', onMouseUp, false );

    if ( Math.abs( distance ) < 2 ) {

      dom.focus();
      dom.select();

    }

  }

  function onChange( event ) {

    scope.setValue( dom.value );

  }

  function onFocus( event ) {

    dom.style.backgroundColor = '';
    dom.style.cursor = '';

  }

  function onBlur( event ) {

    dom.style.backgroundColor = 'transparent';
    dom.style.cursor = 'col-resize';

  }

  onBlur();

  dom.addEventListener( 'mousedown', onMouseDown, false );
  dom.addEventListener( 'change', onChange, false );
  dom.addEventListener( 'focus', onFocus, false );
  dom.addEventListener( 'blur', onBlur, false );

  return this;

};

UI.Number.prototype = Object.create( UI.Element.prototype );
UI.Number.prototype.constructor = UI.Number;

UI.Number.prototype.getValue = function () {

  return this.value;

};

UI.Number.prototype.setValue = function ( value ) {

  if ( value !== undefined ) {

    value = parseFloat( value );

    if ( value < this.min ) value = this.min;
    if ( value > this.max ) value = this.max;

    this.value = value;
    this.dom.value = value.toFixed( this.precision );

    if ( this.unit !== '' ) this.dom.value += ' ' + this.unit;

  }

  return this;

};

UI.Number.prototype.setPrecision = function ( precision ) {

  this.precision = precision;

  return this;

};

UI.Number.prototype.setStep = function ( step ) {

  this.step = step;

  return this;

};

UI.Number.prototype.setRange = function ( min, max ) {

  this.min = min;
  this.max = max;

  return this;

};

UI.Number.prototype.setUnit = function ( unit ) {

  this.unit = unit;

  return this;

};

// Integer

UI.Integer = function ( number ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'input' );
  dom.className = 'Number';
  dom.value = '0';

  dom.addEventListener( 'keydown', function ( event ) {

    event.stopPropagation();

  }, false );

  this.value = 0;

  this.min = - Infinity;
  this.max = Infinity;

  this.step = 1;

  this.dom = dom;

  this.setValue( number );

  var changeEvent = document.createEvent( 'HTMLEvents' );
  changeEvent.initEvent( 'change', true, true );

  var distance = 0;
  var onMouseDownValue = 0;

  var pointer = [ 0, 0 ];
  var prevPointer = [ 0, 0 ];

  function onMouseDown( event ) {

    event.preventDefault();

    distance = 0;

    onMouseDownValue = scope.value;

    prevPointer = [ event.clientX, event.clientY ];

    document.addEventListener( 'mousemove', onMouseMove, false );
    document.addEventListener( 'mouseup', onMouseUp, false );

  }

  function onMouseMove( event ) {

    var currentValue = scope.value;

    pointer = [ event.clientX, event.clientY ];

    distance += ( pointer[ 0 ] - prevPointer[ 0 ] ) - ( pointer[ 1 ] - prevPointer[ 1 ] );

    var value = onMouseDownValue + ( distance / ( event.shiftKey ? 5 : 50 ) ) * scope.step;
    value = Math.min( scope.max, Math.max( scope.min, value ) ) | 0;

    if ( currentValue !== value ) {

      scope.setValue( value );
      dom.dispatchEvent( changeEvent );

    }

    prevPointer = [ event.clientX, event.clientY ];

  }

  function onMouseUp( event ) {

    document.removeEventListener( 'mousemove', onMouseMove, false );
    document.removeEventListener( 'mouseup', onMouseUp, false );

    if ( Math.abs( distance ) < 2 ) {

      dom.focus();
      dom.select();

    }

  }

  function onChange( event ) {

    scope.setValue( dom.value );

  }

  function onFocus( event ) {

    dom.style.backgroundColor = '';
    dom.style.cursor = '';

  }

  function onBlur( event ) {

    dom.style.backgroundColor = 'transparent';
    dom.style.cursor = 'col-resize';

  }

  onBlur();

  dom.addEventListener( 'mousedown', onMouseDown, false );
  dom.addEventListener( 'change', onChange, false );
  dom.addEventListener( 'focus', onFocus, false );
  dom.addEventListener( 'blur', onBlur, false );

  return this;

};

UI.Integer.prototype = Object.create( UI.Element.prototype );
UI.Integer.prototype.constructor = UI.Integer;

UI.Integer.prototype.getValue = function () {

  return this.value;

};

UI.Integer.prototype.setValue = function ( value ) {

  if ( value !== undefined ) {

    value = parseInt( value );

    this.value = value;
    this.dom.value = value;

  }

  return this;

};

UI.Integer.prototype.setStep = function ( step ) {
  
  this.step = parseInt( step ); 
  
  return this;

};

UI.Integer.prototype.setRange = function ( min, max ) {

  this.min = min;
  this.max = max;

  return this;

};


// Break

UI.Break = function () {

  UI.Element.call( this );

  var dom = document.createElement( 'br' );
  dom.className = 'Break';

  this.dom = dom;

  return this;

};

UI.Break.prototype = Object.create( UI.Element.prototype );
UI.Break.prototype.constructor = UI.Break;


// HorizontalRule

UI.HorizontalRule = function () {

  UI.Element.call( this );

  var dom = document.createElement( 'hr' );
  dom.className = 'HorizontalRule';

  this.dom = dom;

  return this;

};

UI.HorizontalRule.prototype = Object.create( UI.Element.prototype );
UI.HorizontalRule.prototype.constructor = UI.HorizontalRule;


// Button

UI.Button = function ( value ) {

  UI.Element.call( this );

  var dom = document.createElement( 'button' );
  dom.className = 'Button';

  this.dom = dom;
  this.dom.textContent = value;

  return this;

};

UI.Button.prototype = Object.create( UI.Element.prototype );
UI.Button.prototype.constructor = UI.Button;

UI.Button.prototype.setLabel = function ( value ) {

  this.dom.textContent = value;

  return this;

};


// Modal

UI.Modal = function ( value ) {

  var scope = this;

  var dom = document.createElement( 'div' );

  dom.style.position = 'absolute';
  dom.style.width = '100%';
  dom.style.height = '100%';
  dom.style.backgroundColor = 'rgba(0,0,0,0.5)';
  dom.style.display = 'none';
  dom.style.alignItems = 'center';
  dom.style.justifyContent = 'center';
  dom.addEventListener( 'click', function ( event ) {

    scope.hide();

  } );

  this.dom = dom;

  this.container = new UI.Panel();
  this.container.dom.style.width = '200px';
  this.container.dom.style.padding = '20px';
  this.container.dom.style.backgroundColor = '#ffffff';
  this.container.dom.style.boxShadow = '0px 5px 10px rgba(0,0,0,0.5)';

  this.add( this.container );

  return this;

};

UI.Modal.prototype = Object.create( UI.Element.prototype );
UI.Modal.prototype.constructor = UI.Modal;

UI.Modal.prototype.show = function ( content ) {

  this.container.clear();
  this.container.add( content );

  this.dom.style.display = 'flex';

  return this;

};

UI.Modal.prototype.hide = function () {

  this.dom.style.display = 'none';

  return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

UI.Texture = function ( mapping ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'span' );

  var form = document.createElement( 'form' );

  var input = document.createElement( 'input' );
  input.type = 'file';
  input.addEventListener( 'change', function ( event ) {

    loadFile( event.target.files[ 0 ] );

  } );
  form.appendChild( input );

  var canvas = document.createElement( 'canvas' );
  canvas.width = 32;
  canvas.height = 16;
  canvas.style.cursor = 'pointer';
  canvas.style.marginRight = '5px';
  canvas.style.border = '1px solid #888';
  canvas.addEventListener( 'click', function ( event ) {

    input.click();

  }, false );
  canvas.addEventListener( 'drop', function ( event ) {

    event.preventDefault();
    event.stopPropagation();
    loadFile( event.dataTransfer.files[ 0 ] );

  }, false );
  dom.appendChild( canvas );

  var name = document.createElement( 'input' );
  name.disabled = true;
  name.style.width = '64px';
  name.style.border = '1px solid #ccc';
  dom.appendChild( name );

  function loadFile( file ) {

    if ( file.type.match( 'image.*' ) ) {

      var reader = new FileReader();

      if ( file.type === 'image/targa' ) {

        reader.addEventListener( 'load', function ( event ) {

          var canvas = new THREE.TGALoader().parse( event.target.result );

          var texture = new THREE.CanvasTexture( canvas, mapping );
          texture.sourceFile = file.name;

          scope.setValue( texture );

          if ( scope.onChangeCallback ) scope.onChangeCallback();

        }, false );

        reader.readAsArrayBuffer( file );

      } else {

        reader.addEventListener( 'load', function ( event ) {

          var image = document.createElement( 'img' );
          image.addEventListener( 'load', function( event ) {

            var texture = new THREE.Texture( this, mapping );
            texture.sourceFile = file.name;
            texture.needsUpdate = true;

            scope.setValue( texture );

            if ( scope.onChangeCallback ) scope.onChangeCallback();

          }, false );

          image.src = event.target.result;

        }, false );

        reader.readAsDataURL( file );

      }

    }

    form.reset();

  }

  this.dom = dom;
  this.texture = null;
  this.onChangeCallback = null;

  return this;

};

UI.Texture.prototype = Object.create( UI.Element.prototype );
UI.Texture.prototype.constructor = UI.Texture;

UI.Texture.prototype.getValue = function () {

  return this.texture;

};

UI.Texture.prototype.setValue = function ( texture ) {

  var canvas = this.dom.children[ 0 ];
  var name = this.dom.children[ 1 ];
  var context = canvas.getContext( '2d' );

  if ( texture !== null ) {

    var image = texture.image;

    if ( image !== undefined && image.width > 0 ) {

      name.value = texture.sourceFile;

      var scale = canvas.width / image.width;
      context.drawImage( image, 0, 0, image.width * scale, image.height * scale );

    } else {

      name.value = texture.sourceFile + ' (error)';
      context.clearRect( 0, 0, canvas.width, canvas.height );

    }

  } else {

    name.value = '';

    if ( context !== null ) {

      // Seems like context can be null if the canvas is not visible

      context.clearRect( 0, 0, canvas.width, canvas.height );

    }

  }

  this.texture = texture;

};

UI.Texture.prototype.onChange = function ( callback ) {

  this.onChangeCallback = callback;

  return this;

};

// Outliner

UI.Outliner = function ( editor ) {

  UI.Element.call( this );

  var scope = this;

  var dom = document.createElement( 'div' );
  dom.className = 'Outliner';
  dom.tabIndex = 0; // keyup event is ignored without setting tabIndex

  // hack
  this.scene = editor.scene;

  // Prevent native scroll behavior
  dom.addEventListener( 'keydown', function ( event ) {

    switch ( event.keyCode ) {
      case 38: // up
      case 40: // down
        event.preventDefault();
        event.stopPropagation();
        break;
    }

  }, false );

  // Keybindings to support arrow navigation
  dom.addEventListener( 'keyup', function ( event ) {

    switch ( event.keyCode ) {
      case 38: // up
        scope.selectIndex( scope.selectedIndex - 1 );
        break;
      case 40: // down
        scope.selectIndex( scope.selectedIndex + 1 );
        break;
    }

  }, false );

  this.dom = dom;

  this.options = [];
  this.selectedIndex = - 1;
  this.selectedValue = null;

  return this;

};

UI.Outliner.prototype = Object.create( UI.Element.prototype );
UI.Outliner.prototype.constructor = UI.Outliner;

UI.Outliner.prototype.selectIndex = function ( index ) {

  if ( index >= 0 && index < this.options.length ) {

    this.setValue( this.options[ index ].value );

    var changeEvent = document.createEvent( 'HTMLEvents' );
    changeEvent.initEvent( 'change', true, true );
    this.dom.dispatchEvent( changeEvent );

  }

};

UI.Outliner.prototype.setOptions = function ( options ) {

  var scope = this;

  while ( scope.dom.children.length > 0 ) {

    scope.dom.removeChild( scope.dom.firstChild );

  }

  function onClick() {

    scope.setValue( this.value );

    var changeEvent = document.createEvent( 'HTMLEvents' );
    changeEvent.initEvent( 'change', true, true );
    scope.dom.dispatchEvent( changeEvent );

  }

  // Drag

  var currentDrag;

  function onDrag( event ) {

    currentDrag = this;

  }

  function onDragStart( event ) {

    event.dataTransfer.setData( 'text', 'foo' );

  }

  function onDragOver( event ) {

    if ( this === currentDrag ) return;

    var area = event.offsetY / this.clientHeight;

    if ( area < 0.25 ) {

      this.className = 'option dragTop';

    } else if ( area > 0.75 ) {

      this.className = 'option dragBottom';

    } else {

      this.className = 'option drag';

    }

  }

  function onDragLeave() {

    if ( this === currentDrag ) return;

    this.className = 'option';

  }

  function onDrop( event ) {

    if ( this === currentDrag ) return;

    this.className = 'option';

    var scene = scope.scene;
    var object = scene.getObjectById( currentDrag.value );

    var area = event.offsetY / this.clientHeight;

    if ( area < 0.25 ) {

      var nextObject = scene.getObjectById( this.value );
      moveObject( object, nextObject.parent, nextObject );

    } else if ( area > 0.75 ) {

      var nextObject = scene.getObjectById( this.nextSibling.value );
      moveObject( object, nextObject.parent, nextObject );

    } else {

      var parentObject = scene.getObjectById( this.value );
      moveObject( object, parentObject );

    }

  }

  function moveObject( object, newParent, nextObject ) {

    if ( nextObject === null ) nextObject = undefined;

    var newParentIsChild = false;

    object.traverse( function ( child ) {

      if ( child === newParent ) newParentIsChild = true;

    } );

    if ( newParentIsChild ) return;

    editor.execute( new MoveObjectCommand( object, newParent, nextObject ) );

    var changeEvent = document.createEvent( 'HTMLEvents' );
    changeEvent.initEvent( 'change', true, true );
    scope.dom.dispatchEvent( changeEvent );

  }

  //

  scope.options = [];

  for ( var i = 0; i < options.length; i ++ ) {

    var div = options[ i ];
    div.className = 'option';
    scope.dom.appendChild( div );

    scope.options.push( div );

    div.addEventListener( 'click', onClick, false );

    if ( div.draggable === true ) {

      div.addEventListener( 'drag', onDrag, false );
      div.addEventListener( 'dragstart', onDragStart, false ); // Firefox needs this

      div.addEventListener( 'dragover', onDragOver, false );
      div.addEventListener( 'dragleave', onDragLeave, false );
      div.addEventListener( 'drop', onDrop, false );

    }


  }

  return scope;

};

UI.Outliner.prototype.getValue = function () {

  return this.selectedValue;

};

UI.Outliner.prototype.setValue = function ( value ) {

  for ( var i = 0; i < this.options.length; i ++ ) {

    var element = this.options[ i ];

    if ( element.value === value ) {

      element.classList.add( 'active' );

      // scroll into view

      var y = element.offsetTop - this.dom.offsetTop;
      var bottomY = y + element.offsetHeight;
      var minScroll = bottomY - this.dom.offsetHeight;

      if ( this.dom.scrollTop > y ) {

        this.dom.scrollTop = y;

      } else if ( this.dom.scrollTop < minScroll ) {

        this.dom.scrollTop = minScroll;

      }

      this.selectedIndex = i;

    } else {

      element.classList.remove( 'active' );

    }

  }

  this.selectedValue = value;

  return this;

};

UI.THREE = {};

UI.THREE.Boolean = function ( boolean, text ) {

  UI.Span.call( this );

  this.setMarginRight( '10px' );

  this.checkbox = new UI.Checkbox( boolean );
  this.text = new UI.Text( text ).setMarginLeft( '3px' );

  this.add( this.checkbox );
  this.add( this.text );

};

UI.THREE.Boolean.prototype = Object.create( UI.Span.prototype );
UI.THREE.Boolean.prototype.constructor = UI.THREE.Boolean;

UI.THREE.Boolean.prototype.getValue = function () {

  return this.checkbox.getValue();

};

UI.THREE.Boolean.prototype.setValue = function ( value ) {

  return this.checkbox.setValue( value );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var APP = {

  Player: function () {

    var loader = new THREE.ObjectLoader();
    var camera, scene, renderer;

    var events = {};

    var dom = document.createElement( 'div' );

    this.dom = dom;

    this.width = 500;
    this.height = 500;

    this.load = function ( json ) {

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setClearColor( 0x000000 );
      renderer.setPixelRatio( window.devicePixelRatio );

      var project = json.project;

      if ( project.gammaInput ) renderer.gammaInput = true;
      if ( project.gammaOutput ) renderer.gammaOutput = true;
      if ( project.shadows ) renderer.shadowMap.enabled = true;
      if ( project.vr ) renderer.vr.enabled = true;

      dom.appendChild( renderer.domElement );

      this.setScene( loader.parse( json.scene ) );
      this.setCamera( loader.parse( json.camera ) );

      events = {
        init: [],
        start: [],
        stop: [],
        keydown: [],
        keyup: [],
        mousedown: [],
        mouseup: [],
        mousemove: [],
        touchstart: [],
        touchend: [],
        touchmove: [],
        update: []
      };

      var scriptWrapParams = 'player,renderer,scene,camera';
      var scriptWrapResultObj = {};

      for ( var eventKey in events ) {

        scriptWrapParams += ',' + eventKey;
        scriptWrapResultObj[ eventKey ] = eventKey;

      }

      var scriptWrapResult = JSON.stringify( scriptWrapResultObj ).replace( /\"/g, '' );

      for ( var uuid in json.scripts ) {

        var object = scene.getObjectByProperty( 'uuid', uuid, true );

        if ( object === undefined ) {

          console.warn( 'APP.Player: Script without object.', uuid );
          continue;

        }

        var scripts = json.scripts[ uuid ];

        for ( var i = 0; i < scripts.length; i ++ ) {

          var script = scripts[ i ];

          var functions = ( new Function( scriptWrapParams, script.source + '\nreturn ' + scriptWrapResult + ';' ).bind( object ) )( this, renderer, scene, camera );

          for ( var name in functions ) {

            if ( functions[ name ] === undefined ) continue;

            if ( events[ name ] === undefined ) {

              console.warn( 'APP.Player: Event type not supported (', name, ')' );
              continue;

            }

            events[ name ].push( functions[ name ].bind( object ) );

          }

        }

      }

      dispatch( events.init, arguments );

    };

    this.setCamera = function ( value ) {

      camera = value;
      camera.aspect = this.width / this.height;
      camera.updateProjectionMatrix();

      if ( renderer.vr.enabled ) {

        WEBVR.checkAvailability().catch( function( message ) {

          dom.appendChild( WEBVR.getMessageContainer( message ) );

        } );

        WEBVR.getVRDisplay( function ( device ) {

          renderer.vr.setDevice( device );
          dom.appendChild( WEBVR.getButton( device, renderer.domElement ) );

        } );

      }

    };

    this.setScene = function ( value ) {

      scene = value;

    };

    this.setSize = function ( width, height ) {

      this.width = width;
      this.height = height;

      if ( camera ) {

        camera.aspect = this.width / this.height;
        camera.updateProjectionMatrix();

      }

      if ( renderer ) {

        renderer.setSize( width, height );

      }

    };

    function dispatch( array, event ) {

      for ( var i = 0, l = array.length; i < l; i ++ ) {

        array[ i ]( event );

      }

    }

    var prevTime;

    function animate( time ) {

      try {

        dispatch( events.update, { time: time, delta: time - prevTime } );

      } catch ( e ) {

        console.error( ( e.message || e ), ( e.stack || "" ) );

      }

      renderer.render( scene, camera );

      prevTime = time;

    }

    this.play = function () {

      prevTime = performance.now();

      document.addEventListener( 'keydown', onDocumentKeyDown );
      document.addEventListener( 'keyup', onDocumentKeyUp );
      document.addEventListener( 'mousedown', onDocumentMouseDown );
      document.addEventListener( 'mouseup', onDocumentMouseUp );
      document.addEventListener( 'mousemove', onDocumentMouseMove );
      document.addEventListener( 'touchstart', onDocumentTouchStart );
      document.addEventListener( 'touchend', onDocumentTouchEnd );
      document.addEventListener( 'touchmove', onDocumentTouchMove );

      dispatch( events.start, arguments );

      renderer.animate( animate );

    };

    this.stop = function () {

      document.removeEventListener( 'keydown', onDocumentKeyDown );
      document.removeEventListener( 'keyup', onDocumentKeyUp );
      document.removeEventListener( 'mousedown', onDocumentMouseDown );
      document.removeEventListener( 'mouseup', onDocumentMouseUp );
      document.removeEventListener( 'mousemove', onDocumentMouseMove );
      document.removeEventListener( 'touchstart', onDocumentTouchStart );
      document.removeEventListener( 'touchend', onDocumentTouchEnd );
      document.removeEventListener( 'touchmove', onDocumentTouchMove );

      dispatch( events.stop, arguments );

      renderer.animate( null );

    };

    this.dispose = function () {

      while ( dom.children.length ) {

        dom.removeChild( dom.firstChild );

      }

      renderer.dispose();

      camera = undefined;
      scene = undefined;
      renderer = undefined;

    };

    //

    function onDocumentKeyDown( event ) {

      dispatch( events.keydown, event );

    }

    function onDocumentKeyUp( event ) {

      dispatch( events.keyup, event );

    }

    function onDocumentMouseDown( event ) {

      dispatch( events.mousedown, event );

    }

    function onDocumentMouseUp( event ) {

      dispatch( events.mouseup, event );

    }

    function onDocumentMouseMove( event ) {

      dispatch( events.mousemove, event );

    }

    function onDocumentTouchStart( event ) {

      dispatch( events.touchstart, event );

    }

    function onDocumentTouchEnd( event ) {

      dispatch( events.touchend, event );

    }

    function onDocumentTouchMove( event ) {

      dispatch( events.touchmove, event );

    }

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Player = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setId( 'player' );
  container.setPosition( 'absolute' );
  container.setDisplay( 'none' );

  //

  var player = new APP.Player();
  container.dom.appendChild( player.dom );

  window.addEventListener( 'resize', function () {

    player.setSize( container.dom.clientWidth, container.dom.clientHeight );

  } );

  signals.startPlayer.add( function () {

    container.setDisplay( '' );

    player.load( editor.toJSON() );
    player.setSize( container.dom.clientWidth, container.dom.clientHeight );
    player.play();

  } );

  signals.stopPlayer.add( function () {

    container.setDisplay( 'none' );

    player.stop();
    player.dispose();

  } );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Script = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setId( 'script' );
  container.setPosition( 'absolute' );
  container.setBackgroundColor( '#272822' );
  container.setDisplay( 'none' );

  var header = new UI.Panel();
  header.setPadding( '10px' );
  container.add( header );

  var title = new UI.Text().setColor( '#fff' );
  header.add( title );

  var buttonSVG = ( function () {
    var svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );
    svg.setAttribute( 'width', 32 );
    svg.setAttribute( 'height', 32 );
    var path = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );
    path.setAttribute( 'd', 'M 12,12 L 22,22 M 22,12 12,22' );
    path.setAttribute( 'stroke', '#fff' );
    svg.appendChild( path );
    return svg;
  } )();

  var close = new UI.Element( buttonSVG );
  close.setPosition( 'absolute' );
  close.setTop( '3px' );
  close.setRight( '1px' );
  close.setCursor( 'pointer' );
  close.onClick( function () {

    container.setDisplay( 'none' );

  } );
  header.add( close );


  var renderer;

  signals.rendererChanged.add( function ( newRenderer ) {

    renderer = newRenderer;

  } );


  var delay;
  var currentMode;
  var currentScript;
  var currentObject;

  var codemirror = CodeMirror( container.dom, {
    value: '',
    lineNumbers: true,
    matchBrackets: true,
    indentWithTabs: true,
    tabSize: 4,
    indentUnit: 4,
    hintOptions: {
      completeSingle: false
    }
  } );
  codemirror.setOption( 'theme', 'monokai' );
  codemirror.on( 'change', function () {

    if ( codemirror.state.focused === false ) return;

    clearTimeout( delay );
    delay = setTimeout( function () {

      var value = codemirror.getValue();

      if ( ! validate( value ) ) return;

      if ( typeof( currentScript ) === 'object' ) {

        if ( value !== currentScript.source ) {

          editor.execute( new SetScriptValueCommand( currentObject, currentScript, 'source', value ) );

        }
        return;
      }

      if ( currentScript !== 'programInfo' ) return;

      var json = JSON.parse( value );

      if ( JSON.stringify( currentObject.material.defines ) !== JSON.stringify( json.defines ) ) {

        var cmd = new SetMaterialValueCommand( currentObject, 'defines', json.defines );
        cmd.updatable = false;
        editor.execute( cmd );

      }
      if ( JSON.stringify( currentObject.material.uniforms ) !== JSON.stringify( json.uniforms ) ) {

        var cmd = new SetMaterialValueCommand( currentObject, 'uniforms', json.uniforms );
        cmd.updatable = false;
        editor.execute( cmd );

      }
      if ( JSON.stringify( currentObject.material.attributes ) !== JSON.stringify( json.attributes ) ) {

        var cmd = new SetMaterialValueCommand( currentObject, 'attributes', json.attributes );
        cmd.updatable = false;
        editor.execute( cmd );

      }

    }, 300 );

  });

  // prevent backspace from deleting objects
  var wrapper = codemirror.getWrapperElement();
  wrapper.addEventListener( 'keydown', function ( event ) {

    event.stopPropagation();

  } );

  // validate

  var errorLines = [];
  var widgets = [];

  var validate = function ( string ) {

    var valid;
    var errors = [];

    return codemirror.operation( function () {

      while ( errorLines.length > 0 ) {

        codemirror.removeLineClass( errorLines.shift(), 'background', 'errorLine' );

      }

      while ( widgets.length > 0 ) {

        codemirror.removeLineWidget( widgets.shift() );

      }

      //

      switch ( currentMode ) {

        case 'javascript':

          try {

            var syntax = esprima.parse( string, { tolerant: true } );
            errors = syntax.errors;

          } catch ( error ) {

            errors.push( {

              lineNumber: error.lineNumber - 1,
              message: error.message

            } );

          }

          for ( var i = 0; i < errors.length; i ++ ) {

            var error = errors[ i ];
            error.message = error.message.replace(/Line [0-9]+: /, '');

          }

          break;

        case 'json':

          errors = [];

          jsonlint.parseError = function ( message, info ) {

            message = message.split('\n')[3];

            errors.push( {

              lineNumber: info.loc.first_line - 1,
              message: message

            } );

          };

          try {

            jsonlint.parse( string );

          } catch ( error ) {

            // ignore failed error recovery

          }

          break;

        case 'glsl':

          try {

            var shaderType = currentScript === 'vertexShader' ?
                glslprep.Shader.VERTEX : glslprep.Shader.FRAGMENT;

            glslprep.parseGlsl( string, shaderType );

          } catch( error ) {

            if ( error instanceof glslprep.SyntaxError ) {

              errors.push( {

                lineNumber: error.line,
                message: "Syntax Error: " + error.message

              } );

            } else {

              console.error( error.stack || error );

            }

          }

          if ( errors.length !== 0 ) break;
          if ( renderer instanceof THREE.WebGLRenderer === false ) break;

          currentObject.material[ currentScript ] = string;
          currentObject.material.needsUpdate = true;
          signals.materialChanged.dispatch( currentObject.material );

          var programs = renderer.info.programs;

          valid = true;
          var parseMessage = /^(?:ERROR|WARNING): \d+:(\d+): (.*)/g;

          for ( var i = 0, n = programs.length; i !== n; ++ i ) {

            var diagnostics = programs[i].diagnostics;

            if ( diagnostics === undefined ||
                diagnostics.material !== currentObject.material ) continue;

            if ( ! diagnostics.runnable ) valid = false;

            var shaderInfo = diagnostics[ currentScript ];
            var lineOffset = shaderInfo.prefix.split(/\r\n|\r|\n/).length;

            while ( true ) {

              var parseResult = parseMessage.exec( shaderInfo.log );
              if ( parseResult === null ) break;

              errors.push( {

                lineNumber: parseResult[ 1 ] - lineOffset,
                message: parseResult[ 2 ]

              } );

            } // messages

            break;

          } // programs

      } // mode switch

      for ( var i = 0; i < errors.length; i ++ ) {

        var error = errors[ i ];

        var message = document.createElement( 'div' );
        message.className = 'esprima-error';
        message.textContent = error.message;

        var lineNumber = Math.max( error.lineNumber, 0 );
        errorLines.push( lineNumber );

        codemirror.addLineClass( lineNumber, 'background', 'errorLine' );

        var widget = codemirror.addLineWidget( lineNumber, message );

        widgets.push( widget );

      }

      return valid !== undefined ? valid : errors.length === 0;

    });

  };

  // tern js autocomplete

  var server = new CodeMirror.TernServer( {
    caseInsensitive: true,
    plugins: { threejs: null }
  } );

  codemirror.setOption( 'extraKeys', {
    'Ctrl-Space': function(cm) { server.complete(cm); },
    'Ctrl-I': function(cm) { server.showType(cm); },
    'Ctrl-O': function(cm) { server.showDocs(cm); },
    'Alt-.': function(cm) { server.jumpToDef(cm); },
    'Alt-,': function(cm) { server.jumpBack(cm); },
    'Ctrl-Q': function(cm) { server.rename(cm); },
    'Ctrl-.': function(cm) { server.selectName(cm); }
  } );

  codemirror.on( 'cursorActivity', function( cm ) {

    if ( currentMode !== 'javascript' ) return;
    server.updateArgHints( cm );

  } );

  codemirror.on( 'keypress', function( cm, kb ) {

    if ( currentMode !== 'javascript' ) return;
    var typed = String.fromCharCode( kb.which || kb.keyCode );
    if ( /[\w\.]/.exec( typed ) ) {

      server.complete( cm );

    }

  } );


  //

  signals.editorCleared.add( function () {

    container.setDisplay( 'none' );

  } );

  signals.editScript.add( function ( object, script ) {

    var mode, name, source;

    if ( typeof( script ) === 'object' ) {

      mode = 'javascript';
      name = script.name;
      source = script.source;
      title.setValue( object.name + ' / ' + name );

    } else {

      switch ( script ) {

        case 'vertexShader':

          mode = 'glsl';
          name = 'Vertex Shader';
          source = object.material.vertexShader || "";

          break;

        case 'fragmentShader':

          mode = 'glsl';
          name = 'Fragment Shader';
          source = object.material.fragmentShader || "";

          break;

        case 'programInfo':

          mode = 'json';
          name = 'Program Properties';
          var json = {
            defines: object.material.defines,
            uniforms: object.material.uniforms,
            attributes: object.material.attributes
          };
          source = JSON.stringify( json, null, '\t' );

      }
      title.setValue( object.material.name + ' / ' + name );

    }

    currentMode = mode;
    currentScript = script;
    currentObject = object;

    container.setDisplay( '' );
    codemirror.setValue( source );
    codemirror.clearHistory();
    if ( mode === 'json' ) mode = { name: 'javascript', json: true };
    codemirror.setOption( 'mode', mode );

  } );

  signals.scriptRemoved.add( function ( script ) {

    if ( currentScript === script ) {

      container.setDisplay( 'none' );

    }

  } );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Storage = function () {

  var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

  if ( indexedDB === undefined  ) {

    console.warn( 'Storage: IndexedDB not available.' );
    return { init: function () {}, get: function () {}, set: function () {}, clear: function () {} };

  }

  var name = 'threejs-editor';
  var version = 1;

  var database;

  return {

    init: function ( callback ) {

      var request = indexedDB.open( name, version );
      request.onupgradeneeded = function ( event ) {

        var db = event.target.result;

        if ( db.objectStoreNames.contains( 'states' ) === false ) {

          db.createObjectStore( 'states' );

        }

      };
      request.onsuccess = function ( event ) {

        database = event.target.result;

        callback();

      };
      request.onerror = function ( event ) {

        console.error( 'IndexedDB', event );

      };


    },

    get: function ( uuid, callback ) {

      if (uuid != "None") {
        $.ajax({
           url: '/rest/resume_state/' + uuid,
           data: {
              format: 'json'
           },
           dataType: 'json',
           success: function (data) {
             callback(data);
           },
           type: 'GET'
        });
      } else {
        var transaction = database.transaction( [ 'states' ], 'readwrite' );
        var objectStore = transaction.objectStore( 'states' );

        var request = objectStore.get( 0 );
        request.onsuccess = function ( event ) {
          callback( event.target.result );
        };
      }




    },

    set: function ( data, callback ) {

      var start = performance.now();
      $.ajax({
        url: '/rest/save_state',
        data: JSON.stringify(data),
        contentType: "application/json",
        dataType: "json",
        success: function(data) {
          if ( data.results == "SUCCESS" ) {
            console.log('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Saved state to server as UUID', data.uuid, ( performance.now() - start ).toFixed( 2 ) + 'ms');
            if ( editor.project_uuid == "" ) {
              editor.project_uuid = data.uuid; //Set the initial UUID if this the first save-state for this session.
            }
          } else {
              if (data.reason == "IOERROR") {
                // The server had a disk or permissions error. Let the user know
                if (data.error == 13) { // No permission
                  console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to save state to server. The server doesn\'t have permission to write to disk.');
                } else if (data.error == 28) { // Disk full
                  console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to save state to server. The server doesn\'t have enough space to save to disk.');
                } else { //Other IO error
                  console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to save state to server. There was an I/O Error.', data.errorstring);
                }
              } else { // Other error
                console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to save state to server.', data.reason, data.error);
              }
            }
        },
        error: function() {
          console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to save state to server. ');
        },
        type: 'POST'
      });

      var transaction = database.transaction( [ 'states' ], 'readwrite' );
      var objectStore = transaction.objectStore( 'states' );
      var request = objectStore.put( data, 0 );


      request.onsuccess = function ( event ) {

        console.log( '[' + /\d\d\:\d\d\:\d\d/.exec( new Date() )[ 0 ] + ']', 'Saved state to IndexedDB. ' + ( performance.now() - start ).toFixed( 2 ) + 'ms' );

      };

    },

    clear: function () {

      if ( database === undefined ) return;

      var transaction = database.transaction( [ 'states' ], 'readwrite' );
      var objectStore = transaction.objectStore( 'states' );
      var request = objectStore.clear();
      request.onsuccess = function ( event ) {

        console.log( '[' + /\d\d\:\d\d\:\d\d/.exec( new Date() )[ 0 ] + ']', 'Cleared IndexedDB.' );

      };

    }

  };

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Editor = function () {

  this.DEFAULT_CAMERA = new THREE.PerspectiveCamera( 50, 1, 0.1, 10000 );
  this.DEFAULT_CAMERA.name = 'Camera';
  this.DEFAULT_CAMERA.position.set( 20, 10, 20 );
  this.DEFAULT_CAMERA.lookAt( new THREE.Vector3() );
  this.project_uuid = "";

    var Signal = signals.Signal;


  this.signals = {

    // script

    editScript: new Signal(),

    // player

    startPlayer: new Signal(),
    stopPlayer: new Signal(),

    // actions

    showModal: new Signal(),

    // notifications

    editorCleared: new Signal(),

    savingStarted: new Signal(),
    savingFinished: new Signal(),

    themeChanged: new Signal(),

    transformModeChanged: new Signal(),
    snapChanged: new Signal(),
    spaceChanged: new Signal(),
    rendererChanged: new Signal(),

    sceneBackgroundChanged: new Signal(),
    sceneFogChanged: new Signal(),
    sceneGraphChanged: new Signal(),

    cameraChanged: new Signal(),

    geometryChanged: new Signal(),

    objectSelected: new Signal(),
    objectFocused: new Signal(),

    objectAdded: new Signal(),
    objectChanged: new Signal(),
    objectRemoved: new Signal(),

    helperAdded: new Signal(),
    helperRemoved: new Signal(),

    materialChanged: new Signal(),

    scriptAdded: new Signal(),
    scriptChanged: new Signal(),
    scriptRemoved: new Signal(),

    windowResize: new Signal(),

    showGridChanged: new Signal(),
    refreshSidebarObject3D: new Signal(),
    historyChanged: new Signal()

  };

  this.config = new Config( 'threejs-editor' );
  this.history = new History( this );
  this.storage = new Storage();
  this.loader = new Loader( this );

  this.camera = this.DEFAULT_CAMERA.clone();

  this.scene = new THREE.Scene();
  this.scene.name = 'Scene';
  this.scene.background = new THREE.Color( 0xaaaaaa );

    this.scene.length = 0;
    this.scene.wingspan = 0;
    this.scene.height = 0;
    this.scene.x_max = 0;
    this.scene.x_min = 0;
    this.scene.y_max = 0;
    this.scene.y_min = 0;
    this.scene.z_max = 0;
    this.scene.z_min = 0;
    this.scene.z_short = 0;
    this.scene.y_short = 0;
    this.scene.antennaSnapping = false;
    this.scene.x_short = [0, 0, 0, 0];
    this.scene.y_short = [0, 0, 0, 0];
    this.scene.z_short = [0, 0, 0, 0];
    this.scene.menu = [null, null, null, null];
    this.scene.posi = [0, 0, 0, 0];
    this.scene.rota = [0, 0, 0 ,0];
    this.scene.scal = [0, 0, 0, 0];

  this.sceneHelpers = new THREE.Scene();

  this.object = {};
  this.geometries = {};
  this.materials = {};
  this.textures = {};
  this.scripts = {};

  this.selected = null;
  this.helpers = {};

};


Editor.prototype = {

  setTheme: function ( value ) {

    document.getElementById( 'theme' ).href = value;

    this.signals.themeChanged.dispatch( value );

  },

  //

  setScene: function ( scene ) {

    this.scene.uuid = scene.uuid;
    this.scene.name = scene.name;

    if ( scene.background !== null ) this.scene.background = scene.background.clone();
    if ( scene.fog !== null ) this.scene.fog = scene.fog.clone();

    this.scene.userData = JSON.parse( JSON.stringify( scene.userData ) );

    // avoid render per object

    this.signals.sceneGraphChanged.active = false;

    while ( scene.children.length > 0 ) {

      this.addObject( scene.children[ 0 ] );

    }

    this.signals.sceneGraphChanged.active = true;
    this.signals.sceneGraphChanged.dispatch();

  },

  //

  setAntennaSnapping: function (checkboxValue) {
    this.scene.antennaSnapping = checkboxValue;
  },

  //

  getAntennaSnapping: function () {
    return this.scene.antennaSnapping;
  },

  addObject: function ( object ) {

    var scope = this;

    object.traverse( function ( child ) {

      if ( child.geometry !== undefined ) scope.addGeometry( child.geometry );
      if ( child.material !== undefined ) scope.addMaterial( child.material );

      scope.addHelper( child );

    } );

    this.scene.add( object );

    this.signals.objectAdded.dispatch( object );
    this.signals.sceneGraphChanged.dispatch();

  },

  moveObject: function ( object, parent, before ) {

    if ( parent === undefined ) {

      parent = this.scene;

    }

    parent.add( object );

    // sort children array

    if ( before !== undefined ) {

      var index = parent.children.indexOf( before );
      parent.children.splice( index, 0, object );
      parent.children.pop();

    }

    this.signals.sceneGraphChanged.dispatch();

  },

  nameObject: function ( object, name ) {

    object.name = name;
    this.signals.sceneGraphChanged.dispatch();

  },

  removeObject: function ( object ) {

    if ( object.parent === null ) return; // avoid deleting the camera or scene

    var scope = this;

    object.traverse( function ( child ) {

      scope.removeHelper( child );

    } );

    object.parent.remove( object );

    this.signals.objectRemoved.dispatch( object );
    this.signals.sceneGraphChanged.dispatch();

  },

  addGeometry: function ( geometry ) {

    this.geometries[ geometry.uuid ] = geometry;

  },

  setGeometryName: function ( geometry, name ) {

    geometry.name = name;
    this.signals.sceneGraphChanged.dispatch();

  },

  addMaterial: function ( material ) {

    this.materials[ material.uuid ] = material;

  },

  setMaterialName: function ( material, name ) {

    material.name = name;
    this.signals.sceneGraphChanged.dispatch();

  },

  addTexture: function ( texture ) {

    this.textures[ texture.uuid ] = texture;

  },

  //

  addHelper: function () {

    var geometry = new THREE.SphereBufferGeometry( 2, 4, 2 );
    var material = new THREE.MeshBasicMaterial( { color: 0xff0000, visible: false } );

    return function ( object ) {

      var helper;

      if ( object instanceof THREE.Camera ) {

        helper = new THREE.CameraHelper( object, 1 );

      } else if ( object instanceof THREE.PointLight ) {

        helper = new THREE.PointLightHelper( object, 1 );

      } else if ( object instanceof THREE.DirectionalLight ) {

        helper = new THREE.DirectionalLightHelper( object, 1 );

      } else if ( object instanceof THREE.SpotLight ) {

        helper = new THREE.SpotLightHelper( object, 1 );

      } else if ( object instanceof THREE.HemisphereLight ) {

        helper = new THREE.HemisphereLightHelper( object, 1 );

      } else if ( object instanceof THREE.SkinnedMesh ) {

        helper = new THREE.SkeletonHelper( object );

      } else {

        // no helper for this object type
        return;

      }

      var picker = new THREE.Mesh( geometry, material );
      picker.name = 'picker';
      picker.userData.object = object;
      helper.add( picker );

      this.sceneHelpers.add( helper );
      this.helpers[ object.id ] = helper;

      this.signals.helperAdded.dispatch( helper );

    };

  }(),

  removeHelper: function ( object ) {

    if ( this.helpers[ object.id ] !== undefined ) {

      var helper = this.helpers[ object.id ];
      helper.parent.remove( helper );

      delete this.helpers[ object.id ];

      this.signals.helperRemoved.dispatch( helper );

    }

  },

  //

  addScript: function ( object, script ) {

    if ( this.scripts[ object.uuid ] === undefined ) {

      this.scripts[ object.uuid ] = [];

    }

    this.scripts[ object.uuid ].push( script );

    this.signals.scriptAdded.dispatch( script );

  },

  removeScript: function ( object, script ) {

    if ( this.scripts[ object.uuid ] === undefined ) return;

    var index = this.scripts[ object.uuid ].indexOf( script );

    if ( index !== - 1 ) {

      this.scripts[ object.uuid ].splice( index, 1 );

    }

    this.signals.scriptRemoved.dispatch( script );

  },

  getObjectMaterial: function ( object, slot ) {

    var material = object.material;

    if ( Array.isArray( material ) ) {

      material = material[ slot ];

    }

    return material;

  },

  setObjectMaterial: function ( object, slot, newMaterial ) {

    if ( Array.isArray( object.material ) ) {

      object.material[ slot ] = newMaterial;

    } else {

      object.material = newMaterial;

    }

  },

  //

  select: function ( object ) {
    if ( this.selected === object ) return;

    if(object === null || this.scene == object || this.scene === object.parent){
      var uuid = null;

      if ( object !== null ) {

        uuid = object.uuid;

      }

      this.selected = object;

      this.config.setKey( 'selected', uuid );
      this.signals.objectSelected.dispatch( object );

    } else {
      var uuid = null;

      if ( object.parent !== null ) {

        uuid = object.parent.uuid;

      }

      this.selected = object.parent;

      this.config.setKey( 'selected', uuid );
      this.signals.objectSelected.dispatch( object.parent );
    }
  },

  selectById: function ( id ) {

    if ( id === this.camera.id ) {

      this.select( this.camera );
      return;

    }

    this.select( this.scene.getObjectById( id, true ) );

  },

  selectByUuid: function ( uuid ) {

    var scope = this;

    this.scene.traverse( function ( child ) {

      if ( child.uuid === uuid ) {

        scope.select( child );

      }

    } );

  },

  deselect: function () {

    this.select( null );

  },

  focus: function ( object ) {

    this.signals.objectFocused.dispatch( object );

  },

  focusById: function ( id ) {

    this.focus( this.scene.getObjectById( id, true ) );

  },

  clear: function () {

    this.history.clear();
    this.storage.clear();

    this.camera.copy( this.DEFAULT_CAMERA );
    this.scene.background.setHex( 0xaaaaaa );
    this.scene.fog = null;

    var objects = this.scene.children;

        this.scene.length = 0;
        this.scene.wingspan = 0;
        this.scene.height = 0;
        this.scene.x_max = 0;
        this.scene.x_min = 0;
        this.scene.y_max = 0;
        this.scene.y_min = 0;
        this.scene.z_max = 0;
        this.scene.z_min = 0;
        this.scene.z_short = 0;
        this.scene.y_short = 0;
        this.scene.antennaSnapping = false;
        this.scene.x_short = [0, 0, 0, 0];
        this.scene.y_short = [0, 0, 0, 0];
        this.scene.z_short = [0, 0, 0, 0];
        this.scene.posi = [0, 0, 0, 0];
        this.scene.rota = [0, 0, 0 ,0];
        this.scene.scal = [0, 0, 0, 0];

    while ( objects.length > 0 ) {

      this.removeObject( objects[ 0 ] );

    }

    this.geometries = {};
    this.materials = {};
    this.textures = {};
    this.scripts = {};

    this.deselect();

    this.signals.editorCleared.dispatch();


  },

  //

  fromJSON: function ( json ) {

    var loader = new THREE.ObjectLoader();

    // backwards

    if ( json.scene === undefined ) {

      this.setScene( loader.parse( json ) );
      return;

    }

    var camera = loader.parse( json.camera );
    this.project_uuid = json.project.uuid;
    this.camera.copy( camera );
    this.camera.aspect = this.DEFAULT_CAMERA.aspect;
    this.camera.updateProjectionMatrix();

    this.setRelativeDimensions(json.project.relative_dimensions);

    this.history.fromJSON( json.history );
    this.scripts = json.scripts;

    this.setScene( loader.parse( json.scene ) );

  },

  toJSON: function () {

    // scripts clean up

    var scene = this.scene;
    var scripts = this.scripts;

    for ( var key in scripts ) {

      var script = scripts[ key ];

      if ( script.length === 0 || scene.getObjectByProperty( 'uuid', key ) === undefined ) {

        delete scripts[ key ];

      }

    }

    //

    return {

      metadata: {},
      project: {
        uuid: this.project_uuid,
        relative_dimensions: this.getRelativeDimensions(),
        gammaInput: this.config.getKey( 'project/renderer/gammaInput' ),
        gammaOutput: this.config.getKey( 'project/renderer/gammaOutput' ),
        shadows: this.config.getKey( 'project/renderer/shadows' ),
        vr: this.config.getKey( 'project/vr' ),
      },
      camera: this.camera.toJSON(),
      scene: this.scene.toJSON(),
      scripts: this.scripts,
      history: this.history.toJSON()

    };

  },

  objectByUuid: function ( uuid ) {

    return this.scene.getObjectByProperty( 'uuid', uuid, true );

  },

  execute: function ( cmd, optionalName ) {

    this.history.execute( cmd, optionalName );

  },

  undo: function () {

    this.history.undo();

  },

  redo: function () {

    this.history.redo();

  },


  getRelativeDimensions: function() {
    output = {
        length: this.scene.length,
        wingspan: this.scene.wingspan,
        height: this.scene.height,
        x_max: this.scene.x_max,
        x_min: this.scene.x_min,
        y_max: this.scene.y_max,
        y_min: this.scene.y_min,
        z_max: this.scene.z_max,
        z_min: this.scene.z_min,
        z_short: this.scene.z_short,
        y_short: this.scene.y_short,
        x_short: this.scene.x_short,
        y_short: this.scene.y_short,
        z_short: this.scene.z_short
    };
    return output;
  },

  setRelativeDimensions: function(dimensions) {
    this.scene.length = dimensions.length;
    this.scene.wingspan = dimensions.wingspan;
    this.scene.height = dimensions.height;
    this.scene.x_max = dimensions.x_max;
    this.scene.x_min = dimensions.x_min;
    this.scene.y_max = dimensions.y_max;
    this.scene.y_min = dimensions.y_min;
    this.scene.z_max = dimensions.z_max;
    this.scene.z_min = dimensions.z_min;
    this.scene.z_short = dimensions.z_short;
    this.scene.y_short = dimensions.y_short;
    this.scene.x_short = dimensions.x_short;
    this.scene.y_short = dimensions.y_short;
    this.scene.z_short = dimensions.z_short;
  },

  getModelLength: function() {                           // return model length

        return this.scene.length;

    },

    getModelWingspan: function() {                         // return model wingspan

        return this.scene.wingspan;

    },

    getModelHeight: function() {                           // return model height (nose up)

        return this.scene.height;

    },

    setModelDimensions: function( len, wing, heigh ) {     // set input model dimensions

        this.scene.length = parseFloat(len);
        this.scene.wingspan = parseFloat(wing);
        this.scene.height = parseFloat(heigh);

    },

    setModel: function ( geo ){

        for ( var i = 0; i < geo.children.length; i++ ){             // check each face of the model to determine extreme points
            var type = geo.children[i].geometry;
            if ( type.type === "BufferGeometry" ) {                  // for type BufferGeometry
                var next = type.attributes.position.array;
                for (var j = 0; j < next.length; j = j + 3) {        // iterate through every third facet
                    if ( next[j] > this.scene.x_max ) {                         // if value is more or less than the highest or lowest x, y, or z: replace
                        this.scene.x_max = next[j];
                        this.scene.y_short[0] = next[j + 1];                    // store the two associated coordinates for the max/min
                        this.scene.z_short[0] = next[j + 2];
                    }
                    if ( next[j] < this.scene.x_min ) {
                        this.scene.x_min = next[j];
                        this.scene.y_short[1] = next[j + 1];
                        this.scene.z_short[1] = next[j + 2];
                    }
                    if ( next[j + 1] > this.scene.y_max ) {
                        this.scene.y_max = next[j + 1];
                        this.scene.x_short[0] = next[j];
                        this.scene.z_short[2] = next[j + 2];
                    }
                    if ( next[j + 1] < this.scene.y_min ) {
                        this.scene.y_min = next[j + 1];
                        this.scene.x_short[1] = next[j];
                        this.scene.z_short[3] = next[j + 2];
                    }
                    if ( next[j + 2] > this.scene.z_max ) {
                        this.scene.z_max = next[j + 2];
                        this.scene.x_short[2] = next[j];
                        this.scene.y_short[2] = next[j + 1];
                    }
                    if ( next[j + 2] < this.scene.z_min ) {
                        this.scene.z_min = next[j + 2];
                        this.scene.x_short[3] = next[j];
                        this.scene.y_short[3] = next[j + 1];
                    }
                }
            }
            else if ( type.type === "Geometry" ){                    // for type Geometry
                var next = type.vertices;
                for ( var j = 0; j < next.length; j++ ) {            // iterate through each coordinate set
                    if ( next[j].x > this.scene.x_max ) {
                        this.scene.x_max = next[j].x;
                        this.scene.y_short[0] = next[j].y;
                        this.scene.z_short[0] = next[j].z;
                    }
                    if ( next[j].x < this.scene.x_min ) {
                        this.scene.x_min = next[j].x;
                        this.scene.y_short[1] = next[j].y;
                        this.scene.z_short[1] = next[j].z;
                    }
                    if ( next[j].y > this.scene.y_max ) {
                        this.scene.y_max = next[j].y;
                        this.scene.x_short[0] = next[j].x;
                        this.scene.z_short[2] = next[j].z;
                    }
                    if ( next[j].y < this.scene.y_min ) {
                        this.scene.y_min = next[j].y;
                        this.scene.x_short[1] = next[j].x;
                        this.scene.z_short[3] = next[j].z;
                    }
                    if ( next[j].z > this.scene.z_max ) {
                        this.scene.z_max = next[j].z;
                        this.scene.x_short[2] = next[j].x;
                        this.scene.y_short[2] = next[j].y;
                    }
                    if ( next[j].z < this.scene.z_min ) {
                        this.scene.z_min = next[j].z;
                        this.scene.x_short[3] = next[j].x;
                        this.scene.y_short[3] = next[j].y;
                    }
                }
            }
        }

        var delta_x = Math.abs( this.scene.x_max - this.scene.x_min );      // check which axis provides the largest/smallest difference in points
        var delta_y = Math.abs( this.scene.y_max - this.scene.y_min );
        var delta_z = Math.abs( this.scene.z_max - this.scene.z_min );
    var wings = true;                             // set flag if this.scene.wingspan > this.scene.length
    if ( this.scene.length > this.scene.wingspan ){
      wings = false;
    }

        /**
         * For each of the scenarios below, the extreme values of each axis
         * are used to determine the exact direction and orientation the model
         * is facing to rotate and scale accordingly to match the THREE.js
         * default viewpoint of positive z, x, and y.
         *
         *  Assumptions made:
         *  - Wing tips are closer to the tail of the plane than to the nose
         *  - Nose is closer to the bottom  the plane than the top
         *
         *  Using the information acquired from the model facets, the direction
         * the model is facing (axis-wise) can be determined. From there, the
         * assumptions made are taken into account to determine the exact
         * orientation of the model whether it be facing positive or negative
         * along each associated axis. With all information compiled,
         * coordinates are swapped to reflect the standard model orientation
         * and facing direction and the model is likewise rotated to visibly
         * show such changes.
         */

        // if the this.scene.wingspan is greater than this.scene.length
        if ( wings ) {
            if (delta_z > delta_y && delta_z > delta_x) {
                if (delta_x > delta_y) {
                    if ( Math.abs(this.scene.x_short[2] - this.scene.x_max) > Math.abs(this.scene.x_short[2] - this.scene.x_min) ){
                        if ( Math.abs(this.scene.y_short[0] - this.scene.y_max) > Math.abs(this.scene.y_short[0] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_max * -1;
                            geo.rotateX(180 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.y_short[1] - this.scene.y_max) > Math.abs(this.scene.y_short[1] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_max * -1;
                            geo.rotateX(180 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.y_short[2] - this.scene.y_max) > Math.abs(this.scene.y_short[2] - this.scene.y_min) ){
                        if ( Math.abs(this.scene.x_short[0] - this.scene.x_max) > Math.abs(this.scene.x_short[0] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[0];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[0];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.x_short[1] - this.scene.x_max) > Math.abs(this.scene.x_short[1] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[1];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[1];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }

                }
            }
            else if (delta_y > delta_x && delta_y > delta_z) {
                if (delta_z > delta_x) {
                    if ( Math.abs(this.scene.z_short[2] - this.scene.z_max) > Math.abs(this.scene.z_short[2] - this.scene.z_min) ){
                        if ( Math.abs(this.scene.x_short[2] - this.scene.x_max) > Math.abs(this.scene.x_short[2] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.x_short[3] - this.scene.x_max) > Math.abs(this.scene.x_short[3] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.x_short[0] - this.scene.x_max) > Math.abs(this.scene.x_short[0] - this.scene.x_min) ){
                        if ( Math.abs(this.scene.z_short[0] - this.scene.z_max) > Math.abs(this.scene.z_short[0] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_min = this.scene.z_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.z_short[1] - this.scene.z_max) > Math.abs(this.scene.z_short[1] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_min = this.scene.z_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
            }
            else {
                if (delta_z > delta_y) {
                    if ( Math.abs(this.scene.z_short[0] - this.scene.z_max) > Math.abs(this.scene.z_short[0] - this.scene.z_min) ){
                        if ( Math.abs(this.scene.y_short[2] - this.scene.y_max) > Math.abs(this.scene.y_short[2] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[2];
                        }
                        else {
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_short[2] * -1;
                            geo.rotateZ(180 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.y_short[3] - this.scene.y_max) > Math.abs(this.scene.y_short[3] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[3];
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_max * -1;
                            this.scene.y_min = this.scene.y_short[3] * -1;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateZ(180 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.y_short[0] - this.scene.y_max) > Math.abs(this.scene.y_short[0] - this.scene.y_min) || geo.name === "C-130 Hercules.obj" ){
                        if ( Math.abs(this.scene.z_short[2] - this.scene.z_max) > Math.abs(this.scene.z_short[2] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_max = this.scene.z_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.z_short[3] - this.scene.z_max) > Math.abs(this.scene.z_short[3] - this.scene.z_min) || geo.name === "MQ-9 Reaper.obj" ) {
                            this.scene.z_min = this.scene.z_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_max = this.scene.z_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
            }
        }

        // if this.scene.length is greater than this.scene.wingspan
        else {
            if ( delta_x > delta_y && delta_x > delta_z ){
                if ( delta_z > delta_y ){
                    if ( Math.abs(this.scene.x_short[2] - this.scene.x_max) > Math.abs(this.scene.x_short[2] - this.scene.x_min) ){
                        if ( Math.abs(this.scene.y_short[0] - this.scene.y_max) > Math.abs(this.scene.y_short[0] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_max * -1;
                            geo.rotateX(180 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.y_short[1] - this.scene.y_max) > Math.abs(this.scene.y_short[1] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_max * -1;
                            geo.rotateX(180 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.x_short[0] - this.scene.x_max) > Math.abs(this.scene.x_short[0] - this.scene.x_min) ){
                        if ( Math.abs(this.scene.z_short[0] - this.scene.z_max) > Math.abs(this.scene.z_short[0] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_min = this.scene.z_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.z_short[1] - this.scene.z_max) > Math.abs(this.scene.z_short[1] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[0];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_min = this.scene.z_short[1];
                            var temp = this.scene.x_max;
                            var temp2 = this.scene.x_min;
                            this.scene.x_max = this.scene.y_max;
                            this.scene.x_min = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
            }
            else if ( delta_y > delta_x && delta_y > delta_z ){
                if ( delta_z > delta_x ){
                    if ( Math.abs(this.scene.y_short[2] - this.scene.y_max) > Math.abs(this.scene.y_short[2] - this.scene.y_min) ){
                        if ( Math.abs(this.scene.x_short[0] - this.scene.x_max) > Math.abs(this.scene.x_short[0] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[0];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[0];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.x_short[1] - this.scene.x_max) > Math.abs(this.scene.x_short[1] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[1];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(-90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[1];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = this.scene.z_max;
                            this.scene.x_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(90 * THREE.Math.DEG2RAD);
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.y_short[0] - this.scene.y_max) > Math.abs(this.scene.y_short[0] - this.scene.y_min) ){
                        if ( Math.abs(this.scene.z_short[2] - this.scene.z_max) > Math.abs(this.scene.z_short[2] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_max = this.scene.z_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp;
                            this.scene.z_min = temp2;
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.z_short[3] - this.scene.z_max) > Math.abs(this.scene.z_short[3] - this.scene.z_min) ){
                            this.scene.z_min = this.scene.z_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_max;
                            this.scene.y_min = this.scene.z_min;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateX(-90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.z_max = this.scene.z_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.z_min * -1;
                            this.scene.y_min = this.scene.z_max * -1;
                            this.scene.z_max = temp2 * -1;
                            this.scene.z_min = temp * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateX(90 * THREE.Math.DEG2RAD);
                        }
                    }
                }
            }
            else {
                if ( delta_x > delta_y ){
                    if ( Math.abs(this.scene.z_short[0] - this.scene.z_max) > Math.abs(this.scene.z_short[0] - this.scene.z_min) ){
                        if ( Math.abs(this.scene.y_short[2] - this.scene.y_max) > Math.abs(this.scene.y_short[2] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[2];
                        }
                        else {
                            this.scene.y_max = this.scene.y_min * -1;
                            this.scene.y_min = this.scene.y_short[2] * -1;
                            geo.rotateZ(180 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.y_short[3] - this.scene.y_max) > Math.abs(this.scene.y_short[3] - this.scene.y_min) ){
                            this.scene.y_min = this.scene.y_short[3];
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.y_max = this.scene.y_max * -1;
                            this.scene.y_min = this.scene.y_short[3] * -1;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                            geo.rotateZ(180 * THREE.Math.DEG2RAD);
                        }
                    }
                }
                else {
                    if ( Math.abs(this.scene.z_short[2] - this.scene.z_max) > Math.abs(this.scene.z_short[2] - this.scene.z_min) ){
                        if ( Math.abs(this.scene.x_short[2] - this.scene.x_max) > Math.abs(this.scene.x_short[2] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[2];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                        }
                    }
                    else {
                        if ( Math.abs(this.scene.x_short[3] - this.scene.x_max) > Math.abs(this.scene.x_short[3] - this.scene.x_min) ){
                            this.scene.x_min = this.scene.x_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_max;
                            this.scene.y_min = this.scene.x_min;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateZ(90 * THREE.Math.DEG2RAD);
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                        else {
                            this.scene.x_max = this.scene.x_short[3];
                            var temp = this.scene.y_max;
                            var temp2 = this.scene.y_min;
                            this.scene.y_max = this.scene.x_min * -1;
                            this.scene.y_min = this.scene.x_max * -1;
                            this.scene.x_max = temp;
                            this.scene.x_min = temp2;
                            this.scene.z_max = this.scene.z_min * -1;
                            this.scene.z_min = this.scene.z_max * -1;
                            geo.rotateZ(-90 * THREE.Math.DEG2RAD);
                            geo.rotateY(180 * THREE.Math.DEG2RAD);
                        }
                    }
                }
            }
        }

        this.scene.x_max = geo.scale.x * this.scene.x_max;    // model points adjusted based on model scale
        this.scene.x_min = geo.scale.x * this.scene.x_min;
        this.scene.y_max = geo.scale.y * this.scene.y_max;
        this.scene.y_min = geo.scale.y * this.scene.y_min;
        this.scene.z_max = geo.scale.z * this.scene.z_max;
        this.scene.z_min = geo.scale.z * this.scene.z_min;

        this.scene.posi[0] = geo.position.x;
        this.scene.posi[1] = geo.position.y;
        this.scene.posi[2] = geo.position.z;
        this.scene.rota[0] = geo.rotation.x;
        this.scene.rota[1] = geo.rotation.y;
        this.scene.rota[2] = geo.rotation.z;
        this.scene.scal[0] = geo.scale.x;
        this.scene.scal[1] = geo.scale.y;
        this.scene.scal[2] = geo.scale.z;

        var scale = Math.abs(this.scene.z_max) + Math.abs(this.scene.z_min);      // camera scale adjusted and camera view changed in relation to new model
        var newPos = new THREE.Vector3( scale , scale/2, scale );
        this.execute( new SetPositionCommand( this.camera, newPos ) );
    },

    getModel: function (){                 // return all axis extreme values

        var array = new Object();
        array[0] = this.scene.x_max;
        array[1] = this.scene.x_min;
        array[2] = this.scene.y_max;
        array[3] = this.scene.y_min;
        array[4] = this.scene.z_max;
        array[5] = this.scene.z_min;
        return array;

    },

    getModelPosition: function (){        // return the initial model position

        return this.scene.posi;

    },

    getModelRotation: function (){        // return the initial model rotation

        return this.scene.rota;

    },

    getModelScale: function (){           // return the initial model scale

        return this.scene.scal;

    },

    setMenubar: function ( file ){       // set reference to the menubar

        var i = 0;
        while (this.scene.menu[i] !== null){
            i++;
        }
        this.scene.menu[i] = file;

    },

    getMenubar: function (){             // return reference to the menubar

        return this.scene.menu;

    }


};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Config = function ( name ) {

  var storage = {
    'autosave': true,
    'theme': '/static/css/light.css',

    'project/renderer': 'WebGLRenderer',
    'project/renderer/antialias': true,
    'project/renderer/gammaInput': false,
    'project/renderer/gammaOutput': false,
    'project/renderer/shadows': true,
    'project/vr': false,

    'settings/history': false
  };

  if ( window.localStorage[ name ] === undefined ) {

    window.localStorage[ name ] = JSON.stringify( storage );

  } else {

    var data = JSON.parse( window.localStorage[ name ] );

    for ( var key in data ) {

      storage[ key ] = data[ key ];

    }

  }

  return {

    getKey: function ( key ) {

      return storage[ key ];

    },

    setKey: function () { // key, value, key, value ...

      for ( var i = 0, l = arguments.length; i < l; i += 2 ) {

        storage[ arguments[ i ] ] = arguments[ i + 1 ];

      }

      window.localStorage[ name ] = JSON.stringify( storage );

      console.log( '[' + /\d\d\:\d\d\:\d\d/.exec( new Date() )[ 0 ] + ']', 'Saved config to LocalStorage.' );

    },

    clear: function () {

      delete window.localStorage[ name ];

    }

  };

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

History = function ( editor ) {

  this.editor = editor;
  this.undos = [];
  this.redos = [];
  this.lastCmdTime = new Date();
  this.idCounter = 0;

  this.historyDisabled = false;
  this.config = editor.config;

  //Set editor-reference in Command

  Command( editor );

  // signals

  var scope = this;

  this.editor.signals.startPlayer.add( function () {

    scope.historyDisabled = true;

  } );

  this.editor.signals.stopPlayer.add( function () {

    scope.historyDisabled = false;

  } );

};

History.prototype = {

  execute: function ( cmd, optionalName ) {

    var lastCmd = this.undos[ this.undos.length - 1 ];
    var timeDifference = new Date().getTime() - this.lastCmdTime.getTime();

    var isUpdatableCmd = lastCmd &&
      lastCmd.updatable &&
      cmd.updatable &&
      lastCmd.object === cmd.object &&
      lastCmd.type === cmd.type &&
      lastCmd.script === cmd.script &&
      lastCmd.attributeName === cmd.attributeName;

    if ( isUpdatableCmd && cmd.type === "SetScriptValueCommand" ) {

      // When the cmd.type is "SetScriptValueCommand" the timeDifference is ignored

      lastCmd.update( cmd );
      cmd = lastCmd;

    } else if ( isUpdatableCmd && timeDifference < 500 ) {

      lastCmd.update( cmd );
      cmd = lastCmd;

    } else {

      // the command is not updatable and is added as a new part of the history

      this.undos.push( cmd );
      cmd.id = ++ this.idCounter;

    }
    cmd.name = ( optionalName !== undefined ) ? optionalName : cmd.name;
    cmd.execute();
    cmd.inMemory = true;

    if ( this.config.getKey( 'settings/history' ) ) {

      cmd.json = cmd.toJSON();  // serialize the cmd immediately after execution and append the json to the cmd

    }
    this.lastCmdTime = new Date();

    // clearing all the redo-commands

    this.redos = [];
    this.editor.signals.historyChanged.dispatch( cmd );

  },

  undo: function () {

    if ( this.historyDisabled ) {

      alert( "Undo/Redo disabled while scene is playing." );
      return;

    }

    var cmd = undefined;

    if ( this.undos.length > 0 ) {

      cmd = this.undos.pop();

      if ( cmd.inMemory === false ) {

        cmd.fromJSON( cmd.json );

      }

    }

    if ( cmd !== undefined ) {

      cmd.undo();
      this.redos.push( cmd );
      this.editor.signals.historyChanged.dispatch( cmd );

    }

    return cmd;

  },

  redo: function () {

    if ( this.historyDisabled ) {

      alert( "Undo/Redo disabled while scene is playing." );
      return;

    }

    var cmd = undefined;

    if ( this.redos.length > 0 ) {

      cmd = this.redos.pop();

      if ( cmd.inMemory === false ) {

        cmd.fromJSON( cmd.json );

      }

    }

    if ( cmd !== undefined ) {

      cmd.execute();
      this.undos.push( cmd );
      this.editor.signals.historyChanged.dispatch( cmd );

    }

    return cmd;

  },

  toJSON: function () {

    var history = {};
    history.undos = [];
    history.redos = [];

    if ( ! this.config.getKey( 'settings/history' ) ) {

      return history;

    }

    // Append Undos to History

    for ( var i = 0 ; i < this.undos.length; i ++ ) {

      if ( this.undos[ i ].hasOwnProperty( "json" ) ) {

        history.undos.push( this.undos[ i ].json );

      }

    }

    // Append Redos to History

    for ( var i = 0 ; i < this.redos.length; i ++ ) {

      if ( this.redos[ i ].hasOwnProperty( "json" ) ) {

        history.redos.push( this.redos[ i ].json );

      }

    }

    return history;

  },

  fromJSON: function ( json ) {

    if ( json === undefined ) return;

    for ( var i = 0; i < json.undos.length; i ++ ) {

      var cmdJSON = json.undos[ i ];
      var cmd = new window[ cmdJSON.type ](); // creates a new object of type "json.type"
      cmd.json = cmdJSON;
      cmd.id = cmdJSON.id;
      cmd.name = cmdJSON.name;
      this.undos.push( cmd );
      this.idCounter = ( cmdJSON.id > this.idCounter ) ? cmdJSON.id : this.idCounter; // set last used idCounter

    }

    for ( var i = 0; i < json.redos.length; i ++ ) {

      var cmdJSON = json.redos[ i ];
      var cmd = new window[ cmdJSON.type ](); // creates a new object of type "json.type"
      cmd.json = cmdJSON;
      cmd.id = cmdJSON.id;
      cmd.name = cmdJSON.name;
      this.redos.push( cmd );
      this.idCounter = ( cmdJSON.id > this.idCounter ) ? cmdJSON.id : this.idCounter; // set last used idCounter

    }

    // Select the last executed undo-command
    this.editor.signals.historyChanged.dispatch( this.undos[ this.undos.length - 1 ] );

  },

  clear: function () {

    this.undos = [];
    this.redos = [];
    this.idCounter = 0;

    this.editor.signals.historyChanged.dispatch();

  },

  goToState: function ( id ) {

    if ( this.historyDisabled ) {

      alert( "Undo/Redo disabled while scene is playing." );
      return;

    }

    this.editor.signals.sceneGraphChanged.active = false;
    this.editor.signals.historyChanged.active = false;

    var cmd = this.undos.length > 0 ? this.undos[ this.undos.length - 1 ] : undefined;  // next cmd to pop

    if ( cmd === undefined || id > cmd.id ) {

      cmd = this.redo();
      while ( cmd !== undefined && id > cmd.id ) {

        cmd = this.redo();

      }

    } else {

      while ( true ) {

        cmd = this.undos[ this.undos.length - 1 ];  // next cmd to pop

        if ( cmd === undefined || id === cmd.id ) break;

        this.undo();

      }

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.historyChanged.active = true;

    this.editor.signals.sceneGraphChanged.dispatch();
    this.editor.signals.historyChanged.dispatch( cmd );

  },

  enableSerialization: function ( id ) {

    /**
     * because there might be commands in this.undos and this.redos
     * which have not been serialized with .toJSON() we go back
     * to the oldest command and redo one command after the other
     * while also calling .toJSON() on them.
     */

    this.goToState( - 1 );

    this.editor.signals.sceneGraphChanged.active = false;
    this.editor.signals.historyChanged.active = false;

    var cmd = this.redo();
    while ( cmd !== undefined ) {

      if ( ! cmd.hasOwnProperty( "json" ) ) {

        cmd.json = cmd.toJSON();

      }
      cmd = this.redo();

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.historyChanged.active = true;

    this.goToState( id );

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Loader = function ( editor ) {

  var scope = this;
  var signals = editor.signals;

  this.texturePath = '';

  this.loadFile = function ( file ) {

    var filename = file.name;
    var extension = filename.split( '.' ).pop().toLowerCase();

    var reader = new FileReader();
    reader.addEventListener( 'progress', function ( event ) {

      var size = '(' + Math.floor( event.total / 1000 ).format() + ' KB)';
      var progress = Math.floor( ( event.loaded / event.total ) * 100 ) + '%';
      console.log( 'Loading', filename, size, progress );

    } );

    switch ( extension ) {

      case '3ds':

        reader.addEventListener( 'load', function ( event ) {

          var loader = new THREE.TDSLoader();
          var object = loader.parse( event.target.result );

          editor.execute( new AddObjectCommand( object ) );
                    editor.setModel( object );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'amf':

        reader.addEventListener( 'load', function ( event ) {

          var loader = new THREE.AMFLoader();
          var amfobject = loader.parse( event.target.result );

          editor.execute( new AddObjectCommand( amfobject ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'awd':

        reader.addEventListener( 'load', function ( event ) {

          var loader = new THREE.AWDLoader();
          var scene = loader.parse( event.target.result );

          editor.execute( new SetSceneCommand( scene ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'babylon':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;
          var json = JSON.parse( contents );

          var loader = new THREE.BabylonLoader();
          var scene = loader.parse( json );

          editor.execute( new SetSceneCommand( scene ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'babylonmeshdata':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;
          var json = JSON.parse( contents );

          var loader = new THREE.BabylonLoader();

          var geometry = loader.parseGeometry( json );
          var material = new THREE.MeshStandardMaterial();

          var mesh = new THREE.Mesh( geometry, material );
          mesh.name = filename;

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'ctm':

        reader.addEventListener( 'load', function ( event ) {

          var data = new Uint8Array( event.target.result );

          var stream = new CTM.Stream( data );
          stream.offset = 0;

          var loader = new THREE.CTMLoader();
          loader.createModel( new CTM.File( stream ), function( geometry ) {

            geometry.sourceType = "ctm";
            geometry.sourceFile = file.name;

            var material = new THREE.MeshStandardMaterial();

            var mesh = new THREE.Mesh( geometry, material );
            mesh.name = filename;

            editor.execute( new AddObjectCommand( mesh ) );

          } );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'dae':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var loader = new THREE.ColladaLoader();
          var collada = loader.parse( contents );

          collada.scene.name = filename;

          editor.execute( new AddObjectCommand( collada.scene ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'fbx':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var loader = new THREE.FBXLoader();
          var object = loader.parse( contents );

          editor.execute( new AddObjectCommand( object ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

        case 'flt':
        $.ajax({
          url: '/rest/convert_object',
          data: file,
          processData: false,
          contentType: false,
          dataType: "text",
          success: function(data) {
            console.log("Loading converted FLT->OBJ");
            var object = new THREE.OBJLoader().parse( data );
            object.name = filename;
            editor.execute( new AddObjectCommand( object ) );
            editor.setModel( object );
          },
          error: function() {
            console.error('[' + /\d\d\:\d\d\:\d\d/.exec(new Date())[0] + ']', 'Failed to send file to server. ');
          },
          type: 'POST'
        });
        break;

      case 'glb':
      case 'gltf':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var loader = new THREE.GLTFLoader();
          loader.parse( contents, '', function ( result ) {

            result.scene.name = filename;
            editor.execute( new AddObjectCommand( result.scene ) );

          } );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'js':
      case 'json':

      case '3geo':
      case '3mat':
      case '3obj':
      case '3scn':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          // 2.0

          if ( contents.indexOf( 'postMessage' ) !== - 1 ) {

            var blob = new Blob( [ contents ], { type: 'text/javascript' } );
            var url = URL.createObjectURL( blob );

            var worker = new Worker( url );

            worker.onmessage = function ( event ) {

              event.data.metadata = { version: 2 };
              handleJSON( event.data, file, filename );

            };

            worker.postMessage( Date.now() );

            return;

          }

          // >= 3.0

          var data;

          try {

            data = JSON.parse( contents );

          } catch ( error ) {

            alert( error );
            return;

          }

          handleJSON( data, file, filename );

        }, false );
        reader.readAsText( file );

        break;


      case 'kmz':

        reader.addEventListener( 'load', function ( event ) {

          var loader = new THREE.KMZLoader();
          var collada = loader.parse( event.target.result );

          collada.scene.name = filename;

          editor.execute( new AddObjectCommand( collada.scene ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'md2':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var geometry = new THREE.MD2Loader().parse( contents );
          var material = new THREE.MeshStandardMaterial( {
            morphTargets: true,
            morphNormals: true
          } );

          var mesh = new THREE.Mesh( geometry, material );
          mesh.mixer = new THREE.AnimationMixer( mesh );
          mesh.name = filename;

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'obj':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var object = new THREE.OBJLoader().parse( contents );
          object.name = filename;

          editor.execute( new AddObjectCommand( object ) );
          editor.setModel( object );                                // set import as base model

        }, false );
        reader.readAsText( file );

        break;

      case 'playcanvas':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;
          var json = JSON.parse( contents );

          var loader = new THREE.PlayCanvasLoader();
          var object = loader.parse( json );

          editor.execute( new AddObjectCommand( object ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'ply':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var geometry = new THREE.PLYLoader().parse( contents );
          geometry.sourceType = "ply";
          geometry.sourceFile = file.name;

          var material = new THREE.MeshStandardMaterial();

          var mesh = new THREE.Mesh( geometry, material );
          mesh.name = filename;

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );
        reader.readAsArrayBuffer( file );

        break;

      case 'stl':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var geometry = new THREE.STLLoader().parse( contents );
          geometry.sourceType = "stl";
          geometry.sourceFile = file.name;

          var material = new THREE.MeshStandardMaterial();

          var mesh = new THREE.Mesh( geometry, material );
          mesh.name = filename;

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );

        if ( reader.readAsBinaryString !== undefined ) {

          reader.readAsBinaryString( file );

        } else {

          reader.readAsArrayBuffer( file );

        }

        break;

      /*
      case 'utf8':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var geometry = new THREE.UTF8Loader().parse( contents );
          var material = new THREE.MeshLambertMaterial();

          var mesh = new THREE.Mesh( geometry, material );

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );
        reader.readAsBinaryString( file );

        break;
      */

      case 'vtk':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var geometry = new THREE.VTKLoader().parse( contents );
          geometry.sourceType = "vtk";
          geometry.sourceFile = file.name;

          var material = new THREE.MeshStandardMaterial();

          var mesh = new THREE.Mesh( geometry, material );
          mesh.name = filename;

          editor.execute( new AddObjectCommand( mesh ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'wrl':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var result = new THREE.VRMLLoader().parse( contents );

          editor.execute( new SetSceneCommand( result ) );

        }, false );
        reader.readAsText( file );

        break;

      case 'zip':

        reader.addEventListener( 'load', function ( event ) {

          var contents = event.target.result;

          var zip = new JSZip( contents );

          // BLOCKS

          if ( zip.files[ 'model.obj' ] && zip.files[ 'materials.mtl' ] ) {

            var materials = new THREE.MTLLoader().parse( zip.file( 'materials.mtl' ).asText() );
            var object = new THREE.OBJLoader().setMaterials( materials ).parse( zip.file( 'model.obj' ).asText() );
            editor.execute( new AddObjectCommand( object ) );

          }

        }, false );
        reader.readAsBinaryString( file );

        break;

      default:

        alert( 'Unsupported file format (' + extension +  ').' );

        break;

    }

  };

  function handleJSON( data, file, filename ) {

    if ( data.metadata === undefined ) { // 2.0

      data.metadata = { type: 'Geometry' };

    }

    if ( data.metadata.type === undefined ) { // 3.0

      data.metadata.type = 'Geometry';

    }

    if ( data.metadata.formatVersion !== undefined ) {

      data.metadata.version = data.metadata.formatVersion;

    }

    switch ( data.metadata.type.toLowerCase() ) {

      case 'buffergeometry':

        var loader = new THREE.BufferGeometryLoader();
        var result = loader.parse( data );

        var mesh = new THREE.Mesh( result );

        editor.execute( new AddObjectCommand( mesh ) );
                editor.setModel( mesh );                             // set import as base model

        break;

      case 'geometry':

        var loader = new THREE.JSONLoader();
        loader.setTexturePath( scope.texturePath );

        var result = loader.parse( data );

        var geometry = result.geometry;
        var material;

        if ( result.materials !== undefined ) {

          if ( result.materials.length > 1 ) {

            material = new THREE.MultiMaterial( result.materials );

          } else {

            material = result.materials[ 0 ];

          }

        } else {

          material = new THREE.MeshStandardMaterial();

        }

        geometry.sourceType = "ascii";
        geometry.sourceFile = file.name;

        var mesh;

        if ( geometry.animation && geometry.animation.hierarchy ) {

          mesh = new THREE.SkinnedMesh( geometry, material );

        } else {

          mesh = new THREE.Mesh( geometry, material );

        }

        mesh.name = filename;

        editor.execute( new AddObjectCommand( mesh ) );
                editor.setModel( mesh );                               // set import as base model

        break;

      case 'object':

        var loader = new THREE.ObjectLoader();
        loader.setTexturePath( scope.texturePath );

        var result = loader.parse( data );

        if ( result instanceof THREE.Scene ) {

          editor.execute( new SetSceneCommand( result ) );

        } else {

          editor.execute( new AddObjectCommand( result ) );
                    editor.setModel( result );                          // set import as base model

        }

        break;

      case 'app':

        editor.fromJSON( data );

        break;

    }

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Menubar = function ( editor ) {

  var container = new UI.Panel();
  container.setId( 'menubar' );

  container.add( new Menubar.File( editor ) );
  container.add( new Menubar.Edit( editor ) );
  container.add( new Menubar.Add( editor ) );
  container.add( new Menubar.Help( editor ) );
  container.add( new Menubar.Status( editor ) );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Menubar.File = function ( editor ) {

    var NUMBER_PRECISION = 6;

    function parseNumber( key, value ) {

        return typeof value === 'number' ? parseFloat( value.toFixed( NUMBER_PRECISION ) ) : value;

    }

    //

    var container = new UI.Panel();
    container.setClass( 'menu' );

    var title = new UI.Panel();
    title.setClass( 'title' );
    title.setTextContent( 'File' );
    container.add( title );

    var options = new UI.Panel();
    options.setClass( 'options' );
    container.add( options );

    // New

    var option = new UI.Row();
    option.setClass( 'option' );
    option.setTextContent( 'New' );
    option.onClick( function () {

        if ( confirm( 'Any unsaved data will be lost. Are you sure?' ) ) {

            editor.clear();
            editor.storage.clear();
            editor.project_uuid = "";
        }

    } );
    options.add( option );

    // Load/Resume State
    var option = new UI.Row();
    option.setClass( 'option' );
    option.setTextContent( 'Load' );
    option.onClick( function () {

        if ( confirm( 'Any unsaved data will be lost. Are you sure?' ) ) {
            fetchStates();

            document.getElementById('myModal').style.display = "block";

        }

    } );
    options.add( option );


    //

    options.add( new UI.HorizontalRule() );


    // Aircraft Dimension Variables

    var check = false;                          // set a flag to check if button already pressed

    var l, w, h;                                // initialize length, wingspan, and height variables for inputs
    var input_pane = new UI.Panel();            // create interface elements to display input option
    var l_row = new UI.Row();
    var w_row = new UI.Row();
    var h_row = new UI.Row();
    var input;                                      // initialize general input button

    var text = new UI.Text("Aircraft Dimensions");  // instruction text and spacing
    var text2 = new UI.Text("(in meters)");
    text.setMarginLeft('11px');
    text.setMarginRight('11px');
    text2.setMarginLeft('39px');
    text2.setMarginRight('39px');
    text2.setPaddingBottom('12px');

    var text_l = new UI.Text("Length:").setMarginRight('62px').setMarginLeft('4px');              // input text, area, and spacing
    var text_w = new UI.Text("Wingspan:").setMarginRight('43px').setMarginLeft('4px');
    var text_h = new UI.Text("Height (nose up):").setMarginRight('2px').setMarginLeft('4px');;
    var input_l = new UI.Number().setWidth( '30px' );
    var input_w = new UI.Number().setWidth( '30px' );
    var input_h = new UI.Number().setWidth( '30px' );

    input_pane.add(text);                       // ready all contents to be displayed once added to the main panel
    input_pane.add(text2);
    l_row.add(text_l);
    l_row.add(input_l);
    w_row.add(text_w);
    w_row.add(input_w);
    h_row.add(text_h);
    h_row.add(input_h);
    h_row.setPaddingBottom('15px');
    input_pane.add(l_row);
    input_pane.add(w_row);
    input_pane.add(h_row);


    // Import

    var form = document.createElement( 'form' );
    form.style.display = 'none';
    document.body.appendChild( form );

    var fileInput = document.createElement( 'input' );
    fileInput.type = 'file';
    fileInput.addEventListener( 'change', function ( event ) {

        editor.loader.loadFile( fileInput.files[ 0 ] );
        if ( editor.scene.children.length == 0 ) {
          var color = 0xffffff;                 // create spotlight when new model imported
          var intensity = 1;
          var distance = 0;
          var angle = Math.PI * 0.1;
          var penumbra = 0;
          var light = new THREE.SpotLight( color, intensity, distance, angle, penumbra );
          light.name = 'SpotLight';
          light.target.name = 'SpotLight Target';
          light.position.set( 0, 5500, 5000 );
          editor.execute( new AddObjectCommand( light ) );
        } else {
          for( var i = 0; i < editor.scene.children.Length; i++ ) {
            if ( editor.scene.children[i].type == "SpotLight" ) {
              break;
            } else if ( i == editor.scene.children.length - 1 )  {
              var color = 0xffffff;                 // create spotlight when new model imported
              var intensity = 1;
              var distance = 0;
              var angle = Math.PI * 0.1;
              var penumbra = 0;
              var light = new THREE.SpotLight( color, intensity, distance, angle, penumbra );
              light.name = 'SpotLight';
              light.target.name = 'SpotLight Target';
              light.position.set( 0, 5500, 5000 );
              editor.execute( new AddObjectCommand( light ) );
            }
          }
        }

        form.reset();
    } );
    form.appendChild( fileInput );

    var option = new UI.Row();
    option.setClass( 'option' );
    option.setTextContent( 'Import' );
    option.onClick( function () {

        for ( var i = 1; i < 4; i ++ ){           // lock menubar
            editor.getMenubar()[i].setClass( 'options3' );
        }
        options.setClass( 'options2' );

        if (check === true){                     // check if prior button state already displayed
            options.newInput();                  // if so, remove the display
            input_pane.remove(input);
        }
        check = true;                            // set flag to true as new display will populate

        input = new UI.Button();                 // set input button spacing and function
        input.setMarginLeft('42px');
        input.setClass("input");
        input.setTextContent("Enter");
        input.onClick( function () {

            options.setClass( 'options' );       // restore menubar functionality
            for ( var i = 1; i < 4; i ++ ){
                editor.getMenubar()[i].setClass( 'options' );
            }

            l = input_l.getValue();              // store entered values and set internal model dimensions
            w = input_w.getValue();
            h = input_h.getValue();
            editor.setModelDimensions(l, w, h);

            fileInput.click();                   // import the model

            input_pane.remove(input);    // remove additional input display
            options.newInput();
            check = false;
        } );

        input_pane.add(input);           // add input display to menubar panel
        options.remove(opt1);
        options.remove(opt2);
        options.remove(opt3);
        options.remove(line)
        options.remove(opt4);
        options.add(input_pane);

    } );

    options.add( option );

    var xmlInput = document.createElement( 'input' );
    xmlInput.type = 'file';
    xmlInput.addEventListener( 'change', function ( event ) {

        var filename = (xmlInput.files[ 0 ].name);
        var extension = filename.split( '.' ).pop().toLowerCase();

        if(extension === 'xml'){
            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {
                var xmlString = event.target.result;

                var parser = new DOMParser();
                var xmlDoc = parser.parseFromString(xmlString,"text/xml");

                AntennasXml = xmlDoc.documentElement;
                antennaList = xmlDoc.documentElement.childNodes;

                if(AntennasXml.nodeName === 'Antennas'){
                    for(var i = 0; i < antennaList.length; i++) {
                        if (antennaList[i].nodeName === 'Antenna') {
                            //Default values
                            var xCoord = 0;
                            var yCoord = 0;
                            var zCoord = 0;
                            var xRot = 0;
                            var yRot = 0;
                            var zRot = 0;
                            var name = 'Antenna';

                            for(var j = 0; j < antennaList[i].childNodes.length; j++) {
                                if (antennaList[i].childNodes[j].nodeName === 'Name') {
                                    name = antennaList[i].childNodes[j].childNodes[0].nodeValue;
                                } else if(antennaList[i].childNodes[j].nodeName === 'Coordinates'){
                                    var coordinates = antennaList[i].childNodes[j].childNodes;
                                    for(var k = 0; k < coordinates.length; k++){
                                        if(coordinates.nodeType != 3){
                                            if(coordinates[k].nodeName === 'X'){
                                                xCoord = coordinates[k].childNodes[0].nodeValue;
                                            } else if(coordinates[k].nodeName === 'Y'){
                                                yCoord = coordinates[k].childNodes[0].nodeValue;
                                            } else if(coordinates[k].nodeName === 'Z'){
                                                zCoord = coordinates[k].childNodes[0].nodeValue;
                                            }
                                        }
                                    }
                                } else if(antennaList[i].childNodes[j].nodeName === 'Rotation'){
                                    var rotation = antennaList[i].childNodes[j].childNodes;
                                    for(var k = 0; k < rotation.length; k++){
                                        if(rotation.nodeType != 3){
                                            if(rotation[k].nodeName === 'X'){
                                                xRot = rotation[k].childNodes[0].nodeValue;
                                            } else if(rotation[k].nodeName === 'Y'){
                                                yRot = rotation[k].childNodes[0].nodeValue;
                                            } else if(rotation[k].nodeName === 'Z'){
                                                zRot = rotation[k].childNodes[0].nodeValue;
                                            }
                                        }
                                    }
                                }
                            }

                            // convert entered values to meters coordinate system
                            var x_nose = editor.getModel()[4];
                            var x_tail = editor.getModel()[5];
                            var x_slope = ( x_nose - x_tail ) / editor.getModelLength();

                            var z_nose = editor.getModel()[3];
                            var z_tail = editor.getModel()[2];
                            var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();

                            var right_wing = editor.getModel()[0];
                            var left_wing = editor.getModel()[1];
                            var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();

                            var xCoord_NG = ( yCoord * y_slope ) + ( left_wing + right_wing ) / 2;
                            var yCoord_NG = ( zCoord * z_slope ) + z_nose;
                            var zCoord_NG = x_nose + ( xCoord * x_slope );

                            //covert entered values to meters rotation system
                            var xRot_NG = yRot * THREE.Math.DEG2RAD;
                            var yRot_NG = zRot * THREE.Math.DEG2RAD;
                            var zRot_NG = xRot * THREE.Math.DEG2RAD;

                            // create sphere object according to model size
                            var radius = Math.abs( right_wing - left_wing ) / 180;
                            var widthSegments = 32;
                            var heightSegments = 16;
                            var phiStart = 0;
                            var phiLength = Math.PI * 2;
                            var thetaStart = 0;
                            var thetaLength = Math.PI;


                            var material = new THREE.MeshBasicMaterial( {color: 0xffffff, vertexColors: THREE.FaceColors} );
                            var geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );
                            for ( var g = 0; g < geometry.faces.length; g++ ){
                                var face = geometry.faces[g];
                                if ( g < 96 ) {
                                    face.color.setRGB( 0, 0, 256 );
                                }
                                else {
                                    face.color.setRGB( 256, 0, 0 );
                                }
                            }

                            // convert to BufferGeometry type
                            var geo = new THREE.BufferGeometry().fromGeometry( geometry );
                            var mesh = new THREE.Mesh( geo, material );
                            mesh.name = name;

                            // move object to desired coordinates and rotation
                            editor.execute( new SetPositionCommand( mesh, new THREE.Vector3( xCoord_NG, yCoord_NG, zCoord_NG ) ) );
                            editor.execute( new SetRotationCommand( mesh, new THREE.Euler( xRot_NG, yRot_NG, zRot_NG ) ) );
                            editor.execute( new AddObjectCommand( mesh ) );
                        }
                    }
                } else {
                    alert('Please use Antennas xml file');
                }
            }, false );
            reader.readAsText( xmlInput.files[ 0 ] );
        } else if(extension === 'csv'){
            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {
                var csvString = event.target.result;
                var allRows = csvString.split(/\r?\n|\r/);
                if( allRows[0] === 'Name,X_Position,Y_Position,Z_Position,X_Rotation,Y_Rotation,Z_Rotation' ){
                    for (var singleRow = 1; singleRow < allRows.length; singleRow++) {
                        var rowCells = allRows[singleRow].split(',');
                        if(rowCells.length === 7){
                            var name = rowCells[0];
                            var xCoord = rowCells[1];
                            var yCoord = rowCells[2];
                            var zCoord = rowCells[3];
                            var xRot = rowCells[4];
                            var yRot = rowCells[5];
                            var zRot = rowCells[6];

                            // convert entered values to meters coordinate system
                            var x_nose = editor.getModel()[4];
                            var x_tail = editor.getModel()[5];
                            var x_slope = ( x_nose - x_tail ) / editor.getModelLength();

                            var z_nose = editor.getModel()[3];
                            var z_tail = editor.getModel()[2];
                            var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();

                            var right_wing = editor.getModel()[0];
                            var left_wing = editor.getModel()[1];
                            var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();

                            var xCoord_NG = ( yCoord * y_slope ) + ( left_wing + right_wing ) / 2;
                            var yCoord_NG = ( zCoord * z_slope ) + z_nose;
                            var zCoord_NG = x_nose + ( xCoord * x_slope );

                            //covert entered values to meters rotation system
                            var xRot_NG = yRot * THREE.Math.DEG2RAD;
                            var yRot_NG = zRot * THREE.Math.DEG2RAD;
                            var zRot_NG = xRot * THREE.Math.DEG2RAD;

                            // create sphere object according to model size
                            var radius = Math.abs( right_wing - left_wing ) / 180;
                            var widthSegments = 32;
                            var heightSegments = 16;
                            var phiStart = 0;
                            var phiLength = Math.PI * 2;
                            var thetaStart = 0;
                            var thetaLength = Math.PI;


                            var material = new THREE.MeshBasicMaterial( {color: 0xffffff, vertexColors: THREE.FaceColors} );
                            var geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );
                            for ( var g = 0; g < geometry.faces.length; g++ ){
                                var face = geometry.faces[g];
                                if ( g < 96 ) {
                                    face.color.setRGB( 0, 0, 256 );
                                }
                                else {
                                    face.color.setRGB( 256, 0, 0 );
                                }
                            }

                            // convert to BufferGeometry type
                            var geo = new THREE.BufferGeometry().fromGeometry( geometry );
                            var mesh = new THREE.Mesh( geo, material );
                            mesh.name = name;

                            // move object to desired coordinates and rotation
                            editor.execute( new SetPositionCommand( mesh, new THREE.Vector3( xCoord_NG, yCoord_NG, zCoord_NG ) ) );
                            editor.execute( new SetRotationCommand( mesh, new THREE.Euler( xRot_NG, yRot_NG, zRot_NG ) ) );
                            editor.execute( new AddObjectCommand( mesh ) );
                        } else {
                            alert("Incorrect format at row " + (singleRow));
                        }
                    }
                } else {
                    alert('Incorrect title');
                }
            }, false );
            reader.readAsText( xmlInput.files[ 0 ] );
        }else {
            alert('Unsupported file format (' + extension +  ').');
        }
        form.reset();

    } );
    form.appendChild( xmlInput );

    // Import Antennas

    var opt1 = new UI.Row();
    opt1.setClass( 'option' );
    opt1.setTextContent( 'Import Antennas' );
    opt1.onClick( function () {

        xmlInput.click();

    } );
    options.add( opt1 );

    //

    options.add( new UI.HorizontalRule() );

    // Export Antennas XML
    var opt2 = new UI.Row();
    opt2.setClass( 'option' );
    opt2.setTextContent( 'Export Antennas XML' );
    opt2.onClick( function () {
        var output = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
        var objects = editor.scene.children

        var right_wing = editor.getModel()[0];              // convert three.js coordinates back to meters for display
        var left_wing = editor.getModel()[1];
        var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();

        var z_nose = editor.getModel()[3];
        var z_tail = editor.getModel()[2];
        var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();

        var x_nose = editor.getModel()[4];
        var x_tail = editor.getModel()[5];
        var x_slope = ( x_nose - x_tail ) / editor.getModelLength();

        output += "<Antennas>\n"
        for ( var i = 0, l = objects.length; i < l; i ++ ) {
            var object = objects[ i ];

            if(object.geometry !== undefined && object.geometry.type === 'BufferGeometry'){
                output += "\t<Antenna>\n";
                output += "\t\t<Name>" + object.name + "</Name>\n";

                output += "\t\t<Coordinates>\n";
                output += "\t\t\t<X>" + (Math.round((( object.position.z - x_nose ) / x_slope) * 100) / 100) + "</X>\n";
                output += "\t\t\t<Y>" + (Math.round((( object.position.x - ( left_wing + right_wing ) / 2 ) / y_slope) * 100) / 100) + "</Y>\n";
                output += "\t\t\t<Z>" + (Math.round((( object.position.y - z_nose ) / z_slope) * 100) / 100) + "</Z>\n";
                output += "\t\t</Coordinates>\n";

                output += "\t\t<Rotation>\n";
                output += "\t\t\t<X>" + (Math.round((object.rotation.z * THREE.Math.RAD2DEG) * 100) / 100) + "</X>\n";
                output += "\t\t\t<Y>" + (Math.round((object.rotation.x * THREE.Math.RAD2DEG) * 100) / 100) + "</Y>\n";
                output += "\t\t\t<Z>" + (Math.round((object.rotation.y * THREE.Math.RAD2DEG) * 100) / 100) + "</Z>\n";
                output += "\t\t</Rotation>\n";

                output += "\t</Antenna>\n";
            }
        }
        output += "</Antennas>";
        saveString(output, 'Antennas.xml');
    } );
    options.add( opt2 );

    // Export Antennas CSV
    var opt3 = new UI.Row();
    opt3.setClass( 'option' );
    opt3.setTextContent( 'Export Antennas CSV' );
    opt3.onClick( function () {
        var output = "Name,X_Position,Y_Position,Z_Position,X_Rotation,Y_Rotation,Z_Rotation";
        var objects = editor.scene.children

        var right_wing = editor.getModel()[0];              // convert three.js coordinates back to meters for display
        var left_wing = editor.getModel()[1];
        var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();

        var z_nose = editor.getModel()[3];
        var z_tail = editor.getModel()[2];
        var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();

        var x_nose = editor.getModel()[4];
        var x_tail = editor.getModel()[5];
        var x_slope = ( x_nose - x_tail ) / editor.getModelLength();

        for ( var i = 0, l = objects.length; i < l; i ++ ) {
            var object = objects[ i ];

            if(object.geometry !== undefined && object.geometry.type === 'BufferGeometry'){
                output += "\n" + object.name + ",";

                output += (Math.round((( object.position.z - x_nose ) / x_slope) * 100) / 100) + ",";
                output += (Math.round((( object.position.x - ( left_wing + right_wing ) / 2 ) / y_slope) * 100) / 100) + ",";
                output += (Math.round((( object.position.y - z_nose ) / z_slope) * 100) / 100) + ",";

                output += (Math.round((object.rotation.z * THREE.Math.RAD2DEG) * 100) / 100) + ",";
                output += (Math.round((object.rotation.x * THREE.Math.RAD2DEG) * 100) / 100) + ",";
                output += (Math.round((object.rotation.y * THREE.Math.RAD2DEG) * 100) / 100);
            }
        }
        saveString(output, 'Antennas.csv');
    } );
    options.add( opt3 );

    // Export

    var line = new UI.HorizontalRule();
    options.add( line );
    var opt4 = new UI.Row();
    opt4.setClass( 'option' );
    opt4.setTextContent( 'Export Scene' );
    opt4.onClick( function () {

        var output = editor.scene.toJSON();

        try {

            output = JSON.stringify( output, parseNumber, '\t' );
            output = output.replace( /[\n\t]+([\d\.e\-\[\]]+)/g, '$1' );

        } catch ( e ) {

            output = JSON.stringify( output );

        }

        saveString( output, 'scene.json' );

    } );
    options.add( opt4 );

    //

    var link = document.createElement( 'a' );
    link.style.display = 'none';
    document.body.appendChild( link ); // Firefox workaround, see #6594

    function save( blob, filename ) {

        link.href = URL.createObjectURL( blob );
        link.download = filename || 'data.json';
        link.click();

        // URL.revokeObjectURL( url ); breaks Firefox...

    }

    function saveString( text, filename ) {

        save( new Blob( [ text ], { type: 'text/plain' } ), filename );

    }

    options.newInput = function(){       // reset all input values and displays
        input_l.setValue(0);
        input_w.setValue(0);
        input_h.setValue(0);
        options.remove(input_pane);
        options.add(opt1);
        options.add(opt2);
        options.add(opt3);
        options.add( line );
        options.add(opt4);
    };

    editor.setMenubar(options);          // store menubar configuration

    return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Menubar.Edit = function ( editor ) {

  var container = new UI.Panel();
  container.setClass( 'menu' );

  var title = new UI.Panel();
  title.setClass( 'title' );
  title.setTextContent( 'Edit' );
  container.add( title );

  var options = new UI.Panel();
  options.setClass( 'options' );
  container.add( options );

  // Undo

  var undo = new UI.Row();
  undo.setClass( 'option' );
  undo.setTextContent( 'Undo (Ctrl+Z)' );
  undo.onClick( function () {

    editor.undo();

  } );
  options.add( undo );

  // Redo

  var redo = new UI.Row();
  redo.setClass( 'option' );
  redo.setTextContent( 'Redo (Ctrl+Shift+Z)' );
  redo.onClick( function () {

    editor.redo();

  } );
  options.add( redo );

  // Clear History

  var option = new UI.Row();
  option.setClass( 'option' );
  option.setTextContent( 'Clear History' );
  option.onClick( function () {

    if ( confirm( 'The Undo/Redo History will be cleared. Are you sure?' ) ) {

      editor.history.clear();

    }

  } );
  options.add( option );


  editor.signals.historyChanged.add( function () {

    var history = editor.history;

    undo.setClass( 'option' );
    redo.setClass( 'option' );

    if ( history.undos.length == 0 ) {

      undo.setClass( 'inactive' );

    }

    if ( history.redos.length == 0 ) {

      redo.setClass( 'inactive' );

    }

  } );

  options.add( new UI.HorizontalRule() );
  
  // Delete

  var option = new UI.Row();
  option.setClass( 'option' );
  option.setTextContent( 'Delete (Del)' );
  option.onClick( function () {

    var object = editor.selected;

    if ( confirm( 'Delete ' + object.name + '?' ) === false ) return;

    var parent = object.parent;
    if ( parent === undefined ) return; // avoid deleting the camera or scene

    editor.execute( new RemoveObjectCommand( object ) );

  } );
  options.add( option );

    editor.setMenubar(options);          // store menubar configuration

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Menubar.Add = function ( editor ) {

  var container = new UI.Panel();
  container.setClass( 'menu' );

  var title = new UI.Panel();
  title.setClass( 'title' );
  title.setTextContent( 'Add' );
  container.add( title );

  var options = new UI.Panel();
  options.setClass( 'options' );
  container.add( options );

  //

  var meshCount = 0;
  var lightCount = 0;
  var cameraCount = 0;

  editor.signals.editorCleared.add( function () {

    meshCount = 0;
    lightCount = 0;
    cameraCount = 0;

  } );

    // Input Variables

    var check = false;                          // set a flag to check if button already pressed

    var x, y, z;                                // initialize x, y, and z variables for inputs
    var input_pane = new UI.Panel();            // create interface elements to display input option
    var input_row = new UI.Row();
    var filler = new UI.HorizontalRule();
    var input;                                    // initialize general input button

    var text = new UI.Text("Input Coordinates");  // instruction text and spacing
    text.setMarginLeft('18px');
    text.setMarginRight('18px');
    text.setPaddingBottom('12px');

    var text_x = new UI.Text("X:").setMarginRight('2px').setMarginLeft('4px');   // input text, area, and spacing
    var text_y = new UI.Text("Y:").setMarginRight('2px');
    var text_z = new UI.Text("Z:").setMarginRight('2px');
    var input_x = new UI.Number().setWidth( '28px' );
    var input_y = new UI.Number().setWidth( '28px' );
    var input_z = new UI.Number().setWidth( '28px' );

    input_pane.add(text);                       // ready all contents to be displayed once added to the main panel
    input_row.add(text_x);
    input_row.add(input_x);
    input_row.add(text_y);
    input_row.add(input_y);
    input_row.add(text_z);
    input_row.add(input_z);
    input_pane.add(input_row);
    input_pane.add(new UI.Break());

  // Antenna

  var option = new UI.Row();                    // basic point for antenna representation
  option.setClass( 'option' );
  option.setTextContent( 'Antenna' );
  option.onClick( function () {

        for ( var i = 0; i < 4; i ++ ){           // lock menubar
            if ( i !== 2 ){
                editor.getMenubar()[i].setClass( 'options3' );
            }
        }
        options.setClass( 'options2' );

      if (check === true){                     // check if prior button state already displayed
            options.newInput();                  // if so, remove the display
            input_pane.remove(input);
        }
        check = true;                            // set flag to true as new display will populate

        input = new UI.Button();                 // set input button spacing and function
        input.setMarginLeft('42px');
        input.setClass("input");
        input.setTextContent("Enter");
        input.onClick( function () {

            options.setClass( 'options' );       // restore menubar functionality
            for ( var i = 0; i < 4; i ++ ){
                if ( i !== 2 ){
                    editor.getMenubar()[i].setClass( 'options' );
                }
            }

            x = input_x.getValue();              // store entered values
            y = input_y.getValue();
            z = input_z.getValue();

            var x_nose = editor.getModel()[4];                // convert entered values to meters coordinate system
            var x_tail = editor.getModel()[5];
            var x_slope = ( x_nose - x_tail ) / editor.getModelLength();

            var z_nose = editor.getModel()[3];
            var z_tail = editor.getModel()[2];
            var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();

            var right_wing = editor.getModel()[0];
            var left_wing = editor.getModel()[1];
            var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();

            var x_NG = ( y * y_slope ) + ( left_wing + right_wing ) / 2;
            var y_NG = ( z * z_slope ) + z_nose;
            var z_NG = x_nose + ( x * x_slope );

            var radius = Math.abs( right_wing - left_wing ) / 180;      // create sphere object according to model size
            var widthSegments = 32;
            var heightSegments = 16;
            var phiStart = 0;
            var phiLength = Math.PI * 2;
            var thetaStart = 0;
            var thetaLength = Math.PI;


            var material = new THREE.MeshBasicMaterial( {color: 0xffffff, vertexColors: THREE.FaceColors} );
            var geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );
            for ( var i = 0; i < geometry.faces.length; i++ ){
                var face = geometry.faces[i];
                if ( i < 96 ) {
                    face.color.setRGB( 0, 0, 256 );
                }
                else {
                  face.color.setRGB( 256, 0, 0 );
          }
            }

            var geo = new THREE.BufferGeometry().fromGeometry( geometry );               // convert to BufferGeometry type
            var mesh = new THREE.Mesh( geo, material );
            mesh.name = 'Antenna ' + ( ++meshCount );
            mesh.isAntenna = true;

            editor.execute( new SetPositionCommand( mesh, new THREE.Vector3( x_NG, y_NG, z_NG ) ) );     // move object to desired coordinates
            editor.execute( new AddObjectCommand( mesh ) );                                              // add object to scene

            input_pane.remove(input);    // remove additional input display
            options.newInput();
            check = false;

        });

        input_pane.add(input);           // add display to menubar panel
        options.add(filler);
        options.add(input_pane);

  } );
  options.add( option );

  options.newInput = function(){       // reset all input values and displays
      input_x.setValue(0);
        input_y.setValue(0);
        input_z.setValue(0);
        options.remove(input_pane);
        options.remove(filler);
    };

    editor.setMenubar(options);          // store menubar configuration

    return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Menubar.Help = function ( editor ) {

  var container = new UI.Panel();
  container.setClass( 'menu' );

  var title = new UI.Panel();
  title.setClass( 'title' );
  title.setTextContent( 'Help' );
  container.add( title );

  var options = new UI.Panel();
  options.setClass( 'options' );
  container.add( options );

  //options.add( option );

  // How To

  var option = new UI.Row();
  option.setClass( 'option' );
  option.setTextContent( 'How To Use' );
  option.onClick( function () {

        document.getElementById('readme').style.display = "block";
        var but = document.getElementById('input');
        but.onclick = function () {
            document.getElementById('readme').style.display = "none";
        }

  } );
  options.add( option );

    editor.setMenubar(options);          // store menubar configuration

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Menubar.Status = function ( editor ) {

  var container = new UI.Panel();
  container.setClass( 'menu right' );

  var autosave = new UI.THREE.Boolean( editor.config.getKey( 'autosave' ), 'autosave' );
  autosave.text.setColor( '#888' );
  autosave.onChange( function () {

    var value = this.getValue();

    editor.config.setKey( 'autosave', value );

    if ( value === true ) {

      editor.signals.sceneGraphChanged.dispatch();

    }

  } );
  container.add( autosave );

  editor.signals.savingStarted.add( function () {

    autosave.text.setTextDecoration( 'underline' );

  } );

  editor.signals.savingFinished.add( function () {

    autosave.text.setTextDecoration( 'none' );

  } );

  var version = new UI.Text( 'v1.0.0' );
  version.setClass( 'title' );
  version.setOpacity( 0.5 );
  container.add( version );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Sidebar = function ( editor ) {

  var container = new UI.Panel();
  container.setId( 'sidebar' );

  //

  var sceneTab = new UI.Text( 'SCENE' ).onClick( onClick );
  var settingsTab = new UI.Text( 'SETTINGS' ).onClick( onClick );

  var tabs = new UI.Div();
  tabs.setId( 'tabs' );
  tabs.add( sceneTab, settingsTab );
  container.add( tabs );

  function onClick( event ) {

    select( event.target.textContent );

  }

  //

  var scene = new UI.Span().add(
    new Sidebar.Scene( editor ),
    new Sidebar.Properties( editor ),
    new Sidebar.Animation( editor )
  );
  container.add( scene );

  var project = new UI.Span().add(
    new Sidebar.Project( editor )
  );

  var settings = new UI.Span().add(
    new Sidebar.Settings( editor ),
    new Sidebar.History( editor )
  );
  container.add( settings );

  //

  function select( section ) {

    sceneTab.setClass( '' );
    settingsTab.setClass( '' );

    scene.setDisplay( 'none' );
    settings.setDisplay( 'none' );

    switch ( section ) {
      case 'SCENE':
        sceneTab.setClass( 'selected' );
        scene.setDisplay( '' );
        break;
      case 'SETTINGS':
        settingsTab.setClass( 'selected' );
        settings.setDisplay( '' );
        break;
    }

  }

  select( 'SCENE' );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Scene = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setBorderTop( '0' );
  container.setPaddingTop( '20px' );

  // outliner

  function buildOption( object, draggable ) {

    var option = document.createElement( 'div' );
    option.draggable = draggable;
    option.innerHTML = buildHTML( object );
    option.value = object.id;

    return option;

  }

  function getMaterialName( material ) {

    if ( Array.isArray( material ) ) {

      var array = [];

      for ( var i = 0; i < material.length; i ++ ) {

        array.push( material[ i ].name );

      }

      return array.join( ',' );

    }

    return material.name;

  }

  function buildHTML( object ) {

    var html = '<span class="type ' + object.type + '"></span> ' + object.name;

    if ( object instanceof THREE.Mesh ) {

      var geometry = object.geometry;
      var material = object.material;

      html += ' <span class="type ' + geometry.type + '"></span> ' + geometry.name;
      html += ' <span class="type ' + material.type + '"></span> ' + getMaterialName( material );

    }

    html += getScript( object.uuid );

    return html;

  }

  function getScript( uuid ) {

    if ( editor.scripts[ uuid ] !== undefined ) {

      return ' <span class="type Script"></span>';

    }

    return '';

  }

  var ignoreObjectSelectedSignal = false;

  var outliner = new UI.Outliner( editor );
  outliner.setId( 'outliner' );
  outliner.onChange( function () {

    ignoreObjectSelectedSignal = true;

    editor.selectById( parseInt( outliner.getValue() ) );

    ignoreObjectSelectedSignal = false;

  } );
  outliner.onDblClick( function () {

    editor.focusById( parseInt( outliner.getValue() ) );

  } );
  container.add( outliner );
  container.add( new UI.Break() );

  // background

  function onBackgroundChanged() {

    signals.sceneBackgroundChanged.dispatch( backgroundColor.getHexValue() );

  }

  var backgroundRow = new UI.Row();

  var backgroundColor = new UI.Color().setValue( '#aaaaaa' ).onChange( onBackgroundChanged );

  backgroundRow.add( new UI.Text( 'Background' ).setWidth( '90px' ) );
  backgroundRow.add( backgroundColor );

  container.add( backgroundRow );
    container.add( new UI.HorizontalRule() );

  // Model Dimensions

    container.add( new UI.Text( 'Aircraft Dimensions (meters)' ) );
    container.add( new UI.Break() );
    container.add( new UI.Break() );

    var lengthRow = new UI.Row();
    var length = new UI.Number().setWidth( '50px' ).onChange( update );
    lengthRow.add( new UI.Text( 'Length' ).setMarginLeft('15px').setWidth( '120px' ) );
    lengthRow.add( length );

    var wingspanRow = new UI.Row();
    var wingspan = new UI.Number().setWidth( '50px' ).onChange( update );
    wingspanRow.add( new UI.Text( 'Wingspan' ).setMarginLeft('15px').setWidth( '120px' ) );
    wingspanRow.add( wingspan );

    var heightRow = new UI.Row();
    var height = new UI.Number().setWidth( '50px' ).onChange( update );
    heightRow.add( new UI.Text( 'Height (nose up)' ).setMarginLeft('15px').setWidth( '120px' ) );
    heightRow.add( height );

    container.add( lengthRow );
    container.add( wingspanRow );
    container.add( heightRow );

    // Model Reset

    var resetRow = new UI.Row();
    var resetButton = new UI.Button('RESET').onClick( function(){

        if ( editor.scene.children[1] !== null ) {
            var model = editor.scene.children[1];
            model.position.x = editor.getModelPosition()[0];
            model.position.y = editor.getModelPosition()[1];
            model.position.z = editor.getModelPosition()[2];
            model.rotation.x = editor.getModelRotation()[0];
            model.rotation.y = editor.getModelRotation()[1];
            model.rotation.z = editor.getModelRotation()[2];
            model.scale.x = editor.getModelScale()[0];
            model.scale.y = editor.getModelScale()[1];
            model.scale.z = editor.getModelScale()[2];
            signals.objectSelected.dispatch( model );
        }
    });

    resetRow.add( new UI.Text( 'Model Position/Size' ).setWidth( '150px' ) );
    resetRow.add( resetButton );

    container.add( resetRow );

    // Antenna Snapping

    container.add( new UI.HorizontalRule() );
    var isSnapOn = false;
    var snapRow = new UI.Row();
    var snapBox = new UI.Checkbox( false ).onChange( function(){

      isSnapOn = !isSnapOn;
      editor.setAntennaSnapping(isSnapOn);
    });

    snapRow.add( new UI.Text( 'Antenna Snapping' ).setWidth( '150px' ) );
    snapRow.add( snapBox );

    container.add( snapRow );

  // fog

  function onFogChanged() {

    signals.sceneFogChanged.dispatch(
      fogType.getValue(),
      fogColor.getHexValue(),
      fogNear.getValue(),
      fogFar.getValue(),
      fogDensity.getValue()
    );

  }

  var fogTypeRow = new UI.Row();
  var fogType = new UI.Select().setOptions( {

    'None': 'None',
    'Fog': 'Linear',
    'FogExp2': 'Exponential'

  } ).setWidth( '150px' );
  fogType.onChange( function () {

    onFogChanged();
    refreshFogUI();

  } );

  fogTypeRow.add( new UI.Text( 'Fog' ).setWidth( '90px' ) );
  fogTypeRow.add( fogType );

  //container.add( fogTypeRow );

  // fog color

  var fogPropertiesRow = new UI.Row();
  fogPropertiesRow.setDisplay( 'none' );
  fogPropertiesRow.setMarginLeft( '90px' );
  container.add( fogPropertiesRow );

  var fogColor = new UI.Color().setValue( '#aaaaaa' );
  fogColor.onChange( onFogChanged );
  fogPropertiesRow.add( fogColor );

  // fog near

  var fogNear = new UI.Number( 0.1 ).setWidth( '40px' ).setRange( 0, Infinity ).onChange( onFogChanged );
  fogPropertiesRow.add( fogNear );

  // fog far

  var fogFar = new UI.Number( 50 ).setWidth( '40px' ).setRange( 0, Infinity ).onChange( onFogChanged );
  fogPropertiesRow.add( fogFar );

  // fog density

  var fogDensity = new UI.Number( 0.05 ).setWidth( '40px' ).setRange( 0, 0.1 ).setPrecision( 3 ).onChange( onFogChanged );
  fogPropertiesRow.add( fogDensity );

  //

  function refreshUI() {

    var camera = editor.camera;
    var scene = editor.scene;

    var options = [];

    options.push( buildOption( camera, false ) );
    options.push( buildOption( scene, false ) );

    length.setValue( editor.getModelLength() );                // refresh entered dimensions back for display
        wingspan.setValue( editor.getModelWingspan() );
        height.setValue( editor.getModelHeight() );

    ( function addObjects( objects, pad ) {

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        var object = objects[ i ];

        var option = buildOption( object, true );
        option.style.paddingLeft = ( pad * 10 ) + 'px';
        options.push( option );

        //addObjects( object.children, pad + 1 );

      }

    } )( scene.children, 1 );

    outliner.setOptions( options );

    if ( editor.selected !== null ) {

      outliner.setValue( editor.selected.id );

    }

    if ( scene.background ) {

      backgroundColor.setHexValue( scene.background.getHex() );

    }

    if ( scene.fog ) {

      fogColor.setHexValue( scene.fog.color.getHex() );

      if ( scene.fog instanceof THREE.Fog ) {

        fogType.setValue( "Fog" );
        fogNear.setValue( scene.fog.near );
        fogFar.setValue( scene.fog.far );

      } else if ( scene.fog instanceof THREE.FogExp2 ) {

        fogType.setValue( "FogExp2" );
        fogDensity.setValue( scene.fog.density );

      }

    } else {

      fogType.setValue( "None" );

    }

    refreshFogUI();

  }

  function refreshFogUI() {

    var type = fogType.getValue();

    fogPropertiesRow.setDisplay( type === 'None' ? 'none' : '' );
    fogNear.setDisplay( type === 'Fog' ? '' : 'none' );
    fogFar.setDisplay( type === 'Fog' ? '' : 'none' );
    fogDensity.setDisplay( type === 'FogExp2' ? '' : 'none' );

  }

  refreshUI();

  // events

  signals.editorCleared.add( refreshUI );

  signals.sceneGraphChanged.add( refreshUI );

  signals.objectChanged.add( function ( object ) {

    var options = outliner.options;

    for ( var i = 0; i < options.length; i ++ ) {

      var option = options[ i ];

      if ( option.value === object.id ) {

        option.innerHTML = buildHTML( object );
        return;

      }

    }

  } );

  signals.objectSelected.add( function ( object ) {

    if ( ignoreObjectSelectedSignal === true ) return;

    outliner.setValue( object !== null ? object.id : null );

  } );

    function update() {

      editor.setModelDimensions( length.getValue(), wingspan.getValue(), height.getValue() )

    }

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Project = function ( editor ) {

  var config = editor.config;
  var signals = editor.signals;

  var rendererTypes = {

    'WebGLRenderer': THREE.WebGLRenderer,
    'CanvasRenderer': THREE.CanvasRenderer,
    'SVGRenderer': THREE.SVGRenderer,
    'SoftwareRenderer': THREE.SoftwareRenderer,
    'RaytracingRenderer': THREE.RaytracingRenderer

  };

  var container = new UI.Panel();
  container.setBorderTop( '0' );
  container.setPaddingTop( '20px' );

  // class

  var options = {};

  for ( var key in rendererTypes ) {

    if ( key.indexOf( 'WebGL' ) >= 0 && System.support.webgl === false ) continue;

    options[ key ] = key;

  }

  var rendererTypeRow = new UI.Row();
  var rendererType = new UI.Select().setOptions( options ).setWidth( '150px' ).onChange( function () {

    var value = this.getValue();

    config.setKey( 'project/renderer', value );

    updateRenderer();

  } );

  rendererTypeRow.add( new UI.Text( 'Renderer' ).setWidth( '90px' ) );
  rendererTypeRow.add( rendererType );

  container.add( rendererTypeRow );

  if ( config.getKey( 'project/renderer' ) !== undefined ) {

    rendererType.setValue( config.getKey( 'project/renderer' ) );

  }

  // antialiasing

  var rendererPropertiesRow = new UI.Row().setMarginLeft( '90px' );

  var rendererAntialias = new UI.THREE.Boolean( config.getKey( 'project/renderer/antialias' ), 'antialias' ).onChange( function () {

    config.setKey( 'project/renderer/antialias', this.getValue() );
    updateRenderer();

  } );
  rendererPropertiesRow.add( rendererAntialias );

  // shadow

  var rendererShadows = new UI.THREE.Boolean( config.getKey( 'project/renderer/shadows' ), 'shadows' ).onChange( function () {

    config.setKey( 'project/renderer/shadows', this.getValue() );
    updateRenderer();

  } );
  rendererPropertiesRow.add( rendererShadows );

  rendererPropertiesRow.add( new UI.Break() );

  // gamma input

  var rendererGammaInput = new UI.THREE.Boolean( config.getKey( 'project/renderer/gammaInput' ), ' input' ).onChange( function () {

    config.setKey( 'project/renderer/gammaInput', this.getValue() );
    updateRenderer();

  } );
  rendererPropertiesRow.add( rendererGammaInput );

  // gamma output

  var rendererGammaOutput = new UI.THREE.Boolean( config.getKey( 'project/renderer/gammaOutput' ), ' output' ).onChange( function () {

    config.setKey( 'project/renderer/gammaOutput', this.getValue() );
    updateRenderer();

  } );
  rendererPropertiesRow.add( rendererGammaOutput );

  container.add( rendererPropertiesRow );

  // VR

  var vrRow = new UI.Row();
  var vr = new UI.Checkbox( config.getKey( 'project/vr' ) ).setLeft( '100px' ).onChange( function () {

    config.setKey( 'project/vr', this.getValue() );
    // updateRenderer();

  } );

  vrRow.add( new UI.Text( 'VR' ).setWidth( '90px' ) );
  vrRow.add( vr );

  container.add( vrRow );

  //

  function updateRenderer() {

    createRenderer( rendererType.getValue(), rendererAntialias.getValue(), rendererShadows.getValue(), rendererGammaInput.getValue(), rendererGammaOutput.getValue() );

  }

  function createRenderer( type, antialias, shadows, gammaIn, gammaOut ) {

    if ( type === 'WebGLRenderer' && System.support.webgl === false ) {

      type = 'CanvasRenderer';

    }

    rendererPropertiesRow.setDisplay( type === 'WebGLRenderer' ? '' : 'none' );

    var renderer = new rendererTypes[ type ]( { antialias: antialias} );
    renderer.gammaInput = gammaIn;
    renderer.gammaOutput = gammaOut;
    if ( shadows && renderer.shadowMap ) {

      renderer.shadowMap.enabled = true;
      // renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    }

    signals.rendererChanged.dispatch( renderer );

  }

  createRenderer( config.getKey( 'project/renderer' ), config.getKey( 'project/renderer/antialias' ), config.getKey( 'project/renderer/shadows' ), config.getKey( 'project/renderer/gammaInput' ), config.getKey( 'project/renderer/gammaOutput' ) );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Settings = function ( editor ) {

  var config = editor.config;
  var signals = editor.signals;

  var container = new UI.Panel();
  container.setBorderTop( '0' );
  container.setPaddingTop( '20px' );

  // class

  var options = {
    'static/css/light.css': 'light',
    'static/css/dark.css': 'dark'
  };

  var themeRow = new UI.Row();
  var theme = new UI.Select().setWidth( '150px' );
  theme.setOptions( options );

  if ( config.getKey( 'theme' ) !== undefined ) {

    theme.setValue( config.getKey( 'theme' ) );

  }

  theme.onChange( function () {

    var value = this.getValue();

    editor.setTheme( value );
    editor.config.setKey( 'theme', value );

  } );

  themeRow.add( new UI.Text( 'Theme' ).setWidth( '90px' ) );
  themeRow.add( theme );

  container.add( themeRow );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Properties = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Span();

  var objectTab = new UI.Text( 'OBJECT' ).onClick( onClick );

  var tabs = new UI.Div();
  tabs.setId( 'tabs' );
  tabs.add( objectTab );
  container.add( tabs );

  function onClick( event ) {

    select( event.target.textContent );

  }

  //

  var object = new UI.Span().add(
    new Sidebar.Object( editor )
  );
  container.add( object );

  //

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Object = function ( editor ) {

    var signals = editor.signals;

    var container = new UI.Panel();
    container.setBorderTop( '0' );
    container.setPaddingTop( '20px' );
    container.setDisplay( 'none' );

    // Actions

    var objectActions = new UI.Select().setPosition( 'absolute' ).setRight( '8px' ).setFontSize( '11px' );
    objectActions.setOptions( {

        'Actions': 'Actions',
        'Reset Position': 'Reset Position',
        'Reset Rotation': 'Reset Rotation',
        'Reset Scale': 'Reset Scale'

    } );
    objectActions.onClick( function ( event ) {

        event.stopPropagation(); // Avoid panel collapsing

    } );
    objectActions.onChange( function ( event ) {

        var object = editor.selected;

        switch ( this.getValue() ) {

            case 'Reset Position':
                editor.execute( new SetPositionCommand( object, new THREE.Vector3( 0, 0, 0 ) ) );
                break;

            case 'Reset Rotation':
                editor.execute( new SetRotationCommand( object, new THREE.Euler( 0, 0, 0 ) ) );
                break;

            case 'Reset Scale':
                editor.execute( new SetScaleCommand( object, new THREE.Vector3( 1, 1, 1 ) ) );
                break;

        }

        this.setValue( 'Actions' );

    } );
    // container.addStatic( objectActions );

    // type

    var objectTypeRow = new UI.Row();
    var objectType = new UI.Text();

    objectTypeRow.add( new UI.Text( 'Type' ).setWidth( '90px' ) );
    objectTypeRow.add( objectType );

    //container.add( objectTypeRow );

    // uuid

    var objectUUIDRow = new UI.Row();
    var objectUUID = new UI.Input().setWidth( '102px' ).setFontSize( '12px' ).setDisabled( true );
    var objectUUIDRenew = new UI.Button( 'New' ).setMarginLeft( '7px' ).onClick( function () {

        objectUUID.setValue( THREE.Math.generateUUID() );

        editor.execute( new SetUuidCommand( editor.selected, objectUUID.getValue() ) );

    } );

    objectUUIDRow.add( new UI.Text( 'UUID' ).setWidth( '90px' ) );
    objectUUIDRow.add( objectUUID );
    objectUUIDRow.add( objectUUIDRenew );

    //container.add( objectUUIDRow );

    // name

    var objectNameRow = new UI.Row();
    var objectName = new UI.Input().setWidth( '150px' ).setFontSize( '12px' ).onChange( function () {

        editor.execute( new SetValueCommand( editor.selected, 'name', objectName.getValue() ) );

    } );

    objectNameRow.add( new UI.Text( 'Name' ).setWidth( '90px' ) );
    objectNameRow.add( objectName );

    container.add( objectNameRow );

    // position

    var objectPositionRow = new UI.Row();
    var objectPositionX = new UI.Number().setWidth( '50px' ).onChange( update );
    var objectPositionY = new UI.Number().setWidth( '50px' ).onChange( update );
    var objectPositionZ = new UI.Number().setWidth( '50px' ).onChange( update );

    objectPositionRow.add( new UI.Text( 'Position' ).setWidth( '90px' ) );
    objectPositionRow.add( objectPositionZ, objectPositionX, objectPositionY );

    container.add( objectPositionRow );

    // rotation

    var objectRotationRow = new UI.Row();
    var objectRotationX = new UI.Number().setStep( 10 ).setUnit( '' ).setWidth( '50px' ).onChange( update );
    var objectRotationY = new UI.Number().setStep( 10 ).setUnit( '' ).setWidth( '50px' ).onChange( update );
    var objectRotationZ = new UI.Number().setStep( 10 ).setUnit( '' ).setWidth( '50px' ).onChange( update );

    objectRotationRow.add( new UI.Text( 'Rotation' ).setWidth( '90px' ) );
    objectRotationRow.add( objectRotationZ, objectRotationX, objectRotationY );

    container.add( objectRotationRow );

    // scale

    var objectScaleRow = new UI.Row();
    var objectScaleLock = new UI.Checkbox( true ).setPosition( 'absolute' ).setLeft( '75px' );
    var objectScaleX = new UI.Number( 1 ).setRange( 0.01, Infinity ).setWidth( '50px' ).onChange( updateScaleX );
    var objectScaleY = new UI.Number( 1 ).setRange( 0.01, Infinity ).setWidth( '50px' ).onChange( updateScaleY );
    var objectScaleZ = new UI.Number( 1 ).setRange( 0.01, Infinity ).setWidth( '50px' ).onChange( updateScaleZ );

    objectScaleRow.add( new UI.Text( 'Scale' ).setWidth( '90px' ) );
    //objectScaleRow.add( objectScaleLock );
    objectScaleRow.add( objectScaleZ, objectScaleX, objectScaleY );    // swap y and z axis

    //container.add( objectScaleRow );

    // fov

    var objectFovRow = new UI.Row();
    var objectFov = new UI.Number().onChange( update );

    objectFovRow.add( new UI.Text( 'Fov' ).setWidth( '90px' ) );
    objectFovRow.add( objectFov );

    //container.add( objectFovRow );

    // near

    var objectNearRow = new UI.Row();
    var objectNear = new UI.Number().onChange( update );

    objectNearRow.add( new UI.Text( 'Near' ).setWidth( '90px' ) );
    objectNearRow.add( objectNear );

    //container.add( objectNearRow );

    // far

    var objectFarRow = new UI.Row();
    var objectFar = new UI.Number().onChange( update );

    objectFarRow.add( new UI.Text( 'Far' ).setWidth( '90px' ) );
    objectFarRow.add( objectFar );

    //container.add( objectFarRow );

    // intensity

    var objectIntensityRow = new UI.Row();
    var objectIntensity = new UI.Number().setRange( 0, Infinity ).onChange( update );

    objectIntensityRow.add( new UI.Text( 'Intensity' ).setWidth( '90px' ) );
    objectIntensityRow.add( objectIntensity );

    //container.add( objectIntensityRow );

    // color

    var objectColorRow = new UI.Row();
    var objectColor = new UI.Color().onChange( update );

    objectColorRow.add( new UI.Text( 'Color' ).setWidth( '90px' ) );
    objectColorRow.add( objectColor );

    //container.add( objectColorRow );

    // ground color

    var objectGroundColorRow = new UI.Row();
    var objectGroundColor = new UI.Color().onChange( update );

    objectGroundColorRow.add( new UI.Text( 'Ground color' ).setWidth( '90px' ) );
    objectGroundColorRow.add( objectGroundColor );

    //container.add( objectGroundColorRow );

    // distance

    var objectDistanceRow = new UI.Row();
    var objectDistance = new UI.Number().setRange( 0, Infinity ).onChange( update );

    objectDistanceRow.add( new UI.Text( 'Distance' ).setWidth( '90px' ) );
    objectDistanceRow.add( objectDistance );

    //container.add( objectDistanceRow );

    // angle

    var objectAngleRow = new UI.Row();
    var objectAngle = new UI.Number().setPrecision( 3 ).setRange( 0, Math.PI / 2 ).onChange( update );

    objectAngleRow.add( new UI.Text( 'Angle' ).setWidth( '90px' ) );
    objectAngleRow.add( objectAngle );

    //container.add( objectAngleRow );

    // penumbra

    var objectPenumbraRow = new UI.Row();
    var objectPenumbra = new UI.Number().setRange( 0, 1 ).onChange( update );

    objectPenumbraRow.add( new UI.Text( 'Penumbra' ).setWidth( '90px' ) );
    objectPenumbraRow.add( objectPenumbra );

    //container.add( objectPenumbraRow );

    // decay

    var objectDecayRow = new UI.Row();
    var objectDecay = new UI.Number().setRange( 0, Infinity ).onChange( update );

    objectDecayRow.add( new UI.Text( 'Decay' ).setWidth( '90px' ) );
    objectDecayRow.add( objectDecay );

    //container.add( objectDecayRow );

    // shadow

    var objectShadowRow = new UI.Row();

    objectShadowRow.add( new UI.Text( 'Shadow' ).setWidth( '90px' ) );

    var objectCastShadow = new UI.THREE.Boolean( false, 'cast' ).onChange( update );
    objectShadowRow.add( objectCastShadow );

    var objectReceiveShadow = new UI.THREE.Boolean( false, 'receive' ).onChange( update );
    objectShadowRow.add( objectReceiveShadow );

    var objectShadowRadius = new UI.Number( 1 ).onChange( update );
    objectShadowRow.add( objectShadowRadius );

    //container.add( objectShadowRow );

    // visible

    var objectVisibleRow = new UI.Row();
    var objectVisible = new UI.Checkbox().onChange( update );

    objectVisibleRow.add( new UI.Text( 'Visible' ).setWidth( '90px' ) );
    objectVisibleRow.add( objectVisible );

    container.add( objectVisibleRow );

    //wireframe
    var materialWireframeRow = new UI.Row();
    //var materialWireframe = new UI.Checkbox( false ).onChange( update );
    var materialWireframe = new UI.Checkbox(false).onChange( update );
    materialWireframeRow.add( new UI.Text( 'Wireframe' ).setWidth( '90px' ) );
    materialWireframeRow.add( materialWireframe );

    container.add( materialWireframeRow );

    // user data

    var timeout;

    var objectUserDataRow = new UI.Row();
    var objectUserData = new UI.TextArea().setWidth( '150px' ).setHeight( '40px' ).setFontSize( '12px' ).onChange( update );
    objectUserData.onKeyUp( function () {

        try {

            JSON.parse( objectUserData.getValue() );

            objectUserData.dom.classList.add( 'success' );
            objectUserData.dom.classList.remove( 'fail' );

        } catch ( error ) {

            objectUserData.dom.classList.remove( 'success' );
            objectUserData.dom.classList.add( 'fail' );

        }

    } );

    objectUserDataRow.add( new UI.Text( 'User data' ).setWidth( '90px' ) );
    objectUserDataRow.add( objectUserData );

    //container.add( objectUserDataRow );


    //

    function updateScaleX() {

        var object = editor.selected;

        if ( objectScaleLock.getValue() === true ) {

            var scale = objectScaleX.getValue() / object.scale.x;

            objectScaleY.setValue( objectScaleY.getValue() * scale );
            objectScaleZ.setValue( objectScaleZ.getValue() * scale );

        }

        update();

    }

    function updateScaleY() {

        var object = editor.selected;

        if ( objectScaleLock.getValue() === true ) {

            var scale = objectScaleY.getValue() / object.scale.y;

            objectScaleX.setValue( objectScaleX.getValue() * scale );
            objectScaleZ.setValue( objectScaleZ.getValue() * scale );

        }

        update();

    }

    function updateScaleZ() {

        var object = editor.selected;

        if ( objectScaleLock.getValue() === true ) {

            var scale = objectScaleZ.getValue() / object.scale.z;

            objectScaleX.setValue( objectScaleX.getValue() * scale );
            objectScaleY.setValue( objectScaleY.getValue() * scale );

        }

        update();

    }

    function update() {

        var object = editor.selected;

        if ( object !== null ) {

            var right_wing = editor.getModel()[0];          // convert entered coordinates to three.js standard
            var left_wing = editor.getModel()[1];
            var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();
            var x = ( objectPositionX.getValue() * y_slope ) + ( left_wing + right_wing ) / 2;

            var z_nose = editor.getModel()[3];
            var z_tail = editor.getModel()[2];
            var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();
            var y = ( ( objectPositionY.getValue() * z_slope ) + z_nose );

            var x_nose = editor.getModel()[4];
            var x_tail = editor.getModel()[5];
            var x_slope = ( x_nose - x_tail ) / editor.getModelLength();
            var z = x_nose + ( objectPositionZ.getValue() * x_slope );

            var newPosition = new THREE.Vector3( x, y, z );
            if ( object.position.distanceTo( newPosition ) >= 0.01 ) {

                editor.execute( new SetPositionCommand( object, newPosition ) );

            }

            var newRotation = new THREE.Euler( objectRotationX.getValue() * THREE.Math.DEG2RAD, objectRotationY.getValue() * THREE.Math.DEG2RAD, objectRotationZ.getValue() * THREE.Math.DEG2RAD );
            if ( object.rotation.toVector3().distanceTo( newRotation.toVector3() ) >= 0.01 ) {

                editor.execute( new SetRotationCommand( object, newRotation ) );

            }

            var newScale = new THREE.Vector3( objectScaleX.getValue(), objectScaleY.getValue(), objectScaleZ.getValue() );
            if ( object.scale.distanceTo( newScale ) >= 0.001 ) {

                editor.execute( new SetScaleCommand( object, newScale ) );

            }

            if ( object.fov !== undefined && Math.abs( object.fov - objectFov.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'fov', objectFov.getValue() ) );
                object.updateProjectionMatrix();

            }

            if ( object.near !== undefined && Math.abs( object.near - objectNear.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'near', objectNear.getValue() ) );

            }

            if ( object.far !== undefined && Math.abs( object.far - objectFar.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'far', objectFar.getValue() ) );

            }

            if ( object.intensity !== undefined && Math.abs( object.intensity - objectIntensity.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'intensity', objectIntensity.getValue() ) );

            }

            if ( object.color !== undefined && object.color.getHex() !== objectColor.getHexValue() ) {

                editor.execute( new SetColorCommand( object, 'color', objectColor.getHexValue() ) );

            }

            if ( object.groundColor !== undefined && object.groundColor.getHex() !== objectGroundColor.getHexValue() ) {

                editor.execute( new SetColorCommand( object, 'groundColor', objectGroundColor.getHexValue() ) );

            }

            if ( object.distance !== undefined && Math.abs( object.distance - objectDistance.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'distance', objectDistance.getValue() ) );

            }

            if ( object.angle !== undefined && Math.abs( object.angle - objectAngle.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'angle', objectAngle.getValue() ) );

            }

            if ( object.penumbra !== undefined && Math.abs( object.penumbra - objectPenumbra.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'penumbra', objectPenumbra.getValue() ) );

            }

            if ( object.decay !== undefined && Math.abs( object.decay - objectDecay.getValue() ) >= 0.01 ) {

                editor.execute( new SetValueCommand( object, 'decay', objectDecay.getValue() ) );

            }

            if ( object.children.length > 0
              && ( editor.getObjectMaterial( (object.children)[0]) ) !== undefined
              && ( editor.getObjectMaterial( (object.children)[0]) ).wireframe !== undefined
              && ( editor.getObjectMaterial( (object.children)[0]) ).wireframe !== materialWireframe.getValue() ) {

              var objects = object.children;
              var cmds = [];
              var currentObject;

              for ( var i = 0, l = objects.length; i < l; i ++ ) {
                currentObject = objects[ i ];
                if ( editor.getObjectMaterial( currentObject ) !== undefined && editor.getObjectMaterial(currentObject).wireframe !== undefined ) {
                  cmds.push(new SetMaterialValueCommand( currentObject, 'wireframe', materialWireframe.getValue()));
                };
              }

              editor.execute( new MultiCmdsCommand(cmds) );

            } else if( object.children.length == 0
              && editor.getObjectMaterial( object ) !== undefined
              && ( editor.getObjectMaterial( object ) ).wireframe !== undefined
              && ( editor.getObjectMaterial( object ) ).wireframe !== materialWireframe.getValue() ) {

              editor.execute(new SetMaterialValueCommand( object, 'wireframe', materialWireframe.getValue()));

            }

            if ( object.visible !== objectVisible.getValue() ) {

                editor.execute( new SetValueCommand( object, 'visible', objectVisible.getValue() ) );

            }

            if ( object.castShadow !== undefined && object.castShadow !== objectCastShadow.getValue() ) {

                editor.execute( new SetValueCommand( object, 'castShadow', objectCastShadow.getValue() ) );

            }

            if ( object.receiveShadow !== undefined && object.receiveShadow !== objectReceiveShadow.getValue() ) {

                editor.execute( new SetValueCommand( object, 'receiveShadow', objectReceiveShadow.getValue() ) );
                object.material.needsUpdate = true;

            }

            if ( object.shadow !== undefined ) {

                if ( object.shadow.radius !== objectShadowRadius.getValue() ) {

                    editor.execute( new SetValueCommand( object.shadow, 'radius', objectShadowRadius.getValue() ) );

                }

            }

            try {

                var userData = JSON.parse( objectUserData.getValue() );
                if ( JSON.stringify( object.userData ) != JSON.stringify( userData ) ) {

                    editor.execute( new SetValueCommand( object, 'userData', userData ) );

                }

            } catch ( exception ) {

                console.warn( exception );

            }

        }

    }

    function updateRows( object ) {

        var properties = {
            'fov': objectFovRow,
            'near': objectNearRow,
            'far': objectFarRow,
            'intensity': objectIntensityRow,
            'color': objectColorRow,
            'groundColor': objectGroundColorRow,
            'distance' : objectDistanceRow,
            'angle' : objectAngleRow,
            'penumbra' : objectPenumbraRow,
            'decay' : objectDecayRow,
            'castShadow' : objectShadowRow,
            'receiveShadow' : objectReceiveShadow,
            'shadow': objectShadowRadius
        };

        for ( var property in properties ) {

            properties[ property ].setDisplay( object[ property ] !== undefined ? '' : 'none' );

        }

    }

    function updateTransformRows( object ) {

        if ( object instanceof THREE.Light ||
            ( object instanceof THREE.Object3D && object.userData.targetInverse ) ) {

            objectRotationRow.setDisplay( 'none' );
            objectScaleRow.setDisplay( 'none' );

        } else {

            objectRotationRow.setDisplay( '' );
            objectScaleRow.setDisplay( '' );

        }

    }

    // events

    signals.objectSelected.add( function ( object ) {

        if ( object !== null ) {

            container.setDisplay( 'block' );

            updateRows( object );
            updateUI( object );

        } else {

            container.setDisplay( 'none' );

        }

    } );

    signals.objectChanged.add( function ( object ) {

        if ( object !== editor.selected ) return;

        updateUI( object );

    } );

    signals.refreshSidebarObject3D.add( function ( object ) {

        if ( object !== editor.selected ) return;

        updateUI( object );

    } );

    function updateUI( object ) {

        objectType.setValue( object.type );
        objectUUID.setValue( object.uuid );
        objectName.setValue( object.name );


        var right_wing = editor.getModel()[0];              // convert three.js coordinates back to meters for display
        var left_wing = editor.getModel()[1];
        var y_slope = ( right_wing - left_wing ) / editor.getModelWingspan();
        var x =( object.position.x - ( left_wing + right_wing ) / 2 ) / y_slope;
        objectPositionX.setValue( x );

        var z_nose = editor.getModel()[3];
        var z_tail = editor.getModel()[2];
        var z_slope = ( z_nose - z_tail ) / editor.getModelHeight();
        var y = ( object.position.y - z_nose ) / z_slope;
        objectPositionY.setValue( y );


        var x_nose = editor.getModel()[4];
        var x_tail = editor.getModel()[5];
        var x_slope = ( x_nose - x_tail ) / editor.getModelLength();
        var z = ( object.position.z - x_nose ) / x_slope;
        objectPositionZ.setValue( z );

        objectRotationX.setValue( object.rotation.x * THREE.Math.RAD2DEG );
        objectRotationY.setValue( object.rotation.y * THREE.Math.RAD2DEG );
        objectRotationZ.setValue( object.rotation.z * THREE.Math.RAD2DEG );

        objectScaleX.setValue( object.scale.x );
        objectScaleY.setValue( object.scale.y );
        objectScaleZ.setValue( object.scale.z );


        if ( object.fov !== undefined ) {

            objectFov.setValue( object.fov );

        }

        if ( object.near !== undefined ) {

            objectNear.setValue( object.near );

        }

        if ( object.far !== undefined ) {

            objectFar.setValue( object.far );

        }

        if ( object.intensity !== undefined ) {

            objectIntensity.setValue( object.intensity );

        }

        if ( object.color !== undefined ) {

            objectColor.setHexValue( object.color.getHexString() );

        }

        if ( object.groundColor !== undefined ) {

            objectGroundColor.setHexValue( object.groundColor.getHexString() );

        }

        if ( object.distance !== undefined ) {

            objectDistance.setValue( object.distance );

        }

        if ( object.angle !== undefined ) {

            objectAngle.setValue( object.angle );

        }

        if ( object.penumbra !== undefined ) {

            objectPenumbra.setValue( object.penumbra );

        }

        if ( object.decay !== undefined ) {

            objectDecay.setValue( object.decay );

        }

        if ( object.castShadow !== undefined ) {

            objectCastShadow.setValue( object.castShadow );

        }

        if ( object.receiveShadow !== undefined ) {

            objectReceiveShadow.setValue( object.receiveShadow );

        }

        if ( object.shadow !== undefined ) {

            objectShadowRadius.setValue( object.shadow.radius );

        }


        objectVisible.setValue( object.visible );


        if ( object.children.length > 0
          && editor.getObjectMaterial( (object.children)[0] ) !== undefined
          && ( editor.getObjectMaterial( (object.children)[0] ) ).wireframe !== undefined ) {

          for (var i = 0; i < object.children.length; i++) {
            if (editor.getObjectMaterial( (object.children)[i] ) !== undefined && editor.getObjectMaterial( (object.children)[i]).wireframe !== undefined) {
              materialWireframe.setValue( (editor.getObjectMaterial((object.children)[i])).wireframe );
            }
          }

        } else if (object.children.length == 0
          && editor.getObjectMaterial( object ) !== undefined
          && editor.getObjectMaterial( object ).wireframe !== undefined ) {

          materialWireframe.setValue( (editor.getObjectMaterial( object )).wireframe );
        }


        try {

            objectUserData.setValue( JSON.stringify( object.userData, null, '  ' ) );

        } catch ( error ) {

            console.log( error );

        }


        objectUserData.setBorderColor( 'transparent' );
        objectUserData.setBackgroundColor( '' );

        updateTransformRows( object );

    }

    return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setBorderTop( '0' );
  container.setPaddingTop( '20px' );

  // Actions

  /*
  var objectActions = new UI.Select().setPosition( 'absolute' ).setRight( '8px' ).setFontSize( '11px' );
  objectActions.setOptions( {

    'Actions': 'Actions',
    'Center': 'Center',
    'Convert': 'Convert',
    'Flatten': 'Flatten'

  } );
  objectActions.onClick( function ( event ) {

    event.stopPropagation(); // Avoid panel collapsing

  } );
  objectActions.onChange( function ( event ) {

    var action = this.getValue();

    var object = editor.selected;
    var geometry = object.geometry;

    if ( confirm( action + ' ' + object.name + '?' ) === false ) return;

    switch ( action ) {

      case 'Center':

        var offset = geometry.center();

        var newPosition = object.position.clone();
        newPosition.sub( offset );
        editor.execute( new SetPositionCommand( object, newPosition ) );

        editor.signals.geometryChanged.dispatch( object );

        break;

      case 'Convert':

        if ( geometry instanceof THREE.Geometry ) {

          editor.execute( new SetGeometryCommand( object, new THREE.BufferGeometry().fromGeometry( geometry ) ) );

        }

        break;

      case 'Flatten':

        var newGeometry = geometry.clone();
        newGeometry.uuid = geometry.uuid;
        newGeometry.applyMatrix( object.matrix );

        var cmds = [ new SetGeometryCommand( object, newGeometry ),
          new SetPositionCommand( object, new THREE.Vector3( 0, 0, 0 ) ),
          new SetRotationCommand( object, new THREE.Euler( 0, 0, 0 ) ),
          new SetScaleCommand( object, new THREE.Vector3( 1, 1, 1 ) ) ];

        editor.execute( new MultiCmdsCommand( cmds ), 'Flatten Geometry' );

        break;

    }

    this.setValue( 'Actions' );

  } );
  container.addStatic( objectActions );
  */

  // type

  var geometryTypeRow = new UI.Row();
  var geometryType = new UI.Text();

  geometryTypeRow.add( new UI.Text( 'Type' ).setWidth( '90px' ) );
  geometryTypeRow.add( geometryType );

  container.add( geometryTypeRow );

  // uuid

  var geometryUUIDRow = new UI.Row();
  var geometryUUID = new UI.Input().setWidth( '102px' ).setFontSize( '12px' ).setDisabled( true );
  var geometryUUIDRenew = new UI.Button( 'New' ).setMarginLeft( '7px' ).onClick( function () {

    geometryUUID.setValue( THREE.Math.generateUUID() );

    editor.execute( new SetGeometryValueCommand( editor.selected, 'uuid', geometryUUID.getValue() ) );

  } );

  geometryUUIDRow.add( new UI.Text( 'UUID' ).setWidth( '90px' ) );
  geometryUUIDRow.add( geometryUUID );
  geometryUUIDRow.add( geometryUUIDRenew );

  container.add( geometryUUIDRow );

  // name

  var geometryNameRow = new UI.Row();
  var geometryName = new UI.Input().setWidth( '150px' ).setFontSize( '12px' ).onChange( function () {

    editor.execute( new SetGeometryValueCommand( editor.selected, 'name', geometryName.getValue() ) );

  } );

  geometryNameRow.add( new UI.Text( 'Name' ).setWidth( '90px' ) );
  geometryNameRow.add( geometryName );

  container.add( geometryNameRow );

  // geometry

  container.add( new Sidebar.Geometry.Geometry( editor ) );

  // buffergeometry

  container.add( new Sidebar.Geometry.BufferGeometry( editor ) );

  // parameters

  var parameters = new UI.Span();
  container.add( parameters );


  //

  function build() {

    var object = editor.selected;

    if ( object && object.geometry ) {

      var geometry = object.geometry;

      container.setDisplay( 'block' );

      geometryType.setValue( geometry.type );

      geometryUUID.setValue( geometry.uuid );
      geometryName.setValue( geometry.name );

      //

      parameters.clear();

      if ( geometry.type === 'BufferGeometry' || geometry.type === 'Geometry' ) {

        parameters.add( new Sidebar.Geometry.Modifiers( editor, object ) );

      } else if ( Sidebar.Geometry[ geometry.type ] !== undefined ) {

        parameters.add( new Sidebar.Geometry[ geometry.type ]( editor, object ) );

      }

    } else {

      container.setDisplay( 'none' );

    }

  }

  signals.objectSelected.add( build );
  signals.geometryChanged.add( build );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.Geometry = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Row();

  // vertices

  var verticesRow = new UI.Row();
  var vertices = new UI.Text();

  verticesRow.add( new UI.Text( 'Vertices' ).setWidth( '90px' ) );
  verticesRow.add( vertices );

  container.add( verticesRow );

  // faces

  var facesRow = new UI.Row();
  var faces = new UI.Text();

  facesRow.add( new UI.Text( 'Faces' ).setWidth( '90px' ) );
  facesRow.add( faces );

  container.add( facesRow );

  //

  function update( object ) {

    if ( object === null ) return; // objectSelected.dispatch( null )
    if ( object === undefined ) return;

    var geometry = object.geometry;

    if ( geometry instanceof THREE.Geometry ) {

      container.setDisplay( 'block' );

      vertices.setValue( ( geometry.vertices.length ).format() );
      faces.setValue( ( geometry.faces.length ).format() );

    } else {

      container.setDisplay( 'none' );

    }

  }

  signals.objectSelected.add( update );
  signals.geometryChanged.add( update );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.BufferGeometry = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Row();

  function update( object ) {

    if ( object === null ) return; // objectSelected.dispatch( null )
    if ( object === undefined ) return;

    var geometry = object.geometry;

    if ( geometry instanceof THREE.BufferGeometry ) {

      container.clear();
      container.setDisplay( 'block' );

      var index = geometry.index;

      if ( index !== null ) {

        var panel = new UI.Row();
        panel.add( new UI.Text( 'index' ).setWidth( '90px' ) );
        panel.add( new UI.Text( ( index.count ).format() ).setFontSize( '12px' ) );
        container.add( panel );

      }

      var attributes = geometry.attributes;

      for ( var name in attributes ) {

        var attribute = attributes[ name ];

        var panel = new UI.Row();
        panel.add( new UI.Text( name ).setWidth( '90px' ) );
        panel.add( new UI.Text( ( attribute.count ).format() + ' (' + attribute.itemSize + ')' ).setFontSize( '12px' ) );
        container.add( panel );

      }

    } else {

      container.setDisplay( 'none' );

    }

  }

  signals.objectSelected.add( update );
  signals.geometryChanged.add( update );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.Modifiers = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row().setPaddingLeft( '90px' );

  var geometry = object.geometry;

  // Compute Vertex Normals

  var button = new UI.Button( 'Compute Vertex Normals' );
  button.onClick( function () {

    geometry.computeVertexNormals();

    if ( geometry instanceof THREE.BufferGeometry ) {

      geometry.attributes.normal.needsUpdate = true;

    } else {

      geometry.normalsNeedUpdate = true;

    }

    signals.geometryChanged.dispatch( object );

  } );

  container.add( button );

  //

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.BoxGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // width

  var widthRow = new UI.Row();
  var width = new UI.Number( parameters.width ).onChange( update );

  widthRow.add( new UI.Text( 'Width' ).setWidth( '90px' ) );
  widthRow.add( width );

  container.add( widthRow );

  // height

  var heightRow = new UI.Row();
  var height = new UI.Number( parameters.height ).onChange( update );

  heightRow.add( new UI.Text( 'Height' ).setWidth( '90px' ) );
  heightRow.add( height );

  container.add( heightRow );

  // depth

  var depthRow = new UI.Row();
  var depth = new UI.Number( parameters.depth ).onChange( update );

  depthRow.add( new UI.Text( 'Depth' ).setWidth( '90px' ) );
  depthRow.add( depth );

  container.add( depthRow );

  // widthSegments

  var widthSegmentsRow = new UI.Row();
  var widthSegments = new UI.Integer( parameters.widthSegments ).setRange( 1, Infinity ).onChange( update );

  widthSegmentsRow.add( new UI.Text( 'Width segments' ).setWidth( '90px' ) );
  widthSegmentsRow.add( widthSegments );

  container.add( widthSegmentsRow );

  // heightSegments

  var heightSegmentsRow = new UI.Row();
  var heightSegments = new UI.Integer( parameters.heightSegments ).setRange( 1, Infinity ).onChange( update );

  heightSegmentsRow.add( new UI.Text( 'Height segments' ).setWidth( '90px' ) );
  heightSegmentsRow.add( heightSegments );

  container.add( heightSegmentsRow );

  // depthSegments

  var depthSegmentsRow = new UI.Row();
  var depthSegments = new UI.Integer( parameters.depthSegments ).setRange( 1, Infinity ).onChange( update );

  depthSegmentsRow.add( new UI.Text( 'Depth segments' ).setWidth( '90px' ) );
  depthSegmentsRow.add( depthSegments );

  container.add( depthSegmentsRow );

  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      width.getValue(),
      height.getValue(),
      depth.getValue(),
      widthSegments.getValue(),
      heightSegments.getValue(),
      depthSegments.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.BoxBufferGeometry = Sidebar.Geometry.BoxGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.CircleGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radius

  var radiusRow = new UI.Row();
  var radius = new UI.Number( parameters.radius ).onChange( update );

  radiusRow.add( new UI.Text( 'Radius' ).setWidth( '90px' ) );
  radiusRow.add( radius );

  container.add( radiusRow );

  // segments

  var segmentsRow = new UI.Row();
  var segments = new UI.Integer( parameters.segments ).setRange( 3, Infinity ).onChange( update );

  segmentsRow.add( new UI.Text( 'Segments' ).setWidth( '90px' ) );
  segmentsRow.add( segments );

  container.add( segmentsRow );

  // thetaStart

  var thetaStartRow = new UI.Row();
  var thetaStart = new UI.Number( parameters.thetaStart ).onChange( update );

  thetaStartRow.add( new UI.Text( 'Theta start' ).setWidth( '90px' ) );
  thetaStartRow.add( thetaStart );

  container.add( thetaStartRow );

  // thetaLength

  var thetaLengthRow = new UI.Row();
  var thetaLength = new UI.Number( parameters.thetaLength ).onChange( update );

  thetaLengthRow.add( new UI.Text( 'Theta length' ).setWidth( '90px' ) );
  thetaLengthRow.add( thetaLength );

  container.add( thetaLengthRow );

  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radius.getValue(),
      segments.getValue(),
      thetaStart.getValue(),
      thetaLength.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.CircleBufferGeometry = Sidebar.Geometry.CircleGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.CylinderGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radiusTop

  var radiusTopRow = new UI.Row();
  var radiusTop = new UI.Number( parameters.radiusTop ).onChange( update );

  radiusTopRow.add( new UI.Text( 'Radius top' ).setWidth( '90px' ) );
  radiusTopRow.add( radiusTop );

  container.add( radiusTopRow );

  // radiusBottom

  var radiusBottomRow = new UI.Row();
  var radiusBottom = new UI.Number( parameters.radiusBottom ).onChange( update );

  radiusBottomRow.add( new UI.Text( 'Radius bottom' ).setWidth( '90px' ) );
  radiusBottomRow.add( radiusBottom );

  container.add( radiusBottomRow );

  // height

  var heightRow = new UI.Row();
  var height = new UI.Number( parameters.height ).onChange( update );

  heightRow.add( new UI.Text( 'Height' ).setWidth( '90px' ) );
  heightRow.add( height );

  container.add( heightRow );

  // radialSegments

  var radialSegmentsRow = new UI.Row();
  var radialSegments = new UI.Integer( parameters.radialSegments ).setRange( 1, Infinity ).onChange( update );

  radialSegmentsRow.add( new UI.Text( 'Radial segments' ).setWidth( '90px' ) );
  radialSegmentsRow.add( radialSegments );

  container.add( radialSegmentsRow );

  // heightSegments

  var heightSegmentsRow = new UI.Row();
  var heightSegments = new UI.Integer( parameters.heightSegments ).setRange( 1, Infinity ).onChange( update );

  heightSegmentsRow.add( new UI.Text( 'Height segments' ).setWidth( '90px' ) );
  heightSegmentsRow.add( heightSegments );

  container.add( heightSegmentsRow );

  // openEnded

  var openEndedRow = new UI.Row();
  var openEnded = new UI.Checkbox( parameters.openEnded ).onChange( update );

  openEndedRow.add( new UI.Text( 'Open ended' ).setWidth( '90px' ) );
  openEndedRow.add( openEnded );

  container.add( openEndedRow );

  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radiusTop.getValue(),
      radiusBottom.getValue(),
      height.getValue(),
      radialSegments.getValue(),
      heightSegments.getValue(),
      openEnded.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.CylinderBufferGeometry = Sidebar.Geometry.CylinderGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.IcosahedronGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radius

  var radiusRow = new UI.Row();
  var radius = new UI.Number( parameters.radius ).onChange( update );

  radiusRow.add( new UI.Text( 'Radius' ).setWidth( '90px' ) );
  radiusRow.add( radius );

  container.add( radiusRow );

  // detail

  var detailRow = new UI.Row();
  var detail = new UI.Integer( parameters.detail ).setRange( 0, Infinity ).onChange( update );

  detailRow.add( new UI.Text( 'Detail' ).setWidth( '90px' ) );
  detailRow.add( detail );

  container.add( detailRow );


  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radius.getValue(),
      detail.getValue()
    ) ) );

    signals.objectChanged.dispatch( object );

  }

  return container;

};

Sidebar.Geometry.IcosahedronBufferGeometry = Sidebar.Geometry.IcosahedronGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.PlaneGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // width

  var widthRow = new UI.Row();
  var width = new UI.Number( parameters.width ).onChange( update );

  widthRow.add( new UI.Text( 'Width' ).setWidth( '90px' ) );
  widthRow.add( width );

  container.add( widthRow );

  // height

  var heightRow = new UI.Row();
  var height = new UI.Number( parameters.height ).onChange( update );

  heightRow.add( new UI.Text( 'Height' ).setWidth( '90px' ) );
  heightRow.add( height );

  container.add( heightRow );

  // widthSegments

  var widthSegmentsRow = new UI.Row();
  var widthSegments = new UI.Integer( parameters.widthSegments ).setRange( 1, Infinity ).onChange( update );

  widthSegmentsRow.add( new UI.Text( 'Width segments' ).setWidth( '90px' ) );
  widthSegmentsRow.add( widthSegments );

  container.add( widthSegmentsRow );

  // heightSegments

  var heightSegmentsRow = new UI.Row();
  var heightSegments = new UI.Integer( parameters.heightSegments ).setRange( 1, Infinity ).onChange( update );

  heightSegmentsRow.add( new UI.Text( 'Height segments' ).setWidth( '90px' ) );
  heightSegmentsRow.add( heightSegments );

  container.add( heightSegmentsRow );


  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      width.getValue(),
      height.getValue(),
      widthSegments.getValue(),
      heightSegments.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.PlaneBufferGeometry = Sidebar.Geometry.PlaneGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.SphereGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radius

  var radiusRow = new UI.Row();
  var radius = new UI.Number( parameters.radius ).onChange( update );

  radiusRow.add( new UI.Text( 'Radius' ).setWidth( '90px' ) );
  radiusRow.add( radius );

  container.add( radiusRow );

  // widthSegments

  var widthSegmentsRow = new UI.Row();
  var widthSegments = new UI.Integer( parameters.widthSegments ).setRange( 1, Infinity ).onChange( update );

  widthSegmentsRow.add( new UI.Text( 'Width segments' ).setWidth( '90px' ) );
  widthSegmentsRow.add( widthSegments );

  container.add( widthSegmentsRow );

  // heightSegments

  var heightSegmentsRow = new UI.Row();
  var heightSegments = new UI.Integer( parameters.heightSegments ).setRange( 1, Infinity ).onChange( update );

  heightSegmentsRow.add( new UI.Text( 'Height segments' ).setWidth( '90px' ) );
  heightSegmentsRow.add( heightSegments );

  container.add( heightSegmentsRow );

  // phiStart

  var phiStartRow = new UI.Row();
  var phiStart = new UI.Number( parameters.phiStart ).onChange( update );

  phiStartRow.add( new UI.Text( 'Phi start' ).setWidth( '90px' ) );
  phiStartRow.add( phiStart );

  container.add( phiStartRow );

  // phiLength

  var phiLengthRow = new UI.Row();
  var phiLength = new UI.Number( parameters.phiLength ).onChange( update );

  phiLengthRow.add( new UI.Text( 'Phi length' ).setWidth( '90px' ) );
  phiLengthRow.add( phiLength );

  container.add( phiLengthRow );

  // thetaStart

  var thetaStartRow = new UI.Row();
  var thetaStart = new UI.Number( parameters.thetaStart ).onChange( update );

  thetaStartRow.add( new UI.Text( 'Theta start' ).setWidth( '90px' ) );
  thetaStartRow.add( thetaStart );

  container.add( thetaStartRow );

  // thetaLength

  var thetaLengthRow = new UI.Row();
  var thetaLength = new UI.Number( parameters.thetaLength ).onChange( update );

  thetaLengthRow.add( new UI.Text( 'Theta length' ).setWidth( '90px' ) );
  thetaLengthRow.add( thetaLength );

  container.add( thetaLengthRow );


  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radius.getValue(),
      widthSegments.getValue(),
      heightSegments.getValue(),
      phiStart.getValue(),
      phiLength.getValue(),
      thetaStart.getValue(),
      thetaLength.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.SphereBufferGeometry = Sidebar.Geometry.SphereGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.TorusGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radius

  var radiusRow = new UI.Row();
  var radius = new UI.Number( parameters.radius ).onChange( update );

  radiusRow.add( new UI.Text( 'Radius' ).setWidth( '90px' ) );
  radiusRow.add( radius );

  container.add( radiusRow );

  // tube

  var tubeRow = new UI.Row();
  var tube = new UI.Number( parameters.tube ).onChange( update );

  tubeRow.add( new UI.Text( 'Tube' ).setWidth( '90px' ) );
  tubeRow.add( tube );

  container.add( tubeRow );

  // radialSegments

  var radialSegmentsRow = new UI.Row();
  var radialSegments = new UI.Integer( parameters.radialSegments ).setRange( 1, Infinity ).onChange( update );

  radialSegmentsRow.add( new UI.Text( 'Radial segments' ).setWidth( '90px' ) );
  radialSegmentsRow.add( radialSegments );

  container.add( radialSegmentsRow );

  // tubularSegments

  var tubularSegmentsRow = new UI.Row();
  var tubularSegments = new UI.Integer( parameters.tubularSegments ).setRange( 1, Infinity ).onChange( update );

  tubularSegmentsRow.add( new UI.Text( 'Tubular segments' ).setWidth( '90px' ) );
  tubularSegmentsRow.add( tubularSegments );

  container.add( tubularSegmentsRow );

  // arc

  var arcRow = new UI.Row();
  var arc = new UI.Number( parameters.arc ).onChange( update );

  arcRow.add( new UI.Text( 'Arc' ).setWidth( '90px' ) );
  arcRow.add( arc );

  container.add( arcRow );


  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radius.getValue(),
      tube.getValue(),
      radialSegments.getValue(),
      tubularSegments.getValue(),
      arc.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.TorusBufferGeometry = Sidebar.Geometry.TorusGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Geometry.TorusKnotGeometry = function ( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // radius

  var radiusRow = new UI.Row();
  var radius = new UI.Number( parameters.radius ).onChange( update );

  radiusRow.add( new UI.Text( 'Radius' ).setWidth( '90px' ) );
  radiusRow.add( radius );

  container.add( radiusRow );

  // tube

  var tubeRow = new UI.Row();
  var tube = new UI.Number( parameters.tube ).onChange( update );

  tubeRow.add( new UI.Text( 'Tube' ).setWidth( '90px' ) );
  tubeRow.add( tube );

  container.add( tubeRow );

  // tubularSegments

  var tubularSegmentsRow = new UI.Row();
  var tubularSegments = new UI.Integer( parameters.tubularSegments ).setRange( 1, Infinity ).onChange( update );

  tubularSegmentsRow.add( new UI.Text( 'Tubular segments' ).setWidth( '90px' ) );
  tubularSegmentsRow.add( tubularSegments );

  container.add( tubularSegmentsRow );

  // radialSegments

  var radialSegmentsRow = new UI.Row();
  var radialSegments = new UI.Integer( parameters.radialSegments ).setRange( 1, Infinity ).onChange( update );

  radialSegmentsRow.add( new UI.Text( 'Radial segments' ).setWidth( '90px' ) );
  radialSegmentsRow.add( radialSegments );

  container.add( radialSegmentsRow );

  // p

  var pRow = new UI.Row();
  var p = new UI.Number( parameters.p ).onChange( update );

  pRow.add( new UI.Text( 'P' ).setWidth( '90px' ) );
  pRow.add( p );

  container.add( pRow );

  // q

  var qRow = new UI.Row();
  var q = new UI.Number( parameters.q ).onChange( update );

  pRow.add( new UI.Text( 'Q' ).setWidth( '90px' ) );
  pRow.add( q );

  container.add( qRow );


  //

  function update() {

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      radius.getValue(),
      tube.getValue(),
      tubularSegments.getValue(),
      radialSegments.getValue(),
      p.getValue(),
      q.getValue()
    ) ) );

  }

  return container;

};

Sidebar.Geometry.TorusKnotBufferGeometry = Sidebar.Geometry.TorusKnotGeometry;

/**
 * @author Eric Haines / http://erichaines.com/
 *
 * Tessellates the famous Utah teapot database by Martin Newell into triangles.
 *
 * THREE.TeapotBufferGeometry = function ( size, segments, bottom, lid, body, fitLid, blinn )
 *
 * defaults: size = 50, segments = 10, bottom = true, lid = true, body = true,
 *   fitLid = false, blinn = true
 *
 * size is a relative scale: I've scaled the teapot to fit vertically between -1 and 1.
 * Think of it as a "radius".
 * segments - number of line segments to subdivide each patch edge;
 *   1 is possible but gives degenerates, so two is the real minimum.
 * bottom - boolean, if true (default) then the bottom patches are added. Some consider
 *   adding the bottom heresy, so set this to "false" to adhere to the One True Way.
 * lid - to remove the lid and look inside, set to true.
 * body - to remove the body and leave the lid, set this and "bottom" to false.
 * fitLid - the lid is a tad small in the original. This stretches it a bit so you can't
 *   see the teapot's insides through the gap.
 * blinn - Jim Blinn scaled the original data vertically by dividing by about 1.3 to look
 *   nicer. If you want to see the original teapot, similar to the real-world model, set
 *   this to false. True by default.
 *   See http://en.wikipedia.org/wiki/File:Original_Utah_Teapot.jpg for the original
 *   real-world teapot (from http://en.wikipedia.org/wiki/Utah_teapot).
 *
 * Note that the bottom (the last four patches) is not flat - blame Frank Crow, not me.
 *
 * The teapot should normally be rendered as a double sided object, since for some
 * patches both sides can be seen, e.g., the gap around the lid and inside the spout.
 *
 * Segments 'n' determines the number of triangles output.
 *   Total triangles = 32*2*n*n - 8*n    [degenerates at the top and bottom cusps are deleted]
 *
 *   size_factor   # triangles
 *       1          56
 *       2         240
 *       3         552
 *       4         992
 *
 *      10        6320
 *      20       25440
 *      30       57360
 *
 * Code converted from my ancient SPD software, http://tog.acm.org/resources/SPD/
 * Created for the Udacity course "Interactive Rendering", http://bit.ly/ericity
 * Lesson: https://www.udacity.com/course/viewer#!/c-cs291/l-68866048/m-106482448
 * YouTube video on teapot history: https://www.youtube.com/watch?v=DxMfblPzFNc
 *
 * See https://en.wikipedia.org/wiki/Utah_teapot for the history of the teapot
 *
 */
/*global THREE */

THREE.TeapotBufferGeometry = function ( size, segments, bottom, lid, body, fitLid, blinn ) {

  "use strict";

  // 32 * 4 * 4 Bezier spline patches
  var teapotPatches = [
/*rim*/
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
3,16,17,18,7,19,20,21,11,22,23,24,15,25,26,27,
18,28,29,30,21,31,32,33,24,34,35,36,27,37,38,39,
30,40,41,0,33,42,43,4,36,44,45,8,39,46,47,12,
/*body*/
12,13,14,15,48,49,50,51,52,53,54,55,56,57,58,59,
15,25,26,27,51,60,61,62,55,63,64,65,59,66,67,68,
27,37,38,39,62,69,70,71,65,72,73,74,68,75,76,77,
39,46,47,12,71,78,79,48,74,80,81,52,77,82,83,56,
56,57,58,59,84,85,86,87,88,89,90,91,92,93,94,95,
59,66,67,68,87,96,97,98,91,99,100,101,95,102,103,104,
68,75,76,77,98,105,106,107,101,108,109,110,104,111,112,113,
77,82,83,56,107,114,115,84,110,116,117,88,113,118,119,92,
/*handle*/
120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
123,136,137,120,127,138,139,124,131,140,141,128,135,142,143,132,
132,133,134,135,144,145,146,147,148,149,150,151,68,152,153,154,
135,142,143,132,147,155,156,144,151,157,158,148,154,159,160,68,
/*spout*/
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
164,177,178,161,168,179,180,165,172,181,182,169,176,183,184,173,
173,174,175,176,185,186,187,188,189,190,191,192,193,194,195,196,
176,183,184,173,188,197,198,185,192,199,200,189,196,201,202,193,
/*lid*/
203,203,203,203,204,205,206,207,208,208,208,208,209,210,211,212,
203,203,203,203,207,213,214,215,208,208,208,208,212,216,217,218,
203,203,203,203,215,219,220,221,208,208,208,208,218,222,223,224,
203,203,203,203,221,225,226,204,208,208,208,208,224,227,228,209,
209,210,211,212,229,230,231,232,233,234,235,236,237,238,239,240,
212,216,217,218,232,241,242,243,236,244,245,246,240,247,248,249,
218,222,223,224,243,250,251,252,246,253,254,255,249,256,257,258,
224,227,228,209,252,259,260,229,255,261,262,233,258,263,264,237,
/*bottom*/
265,265,265,265,266,267,268,269,270,271,272,273,92,119,118,113,
265,265,265,265,269,274,275,276,273,277,278,279,113,112,111,104,
265,265,265,265,276,280,281,282,279,283,284,285,104,103,102,95,
265,265,265,265,282,286,287,266,285,288,289,270,95,94,93,92
  ] ;

  var teapotVertices = [
1.4,0,2.4,
1.4,-0.784,2.4,
0.784,-1.4,2.4,
0,-1.4,2.4,
1.3375,0,2.53125,
1.3375,-0.749,2.53125,
0.749,-1.3375,2.53125,
0,-1.3375,2.53125,
1.4375,0,2.53125,
1.4375,-0.805,2.53125,
0.805,-1.4375,2.53125,
0,-1.4375,2.53125,
1.5,0,2.4,
1.5,-0.84,2.4,
0.84,-1.5,2.4,
0,-1.5,2.4,
-0.784,-1.4,2.4,
-1.4,-0.784,2.4,
-1.4,0,2.4,
-0.749,-1.3375,2.53125,
-1.3375,-0.749,2.53125,
-1.3375,0,2.53125,
-0.805,-1.4375,2.53125,
-1.4375,-0.805,2.53125,
-1.4375,0,2.53125,
-0.84,-1.5,2.4,
-1.5,-0.84,2.4,
-1.5,0,2.4,
-1.4,0.784,2.4,
-0.784,1.4,2.4,
0,1.4,2.4,
-1.3375,0.749,2.53125,
-0.749,1.3375,2.53125,
0,1.3375,2.53125,
-1.4375,0.805,2.53125,
-0.805,1.4375,2.53125,
0,1.4375,2.53125,
-1.5,0.84,2.4,
-0.84,1.5,2.4,
0,1.5,2.4,
0.784,1.4,2.4,
1.4,0.784,2.4,
0.749,1.3375,2.53125,
1.3375,0.749,2.53125,
0.805,1.4375,2.53125,
1.4375,0.805,2.53125,
0.84,1.5,2.4,
1.5,0.84,2.4,
1.75,0,1.875,
1.75,-0.98,1.875,
0.98,-1.75,1.875,
0,-1.75,1.875,
2,0,1.35,
2,-1.12,1.35,
1.12,-2,1.35,
0,-2,1.35,
2,0,0.9,
2,-1.12,0.9,
1.12,-2,0.9,
0,-2,0.9,
-0.98,-1.75,1.875,
-1.75,-0.98,1.875,
-1.75,0,1.875,
-1.12,-2,1.35,
-2,-1.12,1.35,
-2,0,1.35,
-1.12,-2,0.9,
-2,-1.12,0.9,
-2,0,0.9,
-1.75,0.98,1.875,
-0.98,1.75,1.875,
0,1.75,1.875,
-2,1.12,1.35,
-1.12,2,1.35,
0,2,1.35,
-2,1.12,0.9,
-1.12,2,0.9,
0,2,0.9,
0.98,1.75,1.875,
1.75,0.98,1.875,
1.12,2,1.35,
2,1.12,1.35,
1.12,2,0.9,
2,1.12,0.9,
2,0,0.45,
2,-1.12,0.45,
1.12,-2,0.45,
0,-2,0.45,
1.5,0,0.225,
1.5,-0.84,0.225,
0.84,-1.5,0.225,
0,-1.5,0.225,
1.5,0,0.15,
1.5,-0.84,0.15,
0.84,-1.5,0.15,
0,-1.5,0.15,
-1.12,-2,0.45,
-2,-1.12,0.45,
-2,0,0.45,
-0.84,-1.5,0.225,
-1.5,-0.84,0.225,
-1.5,0,0.225,
-0.84,-1.5,0.15,
-1.5,-0.84,0.15,
-1.5,0,0.15,
-2,1.12,0.45,
-1.12,2,0.45,
0,2,0.45,
-1.5,0.84,0.225,
-0.84,1.5,0.225,
0,1.5,0.225,
-1.5,0.84,0.15,
-0.84,1.5,0.15,
0,1.5,0.15,
1.12,2,0.45,
2,1.12,0.45,
0.84,1.5,0.225,
1.5,0.84,0.225,
0.84,1.5,0.15,
1.5,0.84,0.15,
-1.6,0,2.025,
-1.6,-0.3,2.025,
-1.5,-0.3,2.25,
-1.5,0,2.25,
-2.3,0,2.025,
-2.3,-0.3,2.025,
-2.5,-0.3,2.25,
-2.5,0,2.25,
-2.7,0,2.025,
-2.7,-0.3,2.025,
-3,-0.3,2.25,
-3,0,2.25,
-2.7,0,1.8,
-2.7,-0.3,1.8,
-3,-0.3,1.8,
-3,0,1.8,
-1.5,0.3,2.25,
-1.6,0.3,2.025,
-2.5,0.3,2.25,
-2.3,0.3,2.025,
-3,0.3,2.25,
-2.7,0.3,2.025,
-3,0.3,1.8,
-2.7,0.3,1.8,
-2.7,0,1.575,
-2.7,-0.3,1.575,
-3,-0.3,1.35,
-3,0,1.35,
-2.5,0,1.125,
-2.5,-0.3,1.125,
-2.65,-0.3,0.9375,
-2.65,0,0.9375,
-2,-0.3,0.9,
-1.9,-0.3,0.6,
-1.9,0,0.6,
-3,0.3,1.35,
-2.7,0.3,1.575,
-2.65,0.3,0.9375,
-2.5,0.3,1.125,
-1.9,0.3,0.6,
-2,0.3,0.9,
1.7,0,1.425,
1.7,-0.66,1.425,
1.7,-0.66,0.6,
1.7,0,0.6,
2.6,0,1.425,
2.6,-0.66,1.425,
3.1,-0.66,0.825,
3.1,0,0.825,
2.3,0,2.1,
2.3,-0.25,2.1,
2.4,-0.25,2.025,
2.4,0,2.025,
2.7,0,2.4,
2.7,-0.25,2.4,
3.3,-0.25,2.4,
3.3,0,2.4,
1.7,0.66,0.6,
1.7,0.66,1.425,
3.1,0.66,0.825,
2.6,0.66,1.425,
2.4,0.25,2.025,
2.3,0.25,2.1,
3.3,0.25,2.4,
2.7,0.25,2.4,
2.8,0,2.475,
2.8,-0.25,2.475,
3.525,-0.25,2.49375,
3.525,0,2.49375,
2.9,0,2.475,
2.9,-0.15,2.475,
3.45,-0.15,2.5125,
3.45,0,2.5125,
2.8,0,2.4,
2.8,-0.15,2.4,
3.2,-0.15,2.4,
3.2,0,2.4,
3.525,0.25,2.49375,
2.8,0.25,2.475,
3.45,0.15,2.5125,
2.9,0.15,2.475,
3.2,0.15,2.4,
2.8,0.15,2.4,
0,0,3.15,
0.8,0,3.15,
0.8,-0.45,3.15,
0.45,-0.8,3.15,
0,-0.8,3.15,
0,0,2.85,
0.2,0,2.7,
0.2,-0.112,2.7,
0.112,-0.2,2.7,
0,-0.2,2.7,
-0.45,-0.8,3.15,
-0.8,-0.45,3.15,
-0.8,0,3.15,
-0.112,-0.2,2.7,
-0.2,-0.112,2.7,
-0.2,0,2.7,
-0.8,0.45,3.15,
-0.45,0.8,3.15,
0,0.8,3.15,
-0.2,0.112,2.7,
-0.112,0.2,2.7,
0,0.2,2.7,
0.45,0.8,3.15,
0.8,0.45,3.15,
0.112,0.2,2.7,
0.2,0.112,2.7,
0.4,0,2.55,
0.4,-0.224,2.55,
0.224,-0.4,2.55,
0,-0.4,2.55,
1.3,0,2.55,
1.3,-0.728,2.55,
0.728,-1.3,2.55,
0,-1.3,2.55,
1.3,0,2.4,
1.3,-0.728,2.4,
0.728,-1.3,2.4,
0,-1.3,2.4,
-0.224,-0.4,2.55,
-0.4,-0.224,2.55,
-0.4,0,2.55,
-0.728,-1.3,2.55,
-1.3,-0.728,2.55,
-1.3,0,2.55,
-0.728,-1.3,2.4,
-1.3,-0.728,2.4,
-1.3,0,2.4,
-0.4,0.224,2.55,
-0.224,0.4,2.55,
0,0.4,2.55,
-1.3,0.728,2.55,
-0.728,1.3,2.55,
0,1.3,2.55,
-1.3,0.728,2.4,
-0.728,1.3,2.4,
0,1.3,2.4,
0.224,0.4,2.55,
0.4,0.224,2.55,
0.728,1.3,2.55,
1.3,0.728,2.55,
0.728,1.3,2.4,
1.3,0.728,2.4,
0,0,0,
1.425,0,0,
1.425,0.798,0,
0.798,1.425,0,
0,1.425,0,
1.5,0,0.075,
1.5,0.84,0.075,
0.84,1.5,0.075,
0,1.5,0.075,
-0.798,1.425,0,
-1.425,0.798,0,
-1.425,0,0,
-0.84,1.5,0.075,
-1.5,0.84,0.075,
-1.5,0,0.075,
-1.425,-0.798,0,
-0.798,-1.425,0,
0,-1.425,0,
-1.5,-0.84,0.075,
-0.84,-1.5,0.075,
0,-1.5,0.075,
0.798,-1.425,0,
1.425,-0.798,0,
0.84,-1.5,0.075,
1.5,-0.84,0.075
  ] ;

  THREE.BufferGeometry.call( this );

  this.type = 'TeapotBufferGeometry';

  this.parameters = {
    size: size,
    segments: segments,
    bottom: bottom,
    lid: lid,
    body: body,
    fitLid: fitLid,
    blinn: blinn
  };

  size = size || 50;

  // number of segments per patch
  segments = segments !== undefined ? Math.max( 2, Math.floor( segments ) || 10 ) : 10;

  // which parts should be visible
  bottom = bottom === undefined ? true : bottom;
  lid = lid === undefined ? true : lid;
  body = body === undefined ? true : body;

  // Should the lid be snug? It's not traditional, but we make it snug by default
  fitLid = fitLid === undefined ? true : fitLid;

  // Jim Blinn scaled the teapot down in size by about 1.3 for
  // some rendering tests. He liked the new proportions that he kept
  // the data in this form. The model was distributed with these new
  // proportions and became the norm. Trivia: comparing images of the
  // real teapot and the computer model, the ratio for the bowl of the
  // real teapot is more like 1.25, but since 1.3 is the traditional
  // value given, we use it here.
  var blinnScale = 1.3;
  blinn = blinn === undefined ? true : blinn;

  // scale the size to be the real scaling factor
  var maxHeight = 3.15 * ( blinn ? 1 : blinnScale );

  var maxHeight2 = maxHeight / 2;
  var trueSize = size / maxHeight2;

  // Number of elements depends on what is needed. Subtract degenerate
  // triangles at tip of bottom and lid out in advance.
  var numTriangles = bottom ? ( 8 * segments - 4 ) * segments : 0;
  numTriangles += lid ? ( 16 * segments - 4 ) * segments : 0;
  numTriangles += body ? 40 * segments * segments : 0;

  var indices = new Uint32Array( numTriangles * 3 );

  var numVertices = bottom ? 4 : 0;
  numVertices += lid ? 8 : 0;
  numVertices += body ? 20 : 0;
  numVertices *= ( segments + 1 ) * ( segments + 1 );

  var vertices = new Float32Array( numVertices * 3 );
  var normals = new Float32Array( numVertices * 3 );
  var uvs = new Float32Array( numVertices * 2 );

  // Bezier form
  var ms = new THREE.Matrix4();
  ms.set( -1.0,  3.0, -3.0,  1.0,
       3.0, -6.0,  3.0,  0.0,
      -3.0,  3.0,  0.0,  0.0,
       1.0,  0.0,  0.0,  0.0 ) ;

  var g = [];
  var i, r, c;

  var sp = [];
  var tp = [];
  var dsp = [];
  var dtp = [];

  // M * G * M matrix, sort of see
  // http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html
  var mgm = [];

  var vert = [];
  var sdir = [];
  var tdir = [];

  var norm = new THREE.Vector3();

  var tcoord;

  var sstep, tstep;
  var vertPerRow;

  var s, t, sval, tval, p;
  var dsval = 0;
  var dtval = 0;

  var normOut = new THREE.Vector3();
  var v1, v2, v3, v4;

  var gmx = new THREE.Matrix4();
  var tmtx = new THREE.Matrix4();

  var vsp = new THREE.Vector4();
  var vtp = new THREE.Vector4();
  var vdsp = new THREE.Vector4();
  var vdtp = new THREE.Vector4();

  var vsdir = new THREE.Vector3();
  var vtdir = new THREE.Vector3();

  var mst = ms.clone();
  mst.transpose();

  // internal function: test if triangle has any matching vertices;
  // if so, don't save triangle, since it won't display anything.
  var notDegenerate = function ( vtx1, vtx2, vtx3 ) {

    // if any vertex matches, return false
    return ! ( ( ( vertices[ vtx1 * 3 ]     === vertices[ vtx2 * 3 ] ) &&
           ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx2 * 3 + 1 ] ) &&
           ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx2 * 3 + 2 ] ) ) ||
           ( ( vertices[ vtx1 * 3 ]     === vertices[ vtx3 * 3 ] ) &&
           ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&
           ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) ||
           ( ( vertices[ vtx2 * 3 ]     === vertices[ vtx3 * 3 ] ) &&
           ( vertices[ vtx2 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&
           ( vertices[ vtx2 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) );

  };


  for ( i = 0; i < 3; i ++ )
  {

    mgm[ i ] = new THREE.Matrix4();

  }

  var minPatches = body ? 0 : 20;
  var maxPatches = bottom ? 32 : 28;

  vertPerRow = segments + 1;

  var surfCount = 0;

  var vertCount = 0;
  var normCount = 0;
  var uvCount = 0;

  var indexCount = 0;

  for ( var surf = minPatches ; surf < maxPatches ; surf ++ ) {

    // lid is in the middle of the data, patches 20-27,
    // so ignore it for this part of the loop if the lid is not desired
    if ( lid || ( surf < 20 || surf >= 28 ) ) {

      // get M * G * M matrix for x,y,z
      for ( i = 0 ; i < 3 ; i ++ ) {

        // get control patches
        for ( r = 0 ; r < 4 ; r ++ ) {

          for ( c = 0 ; c < 4 ; c ++ ) {

            // transposed
            g[ c * 4 + r ] = teapotVertices[ teapotPatches[ surf * 16 + r * 4 + c ] * 3 + i ] ;

            // is the lid to be made larger, and is this a point on the lid
            // that is X or Y?
            if ( fitLid && ( surf >= 20 && surf < 28 ) && ( i !== 2 ) ) {

              // increase XY size by 7.7%, found empirically. I don't
              // increase Z so that the teapot will continue to fit in the
              // space -1 to 1 for Y (Y is up for the final model).
              g[ c * 4 + r ] *= 1.077;

            }

            // Blinn "fixed" the teapot by dividing Z by blinnScale, and that's the
            // data we now use. The original teapot is taller. Fix it:
            if ( ! blinn && ( i === 2 ) ) {

              g[ c * 4 + r ] *= blinnScale;

            }

          }

        }

        gmx.set( g[ 0 ], g[ 1 ], g[ 2 ], g[ 3 ], g[ 4 ], g[ 5 ], g[ 6 ], g[ 7 ], g[ 8 ], g[ 9 ], g[ 10 ], g[ 11 ], g[ 12 ], g[ 13 ], g[ 14 ], g[ 15 ] );

        tmtx.multiplyMatrices( gmx, ms );
        mgm[ i ].multiplyMatrices( mst, tmtx );

      }

      // step along, get points, and output
      for ( sstep = 0 ; sstep <= segments ; sstep ++ ) {

        s = sstep / segments;

        for ( tstep = 0 ; tstep <= segments ; tstep ++ ) {

          t = tstep / segments;

          // point from basis
          // get power vectors and their derivatives
          for ( p = 4, sval = tval = 1.0 ; p -- ; ) {

            sp[ p ] = sval ;
            tp[ p ] = tval ;
            sval *= s ;
            tval *= t ;

            if ( p === 3 ) {

              dsp[ p ] = dtp[ p ] = 0.0 ;
              dsval = dtval = 1.0 ;

            } else {

              dsp[ p ] = dsval * ( 3 - p ) ;
              dtp[ p ] = dtval * ( 3 - p ) ;
              dsval *= s ;
              dtval *= t ;

            }

          }

          vsp.fromArray( sp );
          vtp.fromArray( tp );
          vdsp.fromArray( dsp );
          vdtp.fromArray( dtp );

          // do for x,y,z
          for ( i = 0 ; i < 3 ; i ++ ) {

            // multiply power vectors times matrix to get value
            tcoord = vsp.clone();
            tcoord.applyMatrix4( mgm[ i ] );
            vert[ i ] = tcoord.dot( vtp );

            // get s and t tangent vectors
            tcoord = vdsp.clone();
            tcoord.applyMatrix4( mgm[ i ] );
            sdir[ i ] = tcoord.dot( vtp ) ;

            tcoord = vsp.clone();
            tcoord.applyMatrix4( mgm[ i ] );
            tdir[ i ] = tcoord.dot( vdtp ) ;

          }

          // find normal
          vsdir.fromArray( sdir );
          vtdir.fromArray( tdir );
          norm.crossVectors( vtdir, vsdir );
          norm.normalize();

          // if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number
          if ( vert[ 0 ] === 0 && vert[ 1 ] === 0 )
          {

            // if above the middle of the teapot, normal points up, else down
            normOut.set( 0, vert[ 2 ] > maxHeight2 ? 1 : - 1, 0 );

          }
          else
          {

            // standard output: rotate on X axis
            normOut.set( norm.x, norm.z, - norm.y );

          }

          // store it all
          vertices[ vertCount ++ ] = trueSize * vert[ 0 ];
          vertices[ vertCount ++ ] = trueSize * ( vert[ 2 ] - maxHeight2 );
          vertices[ vertCount ++ ] = - trueSize * vert[ 1 ];

          normals[ normCount ++ ] = normOut.x;
          normals[ normCount ++ ] = normOut.y;
          normals[ normCount ++ ] = normOut.z;

          uvs[ uvCount ++ ] = 1 - t;
          uvs[ uvCount ++ ] = 1 - s;

        }

      }

      // save the faces
      for ( sstep = 0 ; sstep < segments ; sstep ++ ) {

        for ( tstep = 0 ; tstep < segments ; tstep ++ ) {

          v1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;
          v2 = v1 + 1;
          v3 = v2 + vertPerRow;
          v4 = v1 + vertPerRow;

          // Normals and UVs cannot be shared. Without clone(), you can see the consequences
          // of sharing if you call geometry.applyMatrix( matrix ).
          if ( notDegenerate ( v1, v2, v3 ) ) {

            indices[ indexCount ++ ] = v1;
            indices[ indexCount ++ ] = v2;
            indices[ indexCount ++ ] = v3;

          }
          if ( notDegenerate ( v1, v3, v4 ) ) {

            indices[ indexCount ++ ] = v1;
            indices[ indexCount ++ ] = v3;
            indices[ indexCount ++ ] = v4;

          }

        }

      }

      // increment only if a surface was used
      surfCount ++;

    }

  }

  this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  this.computeBoundingSphere();

};


THREE.TeapotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.TeapotBufferGeometry.prototype.constructor = THREE.TeapotBufferGeometry;

THREE.TeapotBufferGeometry.prototype.clone = function () {

  var bufferGeometry = new THREE.TeapotBufferGeometry(
    this.parameters.size,
    this.parameters.segments,
    this.parameters.bottom,
    this.parameters.lid,
    this.parameters.body,
    this.parameters.fitLid,
    this.parameters.blinn
  );

  return bufferGeometry;

};

/**
 * @author tschw
 */

Sidebar.Geometry.TeapotBufferGeometry = function ( signals, object ) {

  var container = new UI.Row();

  var parameters = object.geometry.parameters;

  // size

  var sizeRow = new UI.Row();
  var size = new UI.Number( parameters.size ).onChange( update );

  sizeRow.add( new UI.Text( 'Size' ).setWidth( '90px' ) );
  sizeRow.add( size );

  container.add( sizeRow );

  // segments

  var segmentsRow = new UI.Row();
  var segments = new UI.Integer( parameters.segments ).setRange( 1, Infinity ).onChange( update );

  segmentsRow.add( new UI.Text( 'Segments' ).setWidth( '90px' ) );
  segmentsRow.add( segments );

  container.add( segmentsRow );

  // bottom

  var bottomRow = new UI.Row();
  var bottom = new UI.Checkbox( parameters.bottom ).onChange( update );

  bottomRow.add( new UI.Text( 'Bottom' ).setWidth( '90px' ) );
  bottomRow.add( bottom );

  container.add( bottomRow );

  // lid

  var lidRow = new UI.Row();
  var lid = new UI.Checkbox( parameters.lid ).onChange( update );

  lidRow.add( new UI.Text( 'Lid' ).setWidth( '90px' ) );
  lidRow.add( lid );

  container.add( lidRow );

  // body

  var bodyRow = new UI.Row();
  var body = new UI.Checkbox( parameters.body ).onChange( update );

  bodyRow.add( new UI.Text( 'Body' ).setWidth( '90px' ) );
  bodyRow.add( body );

  container.add( bodyRow );

  // fitted lid

  var fitLidRow = new UI.Row();
  var fitLid = new UI.Checkbox( parameters.fitLid ).onChange( update );

  fitLidRow.add( new UI.Text( 'Fitted Lid' ).setWidth( '90px' ) );
  fitLidRow.add( fitLid );

  container.add( fitLidRow );

  // blinn-sized

  var blinnRow = new UI.Row();
  var blinn = new UI.Checkbox( parameters.blinn ).onChange( update );

  blinnRow.add( new UI.Text( 'Blinn-scaled' ).setWidth( '90px' ) );
  blinnRow.add( blinn );

  container.add( blinnRow );

  function update() {

    object.geometry.dispose();

    object.geometry = new THREE.TeapotBufferGeometry(
      size.getValue(),
      segments.getValue(),
      bottom.getValue(),
      lid.getValue(),
      body.getValue(),
      fitLid.getValue(),
      blinn.getValue()
    );

    object.geometry.computeBoundingSphere();

    signals.geometryChanged.dispatch( object );

  }

  return container;

};

/**
 * @author rfm1201
 */

Sidebar.Geometry.LatheGeometry = function( editor, object ) {

  var signals = editor.signals;

  var container = new UI.Row();

  var geometry = object.geometry;
  var parameters = geometry.parameters;

  // segments

  var segmentsRow = new UI.Row();
  var segments = new UI.Integer( parameters.segments ).onChange( update );

  segmentsRow.add( new UI.Text( 'Segments' ).setWidth( '90px' ) );
  segmentsRow.add( segments );

  container.add( segmentsRow );

  // phiStart

  var phiStartRow = new UI.Row();
  var phiStart = new UI.Number( parameters.phiStart * 180 / Math.PI ).onChange( update );

  phiStartRow.add( new UI.Text( 'Phi start ()' ).setWidth( '90px' ) );
  phiStartRow.add( phiStart );

  container.add( phiStartRow );

  // phiLength

  var phiLengthRow = new UI.Row();
  var phiLength = new UI.Number( parameters.phiLength * 180 / Math.PI ).onChange( update );

  phiLengthRow.add( new UI.Text( 'Phi length ()' ).setWidth( '90px' ) );
  phiLengthRow.add( phiLength );

  container.add( phiLengthRow );

  // points

  var lastPointIdx = 0;
  var pointsUI = [];

  var pointsRow = new UI.Row();
  pointsRow.add( new UI.Text( 'Points' ).setWidth( '90px' ) );

  var points = new UI.Span().setDisplay( 'inline-block' );
  pointsRow.add( points );

  var pointsList = new UI.Div();
  points.add( pointsList );

  for ( var i = 0; i < parameters.points.length; i ++ ) {

    var point = parameters.points[ i ];
    pointsList.add( createPointRow( point.x, point.y ) );

  }

  var addPointButton = new UI.Button( '+' ).onClick( function() {

    if( pointsUI.length === 0 ){

      pointsList.add( createPointRow( 0, 0 ) );

    } else {

      var point = pointsUI[ pointsUI.length - 1 ];

      pointsList.add( createPointRow( point.x.getValue(), point.y.getValue() ) );

    }

    update();

  } );
  points.add( addPointButton );

  container.add( pointsRow );

  //

  function createPointRow( x, y ) {

    var pointRow = new UI.Div();
    var lbl = new UI.Text( lastPointIdx + 1 ).setWidth( '20px' );
    var txtX = new UI.Number( x ).setRange( 0, Infinity ).setWidth( '40px' ).onChange( update );
    var txtY = new UI.Number( y ).setWidth( '40px' ).onChange( update );
    var idx = lastPointIdx;
    var btn = new UI.Button( '-' ).onClick( function() {

      deletePointRow( idx );

    } );

    pointsUI.push( { row: pointRow, lbl: lbl, x: txtX, y: txtY } );
    lastPointIdx ++;
    pointRow.add( lbl, txtX, txtY, btn );

    return pointRow;

  }

  function deletePointRow( idx ) {

    if ( ! pointsUI[ idx ] ) return;

    pointsList.remove( pointsUI[ idx ].row );
    pointsUI[ idx ] = null;

    update();

  }

  function update() {

    var points = [];
    var count = 0;

    for ( var i = 0; i < pointsUI.length; i ++ ) {

      var pointUI = pointsUI[ i ];

      if ( ! pointUI ) continue;

      points.push( new THREE.Vector2( pointUI.x.getValue(), pointUI.y.getValue() ) );
      count ++;
      pointUI.lbl.setValue( count );

    }

    editor.execute( new SetGeometryCommand( object, new THREE[ geometry.type ](
      points,
      segments.getValue(),
      phiStart.getValue() / 180 * Math.PI,
      phiLength.getValue() / 180 * Math.PI
    ) ) );

  }

  return container;

};

Sidebar.Geometry.LatheBufferGeometry = Sidebar.Geometry.LatheGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Material = function ( editor ) {

  var signals = editor.signals;

  var currentObject;

  var container = new UI.Panel();
  container.setBorderTop( '0' );
  container.setPaddingTop( '20px' );

  // wireframe

  var materialWireframeRow = new UI.Row();
  var materialWireframe = new UI.Checkbox( false ).onChange( update );

  materialWireframeRow.add( new UI.Text( 'Wireframe' ).setWidth( '90px' ) );
  materialWireframeRow.add( materialWireframe );

  container.add( materialWireframeRow );

  //
  
  

  function update() {
    
    var currentObject = editor.selected;
    
    if (currentObject) {
      
      //if ( (editor.getObjectMaterial((currentObject.children)[0])).wireframe !== undefined && (editor.getObjectMaterial((currentObject.children)[0])).wireframe !== materialWireframe.getValue() ) {

      //editor.execute( new SetMaterialValueCommand( (currentObject.children)[3], 'wireframe', materialWireframe.getValue()) );
      //editor.execute( new SetMaterialValueCommand( (currentObject.children)[7], 'wireframe', materialWireframe.getValue()) );
      
      var cmds = [];
      var objects = currentObject.children;
      var object

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        object = objects[ i ];
        
        //var material = editor.getObjectMaterial(object)
        
        //if ( material.wireframe !== undefined && material.wireframe !== materialWireframe.getValue() ) {
          
        cmds.push(new SetMaterialValueCommand( object, 'wireframe', materialWireframe.getValue()));

        //editor.execute( new SetMaterialValueCommand( object, 'wireframe', materialWireframe.getValue()) );

        //}

      }

      editor.execute( new MultiCmdsCommand(cmds), 'wireframe' );

      //}
      refreshUI();

    }

    if ( textureWarning ) {

      console.warn( "Can't set texture, model doesn't have texture coordinates" );

    }

  }


  function refreshUI( resetTextureSelectors ) {

    if ( ! currentObject ) return;

    var material = currentObject.material;

    material = editor.getObjectMaterial( currentObject );

    if ( material.wireframe !== undefined ) {

      materialWireframe.setValue( material.wireframe );

    }
  }

  // events

  signals.objectSelected.add( function ( object ) {

      var objectChanged = object;

      currentObject = object;
      refreshUI( objectChanged );
      container.setDisplay( '' );

  } );

  signals.materialChanged.add( function () {

    refreshUI();

  } );

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Sidebar.Animation = function ( editor ) {

  var signals = editor.signals;

  var options = {};
  var possibleAnimations = {};

  var container = new UI.Panel();
  container.setDisplay( 'none' );

  container.add( new UI.Text( 'Animation' ).setTextTransform( 'uppercase' ) );
  container.add( new UI.Break() );
  container.add( new UI.Break() );

  var animationsRow = new UI.Row();
  container.add( animationsRow );

  return container;

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

Sidebar.History = function ( editor ) {

  var signals = editor.signals;

  var config = editor.config;

  var history = editor.history;

  var container = new UI.Panel();

  container.add( new UI.Text( 'HISTORY' ) );
    container.add( new UI.Break() );
    container.add( new UI.Break() );

  //
  
  /*
  var persistent = new UI.THREE.Boolean( config.getKey( 'settings/history' ), 'persistent' );
  persistent.setPosition( 'absolute' ).setRight( '8px' );
  persistent.onChange( function () {

    var value = this.getValue();

    config.setKey( 'settings/history', value );

    if ( value ) {

      alert( 'The history will be preserved across sessions.\nThis can have an impact on performance when working with textures.' );

      var lastUndoCmd = history.undos[ history.undos.length - 1 ];
      var lastUndoId = ( lastUndoCmd !== undefined ) ? lastUndoCmd.id : 0;
      editor.history.enableSerialization( lastUndoId );

    } else {

      signals.historyChanged.dispatch();

    }

  } );
  container.add( persistent );
  
  */
  
  var ignoreObjectSelectedSignal = false;

  var outliner = new UI.Outliner( editor );
  outliner.onChange( function () {

    ignoreObjectSelectedSignal = true;

    editor.history.goToState( parseInt( outliner.getValue() ) );

    ignoreObjectSelectedSignal = false;

  } );
  container.add( outliner );

  //

  var refreshUI = function () {

    var options = [];
    var enumerator = 1;

    function buildOption( object ) {

      var option = document.createElement( 'div' );
      option.value = object.id;

      return option;

    }

    ( function addObjects( objects ) {

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        var object = objects[ i ];

        var option = buildOption( object );
        option.innerHTML = '&nbsp;' + object.name;

        options.push( option );

      }

    } )( history.undos );


    ( function addObjects( objects, pad ) {

      for ( var i = objects.length - 1; i >= 0; i -- ) {

        var object = objects[ i ];

        var option = buildOption( object );
        option.innerHTML = '&nbsp;' + object.name;
        option.style.opacity = 0.3;

        options.push( option );

      }

    } )( history.redos, '&nbsp;' );

    outliner.setOptions( options );

  };

  refreshUI();

  // events

  signals.editorCleared.add( refreshUI );

  signals.historyChanged.add( refreshUI );
  signals.historyChanged.add( function ( cmd ) {

    outliner.setValue( cmd !== undefined ? cmd.id : null );

  } );


  return container;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Toolbar = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setId( 'toolbar' );

  var buttons = new UI.Panel();
  container.add( buttons );

  // translate / rotate / scale

  var translate = new UI.Button( 'translate' );
  translate.dom.title = 'W';
  translate.dom.className = 'Button selected';
  translate.onClick( function () {

    signals.transformModeChanged.dispatch( 'translate' );

  } );
  buttons.add( translate );

  var rotate = new UI.Button( 'rotate' );
  rotate.dom.title = 'E';
  rotate.onClick( function () {

    signals.transformModeChanged.dispatch( 'rotate' );

  } );
  buttons.add( rotate );

  var scale = new UI.Button( 'scale' );
  scale.dom.title = 'R';
  scale.onClick( function () {

    signals.transformModeChanged.dispatch( 'scale' );

  } );
  buttons.add( scale );

  signals.transformModeChanged.add( function ( mode ) {

    translate.dom.classList.remove( 'selected' );
    rotate.dom.classList.remove( 'selected' );
    scale.dom.classList.remove( 'selected' );

    switch ( mode ) {

      case 'translate': translate.dom.classList.add( 'selected' ); break;
      case 'rotate': rotate.dom.classList.add( 'selected' ); break;
      case 'scale': scale.dom.classList.add( 'selected' ); break;

    }

  } );

  // grid

  var grid = new UI.Number( 25 ).setWidth( '40px' ).onChange( update );
  buttons.add( new UI.Text( 'grid: ' ) );
  buttons.add( grid );

  var snap = new UI.THREE.Boolean( false, 'snap' ).onChange( update );
  buttons.add( snap );

  var local = new UI.THREE.Boolean( false, 'local' ).onChange( update );
  buttons.add( local );

  var showGrid = new UI.THREE.Boolean( true, 'show' ).onChange( update );
  buttons.add( showGrid );

  function update() {

    signals.snapChanged.dispatch( snap.getValue() === true ? grid.getValue() : null );
    signals.spaceChanged.dispatch( local.getValue() === true ? "local" : "world" );
    signals.showGridChanged.dispatch( showGrid.getValue() );

  }

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Viewport = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setId( 'viewport' );
  container.setPosition( 'absolute' );

  container.add( new Viewport.Info( editor ) );

  //

  var renderer = null;

  var camera = editor.camera;
  var scene = editor.scene;
  var sceneHelpers = editor.sceneHelpers;

  var objects = [];

  // helpers

  var grid = new THREE.GridHelper( 60, 60 );
  sceneHelpers.add( grid );

  //

  var box = new THREE.Box3();

  var selectionBox = new THREE.BoxHelper();
  selectionBox.material.depthTest = false;
  selectionBox.material.transparent = true;
  selectionBox.visible = false;
  sceneHelpers.add( selectionBox );

  var objectPositionOnDown = null;
  var objectRotationOnDown = null;
  var objectScaleOnDown = null;

  var transformControls = new THREE.TransformControls( camera, container.dom );
  transformControls.addEventListener( 'change', function () {

    var object = transformControls.object;

    if ( object !== undefined ) {

      selectionBox.setFromObject( object );

      if ( editor.helpers[ object.id ] !== undefined ) {

        editor.helpers[ object.id ].update();

      }

      signals.refreshSidebarObject3D.dispatch( object );

    }

    render();

  } );
  transformControls.addEventListener( 'mouseDown', function () {

    var object = transformControls.object;

    objectPositionOnDown = object.position.clone();
    objectRotationOnDown = object.rotation.clone();
    objectScaleOnDown = object.scale.clone();

    controls.enabled = false;

  } );
  transformControls.addEventListener( 'mouseUp', function () {

    var object = transformControls.object;

    if ( object !== undefined ) {

      switch ( transformControls.getMode() ) {

        case 'translate':

          if ( ! objectPositionOnDown.equals( object.position ) ) {

            editor.execute( new SetPositionCommand( object, object.position, objectPositionOnDown ) );

          }

          break;

        case 'rotate':

          if ( ! objectRotationOnDown.equals( object.rotation ) ) {

            editor.execute( new SetRotationCommand( object, object.rotation, objectRotationOnDown ) );

          }

          break;

        case 'scale':

          if ( ! objectScaleOnDown.equals( object.scale ) ) {

            editor.execute( new SetScaleCommand( object, object.scale, objectScaleOnDown ) );

          }

          break;

      }

    }

    controls.enabled = true;

  } );

  sceneHelpers.add( transformControls );

  // object picking

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  // events

  function getIntersects( point, objects ) {

    mouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );

    raycaster.setFromCamera( mouse, camera );

    return raycaster.intersectObjects( objects );

  }

  var onDownPosition = new THREE.Vector2();
  var onUpPosition = new THREE.Vector2();
  var onDoubleClickPosition = new THREE.Vector2();

  function getMousePosition( dom, x, y ) {

    var rect = dom.getBoundingClientRect();
    return [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];

  }

  function handleClick() {

    if ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {

      var intersects = getIntersects( onUpPosition, objects );

      if ( editor.getAntennaSnapping() ) {

        if (intersects.length>0) {
          var right_wing = editor.getModel()[0];
                var left_wing = editor.getModel()[1];
          var radius = ( right_wing - left_wing ) / 180;      // create sphere object according to model size
                var widthSegments = 32;
                var heightSegments = 16;
                var phiStart = 0;
                var phiLength = Math.PI * 2;
                var thetaStart = 0;
                var thetaLength = Math.PI;

          var localPoint = intersects[0].point;
          var geometrySphere = new THREE.SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );
                var materialAntenna = new THREE.MeshBasicMaterial( {color: 0xffffff, vertexColors: THREE.FaceColors} );

                for ( var i = 0; i < geometrySphere.faces.length; i++ ){
                    var face = geometrySphere.faces[i];
                    if ( i < 96 ) {
                        face.color.setRGB( 0, 0, 256 );
                    }
                    else {
                      face.color.setRGB( 256, 0, 0 );
              }
                }

                var geo = new THREE.BufferGeometry().fromGeometry(geometrySphere);
                var mesh = new THREE.Mesh( geo, materialAntenna );
                mesh.name = 'Antenna';

                editor.execute( new SetPositionCommand( mesh, new THREE.Vector3( localPoint.x, localPoint.y, localPoint.z ) ) );     // move object to desired coordinates
                editor.execute( new AddObjectCommand( mesh ) );

        }
      } else {

        if ( intersects.length > 0 ) {

          var object = intersects[ 0 ].object;

          if ( object.userData.object !== undefined ) {

          // helper

            editor.select( object.userData.object );

          } else {

            editor.select( object );

          }

        } else {

          editor.select( null );

        }
      }

      render();

    }

  }

  function onMouseDown( event ) {

    event.preventDefault();

    var array = getMousePosition( container.dom, event.clientX, event.clientY );
    onDownPosition.fromArray( array );

    document.addEventListener( 'mouseup', onMouseUp, false );

  }

  function onMouseUp( event ) {

    var array = getMousePosition( container.dom, event.clientX, event.clientY );
    onUpPosition.fromArray( array );

    handleClick();

    document.removeEventListener( 'mouseup', onMouseUp, false );

  }

  function onTouchStart( event ) {

    var touch = event.changedTouches[ 0 ];

    var array = getMousePosition( container.dom, touch.clientX, touch.clientY );
    onDownPosition.fromArray( array );

    document.addEventListener( 'touchend', onTouchEnd, false );

  }

  function onTouchEnd( event ) {

    var touch = event.changedTouches[ 0 ];

    var array = getMousePosition( container.dom, touch.clientX, touch.clientY );
    onUpPosition.fromArray( array );

    handleClick();

    document.removeEventListener( 'touchend', onTouchEnd, false );

  }

  function onDoubleClick( event ) {

    var array = getMousePosition( container.dom, event.clientX, event.clientY );
    onDoubleClickPosition.fromArray( array );

    var intersects = getIntersects( onDoubleClickPosition, objects );

    if ( intersects.length > 0 ) {

      var intersect = intersects[ 0 ];

      signals.objectFocused.dispatch( intersect.object );

    }

  }

  container.dom.addEventListener( 'mousedown', onMouseDown, false );
  container.dom.addEventListener( 'touchstart', onTouchStart, false );
  container.dom.addEventListener( 'dblclick', onDoubleClick, false );

  // controls need to be added *after* main logic,
  // otherwise controls.enabled doesn't work.

  var controls = new THREE.EditorControls( camera, container.dom );
  controls.addEventListener( 'change', function () {

    transformControls.update();
    signals.cameraChanged.dispatch( camera );

  } );

  // signals

  signals.editorCleared.add( function () {

    controls.center.set( 0, 0, 0 );
    render();

  } );

  signals.themeChanged.add( function ( value ) {

    switch ( value ) {

      case '/static/css/light.css':
        sceneHelpers.remove( grid );
        grid = new THREE.GridHelper( 60, 60, 0x444444, 0x888888 );
        sceneHelpers.add( grid );
        break;
      case '/static/css/dark.css':
        sceneHelpers.remove( grid );
        grid = new THREE.GridHelper( 60, 60, 0xbbbbbb, 0x888888 );
        sceneHelpers.add( grid );
        break;

    }

    render();

  } );

  signals.transformModeChanged.add( function ( mode ) {

    transformControls.setMode( mode );

  } );

  signals.snapChanged.add( function ( dist ) {

    transformControls.setTranslationSnap( dist );

  } );

  signals.spaceChanged.add( function ( space ) {

    transformControls.setSpace( space );

  } );

  signals.rendererChanged.add( function ( newRenderer ) {

    if ( renderer !== null ) {

      container.dom.removeChild( renderer.domElement );

    }

    renderer = newRenderer;

    renderer.autoClear = false;
    renderer.autoUpdateScene = false;
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( container.dom.offsetWidth, container.dom.offsetHeight );

    container.dom.appendChild( renderer.domElement );

    render();

  } );

  signals.sceneGraphChanged.add( function () {

    render();

  } );

  signals.cameraChanged.add( function () {

    render();

  } );

  signals.objectSelected.add( function ( object ) {

    selectionBox.visible = false;
    transformControls.detach();

    if ( object !== null && object !== scene && object !== camera ) {

      box.setFromObject( object );

      if ( box.isEmpty() === false ) {

        selectionBox.setFromObject( object );
        selectionBox.visible = true;

      }

      transformControls.attach( object );

    }

    render();

  } );

  signals.objectFocused.add( function ( object ) {

    controls.focus( object );

  } );

  signals.geometryChanged.add( function ( object ) {

    if ( object !== undefined ) {

      selectionBox.setFromObject( object );

    }

    render();

  } );

  signals.objectAdded.add( function ( object ) {

    object.traverse( function ( child ) {

      objects.push( child );

    } );

  } );

  signals.objectChanged.add( function ( object ) {

    if ( editor.selected === object ) {

      selectionBox.setFromObject( object );
      transformControls.update();

    }

    if ( object instanceof THREE.PerspectiveCamera ) {

      object.updateProjectionMatrix();

    }

    if ( editor.helpers[ object.id ] !== undefined ) {

      editor.helpers[ object.id ].update();

    }

    render();

  } );

  signals.objectRemoved.add( function ( object ) {

    object.traverse( function ( child ) {

      objects.splice( objects.indexOf( child ), 1 );

    } );

  } );

  signals.helperAdded.add( function ( object ) {

    objects.push( object.getObjectByName( 'picker' ) );

  } );

  signals.helperRemoved.add( function ( object ) {

    objects.splice( objects.indexOf( object.getObjectByName( 'picker' ) ), 1 );

  } );

  signals.materialChanged.add( function ( material ) {

    render();

  } );

  // fog

  signals.sceneBackgroundChanged.add( function ( backgroundColor ) {

    scene.background.setHex( backgroundColor );

    render();

  } );

  var currentFogType = null;

  signals.sceneFogChanged.add( function ( fogType, fogColor, fogNear, fogFar, fogDensity ) {

    if ( currentFogType !== fogType ) {

      switch ( fogType ) {

        case 'None':
          scene.fog = null;
          break;
        case 'Fog':
          scene.fog = new THREE.Fog();
          break;
        case 'FogExp2':
          scene.fog = new THREE.FogExp2();
          break;

      }

      currentFogType = fogType;

    }

    if ( scene.fog instanceof THREE.Fog ) {

      scene.fog.color.setHex( fogColor );
      scene.fog.near = fogNear;
      scene.fog.far = fogFar;

    } else if ( scene.fog instanceof THREE.FogExp2 ) {

      scene.fog.color.setHex( fogColor );
      scene.fog.density = fogDensity;

    }

    render();

  } );

  //

  signals.windowResize.add( function () {

    // TODO: Move this out?

    editor.DEFAULT_CAMERA.aspect = container.dom.offsetWidth / container.dom.offsetHeight;
    editor.DEFAULT_CAMERA.updateProjectionMatrix();

    camera.aspect = container.dom.offsetWidth / container.dom.offsetHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( container.dom.offsetWidth, container.dom.offsetHeight );

    render();

  } );

  signals.showGridChanged.add( function ( showGrid ) {

    grid.visible = showGrid;
    render();

  } );

  //

  function render() {

    sceneHelpers.updateMatrixWorld();
    scene.updateMatrixWorld();

    renderer.render( scene, camera );

    if ( renderer instanceof THREE.RaytracingRenderer === false ) {

      renderer.render( sceneHelpers, camera );

    }

  }

  return container;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

Viewport.Info = function ( editor ) {

  var signals = editor.signals;

  var container = new UI.Panel();
  container.setId( 'info' );
  container.setPosition( 'absolute' );
  container.setLeft( '10px' );
  container.setBottom( '10px' );
  container.setFontSize( '12px' );
  container.setColor( '#fff' );

  var objectsText = new UI.Text( '0' ).setMarginLeft( '6px' );
  var verticesText = new UI.Text( '0' ).setMarginLeft( '6px' );
  var trianglesText = new UI.Text( '0' ).setMarginLeft( '6px' );

  container.add( new UI.Text( 'objects' ), objectsText, new UI.Break() );
  container.add( new UI.Text( 'vertices' ), verticesText, new UI.Break() );
  container.add( new UI.Text( 'triangles' ), trianglesText, new UI.Break() );

  signals.objectAdded.add( update );
  signals.objectRemoved.add( update );
  signals.geometryChanged.add( update );

  //

  function update() {

    var scene = editor.scene;

    var objects = 0, vertices = 0, triangles = 0;

    for ( var i = 0, l = scene.children.length; i < l; i ++ ) {

      var object = scene.children[ i ];

      object.traverseVisible( function ( object ) {

        objects ++;

        if ( object instanceof THREE.Mesh ) {

          var geometry = object.geometry;

          if ( geometry instanceof THREE.Geometry ) {

            vertices += geometry.vertices.length;
            triangles += geometry.faces.length;

          } else if ( geometry instanceof THREE.BufferGeometry ) {

            if ( geometry.index !== null ) {

              vertices += geometry.index.count * 3;
              triangles += geometry.index.count;

            } else {

              vertices += geometry.attributes.position.count;
              triangles += geometry.attributes.position.count / 3;

            }

          }

        }

      } );

    }

    objectsText.setValue( objects.format() );
    verticesText.setValue( vertices.format() );
    trianglesText.setValue( triangles.format() );

  }

  return container;

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param editorRef pointer to main editor object used to initialize
 *        each command object with a reference to the editor
 * @constructor
 */

var Command = function ( editorRef ) {

  this.id = - 1;
  this.inMemory = false;
  this.updatable = false;
  this.type = '';
  this.name = '';

  if ( editorRef !== undefined ) {

    Command.editor = editorRef;

  }
  this.editor = Command.editor;


};

Command.prototype.toJSON = function () {

  var output = {};
  output.type = this.type;
  output.id = this.id;
  output.name = this.name;
  return output;

};

Command.prototype.fromJSON = function ( json ) {

  this.inMemory = true;
  this.type = json.type;
  this.id = json.id;
  this.name = json.name;

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @constructor
 */

var AddObjectCommand = function ( object ) {

  Command.call( this );

  this.type = 'AddObjectCommand';

  this.object = object;
  if ( object !== undefined ) {

    this.name = 'Add Object: ' + object.name;

  }

};

AddObjectCommand.prototype = {

  execute: function () {

    this.editor.addObject( this.object );
    this.editor.select( this.object );

  },

  undo: function () {

    this.editor.removeObject( this.object );
    this.editor.deselect();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );
    output.object = this.object.toJSON();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.object.object.uuid );

    if ( this.object === undefined ) {

      var loader = new THREE.ObjectLoader();
      this.object = loader.parse( json.object );

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @constructor
 */

var RemoveObjectCommand = function ( object ) {

  Command.call( this );

  this.type = 'RemoveObjectCommand';
  this.name = 'Remove Object';

  this.object = object;
  this.parent = ( object !== undefined ) ? object.parent : undefined;
  if ( this.parent !== undefined ) {

    this.index = this.parent.children.indexOf( this.object );

  }

};

RemoveObjectCommand.prototype = {

  execute: function () {

    var scope = this.editor;
    this.object.traverse( function ( child ) {

      scope.removeHelper( child );

    } );

    this.parent.remove( this.object );
    this.editor.select( this.parent );

    this.editor.signals.objectRemoved.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    var scope = this.editor;

    this.object.traverse( function ( child ) {

      if ( child.geometry !== undefined ) scope.addGeometry( child.geometry );
      if ( child.material !== undefined ) scope.addMaterial( child.material );

      scope.addHelper( child );

    } );

    this.parent.children.splice( this.index, 0, this.object );
    this.object.parent = this.parent;
    this.editor.select( this.object );

    this.editor.signals.objectAdded.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );
    output.object = this.object.toJSON();
    output.index = this.index;
    output.parentUuid = this.parent.uuid;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.parent = this.editor.objectByUuid( json.parentUuid );
    if ( this.parent === undefined ) {

      this.parent = this.editor.scene;

    }

    this.index = json.index;

    this.object = this.editor.objectByUuid( json.object.object.uuid );
    if ( this.object === undefined ) {

      var loader = new THREE.ObjectLoader();
      this.object = loader.parse( json.object );

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newParent THREE.Object3D
 * @param newBefore THREE.Object3D
 * @constructor
 */

var MoveObjectCommand = function ( object, newParent, newBefore ) {

  Command.call( this );

  this.type = 'MoveObjectCommand';
  this.name = 'Move Object';

  this.object = object;
  this.oldParent = ( object !== undefined ) ? object.parent : undefined;
  this.oldIndex = ( this.oldParent !== undefined ) ? this.oldParent.children.indexOf( this.object ) : undefined;
  this.newParent = newParent;

  if ( newBefore !== undefined ) {

    this.newIndex = ( newParent !== undefined ) ? newParent.children.indexOf( newBefore ) : undefined;

  } else {

    this.newIndex = ( newParent !== undefined ) ? newParent.children.length : undefined;

  }

  if ( this.oldParent === this.newParent && this.newIndex > this.oldIndex ) {

    this.newIndex --;

  }

  this.newBefore = newBefore;

};

MoveObjectCommand.prototype = {

  execute: function () {

    this.oldParent.remove( this.object );

    var children = this.newParent.children;
    children.splice( this.newIndex, 0, this.object );
    this.object.parent = this.newParent;

    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.newParent.remove( this.object );

    var children = this.oldParent.children;
    children.splice( this.oldIndex, 0, this.object );
    this.object.parent = this.oldParent;

    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.newParentUuid = this.newParent.uuid;
    output.oldParentUuid = this.oldParent.uuid;
    output.newIndex = this.newIndex;
    output.oldIndex = this.oldIndex;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.oldParent = this.editor.objectByUuid( json.oldParentUuid );
    if ( this.oldParent === undefined ) {

      this.oldParent = this.editor.scene;

    }
    this.newParent = this.editor.objectByUuid( json.newParentUuid );
    if ( this.newParent === undefined ) {

      this.newParent = this.editor.scene;

    }
    this.newIndex = json.newIndex;
    this.oldIndex = json.oldIndex;

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newPosition THREE.Vector3
 * @param optionalOldPosition THREE.Vector3
 * @constructor
 */

var SetPositionCommand = function ( object, newPosition, optionalOldPosition ) {

  Command.call( this );

  this.type = 'SetPositionCommand';
  this.name = 'Set Position';
  this.updatable = true;

  this.object = object;

  if ( object !== undefined && newPosition !== undefined ) {

    this.oldPosition = object.position.clone();
    this.newPosition = newPosition.clone();

  }

  if ( optionalOldPosition !== undefined ) {

    this.oldPosition = optionalOldPosition.clone();

  }

};
SetPositionCommand.prototype = {

  execute: function () {

    this.object.position.copy( this.newPosition );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  undo: function () {

    this.object.position.copy( this.oldPosition );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  update: function ( command ) {

    this.newPosition.copy( command.newPosition );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.oldPosition = this.oldPosition.toArray();
    output.newPosition = this.newPosition.toArray();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.oldPosition = new THREE.Vector3().fromArray( json.oldPosition );
    this.newPosition = new THREE.Vector3().fromArray( json.newPosition );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newRotation THREE.Euler
 * @param optionalOldRotation THREE.Euler
 * @constructor
 */

var SetRotationCommand = function ( object, newRotation, optionalOldRotation ) {

  Command.call( this );

  this.type = 'SetRotationCommand';
  this.name = 'Set Rotation';
  this.updatable = true;

  this.object = object;

  if ( object !== undefined && newRotation !== undefined ) {

    this.oldRotation = object.rotation.clone();
    this.newRotation = newRotation.clone();

  }

  if ( optionalOldRotation !== undefined ) {

    this.oldRotation = optionalOldRotation.clone();

  }

};

SetRotationCommand.prototype = {

  execute: function () {

    this.object.rotation.copy( this.newRotation );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  undo: function () {

    this.object.rotation.copy( this.oldRotation );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  update: function ( command ) {

    this.newRotation.copy( command.newRotation );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.oldRotation = this.oldRotation.toArray();
    output.newRotation = this.newRotation.toArray();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.oldRotation = new THREE.Euler().fromArray( json.oldRotation );
    this.newRotation = new THREE.Euler().fromArray( json.newRotation );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newScale THREE.Vector3
 * @param optionalOldScale THREE.Vector3
 * @constructor
 */

var SetScaleCommand = function ( object, newScale, optionalOldScale ) {

  Command.call( this );

  this.type = 'SetScaleCommand';
  this.name = 'Set Scale';
  this.updatable = true;

  this.object = object;

  if ( object !== undefined && newScale !== undefined ) {

    this.oldScale = object.scale.clone();
    this.newScale = newScale.clone();

  }

  if ( optionalOldScale !== undefined ) {

    this.oldScale = optionalOldScale.clone();

  }

};

SetScaleCommand.prototype = {

  execute: function () {

    this.object.scale.copy( this.newScale );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  undo: function () {

    this.object.scale.copy( this.oldScale );
    this.object.updateMatrixWorld( true );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  update: function ( command ) {

    this.newScale.copy( command.newScale );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.oldScale = this.oldScale.toArray();
    output.newScale = this.newScale.toArray();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.oldScale = new THREE.Vector3().fromArray( json.oldScale );
    this.newScale = new THREE.Vector3().fromArray( json.newScale );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param attributeName string
 * @param newValue number, string, boolean or object
 * @constructor
 */

var SetValueCommand = function ( object, attributeName, newValue ) {

  Command.call( this );

  this.type = 'SetValueCommand';
  this.name = 'Set ' + attributeName;
  this.updatable = true;

  this.object = object;
  this.attributeName = attributeName;
  this.oldValue = ( object !== undefined ) ? object[ attributeName ] : undefined;
  this.newValue = newValue;

};

SetValueCommand.prototype = {

  execute: function () {

    this.object[ this.attributeName ] = this.newValue;
    this.editor.signals.objectChanged.dispatch( this.object );
    // this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.object[ this.attributeName ] = this.oldValue;
    this.editor.signals.objectChanged.dispatch( this.object );
    // this.editor.signals.sceneGraphChanged.dispatch();

  },

  update: function ( cmd ) {

    this.newValue = cmd.newValue;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;
    this.object = this.editor.objectByUuid( json.objectUuid );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newUuid string
 * @constructor
 */

var SetUuidCommand = function ( object, newUuid ) {

  Command.call( this );

  this.type = 'SetUuidCommand';
  this.name = 'Update UUID';

  this.object = object;

  this.oldUuid = ( object !== undefined ) ? object.uuid : undefined;
  this.newUuid = newUuid;

};

SetUuidCommand.prototype = {

  execute: function () {

    this.object.uuid = this.newUuid;
    this.editor.signals.objectChanged.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.object.uuid = this.oldUuid;
    this.editor.signals.objectChanged.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.oldUuid = this.oldUuid;
    output.newUuid = this.newUuid;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.oldUuid = json.oldUuid;
    this.newUuid = json.newUuid;
    this.object = this.editor.objectByUuid( json.oldUuid );

    if ( this.object === undefined ) {

      this.object = this.editor.objectByUuid( json.newUuid );

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param attributeName string
 * @param newValue integer representing a hex color value
 * @constructor
 */

var SetColorCommand = function ( object, attributeName, newValue ) {

  Command.call( this );

  this.type = 'SetColorCommand';
  this.name = 'Set ' + attributeName;
  this.updatable = true;

  this.object = object;
  this.attributeName = attributeName;
  this.oldValue = ( object !== undefined ) ? this.object[ this.attributeName ].getHex() : undefined;
  this.newValue = newValue;

};

SetColorCommand.prototype = {

  execute: function () {

    this.object[ this.attributeName ].setHex( this.newValue );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  undo: function () {

    this.object[ this.attributeName ].setHex( this.oldValue );
    this.editor.signals.objectChanged.dispatch( this.object );

  },

  update: function ( cmd ) {

    this.newValue = cmd.newValue;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newGeometry THREE.Geometry
 * @constructor
 */

var SetGeometryCommand = function ( object, newGeometry ) {

  Command.call( this );

  this.type = 'SetGeometryCommand';
  this.name = 'Set Geometry';
  this.updatable = true;

  this.object = object;
  this.oldGeometry = ( object !== undefined ) ? object.geometry : undefined;
  this.newGeometry = newGeometry;

};

SetGeometryCommand.prototype = {

  execute: function () {

    this.object.geometry.dispose();
    this.object.geometry = this.newGeometry;
    this.object.geometry.computeBoundingSphere();

    this.editor.signals.geometryChanged.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.object.geometry.dispose();
    this.object.geometry = this.oldGeometry;
    this.object.geometry.computeBoundingSphere();

    this.editor.signals.geometryChanged.dispatch( this.object );
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  update: function ( cmd ) {

    this.newGeometry = cmd.newGeometry;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.oldGeometry = this.object.geometry.toJSON();
    output.newGeometry = this.newGeometry.toJSON();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );

    this.oldGeometry = parseGeometry( json.oldGeometry );
    this.newGeometry = parseGeometry( json.newGeometry );

    function parseGeometry ( data ) {

      var loader = new THREE.ObjectLoader();
      return loader.parseGeometries( [ data ] )[ data.uuid ];

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param attributeName string
 * @param newValue number, string, boolean or object
 * @constructor
 */

var SetGeometryValueCommand = function ( object, attributeName, newValue ) {

  Command.call( this );

  this.type = 'SetGeometryValueCommand';
  this.name = 'Set Geometry.' + attributeName;

  this.object = object;
  this.attributeName = attributeName;
  this.oldValue = ( object !== undefined ) ? object.geometry[ attributeName ] : undefined;
  this.newValue = newValue;

};

SetGeometryValueCommand.prototype = {

  execute: function () {

    this.object.geometry[ this.attributeName ] = this.newValue;
    this.editor.signals.objectChanged.dispatch( this.object );
    this.editor.signals.geometryChanged.dispatch();
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.object.geometry[ this.attributeName ] = this.oldValue;
    this.editor.signals.objectChanged.dispatch( this.object );
    this.editor.signals.geometryChanged.dispatch();
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param cmdArray array containing command objects
 * @constructor
 */

var MultiCmdsCommand = function ( cmdArray ) {

  Command.call( this );

  this.type = 'MultiCmdsCommand';
  this.name = 'Multiple Changes';

  this.cmdArray = ( cmdArray !== undefined ) ? cmdArray : [];

};

MultiCmdsCommand.prototype = {

  execute: function () {

    this.editor.signals.sceneGraphChanged.active = false;

    for ( var i = 0; i < this.cmdArray.length; i ++ ) {

      this.cmdArray[ i ].execute();

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.editor.signals.sceneGraphChanged.active = false;

    for ( var i = this.cmdArray.length - 1; i >= 0; i -- ) {

      this.cmdArray[ i ].undo();

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    var cmds = [];
    for ( var i = 0; i < this.cmdArray.length; i ++ ) {

      cmds.push( this.cmdArray[ i ].toJSON() );

    }
    output.cmds = cmds;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    var cmds = json.cmds;
    for ( var i = 0; i < cmds.length; i ++ ) {

      var cmd = new window[ cmds[ i ].type ](); // creates a new object of type "json.type"
      cmd.fromJSON( cmds[ i ] );
      this.cmdArray.push( cmd );

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param script javascript object
 * @constructor
 */

var AddScriptCommand = function ( object, script ) {

  Command.call( this );

  this.type = 'AddScriptCommand';
  this.name = 'Add Script';

  this.object = object;
  this.script = script;

};

AddScriptCommand.prototype = {

  execute: function () {

    if ( this.editor.scripts[ this.object.uuid ] === undefined ) {

      this.editor.scripts[ this.object.uuid ] = [];

    }

    this.editor.scripts[ this.object.uuid ].push( this.script );

    this.editor.signals.scriptAdded.dispatch( this.script );

  },

  undo: function () {

    if ( this.editor.scripts[ this.object.uuid ] === undefined ) return;

    var index = this.editor.scripts[ this.object.uuid ].indexOf( this.script );

    if ( index !== - 1 ) {

      this.editor.scripts[ this.object.uuid ].splice( index, 1 );

    }

    this.editor.signals.scriptRemoved.dispatch( this.script );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.script = this.script;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.script = json.script;
    this.object = this.editor.objectByUuid( json.objectUuid );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param script javascript object
 * @constructor
 */

var RemoveScriptCommand = function ( object, script ) {

  Command.call( this );

  this.type = 'RemoveScriptCommand';
  this.name = 'Remove Script';

  this.object = object;
  this.script = script;
  if ( this.object && this.script ) {

    this.index = this.editor.scripts[ this.object.uuid ].indexOf( this.script );

  }

};

RemoveScriptCommand.prototype = {

  execute: function () {

    if ( this.editor.scripts[ this.object.uuid ] === undefined ) return;

    if ( this.index !== - 1 ) {

      this.editor.scripts[ this.object.uuid ].splice( this.index, 1 );

    }

    this.editor.signals.scriptRemoved.dispatch( this.script );

  },

  undo: function () {

    if ( this.editor.scripts[ this.object.uuid ] === undefined ) {

      this.editor.scripts[ this.object.uuid ] = [];

    }

    this.editor.scripts[ this.object.uuid ].splice( this.index, 0, this.script );

    this.editor.signals.scriptAdded.dispatch( this.script );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.script = this.script;
    output.index = this.index;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.script = json.script;
    this.index = json.index;
    this.object = this.editor.objectByUuid( json.objectUuid );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param script javascript object
 * @param attributeName string
 * @param newValue string, object
 * @constructor
 */

var SetScriptValueCommand = function ( object, script, attributeName, newValue ) {

  Command.call( this );

  this.type = 'SetScriptValueCommand';
  this.name = 'Set Script.' + attributeName;
  this.updatable = true;

  this.object = object;
  this.script = script;

  this.attributeName = attributeName;
  this.oldValue = ( script !== undefined ) ? script[ this.attributeName ] : undefined;
  this.newValue = newValue;

};

SetScriptValueCommand.prototype = {

  execute: function () {

    this.script[ this.attributeName ] = this.newValue;

    this.editor.signals.scriptChanged.dispatch();

  },

  undo: function () {

    this.script[ this.attributeName ] = this.oldValue;

    this.editor.signals.scriptChanged.dispatch();

  },

  update: function ( cmd ) {

    this.newValue = cmd.newValue;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.index = this.editor.scripts[ this.object.uuid ].indexOf( this.script );
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.oldValue = json.oldValue;
    this.newValue = json.newValue;
    this.attributeName = json.attributeName;
    this.object = this.editor.objectByUuid( json.objectUuid );
    this.script = this.editor.scripts[ json.objectUuid ][ json.index ];

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param newMaterial THREE.Material
 * @constructor
 */


var SetMaterialCommand = function ( object, newMaterial, materialSlot ) {

  Command.call( this );

  this.type = 'SetMaterialCommand';
  this.name = 'New Material';

  this.object = object;
  this.materialSlot = materialSlot;

  this.oldMaterial = this.editor.getObjectMaterial( object, materialSlot );
  this.newMaterial = newMaterial;

};

SetMaterialCommand.prototype = {

  execute: function () {

    this.editor.setObjectMaterial( this.object, this.materialSlot, this.newMaterial );
    this.editor.signals.materialChanged.dispatch( this.newMaterial );

  },

  undo: function () {

    this.editor.setObjectMaterial( this.object, this.materialSlot, this.oldMaterial );
    this.editor.signals.materialChanged.dispatch( this.oldMaterial );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.oldMaterial = this.oldMaterial.toJSON();
    output.newMaterial = this.newMaterial.toJSON();

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.oldMaterial = parseMaterial( json.oldMaterial );
    this.newMaterial = parseMaterial( json.newMaterial );

    function parseMaterial ( json ) {

      var loader = new THREE.ObjectLoader();
      var images = loader.parseImages( json.images );
      var textures  = loader.parseTextures( json.textures, images );
      var materials = loader.parseMaterials( [ json ], textures );
      return materials[ json.uuid ];

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param attributeName string
 * @param newValue number, string, boolean or object
 * @constructor
 */

var SetMaterialValueCommand = function ( object, attributeName, newValue, materialSlot ) {

  Command.call( this );

  this.type = 'SetMaterialValueCommand';
  this.name = 'Set Material.' + attributeName;
  this.updatable = true;

  this.object = object;
  this.material = this.editor.getObjectMaterial( object, materialSlot );

  this.oldValue = ( this.material !== undefined ) ? this.material[ attributeName ] : undefined;
  this.newValue = newValue;

  this.attributeName = attributeName;

};

SetMaterialValueCommand.prototype = {

  execute: function () {

    this.material[ this.attributeName ] = this.newValue;
    this.material.needsUpdate = true;

    this.editor.signals.objectChanged.dispatch( this.object );
    //this.editor.signals.materialChanged.dispatch( this.material );

  },

  undo: function () {

    this.material[ this.attributeName ] = this.oldValue;
    this.material.needsUpdate = true;

    this.editor.signals.objectChanged.dispatch( this.object );
    this.editor.signals.materialChanged.dispatch( this.material );

  },

  update: function ( cmd ) {

    this.newValue = cmd.newValue;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;
    this.object = this.editor.objectByUuid( json.objectUuid );

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param attributeName string
 * @param newValue integer representing a hex color value
 * @constructor
 */

var SetMaterialColorCommand = function ( object, attributeName, newValue, materialSlot ) {

  Command.call( this );

  this.type = 'SetMaterialColorCommand';
  this.name = 'Set Material.' + attributeName;
  this.updatable = true;

  this.object = object;
  this.material = this.editor.getObjectMaterial( object, materialSlot );

  this.oldValue = ( this.material !== undefined ) ? this.material[ attributeName ].getHex() : undefined;
  this.newValue = newValue;

  this.attributeName = attributeName;

};

SetMaterialColorCommand.prototype = {

  execute: function () {

    this.material[ this.attributeName ].setHex( this.newValue );

    this.editor.signals.materialChanged.dispatch( this.material );

  },

  undo: function () {

    this.material[ this.attributeName ].setHex( this.oldValue );

    this.editor.signals.materialChanged.dispatch( this.material );

  },

  update: function ( cmd ) {

    this.newValue = cmd.newValue;

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.attributeName = this.attributeName;
    output.oldValue = this.oldValue;
    output.newValue = this.newValue;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.attributeName = json.attributeName;
    this.oldValue = json.oldValue;
    this.newValue = json.newValue;

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param object THREE.Object3D
 * @param mapName string
 * @param newMap THREE.Texture
 * @constructor
 */

var SetMaterialMapCommand = function ( object, mapName, newMap, materialSlot ) {

  Command.call( this );

  this.type = 'SetMaterialMapCommand';
  this.name = 'Set Material.' + mapName;

  this.object = object;
  this.material = this.editor.getObjectMaterial( object, materialSlot );

  this.oldMap = ( object !== undefined ) ? this.material[ mapName ] : undefined;
  this.newMap = newMap;

  this.mapName = mapName;

};

SetMaterialMapCommand.prototype = {

  execute: function () {

    this.material[ this.mapName ] = this.newMap;
    this.material.needsUpdate = true;

    this.editor.signals.materialChanged.dispatch( this.material );

  },

  undo: function () {

    this.material[ this.mapName ] = this.oldMap;
    this.material.needsUpdate = true;

    this.editor.signals.materialChanged.dispatch( this.material );

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    output.objectUuid = this.object.uuid;
    output.mapName = this.mapName;
    output.newMap = serializeMap( this.newMap );
    output.oldMap = serializeMap( this.oldMap );

    return output;

    // serializes a map (THREE.Texture)

    function serializeMap ( map ) {

      if ( map === null || map === undefined ) return null;

      var meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };

      var json = map.toJSON( meta );
      var images = extractFromCache( meta.images );
      if ( images.length > 0 ) json.images = images;
      json.sourceFile = map.sourceFile;

      return json;

    }

    // Note: The function 'extractFromCache' is copied from Object3D.toJSON()

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache ( cache ) {

      var values = [];
      for ( var key in cache ) {

        var data = cache[ key ];
        delete data.metadata;
        values.push( data );

      }
      return values;

    }

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    this.object = this.editor.objectByUuid( json.objectUuid );
    this.mapName = json.mapName;
    this.oldMap = parseTexture( json.oldMap );
    this.newMap = parseTexture( json.newMap );

    function parseTexture ( json ) {

      var map = null;
      if ( json !== null ) {

        var loader = new THREE.ObjectLoader();
        var images = loader.parseImages( json.images );
        var textures  = loader.parseTextures( [ json ], images );
        map = textures[ json.uuid ];
        map.sourceFile = json.sourceFile;

      }
      return map;

    }

  }

};

/**
 * @author dforrer / https://github.com/dforrer
 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
 */

/**
 * @param scene containing children to import
 * @constructor
 */

var SetSceneCommand = function ( scene ) {

  Command.call( this );

  this.type = 'SetSceneCommand';
  this.name = 'Set Scene';

  this.cmdArray = [];

  if ( scene !== undefined ) {

    this.cmdArray.push( new SetUuidCommand( this.editor.scene, scene.uuid ) );
    this.cmdArray.push( new SetValueCommand( this.editor.scene, 'name', scene.name ) );
    this.cmdArray.push( new SetValueCommand( this.editor.scene, 'userData', JSON.parse( JSON.stringify( scene.userData ) ) ) );

    while ( scene.children.length > 0 ) {

      var child = scene.children.pop();
      this.cmdArray.push( new AddObjectCommand( child ) );

    }

  }

};

SetSceneCommand.prototype = {

  execute: function () {

    this.editor.signals.sceneGraphChanged.active = false;

    for ( var i = 0; i < this.cmdArray.length; i ++ ) {

      this.cmdArray[ i ].execute();

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  undo: function () {

    this.editor.signals.sceneGraphChanged.active = false;

    for ( var i = this.cmdArray.length - 1; i >= 0; i -- ) {

      this.cmdArray[ i ].undo();

    }

    this.editor.signals.sceneGraphChanged.active = true;
    this.editor.signals.sceneGraphChanged.dispatch();

  },

  toJSON: function () {

    var output = Command.prototype.toJSON.call( this );

    var cmds = [];
    for ( var i = 0; i < this.cmdArray.length; i ++ ) {

      cmds.push( this.cmdArray[ i ].toJSON() );

    }
    output.cmds = cmds;

    return output;

  },

  fromJSON: function ( json ) {

    Command.prototype.fromJSON.call( this, json );

    var cmds = json.cmds;
    for ( var i = 0; i < cmds.length; i ++ ) {

      var cmd = new window[ cmds[ i ].type ](); // creates a new object of type "json.type"
      cmd.fromJSON( cmds[ i ] );
      this.cmdArray.push( cmd );

    }

  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function html2canvas( element ) {

  var range = document.createRange();

  function Clipper( context ) {

    var clips = [];
    var isClipping = false;

    function doClip() {

      if ( isClipping ) {

        isClipping = false;
        context.restore();

      }

      if ( clips.length === 0 ) return;

      var minX = - Infinity, minY = - Infinity;
      var maxX = Infinity, maxY = Infinity;

      for ( var i = 0; i < clips.length; i ++ ) {

        var clip = clips[ i ];

        minX = Math.max( minX, clip.x );
        minY = Math.max( minY, clip.y );
        maxX = Math.min( maxX, clip.x + clip.width );
        maxY = Math.min( maxY, clip.y + clip.height );

      }

      context.save();
      context.beginPath();
      context.rect( minX, minY, maxX - minX, maxY - minY );
      context.clip();

      isClipping = true;

    }

    return {
      add: function ( clip ) {
        clips.push( clip );
        doClip();
      },
      remove: function () {
        clips.pop();
        doClip();
      }
    };

  }

  function drawText( style, x, y, string ) {

    if ( string !== '' ) {

      context.font = style.fontSize + ' ' + style.fontFamily;
      context.textBaseline = 'top';
      context.fillStyle = style.color;
      context.fillText( string, x, y );

    }

  }

  function drawBorder( style, which, x, y, width, height ) {

    var borderWidth = style[ which + 'Width' ];
    var borderStyle = style[ which + 'Style' ];
    var borderColor = style[ which + 'Color' ];

    if ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {

      context.strokeStyle = borderColor;
      context.beginPath();
      context.moveTo( x, y );
      context.lineTo( x + width, y + height );
      context.stroke();

    }

  }

  function drawElement( element, style ) {

    var x = 0, y = 0, width = 0, height = 0;

    if ( element.nodeType === 3 ) {

      // text

      range.selectNode( element );

      var rect = range.getBoundingClientRect();

      x = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      width = rect.width;
      height = rect.height;

      drawText( style, x, y, element.nodeValue.trim() );

    } else {

      if ( element.style.display === 'none' ) return;

      var rect = element.getBoundingClientRect();

      x = rect.left - offset.left - 0.5;
      y = rect.top - offset.top - 0.5;
      width = rect.width;
      height = rect.height;

      style = window.getComputedStyle( element );

      var backgroundColor = style.backgroundColor;

      if ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {

        context.fillStyle = backgroundColor;
        context.fillRect( x, y, width, height );

      }

      drawBorder( style, 'borderTop', x, y, width, 0 );
      drawBorder( style, 'borderLeft', x, y, 0, height );
      drawBorder( style, 'borderBottom', x, y + height, width, 0 );
      drawBorder( style, 'borderRight', x + width, y, 0, height );

      if ( element.type === 'color' || element.type === 'text' ) {

        clipper.add( { x: x, y: y, width: width, height: height } );

        drawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), element.value );

        clipper.remove();

      }

    }

    /*
    // debug

    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );
    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );
    */

    var isClipping = style.overflow === 'auto' || style.overflow === 'hidden';

    if ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      drawElement( element.childNodes[ i ], style );

    }

    if ( isClipping ) clipper.remove();

  }

  var offset = element.getBoundingClientRect();

  var canvas = document.createElement( 'canvas' );
  canvas.width = offset.width;
  canvas.height = offset.height;

  var context = canvas.getContext( '2d'/*, { alpha: false }*/ );

  var clipper = new Clipper( context );

  console.time( 'drawElement' );

  drawElement( element );

  console.timeEnd( 'drawElement' );

  return canvas;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

 THREE.HTMLGroup = function ( dom ) {

  THREE.Group.call( this );

  this.type = 'HTMLGroup';

  /*
  dom.addEventListener( 'mousemove', function ( event ) {

    console.log( 'mousemove' );

  } );

  dom.addEventListener( 'click', function ( event ) {

    console.log( 'click' );

  } );
  */

 };

 THREE.HTMLGroup.prototype = Object.assign( Object.create( THREE.Group.prototype ), {

  constructor: THREE.HTMLGroup

 } );

 THREE.HTMLMesh = function ( dom ) {

  var texture = new THREE.HTMLTexture( dom );

  var geometry = new THREE.PlaneGeometry( texture.image.width * 0.05, texture.image.height * 0.05 );
  var material = new THREE.MeshBasicMaterial( { map: texture } );

  THREE.Mesh.call( this, geometry, material );

  this.type = 'HTMLMesh';

 };

 THREE.HTMLMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {

  constructor: THREE.HTMLMesh

 } );

 THREE.HTMLTexture = function ( dom ) {

  THREE.CanvasTexture.call( this, html2canvas( dom ) );

  this.dom = dom;

  this.anisotropy = 16;

 };

 THREE.HTMLTexture.prototype = Object.assign( Object.create( THREE.CanvasTexture.prototype ), {

  constructor: THREE.HTMLTexture,

  update: function () {

    console.log( 'yo!', this, this.dom );

    this.image = html2canvas( this.dom );
    this.needsUpdate = true;

  }

 } );
